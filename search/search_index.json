{"config":{"lang":["ja"],"separator":"[\\s\\-\u3000\u3001\u3002\uff0c\uff0e]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"cpp_robotics","text":"<p>\u5236\u5fa1\u5de5\u5b66\u3001\u6700\u9069\u5316\u3001\u9006\u904b\u52d5\u5b66\u306a\u3069\u30ed\u30dc\u30c6\u30a3\u30af\u30b9\u306b\u591a\u7528\u3055\u308c\u308b\u6280\u8853\u3092\u30d1\u30c3\u30b1\u30fc\u30b8\u5316\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea</p>"},{"location":"#_1","title":"\u6a5f\u80fd","text":""},{"location":"#_2","title":"\u4f1d\u9054\u95a2\u6570\u30fb\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u8868\u73fe\u3068\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3","text":"<p>\u4f1d\u9054\u95a2\u6570\u3084\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u30af\u30e9\u30b9\u3092\u4f7f\u7528\u3057\u3066\u30b7\u30b9\u30c6\u30e0\u3092\u8868\u73fe\u3057\u3001\u5fdc\u7b54\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b</p>"},{"location":"#_3","title":"\u69d8\u3005\u306a\u5236\u5fa1\u5668\u306b\u3088\u308b\u5236\u5fa1\u7cfb\u306e\u5b9f\u73fe","text":"<p>PID\u5236\u5fa1\u5668\u3001LQR\u3001\u6975\u914d\u7f6e\u7b49\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3001MPC\u7b49\u306e\u5236\u5fa1\u7cfb\u3092\u69cb\u6210\u3059\u308b</p>"},{"location":"#_4","title":"\u6700\u9069\u5316","text":"<p>\u9023\u7d9a\u95a2\u6570\u306e\u6700\u9069\u5316\u3067\u6700\u9069\u5236\u5fa1\u306e\u5b9f\u73fe\u3092\u88dc\u52a9</p>"},{"location":"#_5","title":"\u30d5\u30a3\u30eb\u30bf","text":"<p>\u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3084\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u306f\u3058\u3081\u3001\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3084\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3001\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u7b49</p>"},{"location":"#_6","title":"\u9006\u904b\u52d5\u5b66","text":"<p>\u79fb\u52d5\u6a5f\u69cb\u3084\u30ed\u30dc\u30c3\u30c8\u306e\u30a2\u30fc\u30e0\u306e\u9006\u904b\u52d5\u5b66\u3092\u89e3\u304f\u305f\u3081\u306e\u30af\u30e9\u30b9</p>"},{"location":"#_7","title":"\u5358\u4f4d\u30af\u30e9\u30b9","text":"<p>SI\u5358\u4f4d\u7cfb\u3092\u5b9f\u88c5\u3057\u3066\u3042\u308a\u7269\u7406\u7684\u306a\u610f\u5473\u3092\u5bfe\u5fdc\u3055\u305b\u306a\u304c\u3089\u306e\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u304c\u53ef\u80fd \u7d44\u7acb\u5358\u4f4d\u306b\u3082\u5bfe\u5fdc</p>"},{"location":"#_8","title":"\u983b\u7e41\u306b\u4f7f\u7528\u3059\u308b\u30d9\u30af\u30c8\u30eb\u6f14\u7b97\u30af\u30e9\u30b9","text":"<p>Vector2 Vector3 Vector4 Quaternion Transform\u3092\u7528\u610f \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u6f14\u7b97\u3084\u30ce\u30eb\u30e0\u3001\u56de\u8ee2\u306e\u51e6\u7406\u3092\u7c21\u5358\u306b\u8a18\u8ff0</p>"},{"location":"#_9","title":"\u30e2\u30fc\u30bf\u30fc\u30af\u30e9\u30b9","text":"<p>DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u3092\u4f7f\u3063\u3066\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3</p>"},{"location":"#_10","title":"\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0","text":"<p>A*\u3001wave propagation\u3001\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3001Dubins\u66f2\u7dda</p>"},{"location":"#_11","title":"\u305d\u306e\u4ed6\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Kd\u6728, k-means\u6cd5, ICP\u30de\u30c3\u30c1\u30f3\u30b0\u7b49</p>"},{"location":"doxybook/classes/","title":"Classes","text":"<ul> <li>namespace Eigen </li> <li>namespace cpp_robotics <ul> <li>class ADVector </li> <li>struct ALConfig </li> <li>class ALiLQR </li> <li>class AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) <ul> <li>class DiffTri </li> </ul> </li> <li>class ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 <ul> <li>struct Problem </li> <li>struct Result </li> </ul> </li> <li>class AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b </li> <li>class ArmForwardKinematics </li> <li>class ArmInverseKinematics </li> <li>class ArmKinematics </li> <li>class BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </li> <li>class ButterworthFilter \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf </li> <li>class CatumullRom2D Catumull\u66f2\u7dda </li> <li>struct Circle \u5186\u30af\u30e9\u30b9 </li> <li>struct Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 </li> <li>class ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 <ul> <li>struct VariItem </li> </ul> </li> <li>class CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda </li> <li>struct DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </li> <li>struct DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </li> <li>class DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf </li> <li>class Differentiator \u7591\u4f3c\u5fae\u5206\u5668 </li> <li>class Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b </li> <li>class DiscretTransferFunction </li> <li>class DubinsPath Dubins\u30d1\u30b9 <ul> <li>struct PlanningResult </li> </ul> </li> <li>class ExtendedKalmanFilter </li> <li>class FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 </li> <li>struct GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb </li> <li>class HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </li> <li>class Integrator \u7a4d\u5206\u5668 </li> <li>class KDTree k-d\u6728 <ul> <li>struct Node </li> </ul> </li> <li>class KMeansMethod K-means\u6cd5 </li> <li>class KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf </li> <li>struct Line \u76f4\u7dda\u30af\u30e9\u30b9 </li> <li>class LinearMPC \u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9 </li> <li>class LinearRegulatorMPC </li> <li>class LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc </li> <li>class MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb <ul> <li>struct Config </li> </ul> </li> <li>class NctfController NCTF\u5236\u5fa1\u5668 </li> <li>class NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf </li> <li>class OCPConstraint </li> <li>class OCPConstraintArray <ul> <li>struct VariItem </li> </ul> </li> <li>class OCPContinuousLinearDynamics </li> <li>class OCPContinuousNonlinearDynamics </li> <li>class OCPContinuousNonlinearDynamicsAD </li> <li>class OCPCost </li> <li>class OCPCostQuadratic </li> <li>class OCPCostServoQuadratic </li> <li>class OCPDiscreteLinearDynamics </li> <li>class OCPDiscreteNonlinearDynamics </li> <li>class OCPDynamics </li> <li>class OCPFunctionalConstraint </li> <li>class OCPInputIndexedBoundConstraint </li> <li>class OCPStateIndexedBoundConstraint </li> <li>class Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb <ul> <li>struct Config </li> </ul> </li> <li>class Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb <ul> <li>struct Config </li> </ul> </li> <li>class OptimalControlProblem </li> <li>class PID PID\u5236\u5fa1\u5668 <ul> <li>struct pid_param_t </li> </ul> </li> <li>class PID2 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 <ul> <li>struct pid_param_t </li> </ul> </li> <li>class PSMC <ul> <li>struct param_t </li> </ul> </li> <li>struct Polynomial \u591a\u9805\u5f0f </li> <li>class PurePursuit Pure pursuit\u5236\u5fa1\u5668 </li> <li>struct Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 </li> <li>class QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 <ul> <li>struct Param </li> <li>struct Result </li> </ul> </li> <li>class Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 </li> <li>class RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 </li> <li>struct Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) </li> <li>class SISOPFC </li> <li>class SQP SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) <ul> <li>struct Problem </li> <li>struct Result </li> </ul> </li> <li>class Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b </li> <li>class SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 <ul> <li>struct func_list_t </li> </ul> </li> <li>class Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 <ul> <li>struct segment_info_t </li> <li>struct segment_t </li> </ul> </li> <li>class StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb </li> <li>class SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </li> <li>class Timer </li> <li>class TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb <ul> <li>class CircularBuffer </li> <li>struct tf_t </li> </ul> </li> <li>struct Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 </li> <li>struct Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 </li> <li>struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 </li> <li>struct Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </li> <li>struct Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </li> <li>struct Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </li> <li>class VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf <ul> <li>class DiffPair </li> </ul> </li> <li>class XY2LinkRobot </li> <li>namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 </li> <li>namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 <ul> <li>struct GridNode </li> </ul> </li> <li>class iLQR </li> <li>struct iLQRConfig </li> <li>namespace internal <ul> <li>struct has_ad_dynamics </li> <li>struct has_ad_dynamics&lt; DerClass, Scalar, std::void_t&lt; decltype(std::declval&lt; const DerClass &gt;().dynamics(std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;()))&gt;&gt; </li> <li>struct has_forward_kinematics </li> <li>struct has_forward_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().forward_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt; </li> <li>struct has_inverse_kinematics </li> <li>struct has_inverse_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().inverse_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt; </li> </ul> </li> <li>namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 <ul> <li>struct spline_c </li> </ul> </li> <li>namespace unit \u5358\u4f4d\u7cfb <ul> <li>struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 </li> <li>struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 </li> <li>class Unit \u5358\u4f4d\u30af\u30e9\u30b9 </li> <li>namespace prefix <ul> <li>struct pfx_div </li> <li>struct pfx_inv </li> <li>struct pfx_min </li> <li>struct pfx_mul </li> </ul> </li> <li>namespace tag <ul> <li>struct is_normal_tag </li> <li>struct is_normal_tag&lt; 0 &gt; </li> <li>struct is_normal_tag&lt;-1 &gt; </li> </ul> </li> <li>namespace unit_dimention </li> </ul> </li> <li>struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 </li> <li>class Unit \u5358\u4f4d\u30af\u30e9\u30b9 </li> <li>namespace prefix <ul> <li>struct pfx_div </li> <li>struct pfx_inv </li> <li>struct pfx_min </li> <li>struct pfx_mul </li> </ul> </li> <li>namespace tag <ul> <li>struct is_normal_tag </li> <li>struct is_normal_tag&lt; 0 &gt; </li> <li>struct is_normal_tag&lt;-1 &gt; </li> </ul> </li> <li>namespace unit_dimention </li> </ul> </li> <li>namespace std </li> <li>namespace unit_dim_assem </li> </ul> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/examples/","title":"Examples","text":"<p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/files/","title":"Files","text":"<ul> <li>dir include <ul> <li>dir include/cpp_robotics <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>dir include/cpp_robotics/algorithm <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/arm_kinematics <ul> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/chassis <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/controller <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/filter <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/geometry <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/motor <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/optimize <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/path_planning <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/system <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/unit <ul> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/utility <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/vector <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> </ul> </li> </ul> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/groups/","title":"Modules","text":"<p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/namespaces/","title":"Namespaces","text":"<ul> <li>namespace Eigen </li> <li>namespace cpp_robotics <ul> <li>namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 </li> <li>namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 </li> <li>namespace internal </li> <li>namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 </li> <li>namespace unit \u5358\u4f4d\u7cfb <ul> <li>namespace prefix </li> <li>namespace tag </li> <li>namespace unit_dimention </li> </ul> </li> <li>namespace prefix </li> <li>namespace tag </li> <li>namespace unit_dimention </li> </ul> </li> <li>namespace std </li> <li>namespace unit_dim_assem </li> </ul> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/related_pages/","title":"Pages","text":"<p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/","title":"cpp_robotics::ADVector","text":"<p>More...</p> <p><code>#include &lt;auto_diff.hpp&gt;</code></p> <p>Inherits from Eigen::Matrix&lt; ADScalar&lt; DerType &gt;, NX, 1 &gt;</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#public-types","title":"Public Types","text":"Name using ADScalar&lt; DerType &gt; Scalar using Eigen::Matrix&lt; double, NX, 1 &gt; RealVector"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#public-functions","title":"Public Functions","text":"Name ADVector(const size_t dim) ADVector(const DerType &amp; x) ADVector(const size_t dim, const size_t all_dim, const size_t start) ADVector(const size_t dim, const size_t all_dim, const size_t start, const DerType &amp; x) ADVector &amp; operator=(const RealVector &amp; x) RealVector real_cast() const ADVector operator+(const ADVector &amp; other) const ADVector operator-(const ADVector &amp; other) const void operator+=(const ADVector &amp; other) void operator-=(const ADVector &amp; other) template &lt;class SScalar &gt; ADVector operator*(const SScalar &amp; scalar) const template &lt;class SScalar &gt; void operator*=(const SScalar &amp; scalar) template &lt;class SScalar &gt; ADVector operator/(const SScalar &amp; scalar) const template &lt;class SScalar &gt; void operator/=(const SScalar &amp; scalar)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#friends","title":"Friends","text":"Name ADVector operator*(const SScalar &amp; scalar, const ADVector &amp; vec)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class DerType ,\nint NX&gt;\nclass cpp_robotics::ADVector;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#using-scalar","title":"using Scalar","text":"<pre><code>using cpp_robotics::ADVector&lt; DerType, NX &gt;::Scalar =  ADScalar&lt;DerType&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#using-realvector","title":"using RealVector","text":"<pre><code>using cpp_robotics::ADVector&lt; DerType, NX &gt;::RealVector =  Eigen::Matrix&lt;double, NX, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-advector","title":"function ADVector","text":"<pre><code>inline ADVector(\n    const size_t dim\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-advector_1","title":"function ADVector","text":"<pre><code>inline ADVector(\n    const DerType &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-advector_2","title":"function ADVector","text":"<pre><code>inline ADVector(\n    const size_t dim,\n    const size_t all_dim,\n    const size_t start\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-advector_3","title":"function ADVector","text":"<pre><code>inline ADVector(\n    const size_t dim,\n    const size_t all_dim,\n    const size_t start,\n    const DerType &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator","title":"function operator=","text":"<pre><code>inline ADVector &amp; operator=(\n    const RealVector &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-real_cast","title":"function real_cast","text":"<pre><code>inline RealVector real_cast() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator_1","title":"function operator+","text":"<pre><code>inline ADVector operator+(\n    const ADVector &amp; other\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator-","title":"function operator-","text":"<pre><code>inline ADVector operator-(\n    const ADVector &amp; other\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator_2","title":"function operator+=","text":"<pre><code>inline void operator+=(\n    const ADVector &amp; other\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator-_1","title":"function operator-=","text":"<pre><code>inline void operator-=(\n    const ADVector &amp; other\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator_3","title":"function operator*","text":"<pre><code>template &lt;class SScalar &gt;\ninline ADVector operator*(\n    const SScalar &amp; scalar\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator_4","title":"function operator*=","text":"<pre><code>template &lt;class SScalar &gt;\ninline void operator*=(\n    const SScalar &amp; scalar\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator_5","title":"function operator/","text":"<pre><code>template &lt;class SScalar &gt;\ninline ADVector operator/(\n    const SScalar &amp; scalar\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#function-operator_6","title":"function operator/=","text":"<pre><code>template &lt;class SScalar &gt;\ninline void operator/=(\n    const SScalar &amp; scalar\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ADVector/#friend-operator","title":"friend operator*","text":"<pre><code>friend ADVector operator*(\n    const SScalar &amp; scalar,\n\n    const ADVector &amp; vec\n);\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/","title":"cpp_robotics::ALiLQR","text":"<p><code>#include &lt;al_ilqr.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#public-types","title":"Public Types","text":"Name enum class Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#public-functions","title":"Public Functions","text":"Name ALiLQR(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost, const OCPConstraintArray &amp; constraints =OCPConstraintArray(), ALConfig config =ALConfig()) ALiLQR(const OptimalControlProblem &amp; prob, ALConfig config =ALConfig()) Result generate_trajectory(const Eigen::VectorXd &amp; x0) const std::vector&lt; Eigen::VectorXd &gt; &amp; get_input() const const std::vector&lt; Eigen::VectorXd &gt; &amp; get_state() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#enum-result","title":"enum Result","text":"Enumerator Value Description SUCCESS 0 MAX_INNER_ITER_REACHED MAX_ITER_REACHED MAX_PENALTY_EXCEEDED FAILED"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#function-alilqr","title":"function ALiLQR","text":"<pre><code>inline ALiLQR(\n    OCPDynamics::SharedPtr dynamics,\n    OCPCost::SharedPtr cost,\n    const OCPConstraintArray &amp; constraints =OCPConstraintArray(),\n    ALConfig config =ALConfig()\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#function-alilqr_1","title":"function ALiLQR","text":"<pre><code>inline ALiLQR(\n    const OptimalControlProblem &amp; prob,\n    ALConfig config =ALConfig()\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#function-generate_trajectory","title":"function generate_trajectory","text":"<pre><code>inline Result generate_trajectory(\n    const Eigen::VectorXd &amp; x0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#function-get_input","title":"function get_input","text":"<pre><code>inline const std::vector&lt; Eigen::VectorXd &gt; &amp; get_input() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ALiLQR/#function-get_state","title":"function get_state","text":"<pre><code>inline const std::vector&lt; Eigen::VectorXd &gt; &amp; get_state() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/","title":"cpp_robotics::AccelerationLimitFilter","text":"<p>\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f)  More...</p> <p><code>#include &lt;acceleration_limit_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#public-functions","title":"Public Functions","text":"Name AccelerationLimitFilter(double acc_max, double Ts, double gpd, double Kx, double Kv, std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt) AccelerationLimitFilter(double acc_max, double Ts, std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt) virtual void reset() virtual double filtering(double u) double Ts() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#detailed-description","title":"Detailed Description","text":"<pre><code>class cpp_robotics::AccelerationLimitFilter;\n</code></pre> <p>\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) </p> <p>\u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-accelerationlimitfilter","title":"function AccelerationLimitFilter","text":"<pre><code>inline AccelerationLimitFilter(\n    double acc_max,\n    double Ts,\n    double gpd,\n    double Kx,\n    double Kv,\n    std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-accelerationlimitfilter_1","title":"function AccelerationLimitFilter","text":"<pre><code>inline AccelerationLimitFilter(\n    double acc_max,\n    double Ts,\n    std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline virtual double filtering(\n    double u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/","title":"cpp_robotics::AccelerationLimitFilter::DiffTri","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#public-functions","title":"Public Functions","text":"Name DiffTri(double gpd, double Ts) void reset() std::tuple&lt; double, double, double &gt; filtering(double u)"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#function-difftri","title":"function DiffTri","text":"<pre><code>inline DiffTri(\n    double gpd,\n    double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#function-filtering","title":"function filtering","text":"<pre><code>inline std::tuple&lt; double, double, double &gt; filtering(\n    double u\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/","title":"cpp_robotics::ActiveSetMethod","text":"<p>\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 </p> <p><code>#include &lt;active_set_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-classes","title":"Public Classes","text":"Name struct Problem struct Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-functions","title":"Public Functions","text":"Name Result solve(Problem prob, Eigen::VectorXd x)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#function-solve","title":"function solve","text":"<pre><code>inline Result solve(\n    Problem prob,\n    Eigen::VectorXd x\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/","title":"cpp_robotics::AngleRange","text":"<p>\u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b </p> <p><code>#include &lt;angle_range.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-types","title":"Public Types","text":"Name using std::pair&lt; double, double &gt; range_pair_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-functions","title":"Public Functions","text":"Name AngleRange() =default void add_range(const AngleRange &amp; range) void add_range(double start, double end) size_t size() const AngleRange invert() const double most_near_by(double angle) bool in_range_part(range_pair_t &amp; range, double angle) bool in_range(double angle) std::vector&lt; range_pair_t &gt; ranges() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-attributes","title":"Public Attributes","text":"Name constexpr static double PI"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#using-range_pair_t","title":"using range_pair_t","text":"<pre><code>using cpp_robotics::AngleRange::range_pair_t =  std::pair&lt;double, double&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-anglerange","title":"function AngleRange","text":"<pre><code>AngleRange() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-add_range","title":"function add_range","text":"<pre><code>inline void add_range(\n    const AngleRange &amp; range\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-add_range_1","title":"function add_range","text":"<pre><code>inline void add_range(\n    double start,\n    double end\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-size","title":"function size","text":"<pre><code>inline size_t size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-invert","title":"function invert","text":"<pre><code>inline AngleRange invert() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-most_near_by","title":"function most_near_by","text":"<pre><code>inline double most_near_by(\n    double angle\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-in_range_part","title":"function in_range_part","text":"<pre><code>inline bool in_range_part(\n    range_pair_t &amp; range,\n    double angle\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-in_range","title":"function in_range","text":"<pre><code>inline bool in_range(\n    double angle\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-ranges","title":"function ranges","text":"<pre><code>inline std::vector&lt; range_pair_t &gt; ranges() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#variable-pi","title":"variable PI","text":"<pre><code>static constexpr static double PI = M_PI;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/","title":"cpp_robotics::ArmForwardKinematics","text":"<p>More...</p> <p><code>#include &lt;arm_kinematics.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#public-functions","title":"Public Functions","text":"Name ArmForwardKinematics(size_t nq, size_t nx)Construct a new Arm IK object. Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles) Eigen::VectorXd solve_ik(Eigen::VectorXd pos, Eigen::VectorXd joint_angles0) Eigen::VectorXd solve_ik(Eigen::VectorXd pos) Eigen::MatrixXd jacobian(Eigen::VectorXd joint_angles)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Derived &gt;\nclass cpp_robotics::ArmForwardKinematics;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#function-armforwardkinematics","title":"function ArmForwardKinematics","text":"<pre><code>inline ArmForwardKinematics(\n    size_t nq,\n    size_t nx\n)\n</code></pre> <p>Construct a new Arm IK object. </p> <p>Parameters: </p> <ul> <li>nq Number of joints </li> <li>nx Number of end effector's degrees of freedom </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#function-solve_fk","title":"function solve_fk","text":"<pre><code>inline Eigen::VectorXd solve_fk(\n    Eigen::VectorXd joint_angles\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#function-solve_ik","title":"function solve_ik","text":"<pre><code>inline Eigen::VectorXd solve_ik(\n    Eigen::VectorXd pos,\n    Eigen::VectorXd joint_angles0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#function-solve_ik_1","title":"function solve_ik","text":"<pre><code>inline Eigen::VectorXd solve_ik(\n    Eigen::VectorXd pos\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmForwardKinematics/#function-jacobian","title":"function jacobian","text":"<pre><code>inline Eigen::MatrixXd jacobian(\n    Eigen::VectorXd joint_angles\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/","title":"cpp_robotics::ArmInverseKinematics","text":"<p>More...</p> <p><code>#include &lt;arm_kinematics.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#public-functions","title":"Public Functions","text":"Name ArmInverseKinematics(size_t nq, size_t nx)Construct a new Arm IK object. Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles, Eigen::VectorXd pos0) Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles) Eigen::VectorXd solve_ik(Eigen::VectorXd pos) Eigen::MatrixXd jacobian(Eigen::VectorXd joint_angles)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Derived &gt;\nclass cpp_robotics::ArmInverseKinematics;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#function-arminversekinematics","title":"function ArmInverseKinematics","text":"<pre><code>inline ArmInverseKinematics(\n    size_t nq,\n    size_t nx\n)\n</code></pre> <p>Construct a new Arm IK object. </p> <p>Parameters: </p> <ul> <li>nq Number of joints </li> <li>nx Number of end effector's degrees of freedom </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#function-solve_fk","title":"function solve_fk","text":"<pre><code>inline Eigen::VectorXd solve_fk(\n    Eigen::VectorXd joint_angles,\n    Eigen::VectorXd pos0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#function-solve_fk_1","title":"function solve_fk","text":"<pre><code>inline Eigen::VectorXd solve_fk(\n    Eigen::VectorXd joint_angles\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#function-solve_ik","title":"function solve_ik","text":"<pre><code>inline Eigen::VectorXd solve_ik(\n    Eigen::VectorXd pos\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmInverseKinematics/#function-jacobian","title":"function jacobian","text":"<pre><code>inline Eigen::MatrixXd jacobian(\n    Eigen::VectorXd joint_angles\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/","title":"cpp_robotics::ArmKinematics","text":"<p>More...</p> <p><code>#include &lt;arm_kinematics.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/#public-functions","title":"Public Functions","text":"Name ArmKinematics(size_t nq, size_t nx)Construct a new Arm IK object. Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles) Eigen::VectorXd solve_ik(Eigen::VectorXd pos, Eigen::VectorXd joint_angles0) Eigen::MatrixXd jacobian(Eigen::VectorXd joint_angles)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Derived &gt;\nclass cpp_robotics::ArmKinematics;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/#function-armkinematics","title":"function ArmKinematics","text":"<pre><code>inline ArmKinematics(\n    size_t nq,\n    size_t nx\n)\n</code></pre> <p>Construct a new Arm IK object. </p> <p>Parameters: </p> <ul> <li>nq Number of joints </li> <li>nx Number of end effector's degrees of freedom </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/#function-solve_fk","title":"function solve_fk","text":"<pre><code>inline Eigen::VectorXd solve_fk(\n    Eigen::VectorXd joint_angles\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/#function-solve_ik","title":"function solve_ik","text":"<pre><code>inline Eigen::VectorXd solve_ik(\n    Eigen::VectorXd pos,\n    Eigen::VectorXd joint_angles0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ArmKinematics/#function-jacobian","title":"function jacobian","text":"<pre><code>inline Eigen::MatrixXd jacobian(\n    Eigen::VectorXd joint_angles\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/","title":"cpp_robotics::BandPassFilter","text":"<p>\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;band_pass_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#public-functions","title":"Public Functions","text":"Name BandPassFilter(double omega, double zeta, double dt)Construct a new Notch Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97 double zeta() const\u92ed\u3055\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from cpp_robotics::TransferFunction</p> Name struct tf_t <p>Protected Classes inherited from cpp_robotics::TransferFunction</p> Name class CircularBuffer <p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const <p>Protected Attributes inherited from cpp_robotics::TransferFunction</p> Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_ <p>Friends inherited from cpp_robotics::TransferFunction</p> Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-bandpassfilter","title":"function BandPassFilter","text":"<pre><code>inline BandPassFilter(\n    double omega,\n    double zeta,\n    double dt\n)\n</code></pre> <p>Construct a new Notch Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] </li> <li>zeta \u92ed\u3055 </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\n    double u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97 </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-zeta","title":"function zeta","text":"<pre><code>inline double zeta() const\n</code></pre> <p>\u92ed\u3055\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/","title":"cpp_robotics::ButterworthFilter","text":"<p>\u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;butterworth_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#public-functions","title":"Public Functions","text":"Name ButterworthFilter(double omega, size_t n, double dt)Construct a new Butterworth Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6642\u5b9a\u6570\u306e\u53d6\u5f97 size_t n() const\u30d5\u30a3\u30eb\u30bf\u306e\u6b21\u6570"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from cpp_robotics::TransferFunction</p> Name struct tf_t <p>Protected Classes inherited from cpp_robotics::TransferFunction</p> Name class CircularBuffer <p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const <p>Protected Attributes inherited from cpp_robotics::TransferFunction</p> Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_ <p>Friends inherited from cpp_robotics::TransferFunction</p> Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-butterworthfilter","title":"function ButterworthFilter","text":"<pre><code>inline ButterworthFilter(\n    double omega,\n    size_t n,\n    double dt\n)\n</code></pre> <p>Construct a new Butterworth Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>n \u30d5\u30a3\u30eb\u30bf\u306e\u6b21\u6570 </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\n    double u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6642\u5b9a\u6570\u306e\u53d6\u5f97 </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-n","title":"function n","text":"<pre><code>inline size_t n() const\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u306e\u6b21\u6570 </p> <p>Return: size_t </p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/","title":"cpp_robotics::CatumullRom2D","text":"<p>Catumull\u66f2\u7dda </p> <p><code>#include &lt;spline.hpp&gt;</code></p> <p>Inherits from cpp_robotics::Spline2D</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#public-functions","title":"Public Functions","text":"Name CatumullRom2D(std::vector&lt; Vector2d &gt; &amp; points, bool trajectory_loop =false, const double error =0.01)"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#additional-inherited-members","title":"Additional inherited members","text":"<p>Protected Classes inherited from cpp_robotics::Spline2D</p> Name struct segment_info_t struct segment_t <p>Public Functions inherited from cpp_robotics::Spline2D</p> Name Spline2D() =default bool is_empty() size_t size() size_t point_num() double length() double length(size_t i) Vector2d position(double length) Vector2d spline_position(double t) Vector2d spline_velocity(double t) Vector2d spline_acceleration(double t) <p>Protected Functions inherited from cpp_robotics::Spline2D</p> Name segment_info_t get_segmet_idx(const double t) segment_info_t get_segmet_idx_length(double length) <p>Protected Attributes inherited from cpp_robotics::Spline2D</p> Name std::vector&lt; segment_t &gt; _spline bool _is_empty size_t _size double _all_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#function-catumullrom2d","title":"function CatumullRom2D","text":"<pre><code>inline CatumullRom2D(\n    std::vector&lt; Vector2d &gt; &amp; points,\n    bool trajectory_loop =false,\n    const double error =0.01\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/","title":"cpp_robotics::ConstraintArray","text":"<p>\u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 </p> <p><code>#include &lt;constraint.hpp&gt;</code></p> <p>Inherits from std::vector&lt; Constraint &gt;</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#public-functions","title":"Public Functions","text":"Name ConstraintArray() =default ConstraintArray(std::initializer_list&lt; Constraint &gt; con) ConstraintArray(std::initializer_list&lt; VariItem&lt; Constraint, ConstraintArray &gt;&gt; cons) std::vector&lt; double &gt; eval(const Eigen::VectorXd &amp; x) const double eval_sum(const Eigen::VectorXd &amp; x) const bool all_satisfy(const Eigen::VectorXd &amp; x, const double tol) const std::vector&lt; Constraint &gt;::size_type eq_constraint_size() const std::vector&lt; Constraint &gt;::size_type ineq_constraint_size() const std::vector&lt; Constraint &gt; gen_eq_constraint_list() const std::vector&lt; Constraint &gt; gen_ineq_constraint_list() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-constraintarray","title":"function ConstraintArray","text":"<pre><code>ConstraintArray() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-constraintarray_1","title":"function ConstraintArray","text":"<pre><code>inline ConstraintArray(\n    std::initializer_list&lt; Constraint &gt; con\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-constraintarray_2","title":"function ConstraintArray","text":"<pre><code>inline ConstraintArray(\n    std::initializer_list&lt; VariItem&lt; Constraint, ConstraintArray &gt;&gt; cons\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eval","title":"function eval","text":"<pre><code>inline std::vector&lt; double &gt; eval(\n    const Eigen::VectorXd &amp; x\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eval_sum","title":"function eval_sum","text":"<pre><code>inline double eval_sum(\n    const Eigen::VectorXd &amp; x\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-all_satisfy","title":"function all_satisfy","text":"<pre><code>inline bool all_satisfy(\n    const Eigen::VectorXd &amp; x,\n    const double tol\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eq_constraint_size","title":"function eq_constraint_size","text":"<pre><code>inline std::vector&lt; Constraint &gt;::size_type eq_constraint_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-ineq_constraint_size","title":"function ineq_constraint_size","text":"<pre><code>inline std::vector&lt; Constraint &gt;::size_type ineq_constraint_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-gen_eq_constraint_list","title":"function gen_eq_constraint_list","text":"<pre><code>inline std::vector&lt; Constraint &gt; gen_eq_constraint_list() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-gen_ineq_constraint_list","title":"function gen_ineq_constraint_list","text":"<pre><code>inline std::vector&lt; Constraint &gt; gen_ineq_constraint_list() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/","title":"cpp_robotics::CubicSpline","text":"<p>3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda </p> <p><code>#include &lt;spline.hpp&gt;</code></p> <p>Inherits from cpp_robotics::Spline2D</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#public-functions","title":"Public Functions","text":"Name CubicSpline(std::vector&lt; Vector2d &gt; &amp; points, const double error =0.01)"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#additional-inherited-members","title":"Additional inherited members","text":"<p>Protected Classes inherited from cpp_robotics::Spline2D</p> Name struct segment_info_t struct segment_t <p>Public Functions inherited from cpp_robotics::Spline2D</p> Name Spline2D() =default bool is_empty() size_t size() size_t point_num() double length() double length(size_t i) Vector2d position(double length) Vector2d spline_position(double t) Vector2d spline_velocity(double t) Vector2d spline_acceleration(double t) <p>Protected Functions inherited from cpp_robotics::Spline2D</p> Name segment_info_t get_segmet_idx(const double t) segment_info_t get_segmet_idx_length(double length) <p>Protected Attributes inherited from cpp_robotics::Spline2D</p> Name std::vector&lt; segment_t &gt; _spline bool _is_empty size_t _size double _all_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#function-cubicspline","title":"function CubicSpline","text":"<pre><code>inline CubicSpline(\n    std::vector&lt; Vector2d &gt; &amp; points,\n    const double error =0.01\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/","title":"cpp_robotics::DelayFilter","text":"<p>\u9045\u5ef6\u30d5\u30a3\u30eb\u30bf  More...</p> <p><code>#include &lt;delay_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#public-functions","title":"Public Functions","text":"Name DelayFilter(double delay_time, double Ts) virtual void reset() virtual double filtering(double u)"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#detailed-description","title":"Detailed Description","text":"<pre><code>class cpp_robotics::DelayFilter;\n</code></pre> <p>\u9045\u5ef6\u30d5\u30a3\u30eb\u30bf </p> <p>G(s) = e^(-T*s) \u9045\u5ef6\u6642\u9593\u306f\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593\u306e\u6574\u6570\u500d\u306e\u307f </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-delayfilter","title":"function DelayFilter","text":"<pre><code>inline DelayFilter(\n    double delay_time,\n    double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline virtual double filtering(\n    double u\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/","title":"cpp_robotics::Differentiator","text":"<p>\u7591\u4f3c\u5fae\u5206\u5668  More...</p> <p><code>#include &lt;differentiator.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#public-functions","title":"Public Functions","text":"Name Differentiator(double omega, double dt)Construct a new Differentiator object. virtual void reset(double state =0) override void reset_test(double state =0, double input =0) double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6642\u5b9a\u6570\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from cpp_robotics::TransferFunction</p> Name struct tf_t <p>Protected Classes inherited from cpp_robotics::TransferFunction</p> Name class CircularBuffer <p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const <p>Protected Attributes inherited from cpp_robotics::TransferFunction</p> Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_ <p>Friends inherited from cpp_robotics::TransferFunction</p> Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#detailed-description","title":"Detailed Description","text":"<pre><code>class cpp_robotics::Differentiator;\n</code></pre> <p>\u7591\u4f3c\u5fae\u5206\u5668 </p> <p>G(s) = omega*s / (s + omega) \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-differentiator","title":"function Differentiator","text":"<pre><code>inline Differentiator(\n    double omega,\n    double dt\n)\n</code></pre> <p>Construct a new Differentiator object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset(\n    double state =0\n) override\n</code></pre> <p>Reimplements: cpp_robotics::TransferFunction::reset</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-reset_test","title":"function reset_test","text":"<pre><code>inline void reset_test(\n    double state =0,\n    double input =0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\n    double u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6642\u5b9a\u6570\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/","title":"cpp_robotics::Discret","text":"<p>\u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b </p> <p><code>#include &lt;discret.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#public-functions","title":"Public Functions","text":"Name template &lt;typename Derived &gt; auto discretize_a(const Eigen::MatrixBase&lt; Derived &gt; &amp; A, const double Ts) template &lt;typename Derived1 ,typename Derived2 &gt; auto discretize_b(const Eigen::MatrixBase&lt; Derived1 &gt; &amp; A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp; B, const double &amp; Ts, size_t hdiv =1000) template &lt;typename Derived1 ,typename Derived2 &gt; auto discritize(const Eigen::MatrixBase&lt; Derived1 &gt; &amp; A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp; B, const double &amp; Ts, size_t hdiv =1000)\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discretize_a","title":"function discretize_a","text":"<pre><code>template &lt;typename Derived &gt;\nstatic inline auto discretize_a(\n    const Eigen::MatrixBase&lt; Derived &gt; &amp; A,\n    const double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discretize_b","title":"function discretize_b","text":"<pre><code>template &lt;typename Derived1 ,\ntypename Derived2 &gt;\nstatic inline auto discretize_b(\n    const Eigen::MatrixBase&lt; Derived1 &gt; &amp; A,\n    const Eigen::MatrixBase&lt; Derived2 &gt; &amp; B,\n    const double &amp; Ts,\n    size_t hdiv =1000\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discritize","title":"function discritize","text":"<pre><code>template &lt;typename Derived1 ,\ntypename Derived2 &gt;\nstatic inline auto discritize(\n    const Eigen::MatrixBase&lt; Derived1 &gt; &amp; A,\n    const Eigen::MatrixBase&lt; Derived2 &gt; &amp; B,\n    const double &amp; Ts,\n    size_t hdiv =1000\n)\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> <li>Ts </li> <li>hdiv </li> </ul> <p>Template Parameters: </p> <ul> <li>Derived1 </li> <li>Derived2 </li> </ul> <p>Return: auto </p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/","title":"cpp_robotics::DiscretTransferFunction","text":"<p><code>#include &lt;discret.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/#public-functions","title":"Public Functions","text":"Name std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; discritize(const std::vector&lt; double &gt; &amp; num, const std::vector&lt; double &gt; &amp; den, const double Ts)"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/#function-discritize","title":"function discritize","text":"<pre><code>static inline std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; discritize(\n    const std::vector&lt; double &gt; &amp; num,\n    const std::vector&lt; double &gt; &amp; den,\n    const double Ts\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/","title":"cpp_robotics::DubinsPath","text":"<p>Dubins\u30d1\u30b9 </p> <p><code>#include &lt;dubins_path.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-types","title":"Public Types","text":"Name enum class Mode"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-functions","title":"Public Functions","text":"Name DubinsPath(Transformd start, Transformd end, double cavature) double length() const double segment_length(size_t i) const Transformd position(double len) const std::string path_type() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#enum-mode","title":"enum Mode","text":"Enumerator Value Description LRL RLR LSL LSR RSL RSR NONE"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-dubinspath","title":"function DubinsPath","text":"<pre><code>inline DubinsPath(\n    Transformd start,\n    Transformd end,\n    double cavature\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-length","title":"function length","text":"<pre><code>inline double length() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-segment_length","title":"function segment_length","text":"<pre><code>inline double segment_length(\n    size_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-position","title":"function position","text":"<pre><code>inline Transformd position(\n    double len\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-path_type","title":"function path_type","text":"<pre><code>inline std::string path_type() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/","title":"cpp_robotics::ExtendedKalmanFilter","text":"<p><code>#include &lt;extended_kalman_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-functions","title":"Public Functions","text":"Name ExtendedKalmanFilter(const double dt, size_t input_size, size_t state_size, size_t observe_size, std::optional&lt; double &gt; correction_threshold =std::nullopt) void reset(Eigen::VectorXd new_x, Eigen::MatrixXd new_P) Eigen::VectorXd filtering(Eigen::VectorXd u, Eigen::VectorXd z) double dt() const Eigen::VectorXd get_x() const Eigen::MatrixXd get_P() const virtual Eigen::VectorXd system(Eigen::VectorXd x, Eigen::VectorXd u) =0\u30b7\u30b9\u30c6\u30e0 virtual Eigen::VectorXd observe(Eigen::VectorXd x) =0\u89b3\u6e2c virtual void system_noise_conv(Eigen::MatrixXd &amp; Q, Eigen::VectorXd x, Eigen::VectorXd u) =0\u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217 virtual void observe_noise_conv(Eigen::MatrixXd &amp; R, Eigen::VectorXd x, Eigen::VectorXd z) =0\u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 virtual void linearized_system_matrix(Eigen::MatrixXd &amp; F, Eigen::VectorXd x, Eigen::VectorXd u)\u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217 virtual void linearized_observe_matrix(Eigen::MatrixXd &amp; H, Eigen::VectorXd x, Eigen::VectorXd z)\u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-attributes","title":"Public Attributes","text":"Name Eigen::VectorXd x \u72b6\u614b\u91cf Eigen::MatrixXd F \u9077\u79fb\u884c\u5217 Eigen::MatrixXd B \u5236\u5fa1\u884c\u5217 Eigen::MatrixXd H \u89b3\u6e2c\u884c\u5217 Eigen::MatrixXd Q \u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd R \u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd P \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#protected-attributes","title":"Protected Attributes","text":"Name const double dt_ const size_t input_size_ const size_t state_size_ const size_t observe_size_ std::optional&lt; double &gt; mn_threshold_"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-extendedkalmanfilter","title":"function ExtendedKalmanFilter","text":"<pre><code>inline ExtendedKalmanFilter(\n    const double dt,\n    size_t input_size,\n    size_t state_size,\n    size_t observe_size,\n    std::optional&lt; double &gt; correction_threshold =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-reset","title":"function reset","text":"<pre><code>inline void reset(\n    Eigen::VectorXd new_x,\n    Eigen::MatrixXd new_P\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline Eigen::VectorXd filtering(\n    Eigen::VectorXd u,\n    Eigen::VectorXd z\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-dt","title":"function dt","text":"<pre><code>inline double dt() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-get_x","title":"function get_x","text":"<pre><code>inline Eigen::VectorXd get_x() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-get_p","title":"function get_P","text":"<pre><code>inline Eigen::MatrixXd get_P() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-system","title":"function system","text":"<pre><code>virtual Eigen::VectorXd system(\n    Eigen::VectorXd x,\n    Eigen::VectorXd u\n) =0\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-observe","title":"function observe","text":"<pre><code>virtual Eigen::VectorXd observe(\n    Eigen::VectorXd x\n) =0\n</code></pre> <p>\u89b3\u6e2c </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-system_noise_conv","title":"function system_noise_conv","text":"<pre><code>virtual void system_noise_conv(\n    Eigen::MatrixXd &amp; Q,\n    Eigen::VectorXd x,\n    Eigen::VectorXd u\n) =0\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-observe_noise_conv","title":"function observe_noise_conv","text":"<pre><code>virtual void observe_noise_conv(\n    Eigen::MatrixXd &amp; R,\n    Eigen::VectorXd x,\n    Eigen::VectorXd z\n) =0\n</code></pre> <p>\u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-linearized_system_matrix","title":"function linearized_system_matrix","text":"<pre><code>inline virtual void linearized_system_matrix(\n    Eigen::MatrixXd &amp; F,\n    Eigen::VectorXd x,\n    Eigen::VectorXd u\n)\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-linearized_observe_matrix","title":"function linearized_observe_matrix","text":"<pre><code>inline virtual void linearized_observe_matrix(\n    Eigen::MatrixXd &amp; H,\n    Eigen::VectorXd x,\n    Eigen::VectorXd z\n)\n</code></pre> <p>\u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-x","title":"variable x","text":"<pre><code>Eigen::VectorXd x;\n</code></pre> <p>\u72b6\u614b\u91cf </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-f","title":"variable F","text":"<pre><code>Eigen::MatrixXd F;\n</code></pre> <p>\u9077\u79fb\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-b","title":"variable B","text":"<pre><code>Eigen::MatrixXd B;\n</code></pre> <p>\u5236\u5fa1\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-h","title":"variable H","text":"<pre><code>Eigen::MatrixXd H;\n</code></pre> <p>\u89b3\u6e2c\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre> <p>\u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-r","title":"variable R","text":"<pre><code>Eigen::MatrixXd R;\n</code></pre> <p>\u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-p","title":"variable P","text":"<pre><code>Eigen::MatrixXd P;\n</code></pre> <p>\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-dt_","title":"variable dt_","text":"<pre><code>const double dt_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-input_size_","title":"variable input_size_","text":"<pre><code>const size_t input_size_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-state_size_","title":"variable state_size_","text":"<pre><code>const size_t state_size_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-observe_size_","title":"variable observe_size_","text":"<pre><code>const size_t observe_size_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-mn_threshold_","title":"variable mn_threshold_","text":"<pre><code>std::optional&lt; double &gt; mn_threshold_;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/","title":"cpp_robotics::FilterStateHolder","text":"<p>\u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;filter_state_holder.hpp&gt;</code></p> <p>Inherits from BASE_FILTER_TYPE</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#public-functions","title":"Public Functions","text":"Name void set_input(double u) double filtering() double u() const double y() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class BASE_FILTER_TYPE &gt;\nclass cpp_robotics::FilterStateHolder;\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>BASE_FILTER_TYPE </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-set_input","title":"function set_input","text":"<pre><code>inline void set_input(\n    double u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-u","title":"function u","text":"<pre><code>inline double u() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-y","title":"function y","text":"<pre><code>inline double y() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/","title":"cpp_robotics::HighPassFilter","text":"<p>\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;high_pass_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#public-functions","title":"Public Functions","text":"Name HighPassFilter(double omega, double dt)Construct a new High Pass Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6642\u5b9a\u6570\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from cpp_robotics::TransferFunction</p> Name struct tf_t <p>Protected Classes inherited from cpp_robotics::TransferFunction</p> Name class CircularBuffer <p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const <p>Protected Attributes inherited from cpp_robotics::TransferFunction</p> Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_ <p>Friends inherited from cpp_robotics::TransferFunction</p> Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-highpassfilter","title":"function HighPassFilter","text":"<pre><code>inline HighPassFilter(\n    double omega,\n    double dt\n)\n</code></pre> <p>Construct a new High Pass Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\n    double u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6642\u5b9a\u6570\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/","title":"cpp_robotics::Integrator","text":"<p>\u7a4d\u5206\u5668 </p> <p><code>#include &lt;integrator.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#public-functions","title":"Public Functions","text":"Name Integrator(double dt)Construct a new Integrator object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from cpp_robotics::TransferFunction</p> Name struct tf_t <p>Protected Classes inherited from cpp_robotics::TransferFunction</p> Name class CircularBuffer <p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const <p>Protected Attributes inherited from cpp_robotics::TransferFunction</p> Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_ <p>Friends inherited from cpp_robotics::TransferFunction</p> Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#function-integrator","title":"function Integrator","text":"<pre><code>inline Integrator(\n    double dt\n)\n</code></pre> <p>Construct a new Integrator object. </p> <p>Parameters: </p> <ul> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\n    double u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/","title":"cpp_robotics::KDTree","text":"<p>k-d\u6728  More...</p> <p><code>#include &lt;kdtree.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-types","title":"Public Types","text":"Name using POINT_T point_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-functions","title":"Public Functions","text":"Name KDTree() =default KDTree(std::vector&lt; point_type &gt; point, size_t dimention) void clear() void build(std::vector&lt; point_type &gt; point, size_t dimention) size_t nn_search(const point_type &amp; point) const std::vector&lt; size_t &gt; nn_search(const std::vector&lt; point_type &gt; &amp; point) const std::vector&lt; size_t &gt; knn_search(const point_type &amp; point, size_t k) const std::vector&lt; size_t &gt; radius_search(const point_type &amp; point, double radius) const std::vector&lt; point_type &gt; get_points(const std::vector&lt; size_t &gt; &amp; idx) const std::vector&lt; point_type &gt; knn_search_points(const point_type &amp; point, size_t k) const std::vector&lt; point_type &gt; radius_search_points(const point_type &amp; point, double radius) const void debug_node()"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class POINT_T &gt;\nclass cpp_robotics::KDTree;\n</code></pre> <p>k-d\u6728 </p> <p>Template Parameters: </p> <ul> <li>POINT_T \u30c7\u30fc\u30bf\u578b </li> <li>DIM \u6b21\u5143\u30b5\u30a4\u30ba </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#using-point_type","title":"using point_type","text":"<pre><code>using cpp_robotics::KDTree&lt; POINT_T &gt;::point_type =  POINT_T;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-kdtree","title":"function KDTree","text":"<pre><code>KDTree() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-kdtree_1","title":"function KDTree","text":"<pre><code>inline KDTree(\n    std::vector&lt; point_type &gt; point,\n    size_t dimention\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-clear","title":"function clear","text":"<pre><code>inline void clear()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-build","title":"function build","text":"<pre><code>inline void build(\n    std::vector&lt; point_type &gt; point,\n    size_t dimention\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-nn_search","title":"function nn_search","text":"<pre><code>inline size_t nn_search(\n    const point_type &amp; point\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-nn_search_1","title":"function nn_search","text":"<pre><code>inline std::vector&lt; size_t &gt; nn_search(\n    const std::vector&lt; point_type &gt; &amp; point\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-knn_search","title":"function knn_search","text":"<pre><code>inline std::vector&lt; size_t &gt; knn_search(\n    const point_type &amp; point,\n    size_t k\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-radius_search","title":"function radius_search","text":"<pre><code>inline std::vector&lt; size_t &gt; radius_search(\n    const point_type &amp; point,\n    double radius\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-get_points","title":"function get_points","text":"<pre><code>inline std::vector&lt; point_type &gt; get_points(\n    const std::vector&lt; size_t &gt; &amp; idx\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-knn_search_points","title":"function knn_search_points","text":"<pre><code>inline std::vector&lt; point_type &gt; knn_search_points(\n    const point_type &amp; point,\n    size_t k\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-radius_search_points","title":"function radius_search_points","text":"<pre><code>inline std::vector&lt; point_type &gt; radius_search_points(\n    const point_type &amp; point,\n    double radius\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-debug_node","title":"function debug_node","text":"<pre><code>inline void debug_node()\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/","title":"cpp_robotics::KMeansMethod","text":"<p>K-means\u6cd5  More...</p> <p><code>#include &lt;k_means_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-types","title":"Public Types","text":"Name using PointType point_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-functions","title":"Public Functions","text":"Name KMeansMethod() =default std::vector&lt; size_t &gt; fit(std::vector&lt; point_t &gt; &amp; data_set, size_t cluster_size, size_t max_iter =1000)\u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b size_t predict(const point_t &amp; x)\u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class PointType &gt;\nclass cpp_robotics::KMeansMethod;\n</code></pre> <p>K-means\u6cd5 </p> <p>Template Parameters: </p> <ul> <li>PointType \u30c7\u30fc\u30bf\u578b </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#using-point_t","title":"using point_t","text":"<pre><code>using cpp_robotics::KMeansMethod&lt; PointType &gt;::point_t =  PointType;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-kmeansmethod","title":"function KMeansMethod","text":"<pre><code>KMeansMethod() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-fit","title":"function fit","text":"<pre><code>inline std::vector&lt; size_t &gt; fit(\n    std::vector&lt; point_t &gt; &amp; data_set,\n    size_t cluster_size,\n    size_t max_iter =1000\n)\n</code></pre> <p>\u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>data_set \u70b9\u7fa4\u30c7\u30fc\u30bf </li> <li>cluster_size \u751f\u6210\u3059\u308b\u30af\u30e9\u30b9\u30bf\u306e\u30b5\u30a4\u30ba </li> <li>max_iter \u6700\u5927\u53cd\u5fa9\u56de\u6570 </li> </ul> <p>Return: std::vector data_set\u306e\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-predict","title":"function predict","text":"<pre><code>inline size_t predict(\n    const point_t &amp; x\n)\n</code></pre> <p>\u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>x \u70b9\u30c7\u30fc\u30bf </li> </ul> <p>Return: size_t \u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c </p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/","title":"cpp_robotics::KalmanFilter","text":"<p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf  More...</p> <p><code>#include &lt;kalman_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type using Eigen::Matrix&lt; value_type, state_size, 1 &gt; x_vec_t using Eigen::Matrix&lt; value_type, input_size, 1 &gt; u_vec_t using Eigen::Matrix&lt; value_type, observe_size, 1 &gt; z_vec_t using Eigen::Matrix&lt; value_type, state_size, state_size &gt; f_mat_t using Eigen::Matrix&lt; value_type, state_size, input_size &gt; g_mat_t using Eigen::Matrix&lt; value_type, observe_size, state_size &gt; h_mat_t using Eigen::Matrix&lt; value_type, state_size, state_size &gt; q_mat_t using Eigen::Matrix&lt; value_type, observe_size, observe_size &gt; r_mat_t using Eigen::Matrix&lt; value_type, state_size, state_size &gt; p_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-functions","title":"Public Functions","text":"Name KalmanFilter() =default void reset(x_vec_t x, p_mat_t P) x_vec_t filtering(u_vec_t u, z_vec_t z) x_vec_t get_x() p_mat_t get_P()"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-attributes","title":"Public Attributes","text":"Name constexpr size_t state_size constexpr size_t input_size constexpr size_t observe_size f_mat_t F g_mat_t G h_mat_t H q_mat_t Q r_mat_t R"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE ,\nsize_t STATE_SIZE,\nsize_t INPUT_SIZE,\nsize_t OBSERVE_SIZE&gt;\nclass cpp_robotics::KalmanFilter;\n</code></pre> <p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf </p> <p>Template Parameters: </p> <ul> <li>FLOATING_TYPE \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b </li> <li>STATE_SIZE \u72b6\u614b\u91cf\u306e\u30b5\u30a4\u30ba </li> <li>INPUT_SIZE \u5165\u529b\u91cf\u306e\u30b5\u30a4\u30ba </li> <li>OBSERVE_SIZE \u89b3\u6e2c\u91cf\u306e\u30b5\u30a4\u30ba </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-x_vec_t","title":"using x_vec_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::x_vec_t =  Eigen::Matrix&lt;value_type, state_size, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-u_vec_t","title":"using u_vec_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::u_vec_t =  Eigen::Matrix&lt;value_type, input_size, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-z_vec_t","title":"using z_vec_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::z_vec_t =  Eigen::Matrix&lt;value_type, observe_size, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-f_mat_t","title":"using f_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::f_mat_t =  Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-g_mat_t","title":"using g_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::g_mat_t =  Eigen::Matrix&lt;value_type, state_size, input_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-h_mat_t","title":"using h_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::h_mat_t =  Eigen::Matrix&lt;value_type, observe_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-q_mat_t","title":"using q_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::q_mat_t =  Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-r_mat_t","title":"using r_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::r_mat_t =  Eigen::Matrix&lt;value_type, observe_size, observe_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-p_mat_t","title":"using p_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::p_mat_t =  Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-kalmanfilter","title":"function KalmanFilter","text":"<pre><code>KalmanFilter() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-reset","title":"function reset","text":"<pre><code>inline void reset(\n    x_vec_t x,\n    p_mat_t P\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline x_vec_t filtering(\n    u_vec_t u,\n    z_vec_t z\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-get_x","title":"function get_x","text":"<pre><code>inline x_vec_t get_x()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-get_p","title":"function get_P","text":"<pre><code>inline p_mat_t get_P()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-state_size","title":"variable state_size","text":"<pre><code>static constexpr size_t state_size = STATE_SIZE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-input_size","title":"variable input_size","text":"<pre><code>static constexpr size_t input_size = INPUT_SIZE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-observe_size","title":"variable observe_size","text":"<pre><code>static constexpr size_t observe_size = OBSERVE_SIZE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-f","title":"variable F","text":"<pre><code>f_mat_t F;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-g","title":"variable G","text":"<pre><code>g_mat_t G;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-h","title":"variable H","text":"<pre><code>h_mat_t H;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-q","title":"variable Q","text":"<pre><code>q_mat_t Q;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-r","title":"variable R","text":"<pre><code>r_mat_t R;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/","title":"cpp_robotics::LinearMPC","text":"<p>\u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9 </p> <p><code>#include &lt;linear_mpc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#public-functions","title":"Public Functions","text":"Name LinearMPC(const Eigen::MatrixXd &amp; Ad, const Eigen::MatrixXd &amp; Bd, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R, const Eigen::MatrixXd &amp; Qf, const size_t N, std::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt)Construct a new Linear MPC object. std::tuple&lt; bool, Eigen::VectorXd &gt; control(const Eigen::VectorXd &amp; x0, const std::vector&lt; Eigen::VectorXd &gt; &amp; x_ref, bool warm_start =true)\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 std::tuple&lt; bool, Eigen::VectorXd &gt; control(const Eigen::VectorXd &amp; x0, const Eigen::VectorXd &amp; x_ref, bool warm_start =true)\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 QuadProg::Result latest_qp_result() const Eigen::MatrixXd Ad() const Eigen::MatrixXd Bd() const Eigen::MatrixXd Q() const Eigen::MatrixXd R() const Eigen::MatrixXd Qf() const size_t N() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-linearmpc","title":"function LinearMPC","text":"<pre><code>inline LinearMPC(\n    const Eigen::MatrixXd &amp; Ad,\n    const Eigen::MatrixXd &amp; Bd,\n    const Eigen::MatrixXd &amp; Q,\n    const Eigen::MatrixXd &amp; R,\n    const Eigen::MatrixXd &amp; Qf,\n    const size_t N,\n    std::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt\n)\n</code></pre> <p>Construct a new Linear MPC object. </p> <p>Parameters: </p> <ul> <li>Ad \u72b6\u614b\u884c\u5217 </li> <li>Bd \u5165\u529b\u884c\u5217 </li> <li>Q \u72b6\u614b\u91cd\u307f\u884c\u5217 </li> <li>R \u5165\u529b\u91cd\u307f\u884c\u5217 </li> <li>Qf \u6700\u7d42\u72b6\u614b\u91cd\u307f\u884c\u5217 </li> <li>N \u30db\u30e9\u30a4\u30be\u30f3\u9577\u3055 </li> <li>u_limit \u5236\u5fa1\u5165\u529b\u7bc4\u56f2 </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-control","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, Eigen::VectorXd &gt; control(\n    const Eigen::VectorXd &amp; x0,\n    const std::vector&lt; Eigen::VectorXd &gt; &amp; x_ref,\n    bool warm_start =true\n)\n</code></pre> <p>\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>x0 \u72b6\u614b </li> <li>x_ref \u76ee\u6a19\u5024 </li> <li>warm_start </li> </ul> <p>Return: std::tuple \u6700\u9069\u5316\u306e\u6210\u529f/\u5931\u6557\u3001\u6700\u9069\u5165\u529b"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-control_1","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, Eigen::VectorXd &gt; control(\n    const Eigen::VectorXd &amp; x0,\n    const Eigen::VectorXd &amp; x_ref,\n    bool warm_start =true\n)\n</code></pre> <p>\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>x0 \u72b6\u614b </li> <li>x_ref \u76ee\u6a19\u5024 </li> <li>warm_start </li> </ul> <p>Return: std::tuple \u6700\u9069\u5316\u306e\u6210\u529f/\u5931\u6557\u3001\u6700\u9069\u5165\u529b"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-latest_qp_result","title":"function latest_qp_result","text":"<pre><code>inline QuadProg::Result latest_qp_result() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-ad","title":"function Ad","text":"<pre><code>inline Eigen::MatrixXd Ad() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-bd","title":"function Bd","text":"<pre><code>inline Eigen::MatrixXd Bd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-q","title":"function Q","text":"<pre><code>inline Eigen::MatrixXd Q() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-r","title":"function R","text":"<pre><code>inline Eigen::MatrixXd R() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-qf","title":"function Qf","text":"<pre><code>inline Eigen::MatrixXd Qf() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-n","title":"function N","text":"<pre><code>inline size_t N() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/","title":"cpp_robotics::LinearRegulatorMPC","text":"<p><code>#include &lt;linear_regulator_mpc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#public-functions","title":"Public Functions","text":"Name LinearRegulatorMPC(const Eigen::MatrixXd &amp; Ad, const Eigen::MatrixXd &amp; Bd, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R, const Eigen::MatrixXd &amp; Qf, const size_t N, std::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt) void set_initial_input(const std::vector&lt; Eigen::VectorXd &gt; &amp; u0) std::tuple&lt; bool, Eigen::VectorXd &gt; control(const Eigen::VectorXd &amp; x0, bool warm_start =true) QuadProg::Result latest_qp_result() const Eigen::MatrixXd Ad() const Eigen::MatrixXd Bd() const Eigen::MatrixXd Q() const Eigen::MatrixXd R() const Eigen::MatrixXd Qf() const size_t N() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-linearregulatormpc","title":"function LinearRegulatorMPC","text":"<pre><code>inline LinearRegulatorMPC(\n    const Eigen::MatrixXd &amp; Ad,\n    const Eigen::MatrixXd &amp; Bd,\n    const Eigen::MatrixXd &amp; Q,\n    const Eigen::MatrixXd &amp; R,\n    const Eigen::MatrixXd &amp; Qf,\n    const size_t N,\n    std::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-set_initial_input","title":"function set_initial_input","text":"<pre><code>inline void set_initial_input(\n    const std::vector&lt; Eigen::VectorXd &gt; &amp; u0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-control","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, Eigen::VectorXd &gt; control(\n    const Eigen::VectorXd &amp; x0,\n    bool warm_start =true\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-latest_qp_result","title":"function latest_qp_result","text":"<pre><code>inline QuadProg::Result latest_qp_result() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-ad","title":"function Ad","text":"<pre><code>inline Eigen::MatrixXd Ad() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-bd","title":"function Bd","text":"<pre><code>inline Eigen::MatrixXd Bd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-q","title":"function Q","text":"<pre><code>inline Eigen::MatrixXd Q() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-r","title":"function R","text":"<pre><code>inline Eigen::MatrixXd R() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-qf","title":"function Qf","text":"<pre><code>inline Eigen::MatrixXd Qf() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-n","title":"function N","text":"<pre><code>inline size_t N() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/","title":"cpp_robotics::LowPassFilter","text":"<p>\u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc </p> <p><code>#include &lt;low_pass_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#public-functions","title":"Public Functions","text":"Name LowPassFilter(double omega, double dt)Construct a new Low Pass Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from cpp_robotics::TransferFunction</p> Name struct tf_t <p>Protected Classes inherited from cpp_robotics::TransferFunction</p> Name class CircularBuffer <p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const <p>Protected Attributes inherited from cpp_robotics::TransferFunction</p> Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_ <p>Friends inherited from cpp_robotics::TransferFunction</p> Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-lowpassfilter","title":"function LowPassFilter","text":"<pre><code>inline LowPassFilter(\n    double omega,\n    double dt\n)\n</code></pre> <p>Construct a new Low Pass Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\n    double u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/","title":"cpp_robotics::MecanumIk","text":"<p>\u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;mecanum_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-classes","title":"Public Classes","text":"Name struct Config"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-functions","title":"Public Functions","text":"Name MecanumIk(double width, double length) MecanumIk(Config config) std::array&lt; double, 4 &gt; calculate(Transformd velocity) Config config() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-mecanumik","title":"function MecanumIk","text":"<pre><code>inline MecanumIk(\n    double width,\n    double length\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-mecanumik_1","title":"function MecanumIk","text":"<pre><code>inline MecanumIk(\n    Config config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-calculate","title":"function calculate","text":"<pre><code>inline std::array&lt; double, 4 &gt; calculate(\n    Transformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-config","title":"function config","text":"<pre><code>inline Config config() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/","title":"cpp_robotics::NctfController","text":"<p>NCTF\u5236\u5fa1\u5668 </p> <p><code>#include &lt;nctf.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-functions","title":"Public Functions","text":"Name std::function&lt; double(double)&gt; make_simple_nct(double max_velocity, double slope) NctfController(double max_velocity, double nct_slope, PID::pid_param_t pid_param, double dt) NctfController(std::function&lt; double(double)&gt; nct, PID::pid_param_t pid_param, double dt) void reset() double control(double target, double state) double control(double e) std::function&lt; double(double)&gt; nct() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-attributes","title":"Public Attributes","text":"Name double nct_error"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-make_simple_nct","title":"function make_simple_nct","text":"<pre><code>static inline std::function&lt; double(double)&gt; make_simple_nct(\n    double max_velocity,\n    double slope\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nctfcontroller","title":"function NctfController","text":"<pre><code>inline NctfController(\n    double max_velocity,\n    double nct_slope,\n    PID::pid_param_t pid_param,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nctfcontroller_1","title":"function NctfController","text":"<pre><code>inline NctfController(\n    std::function&lt; double(double)&gt; nct,\n    PID::pid_param_t pid_param,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-control","title":"function control","text":"<pre><code>inline double control(\n    double target,\n    double state\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-control_1","title":"function control","text":"<pre><code>inline double control(\n    double e\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nct","title":"function nct","text":"<pre><code>inline std::function&lt; double(double)&gt; nct() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#variable-nct_error","title":"variable nct_error","text":"<pre><code>double nct_error = 0;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/","title":"cpp_robotics::NotchFilter","text":"<p>\u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;notch_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#public-functions","title":"Public Functions","text":"Name NotchFilter(double omega, double zeta, double d, double dt)Construct a new Notch Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] double zeta() const\u92ed\u3055 double d() const\u6df1\u3055"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from cpp_robotics::TransferFunction</p> Name struct tf_t <p>Protected Classes inherited from cpp_robotics::TransferFunction</p> Name class CircularBuffer <p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const <p>Protected Attributes inherited from cpp_robotics::TransferFunction</p> Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_ <p>Friends inherited from cpp_robotics::TransferFunction</p> Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-notchfilter","title":"function NotchFilter","text":"<pre><code>inline NotchFilter(\n    double omega,\n    double zeta,\n    double d,\n    double dt\n)\n</code></pre> <p>Construct a new Notch Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] </li> <li>zeta \u92ed\u3055 </li> <li>d \u6df1\u3055(0.0\u3067\u4e00\u756a\u6df1\u304f\u30011.0\u306b\u8fd1\u3065\u3051\u308b\u307b\u3069\u30d5\u30a3\u30eb\u30bf\u306e\u52b9\u679c\u304c\u5f31\u304f\u306a\u308b) </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\n    double u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-zeta","title":"function zeta","text":"<pre><code>inline double zeta() const\n</code></pre> <p>\u92ed\u3055 </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-d","title":"function d","text":"<pre><code>inline double d() const\n</code></pre> <p>\u6df1\u3055 </p> <p>Return: double </p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/","title":"cpp_robotics::OCPConstraint","text":"<p><code>#include &lt;ocp_constraint.hpp&gt;</code></p> <p>Inherited by cpp_robotics::OCPFunctionalConstraint, cpp_robotics::OCPInputIndexedBoundConstraint, cpp_robotics::OCPStateIndexedBoundConstraint</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; OCPConstraint &gt; SharedPtr"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#public-functions","title":"Public Functions","text":"Name OCPConstraint() OCPConstraint(OCPConstraintType type) virtual double eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const =0 bool satisfy(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const double tol) const virtual Eigen::VectorXd grad_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const virtual Eigen::VectorXd grad_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#public-attributes","title":"Public Attributes","text":"Name double eps OCPConstraintType type"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#using-sharedptr","title":"using SharedPtr","text":"<pre><code>using cpp_robotics::OCPConstraint::SharedPtr =  std::shared_ptr&lt;OCPConstraint&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-ocpconstraint","title":"function OCPConstraint","text":"<pre><code>inline OCPConstraint()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-ocpconstraint_1","title":"function OCPConstraint","text":"<pre><code>inline OCPConstraint(\n    OCPConstraintType type\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-eval","title":"function eval","text":"<pre><code>virtual double eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const =0\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPFunctionalConstraint::eval, cpp_robotics::OCPInputIndexedBoundConstraint::eval, cpp_robotics::OCPStateIndexedBoundConstraint::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-satisfy","title":"function satisfy","text":"<pre><code>inline bool satisfy(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const double tol\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-grad_x","title":"function grad_x","text":"<pre><code>inline virtual Eigen::VectorXd grad_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPFunctionalConstraint::grad_x, cpp_robotics::OCPInputIndexedBoundConstraint::grad_x, cpp_robotics::OCPStateIndexedBoundConstraint::grad_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-grad_u","title":"function grad_u","text":"<pre><code>inline virtual Eigen::VectorXd grad_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPFunctionalConstraint::grad_u, cpp_robotics::OCPInputIndexedBoundConstraint::grad_u, cpp_robotics::OCPStateIndexedBoundConstraint::grad_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-hessian_xx","title":"function hessian_xx","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPFunctionalConstraint::hessian_xx, cpp_robotics::OCPInputIndexedBoundConstraint::hessian_xx, cpp_robotics::OCPStateIndexedBoundConstraint::hessian_xx</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-hessian_uu","title":"function hessian_uu","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_uu(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPFunctionalConstraint::hessian_uu, cpp_robotics::OCPInputIndexedBoundConstraint::hessian_uu, cpp_robotics::OCPStateIndexedBoundConstraint::hessian_uu</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#function-hessian_ux","title":"function hessian_ux","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_ux(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPFunctionalConstraint::hessian_ux, cpp_robotics::OCPInputIndexedBoundConstraint::hessian_ux, cpp_robotics::OCPStateIndexedBoundConstraint::hessian_ux</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#variable-eps","title":"variable eps","text":"<pre><code>double eps = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraint/#variable-type","title":"variable type","text":"<pre><code>OCPConstraintType type;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/","title":"cpp_robotics::OCPConstraintArray","text":"<p><code>#include &lt;ocp_constraint.hpp&gt;</code></p> <p>Inherits from std::vector&lt; OCPConstraint::SharedPtr &gt;</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#public-functions","title":"Public Functions","text":"Name OCPConstraintArray() =default OCPConstraintArray(std::initializer_list&lt; OCPConstraint::SharedPtr &gt; con) OCPConstraintArray(std::initializer_list&lt; VariItem&lt; OCPConstraint::SharedPtr, OCPConstraintArray &gt;&gt; cons) void push_back(const OCPConstraintArray &amp; cons) Eigen::VectorXd eval_all_vec(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const std::vector&lt; double &gt; eval_all(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u)"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#function-ocpconstraintarray","title":"function OCPConstraintArray","text":"<pre><code>OCPConstraintArray() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#function-ocpconstraintarray_1","title":"function OCPConstraintArray","text":"<pre><code>inline OCPConstraintArray(\n    std::initializer_list&lt; OCPConstraint::SharedPtr &gt; con\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#function-ocpconstraintarray_2","title":"function OCPConstraintArray","text":"<pre><code>inline OCPConstraintArray(\n    std::initializer_list&lt; VariItem&lt; OCPConstraint::SharedPtr, OCPConstraintArray &gt;&gt; cons\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#function-push_back","title":"function push_back","text":"<pre><code>inline void push_back(\n    const OCPConstraintArray &amp; cons\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#function-eval_all_vec","title":"function eval_all_vec","text":"<pre><code>inline Eigen::VectorXd eval_all_vec(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPConstraintArray/#function-eval_all","title":"function eval_all","text":"<pre><code>inline std::vector&lt; double &gt; eval_all(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/","title":"cpp_robotics::OCPContinuousLinearDynamics","text":"<p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPDynamics</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#public-functions","title":"Public Functions","text":"Name OCPContinuousLinearDynamics(const size_t nx, const size_t nu, const size_t horizon) OCPContinuousLinearDynamics(const Eigen::MatrixXd &amp; Acon, const Eigen::MatrixXd &amp; Bcon, double dt, size_t horizon) void set_continuous_dynamics(const Eigen::MatrixXd &amp; Acon, const Eigen::MatrixXd &amp; Bcon, double dt) virtual Eigen::VectorXd eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override virtual Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override virtual Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPDynamics</p> Name using std::shared_ptr&lt; OCPDynamics &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPDynamics</p> Name OCPDynamics(size_t nx, size_t nu, size_t horizon) size_t state_size() const size_t input_size() const size_t horizon() const <p>Public Attributes inherited from cpp_robotics::OCPDynamics</p> Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#function-ocpcontinuouslineardynamics","title":"function OCPContinuousLinearDynamics","text":"<pre><code>inline OCPContinuousLinearDynamics(\n    const size_t nx,\n    const size_t nu,\n    const size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#function-ocpcontinuouslineardynamics_1","title":"function OCPContinuousLinearDynamics","text":"<pre><code>inline OCPContinuousLinearDynamics(\n    const Eigen::MatrixXd &amp; Acon,\n    const Eigen::MatrixXd &amp; Bcon,\n    double dt,\n    size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#function-set_continuous_dynamics","title":"function set_continuous_dynamics","text":"<pre><code>inline void set_continuous_dynamics(\n    const Eigen::MatrixXd &amp; Acon,\n    const Eigen::MatrixXd &amp; Bcon,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#function-eval","title":"function eval","text":"<pre><code>inline virtual Eigen::VectorXd eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#function-jacobian_x","title":"function jacobian_x","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::jacobian_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousLinearDynamics/#function-jacobian_u","title":"function jacobian_u","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::jacobian_u</p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/","title":"cpp_robotics::OCPContinuousNonlinearDynamics","text":"<p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPDynamics</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/#public-functions","title":"Public Functions","text":"Name OCPContinuousNonlinearDynamics(OCPIntegrationMethod method, size_t nx, size_t nu, size_t horizon, double dt) virtual Eigen::VectorXd dynamics(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) =0 virtual Eigen::VectorXd eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override double dt() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPDynamics</p> Name using std::shared_ptr&lt; OCPDynamics &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPDynamics</p> Name OCPDynamics(size_t nx, size_t nu, size_t horizon) virtual Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) virtual Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) size_t state_size() const size_t input_size() const size_t horizon() const <p>Public Attributes inherited from cpp_robotics::OCPDynamics</p> Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/#function-ocpcontinuousnonlineardynamics","title":"function OCPContinuousNonlinearDynamics","text":"<pre><code>inline OCPContinuousNonlinearDynamics(\n    OCPIntegrationMethod method,\n    size_t nx,\n    size_t nu,\n    size_t horizon,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/#function-dynamics","title":"function dynamics","text":"<pre><code>virtual Eigen::VectorXd dynamics(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) =0\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/#function-eval","title":"function eval","text":"<pre><code>inline virtual Eigen::VectorXd eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamics/#function-dt","title":"function dt","text":"<pre><code>inline double dt() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/","title":"cpp_robotics::OCPContinuousNonlinearDynamicsAD","text":"<p>More...</p> <p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPDynamics</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#public-functions","title":"Public Functions","text":"Name OCPContinuousNonlinearDynamicsAD(OCPIntegrationMethod method, size_t nx, size_t nu, size_t horizon, double dt) virtual Eigen::VectorXd eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override virtual Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override virtual Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPDynamics</p> Name using std::shared_ptr&lt; OCPDynamics &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPDynamics</p> Name OCPDynamics(size_t nx, size_t nu, size_t horizon) size_t state_size() const size_t input_size() const size_t horizon() const <p>Public Attributes inherited from cpp_robotics::OCPDynamics</p> Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Derived &gt;\nclass cpp_robotics::OCPContinuousNonlinearDynamicsAD;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#function-ocpcontinuousnonlineardynamicsad","title":"function OCPContinuousNonlinearDynamicsAD","text":"<pre><code>inline OCPContinuousNonlinearDynamicsAD(\n    OCPIntegrationMethod method,\n    size_t nx,\n    size_t nu,\n    size_t horizon,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#function-eval","title":"function eval","text":"<pre><code>inline virtual Eigen::VectorXd eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#function-jacobian_x","title":"function jacobian_x","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::jacobian_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPContinuousNonlinearDynamicsAD/#function-jacobian_u","title":"function jacobian_u","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::jacobian_u</p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/","title":"cpp_robotics::OCPCost","text":"<p><code>#include &lt;ocp_cost.hpp&gt;</code></p> <p>Inherited by cpp_robotics::OCPCostQuadratic, cpp_robotics::OCPCostServoQuadratic</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; OCPCost &gt; SharedPtr"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#public-functions","title":"Public Functions","text":"Name OCPCost(size_t nx, size_t nu, size_t horizon) OCPCost(std::shared_ptr&lt; OCPDynamics &gt; model) virtual double eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const =0 virtual double eval_terminal(const Eigen::VectorXd &amp; x) const =0 virtual Eigen::VectorXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const virtual Eigen::VectorXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const virtual Eigen::VectorXd jacobian_x_terminal(const Eigen::VectorXd &amp; x) const virtual Eigen::MatrixXd hessian_xx_terminal(const Eigen::VectorXd &amp; x) const bool is_terminal(const size_t i) const size_t state_size() const size_t input_size() const size_t horizon() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#public-attributes","title":"Public Attributes","text":"Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#using-sharedptr","title":"using SharedPtr","text":"<pre><code>using cpp_robotics::OCPCost::SharedPtr =  std::shared_ptr&lt;OCPCost&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-ocpcost","title":"function OCPCost","text":"<pre><code>inline OCPCost(\n    size_t nx,\n    size_t nu,\n    size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-ocpcost_1","title":"function OCPCost","text":"<pre><code>inline OCPCost(\n    std::shared_ptr&lt; OCPDynamics &gt; model\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-eval","title":"function eval","text":"<pre><code>virtual double eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const =0\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::eval, cpp_robotics::OCPCostServoQuadratic::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-eval_terminal","title":"function eval_terminal","text":"<pre><code>virtual double eval_terminal(\n    const Eigen::VectorXd &amp; x\n) const =0\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::eval_terminal, cpp_robotics::OCPCostServoQuadratic::eval_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-jacobian_x","title":"function jacobian_x","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::jacobian_x, cpp_robotics::OCPCostServoQuadratic::jacobian_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-jacobian_u","title":"function jacobian_u","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::jacobian_u, cpp_robotics::OCPCostServoQuadratic::jacobian_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-hessian_xx","title":"function hessian_xx","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::hessian_xx, cpp_robotics::OCPCostServoQuadratic::hessian_xx</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-hessian_uu","title":"function hessian_uu","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_uu(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::hessian_uu, cpp_robotics::OCPCostServoQuadratic::hessian_uu</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-hessian_ux","title":"function hessian_ux","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_ux(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::hessian_ux, cpp_robotics::OCPCostServoQuadratic::hessian_ux</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-jacobian_x_terminal","title":"function jacobian_x_terminal","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_x_terminal(\n    const Eigen::VectorXd &amp; x\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::jacobian_x_terminal, cpp_robotics::OCPCostServoQuadratic::jacobian_x_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-hessian_xx_terminal","title":"function hessian_xx_terminal","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx_terminal(\n    const Eigen::VectorXd &amp; x\n) const\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPCostQuadratic::hessian_xx_terminal, cpp_robotics::OCPCostServoQuadratic::hessian_xx_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-is_terminal","title":"function is_terminal","text":"<pre><code>inline bool is_terminal(\n    const size_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-state_size","title":"function state_size","text":"<pre><code>inline size_t state_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-input_size","title":"function input_size","text":"<pre><code>inline size_t input_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#function-horizon","title":"function horizon","text":"<pre><code>inline size_t horizon() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCost/#variable-eps","title":"variable eps","text":"<pre><code>double eps = 1e-6;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/","title":"cpp_robotics::OCPCostQuadratic","text":"<p><code>#include &lt;ocp_cost.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPCost</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#public-functions","title":"Public Functions","text":"Name OCPCostQuadratic(OCPDynamics::SharedPtr model) OCPCostQuadratic(size_t nx, size_t nu, size_t horizon) virtual double eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::VectorXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::VectorXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual double eval_terminal(const Eigen::VectorXd &amp; x) const override virtual Eigen::VectorXd jacobian_x_terminal(const Eigen::VectorXd &amp; x) const override virtual Eigen::MatrixXd hessian_xx_terminal(const Eigen::VectorXd &amp; x) const override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#public-attributes","title":"Public Attributes","text":"Name Eigen::MatrixXd Q Eigen::MatrixXd R Eigen::MatrixXd Qf"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPCost</p> Name using std::shared_ptr&lt; OCPCost &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPCost</p> Name OCPCost(size_t nx, size_t nu, size_t horizon) OCPCost(std::shared_ptr&lt; OCPDynamics &gt; model) bool is_terminal(const size_t i) const size_t state_size() const size_t input_size() const size_t horizon() const <p>Public Attributes inherited from cpp_robotics::OCPCost</p> Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-ocpcostquadratic","title":"function OCPCostQuadratic","text":"<pre><code>inline OCPCostQuadratic(\n    OCPDynamics::SharedPtr model\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-ocpcostquadratic_1","title":"function OCPCostQuadratic","text":"<pre><code>inline OCPCostQuadratic(\n    size_t nx,\n    size_t nu,\n    size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-eval","title":"function eval","text":"<pre><code>inline virtual double eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-jacobian_x","title":"function jacobian_x","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::jacobian_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-jacobian_u","title":"function jacobian_u","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::jacobian_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-hessian_xx","title":"function hessian_xx","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_xx</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-hessian_uu","title":"function hessian_uu","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_uu(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_uu</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-hessian_ux","title":"function hessian_ux","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_ux(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_ux</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-eval_terminal","title":"function eval_terminal","text":"<pre><code>inline virtual double eval_terminal(\n    const Eigen::VectorXd &amp; x\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::eval_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-jacobian_x_terminal","title":"function jacobian_x_terminal","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_x_terminal(\n    const Eigen::VectorXd &amp; x\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::jacobian_x_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#function-hessian_xx_terminal","title":"function hessian_xx_terminal","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx_terminal(\n    const Eigen::VectorXd &amp; x\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_xx_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#variable-r","title":"variable R","text":"<pre><code>Eigen::MatrixXd R;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostQuadratic/#variable-qf","title":"variable Qf","text":"<pre><code>Eigen::MatrixXd Qf;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/","title":"cpp_robotics::OCPCostServoQuadratic","text":"<p><code>#include &lt;ocp_cost.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPCost</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#public-functions","title":"Public Functions","text":"Name OCPCostServoQuadratic(OCPDynamics::SharedPtr model) OCPCostServoQuadratic(size_t nx, size_t nu, size_t horizon) void set_x_ref_const(const Eigen::VectorXd &amp; x_ref) virtual double eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::VectorXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::VectorXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const size_t i) const override virtual double eval_terminal(const Eigen::VectorXd &amp; x) const override virtual Eigen::VectorXd jacobian_x_terminal(const Eigen::VectorXd &amp; x) const override virtual Eigen::MatrixXd hessian_xx_terminal(const Eigen::VectorXd &amp; x) const override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#public-attributes","title":"Public Attributes","text":"Name Eigen::MatrixXd Q Eigen::MatrixXd R Eigen::MatrixXd Qf std::vector&lt; Eigen::MatrixXd &gt; x_ref"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPCost</p> Name using std::shared_ptr&lt; OCPCost &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPCost</p> Name OCPCost(size_t nx, size_t nu, size_t horizon) OCPCost(std::shared_ptr&lt; OCPDynamics &gt; model) bool is_terminal(const size_t i) const size_t state_size() const size_t input_size() const size_t horizon() const <p>Public Attributes inherited from cpp_robotics::OCPCost</p> Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-ocpcostservoquadratic","title":"function OCPCostServoQuadratic","text":"<pre><code>inline OCPCostServoQuadratic(\n    OCPDynamics::SharedPtr model\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-ocpcostservoquadratic_1","title":"function OCPCostServoQuadratic","text":"<pre><code>inline OCPCostServoQuadratic(\n    size_t nx,\n    size_t nu,\n    size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-set_x_ref_const","title":"function set_x_ref_const","text":"<pre><code>inline void set_x_ref_const(\n    const Eigen::VectorXd &amp; x_ref\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-eval","title":"function eval","text":"<pre><code>inline virtual double eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-jacobian_x","title":"function jacobian_x","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::jacobian_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-jacobian_u","title":"function jacobian_u","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::jacobian_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-hessian_xx","title":"function hessian_xx","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_xx</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-hessian_uu","title":"function hessian_uu","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_uu(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_uu</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-hessian_ux","title":"function hessian_ux","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_ux(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const size_t i\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_ux</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-eval_terminal","title":"function eval_terminal","text":"<pre><code>inline virtual double eval_terminal(\n    const Eigen::VectorXd &amp; x\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::eval_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-jacobian_x_terminal","title":"function jacobian_x_terminal","text":"<pre><code>inline virtual Eigen::VectorXd jacobian_x_terminal(\n    const Eigen::VectorXd &amp; x\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::jacobian_x_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#function-hessian_xx_terminal","title":"function hessian_xx_terminal","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx_terminal(\n    const Eigen::VectorXd &amp; x\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPCost::hessian_xx_terminal</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#variable-r","title":"variable R","text":"<pre><code>Eigen::MatrixXd R;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#variable-qf","title":"variable Qf","text":"<pre><code>Eigen::MatrixXd Qf;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPCostServoQuadratic/#variable-x_ref","title":"variable x_ref","text":"<pre><code>std::vector&lt; Eigen::MatrixXd &gt; x_ref;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/","title":"cpp_robotics::OCPDiscreteLinearDynamics","text":"<p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPDynamics</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#public-functions","title":"Public Functions","text":"Name OCPDiscreteLinearDynamics(const size_t nx, const size_t nu, const size_t horizon) OCPDiscreteLinearDynamics(const Eigen::MatrixXd &amp; A, const Eigen::MatrixXd &amp; B, size_t horizon) virtual Eigen::VectorXd eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override virtual Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override virtual Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPDynamics</p> Name using std::shared_ptr&lt; OCPDynamics &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPDynamics</p> Name OCPDynamics(size_t nx, size_t nu, size_t horizon) size_t state_size() const size_t input_size() const size_t horizon() const <p>Public Attributes inherited from cpp_robotics::OCPDynamics</p> Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#function-ocpdiscretelineardynamics","title":"function OCPDiscreteLinearDynamics","text":"<pre><code>inline OCPDiscreteLinearDynamics(\n    const size_t nx,\n    const size_t nu,\n    const size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#function-ocpdiscretelineardynamics_1","title":"function OCPDiscreteLinearDynamics","text":"<pre><code>inline OCPDiscreteLinearDynamics(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::MatrixXd &amp; B,\n    size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#function-eval","title":"function eval","text":"<pre><code>inline virtual Eigen::VectorXd eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#function-jacobian_x","title":"function jacobian_x","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::jacobian_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteLinearDynamics/#function-jacobian_u","title":"function jacobian_u","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) override\n</code></pre> <p>Reimplements: cpp_robotics::OCPDynamics::jacobian_u</p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteNonlinearDynamics/","title":"cpp_robotics::OCPDiscreteNonlinearDynamics","text":"<p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPDynamics</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteNonlinearDynamics/#public-functions","title":"Public Functions","text":"Name OCPDiscreteNonlinearDynamics(size_t nx, size_t nu, size_t horizon)"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteNonlinearDynamics/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPDynamics</p> Name using std::shared_ptr&lt; OCPDynamics &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPDynamics</p> Name OCPDynamics(size_t nx, size_t nu, size_t horizon) virtual Eigen::VectorXd eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) =0 virtual Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) virtual Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) size_t state_size() const size_t input_size() const size_t horizon() const <p>Public Attributes inherited from cpp_robotics::OCPDynamics</p> Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteNonlinearDynamics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDiscreteNonlinearDynamics/#function-ocpdiscretenonlineardynamics","title":"function OCPDiscreteNonlinearDynamics","text":"<pre><code>inline OCPDiscreteNonlinearDynamics(\n    size_t nx,\n    size_t nu,\n    size_t horizon\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/","title":"cpp_robotics::OCPDynamics","text":"<p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherited by cpp_robotics::OCPContinuousLinearDynamics, cpp_robotics::OCPContinuousNonlinearDynamics, cpp_robotics::OCPContinuousNonlinearDynamicsAD&lt; Derived &gt;, cpp_robotics::OCPDiscreteLinearDynamics, cpp_robotics::OCPDiscreteNonlinearDynamics</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; OCPDynamics &gt; SharedPtr"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#public-functions","title":"Public Functions","text":"Name OCPDynamics(size_t nx, size_t nu, size_t horizon) virtual Eigen::VectorXd eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) =0 virtual Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) virtual Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) size_t state_size() const size_t input_size() const size_t horizon() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#public-attributes","title":"Public Attributes","text":"Name double eps"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#using-sharedptr","title":"using SharedPtr","text":"<pre><code>using cpp_robotics::OCPDynamics::SharedPtr =  std::shared_ptr&lt;OCPDynamics&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#function-ocpdynamics","title":"function OCPDynamics","text":"<pre><code>inline OCPDynamics(\n    size_t nx,\n    size_t nu,\n    size_t horizon\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#function-eval","title":"function eval","text":"<pre><code>virtual Eigen::VectorXd eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) =0\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPDiscreteLinearDynamics::eval, cpp_robotics::OCPContinuousLinearDynamics::eval, cpp_robotics::OCPContinuousNonlinearDynamics::eval, cpp_robotics::OCPContinuousNonlinearDynamicsAD::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#function-jacobian_x","title":"function jacobian_x","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n)\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPDiscreteLinearDynamics::jacobian_x, cpp_robotics::OCPContinuousLinearDynamics::jacobian_x, cpp_robotics::OCPContinuousNonlinearDynamicsAD::jacobian_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#function-jacobian_u","title":"function jacobian_u","text":"<pre><code>inline virtual Eigen::MatrixXd jacobian_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n)\n</code></pre> <p>Reimplemented by: cpp_robotics::OCPDiscreteLinearDynamics::jacobian_u, cpp_robotics::OCPContinuousLinearDynamics::jacobian_u, cpp_robotics::OCPContinuousNonlinearDynamicsAD::jacobian_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#function-state_size","title":"function state_size","text":"<pre><code>inline size_t state_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#function-input_size","title":"function input_size","text":"<pre><code>inline size_t input_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#function-horizon","title":"function horizon","text":"<pre><code>inline size_t horizon() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPDynamics/#variable-eps","title":"variable eps","text":"<pre><code>double eps = 1e-6;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/","title":"cpp_robotics::OCPFunctionalConstraint","text":"<p><code>#include &lt;ocp_constraint.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPConstraint</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#public-types","title":"Public Types","text":"Name using std::function&lt; double(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt; func_t using std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt; grad_func_t using std::function&lt; Eigen::MatrixXd(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt; hessian_func_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#public-functions","title":"Public Functions","text":"Name OCPFunctionalConstraint(OCPConstraintType type, func_t f) virtual double eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::VectorXd grad_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::VectorXd grad_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#public-attributes","title":"Public Attributes","text":"Name func_t f std::optional&lt; grad_func_t &gt; f_grad_x std::optional&lt; grad_func_t &gt; f_grad_u std::optional&lt; hessian_func_t &gt; f_hessian_xx std::optional&lt; hessian_func_t &gt; f_hessian_ux std::optional&lt; hessian_func_t &gt; f_hessian_uu"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPConstraint</p> Name using std::shared_ptr&lt; OCPConstraint &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPConstraint</p> Name OCPConstraint() OCPConstraint(OCPConstraintType type) bool satisfy(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const double tol) const <p>Public Attributes inherited from cpp_robotics::OCPConstraint</p> Name double eps OCPConstraintType type"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#using-func_t","title":"using func_t","text":"<pre><code>using cpp_robotics::OCPFunctionalConstraint::func_t =  std::function&lt;double(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#using-grad_func_t","title":"using grad_func_t","text":"<pre><code>using cpp_robotics::OCPFunctionalConstraint::grad_func_t =  std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#using-hessian_func_t","title":"using hessian_func_t","text":"<pre><code>using cpp_robotics::OCPFunctionalConstraint::hessian_func_t =  std::function&lt;Eigen::MatrixXd(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#function-ocpfunctionalconstraint","title":"function OCPFunctionalConstraint","text":"<pre><code>inline OCPFunctionalConstraint(\n    OCPConstraintType type,\n    func_t f\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#function-eval","title":"function eval","text":"<pre><code>inline virtual double eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#function-grad_x","title":"function grad_x","text":"<pre><code>inline virtual Eigen::VectorXd grad_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::grad_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#function-grad_u","title":"function grad_u","text":"<pre><code>inline virtual Eigen::VectorXd grad_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::grad_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#function-hessian_xx","title":"function hessian_xx","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_xx</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#function-hessian_uu","title":"function hessian_uu","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_uu(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_uu</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#function-hessian_ux","title":"function hessian_ux","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_ux(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_ux</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#variable-f","title":"variable f","text":"<pre><code>func_t f;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#variable-f_grad_x","title":"variable f_grad_x","text":"<pre><code>std::optional&lt; grad_func_t &gt; f_grad_x;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#variable-f_grad_u","title":"variable f_grad_u","text":"<pre><code>std::optional&lt; grad_func_t &gt; f_grad_u;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#variable-f_hessian_xx","title":"variable f_hessian_xx","text":"<pre><code>std::optional&lt; hessian_func_t &gt; f_hessian_xx;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#variable-f_hessian_ux","title":"variable f_hessian_ux","text":"<pre><code>std::optional&lt; hessian_func_t &gt; f_hessian_ux;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPFunctionalConstraint/#variable-f_hessian_uu","title":"variable f_hessian_uu","text":"<pre><code>std::optional&lt; hessian_func_t &gt; f_hessian_uu;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/","title":"cpp_robotics::OCPInputIndexedBoundConstraint","text":"<p><code>#include &lt;ocp_constraint.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPConstraint</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#public-types","title":"Public Types","text":"Name enum uint8_t BoundType"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#public-functions","title":"Public Functions","text":"Name OCPInputIndexedBoundConstraint(BoundType type, size_t index, double bound_val, double scale =1.0) virtual double eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::VectorXd grad_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::VectorXd grad_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPConstraint</p> Name using std::shared_ptr&lt; OCPConstraint &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPConstraint</p> Name OCPConstraint() OCPConstraint(OCPConstraintType type) bool satisfy(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const double tol) const <p>Public Attributes inherited from cpp_robotics::OCPConstraint</p> Name double eps OCPConstraintType type"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#enum-boundtype","title":"enum BoundType","text":"Enumerator Value Description Lower Upper"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#function-ocpinputindexedboundconstraint","title":"function OCPInputIndexedBoundConstraint","text":"<pre><code>inline OCPInputIndexedBoundConstraint(\n    BoundType type,\n    size_t index,\n    double bound_val,\n    double scale =1.0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#function-eval","title":"function eval","text":"<pre><code>inline virtual double eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#function-grad_x","title":"function grad_x","text":"<pre><code>inline virtual Eigen::VectorXd grad_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::grad_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#function-grad_u","title":"function grad_u","text":"<pre><code>inline virtual Eigen::VectorXd grad_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::grad_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#function-hessian_xx","title":"function hessian_xx","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_xx</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#function-hessian_uu","title":"function hessian_uu","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_uu(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_uu</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPInputIndexedBoundConstraint/#function-hessian_ux","title":"function hessian_ux","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_ux(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_ux</p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/","title":"cpp_robotics::OCPStateIndexedBoundConstraint","text":"<p><code>#include &lt;ocp_constraint.hpp&gt;</code></p> <p>Inherits from cpp_robotics::OCPConstraint</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#public-types","title":"Public Types","text":"Name enum uint8_t BoundType"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#public-functions","title":"Public Functions","text":"Name OCPStateIndexedBoundConstraint(BoundType type, size_t index, double bound_val, double scale =1.0) virtual double eval(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::VectorXd grad_x(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::VectorXd grad_u(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u) const override"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from cpp_robotics::OCPConstraint</p> Name using std::shared_ptr&lt; OCPConstraint &gt; SharedPtr <p>Public Functions inherited from cpp_robotics::OCPConstraint</p> Name OCPConstraint() OCPConstraint(OCPConstraintType type) bool satisfy(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const double tol) const <p>Public Attributes inherited from cpp_robotics::OCPConstraint</p> Name double eps OCPConstraintType type"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#enum-boundtype","title":"enum BoundType","text":"Enumerator Value Description Lower Upper"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#function-ocpstateindexedboundconstraint","title":"function OCPStateIndexedBoundConstraint","text":"<pre><code>inline OCPStateIndexedBoundConstraint(\n    BoundType type,\n    size_t index,\n    double bound_val,\n    double scale =1.0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#function-eval","title":"function eval","text":"<pre><code>inline virtual double eval(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::eval</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#function-grad_x","title":"function grad_x","text":"<pre><code>inline virtual Eigen::VectorXd grad_x(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::grad_x</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#function-grad_u","title":"function grad_u","text":"<pre><code>inline virtual Eigen::VectorXd grad_u(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::grad_u</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#function-hessian_xx","title":"function hessian_xx","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_xx(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_xx</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#function-hessian_uu","title":"function hessian_uu","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_uu(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_uu</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OCPStateIndexedBoundConstraint/#function-hessian_ux","title":"function hessian_ux","text":"<pre><code>inline virtual Eigen::MatrixXd hessian_ux(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u\n) const override\n</code></pre> <p>Reimplements: cpp_robotics::OCPConstraint::hessian_ux</p> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/","title":"cpp_robotics::Omni3Ik","text":"<p>3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-classes","title":"Public Classes","text":"Name struct Config"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-functions","title":"Public Functions","text":"Name Omni3Ik(double radius, double first_wheel_angle =M_PI/6) Omni3Ik(Config config) std::array&lt; double, 3 &gt; calculate(Transformd velocity) Config config() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-omni3ik","title":"function Omni3Ik","text":"<pre><code>inline Omni3Ik(\n    double radius,\n    double first_wheel_angle =M_PI/6\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-omni3ik_1","title":"function Omni3Ik","text":"<pre><code>inline Omni3Ik(\n    Config config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-calculate","title":"function calculate","text":"<pre><code>inline std::array&lt; double, 3 &gt; calculate(\n    Transformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-config","title":"function config","text":"<pre><code>inline Config config() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/","title":"cpp_robotics::Omni4Ik","text":"<p>4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-classes","title":"Public Classes","text":"Name struct Config"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-functions","title":"Public Functions","text":"Name Omni4Ik(double radius, double first_wheel_angle =M_PI/4) Omni4Ik(Config config) std::array&lt; double, 4 &gt; calculate(Transformd velocity) Config config() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-omni4ik","title":"function Omni4Ik","text":"<pre><code>inline Omni4Ik(\n    double radius,\n    double first_wheel_angle =M_PI/4\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-omni4ik_1","title":"function Omni4Ik","text":"<pre><code>inline Omni4Ik(\n    Config config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-calculate","title":"function calculate","text":"<pre><code>inline std::array&lt; double, 4 &gt; calculate(\n    Transformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-config","title":"function config","text":"<pre><code>inline Config config() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/","title":"cpp_robotics::OptimalControlProblem","text":"<p><code>#include &lt;optimal_control_problem.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#public-functions","title":"Public Functions","text":"Name OptimalControlProblem() =default OptimalControlProblem(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost) OptimalControlProblem(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost, const OCPConstraintArray &amp; constraints) size_t input_size() const size_t state_size() const size_t horizon() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#public-attributes","title":"Public Attributes","text":"Name std::shared_ptr&lt; OCPDynamics &gt; dynamics std::shared_ptr&lt; OCPCost &gt; cost OCPConstraintArray constraints"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#function-optimalcontrolproblem","title":"function OptimalControlProblem","text":"<pre><code>OptimalControlProblem() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#function-optimalcontrolproblem_1","title":"function OptimalControlProblem","text":"<pre><code>inline OptimalControlProblem(\n    OCPDynamics::SharedPtr dynamics,\n    OCPCost::SharedPtr cost\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#function-optimalcontrolproblem_2","title":"function OptimalControlProblem","text":"<pre><code>inline OptimalControlProblem(\n    OCPDynamics::SharedPtr dynamics,\n    OCPCost::SharedPtr cost,\n    const OCPConstraintArray &amp; constraints\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#function-input_size","title":"function input_size","text":"<pre><code>inline size_t input_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#function-state_size","title":"function state_size","text":"<pre><code>inline size_t state_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#function-horizon","title":"function horizon","text":"<pre><code>inline size_t horizon() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#variable-dynamics","title":"variable dynamics","text":"<pre><code>std::shared_ptr&lt; OCPDynamics &gt; dynamics;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#variable-cost","title":"variable cost","text":"<pre><code>std::shared_ptr&lt; OCPCost &gt; cost;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1OptimalControlProblem/#variable-constraints","title":"variable constraints","text":"<pre><code>OCPConstraintArray constraints;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/","title":"cpp_robotics::PID","text":"<p>PID\u5236\u5fa1\u5668 </p> <p><code>#include &lt;pid.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#public-classes","title":"Public Classes","text":"Name struct pid_param_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#public-functions","title":"Public Functions","text":"Name PID(pid_param_t param) void set_param(pid_param_t param) void reset() double calculate(double error)"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-pid","title":"function PID","text":"<pre><code>inline PID(\n    pid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-set_param","title":"function set_param","text":"<pre><code>inline void set_param(\n    pid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\n    double error\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/","title":"cpp_robotics::PID2","text":"<p>2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 </p> <p><code>#include &lt;pid2.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#public-classes","title":"Public Classes","text":"Name struct pid_param_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#public-functions","title":"Public Functions","text":"Name PID2 create_PI_D(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt) PID2 create_I_PD(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt) PID2 create_feed_foward_pid2(double Ts, double gpd, double Kpff, double Kdff, double Kpfb, double Kifb, double Kdfb, std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt) PID2(pid_param_t param) void set_param(pid_param_t param) void reset() double calculate(double target, double present)"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-create_pi_d","title":"function create_PI_D","text":"<pre><code>static inline PID2 create_PI_D(\n    double Ts,\n    double gpd,\n    double Kp,\n    double Ki,\n    double Kd,\n    std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-create_i_pd","title":"function create_I_PD","text":"<pre><code>static inline PID2 create_I_PD(\n    double Ts,\n    double gpd,\n    double Kp,\n    double Ki,\n    double Kd,\n    std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-create_feed_foward_pid2","title":"function create_feed_foward_pid2","text":"<pre><code>static inline PID2 create_feed_foward_pid2(\n    double Ts,\n    double gpd,\n    double Kpff,\n    double Kdff,\n    double Kpfb,\n    double Kifb,\n    double Kdfb,\n    std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-pid2","title":"function PID2","text":"<pre><code>inline PID2(\n    pid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-set_param","title":"function set_param","text":"<pre><code>inline void set_param(\n    pid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\n    double target,\n    double present\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/","title":"cpp_robotics::PSMC","text":"<p><code>#include &lt;psmc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#public-classes","title":"Public Classes","text":"Name struct param_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#public-functions","title":"Public Functions","text":"Name PSMC() PSMC(param_t param) PSMC(double p, double d, double Hs, double dt) PSMC(double p, double d, double Hs, double min_output, double max_output, double dt) void reset() void set_param(param_t param) double calculate(double target_val, double now_val) double calculate(double target_val, double now_val, double target_velocity, double now_velocity) double &amp; Kp() double &amp; Kd() double &amp; Hs()"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc","title":"function PSMC","text":"<pre><code>inline PSMC()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc_1","title":"function PSMC","text":"<pre><code>inline PSMC(\n    param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc_2","title":"function PSMC","text":"<pre><code>inline PSMC(\n    double p,\n    double d,\n    double Hs,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc_3","title":"function PSMC","text":"<pre><code>inline PSMC(\n    double p,\n    double d,\n    double Hs,\n    double min_output,\n    double max_output,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-set_param","title":"function set_param","text":"<pre><code>inline void set_param(\n    param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\n    double target_val,\n    double now_val\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-calculate_1","title":"function calculate","text":"<pre><code>inline double calculate(\n    double target_val,\n    double now_val,\n    double target_velocity,\n    double now_velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-kp","title":"function Kp","text":"<pre><code>inline double &amp; Kp()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-kd","title":"function Kd","text":"<pre><code>inline double &amp; Kd()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-hs","title":"function Hs","text":"<pre><code>inline double &amp; Hs()\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/","title":"cpp_robotics::PurePursuit","text":"<p>Pure pursuit\u5236\u5fa1\u5668 </p> <p><code>#include &lt;pure_pursuit.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#public-functions","title":"Public Functions","text":"Name PurePursuit(double K) void set_K(double K) std::tuple&lt; bool, double &gt; control(std::function&lt; Vector2d(double)&gt; traj_ref, double traj_progress, Vector2d pos_present, double vel, double angle_present)"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-purepursuit","title":"function PurePursuit","text":"<pre><code>inline PurePursuit(\n    double K\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-set_k","title":"function set_K","text":"<pre><code>inline void set_K(\n    double K\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-control","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, double &gt; control(\n    std::function&lt; Vector2d(double)&gt; traj_ref,\n    double traj_progress,\n    Vector2d pos_present,\n    double vel,\n    double angle_present\n)\n</code></pre> <p>Parameters: </p> <ul> <li>traj_ref \u59cb\u70b9\u304b\u3089\u306e\u9577\u3055\u306b\u3088\u308b\u7d4c\u8def\u306e\u95a2\u6570 </li> <li>traj_progress \u73fe\u5728\u306e\u7d4c\u8def\u4e0a\u306e\u9577\u3055\u4f4d\u7f6e </li> <li>pos_present \u73fe\u5728\u306e\u5ea7\u6a19 </li> <li>target_angle_offset traj_ref\u304b\u3089\u76ee\u6a19\u5ea7\u6a19\u3092\u53d6\u3063\u3066\u304d\u305f\u6642\u306b\u4f4d\u7f6e\u8aa4\u5dee\u304b\u3089\u89d2\u5ea6\u3092\u51fa\u3057\u305f\u6642\u306b\u52a0\u3048\u308b\u30aa\u30d5\u30bb\u30c3\u30c8 </li> <li>vel \u73fe\u5728\u306e\u9032\u884c\u65b9\u5411\u306e\u901f\u5ea6 </li> <li>angle_present \u73fe\u5728\u306e\u30ed\u30dc\u30c3\u30c8\u306eYaw\u89d2\u5ea6 </li> </ul> <p>Return: std::tuple [Pure Pursuit\u304c\u6709\u52b9\u306a\u51fa\u529b\u3092\u8fd4\u3059\u304b, \u51fa\u529b\u5024]  <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/","title":"cpp_robotics::QuadProg","text":"<p>\u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 </p> <p><code>#include &lt;quadprog.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-classes","title":"Public Classes","text":"Name struct Param struct Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-functions","title":"Public Functions","text":"Name void set_problem_size(const size_t valiable_size, const size_t ineq_constraint_size, const size_t eq_constraint_size) void debug_prog() Result solve(Eigen::VectorXd x_init) double evaluate(const Eigen::VectorXd &amp; x) Eigen::VectorXd grad_lagrange(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const Eigen::VectorXd &amp; v) bool satisfy(const Eigen::MatrixXd &amp; x, double eps =1e-5)"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-attributes","title":"Public Attributes","text":"Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd Aeq Eigen::VectorXd beq Eigen::MatrixXd A Eigen::VectorXd b Param param"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-set_problem_size","title":"function set_problem_size","text":"<pre><code>inline void set_problem_size(\n    const size_t valiable_size,\n    const size_t ineq_constraint_size,\n    const size_t eq_constraint_size\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-debug_prog","title":"function debug_prog","text":"<pre><code>inline void debug_prog()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-solve","title":"function solve","text":"<pre><code>inline Result solve(\n    Eigen::VectorXd x_init\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-evaluate","title":"function evaluate","text":"<pre><code>inline double evaluate(\n    const Eigen::VectorXd &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-grad_lagrange","title":"function grad_lagrange","text":"<pre><code>inline Eigen::VectorXd grad_lagrange(\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; u,\n    const Eigen::VectorXd &amp; v\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-satisfy","title":"function satisfy","text":"<pre><code>inline bool satisfy(\n    const Eigen::MatrixXd &amp; x,\n    double eps =1e-5\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-c","title":"variable c","text":"<pre><code>Eigen::VectorXd c;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-aeq","title":"variable Aeq","text":"<pre><code>Eigen::MatrixXd Aeq;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-beq","title":"variable beq","text":"<pre><code>Eigen::VectorXd beq;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-a","title":"variable A","text":"<pre><code>Eigen::MatrixXd A;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-b","title":"variable b","text":"<pre><code>Eigen::VectorXd b;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-param","title":"variable param","text":"<pre><code>Param param;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/","title":"cpp_robotics::RandomGenerator","text":"<p>std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668  More...</p> <p><code>#include &lt;random.hpp&gt;</code></p> <p>Inherits from Distribution</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-types","title":"Public Types","text":"Name using Distribution distribution_t using EngineMethod engine_method_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-functions","title":"Public Functions","text":"Name template &lt;typename ... Arg&gt;  RandomGenerator(Arg ... arg)\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 distribution_t::result_type value()\u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Distribution ,\nclass EngineMethod  =std::mt19937&gt;\nclass cpp_robotics::RandomGenerator;\n</code></pre> <p>std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 </p> <p>Template Parameters: </p> <ul> <li>Distribution \u4e71\u6570\u306e\u5206\u5e03, std::normal_distribution\u7b49  <li>EngineMethod \u7591\u4f3c\u4e71\u6570\u751f\u6210\u6cd5, std::mt19937\u7b49 </li>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#using-distribution_t","title":"using distribution_t","text":"<pre><code>using cpp_robotics::RandomGenerator&lt; Distribution, EngineMethod &gt;::distribution_t =  Distribution;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#using-engine_method_t","title":"using engine_method_t","text":"<pre><code>using cpp_robotics::RandomGenerator&lt; Distribution, EngineMethod &gt;::engine_method_t =  EngineMethod;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#function-randomgenerator","title":"function RandomGenerator","text":"<pre><code>template &lt;typename ... Arg&gt;\ninline RandomGenerator(\n    Arg ... arg\n)\n</code></pre> <p>\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 </p> <p>Parameters: </p> <ul> <li>arg </li> </ul> <p>Template Parameters: </p> <ul> <li>Arg </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#function-value","title":"function value","text":"<pre><code>inline distribution_t::result_type value()\n</code></pre> <p>\u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046 </p> <p>Return: distribution_t::result_type </p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/","title":"cpp_robotics::SISOPFC","text":"<p><code>#include &lt;pfc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#public-functions","title":"Public Functions","text":"Name SISOPFC(const Eigen::MatrixXd &amp; Ad, const Eigen::VectorXd &amp; Bd, const Eigen::VectorXd &amp; Cd, const double delay, const double target_responce_time, const double dt)Construct a new SISOPFC object. double calculate(std::function&lt; double(double)&gt; ref_target, double now_state) double calculate(std::function&lt; double(double)&gt; ref_target, double now_state, double prev_input) double prev_input() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-sisopfc","title":"function SISOPFC","text":"<pre><code>inline SISOPFC(\n    const Eigen::MatrixXd &amp; Ad,\n    const Eigen::VectorXd &amp; Bd,\n    const Eigen::VectorXd &amp; Cd,\n    const double delay,\n    const double target_responce_time,\n    const double dt\n)\n</code></pre> <p>Construct a new SISOPFC object. </p> <p>Parameters: </p> <ul> <li>Ad </li> <li>Bd </li> <li>Cd </li> <li>delay </li> <li>target_responce_time </li> <li>dt </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\n    std::function&lt; double(double)&gt; ref_target,\n    double now_state\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-calculate_1","title":"function calculate","text":"<pre><code>inline double calculate(\n    std::function&lt; double(double)&gt; ref_target,\n    double now_state,\n    double prev_input\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-prev_input","title":"function prev_input","text":"<pre><code>inline double prev_input() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/","title":"cpp_robotics::SQP","text":"<p>SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) </p> <p><code>#include &lt;sqp.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-classes","title":"Public Classes","text":"Name struct Problem struct Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-types","title":"Public Types","text":"Name using std::function&lt; double(Eigen::VectorXd)&gt; func_type using std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad_func_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-functions","title":"Public Functions","text":"Name Result solve(Problem prob, const Eigen::VectorXd &amp; x0, std::optional&lt; std::function&lt; void(Eigen::VectorXd)&gt;&gt; callback =std::nullopt)"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#using-func_type","title":"using func_type","text":"<pre><code>using cpp_robotics::SQP::func_type =  std::function&lt;double(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#using-grad_func_type","title":"using grad_func_type","text":"<pre><code>using cpp_robotics::SQP::grad_func_type =  std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#function-solve","title":"function solve","text":"<pre><code>inline Result solve(\n    Problem prob,\n    const Eigen::VectorXd &amp; x0,\n    std::optional&lt; std::function&lt; void(Eigen::VectorXd)&gt;&gt; callback =std::nullopt\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/","title":"cpp_robotics::Singleton","text":"<p>\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b  More...</p> <p><code>#include &lt;singleton.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-types","title":"Public Types","text":"Name using T class_t using std::shared_ptr&lt; class_t &gt; shared_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-functions","title":"Public Functions","text":"Name shared_t get_shared_instance()\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass cpp_robotics::Singleton;\n</code></pre> <p>\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b </p> <p>Template Parameters: </p> <ul> <li>T \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u3067\u751f\u6210\u3057\u305f\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u578b </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#using-class_t","title":"using class_t","text":"<pre><code>using cpp_robotics::Singleton&lt; T &gt;::class_t =  T;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#using-shared_t","title":"using shared_t","text":"<pre><code>using cpp_robotics::Singleton&lt; T &gt;::shared_t =  std::shared_ptr&lt;class_t&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#function-get_shared_instance","title":"function get_shared_instance","text":"<pre><code>static inline shared_t get_shared_instance()\n</code></pre> <p>\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059 </p> <p>Return: shared_t \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306eshared_ptr </p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/","title":"cpp_robotics::SisoFeedbackSystem","text":"<p>\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 </p> <p><code>#include &lt;siso_system.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-classes","title":"Public Classes","text":"Name struct func_list_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-functions","title":"Public Functions","text":"Name SisoFeedbackSystem() =default SisoFeedbackSystem(func_list_t fn, double dt) void reset() double responce(double target) std::tuple&lt; double, double &gt; responce_uy(double target) double Ts() const double u() const double y() const std::function&lt; double(double)&gt; make_control_function() operator std::function&lt; double(double )"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-sisofeedbacksystem","title":"function SisoFeedbackSystem","text":"<pre><code>SisoFeedbackSystem() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-sisofeedbacksystem_1","title":"function SisoFeedbackSystem","text":"<pre><code>inline SisoFeedbackSystem(\n    func_list_t fn,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-responce","title":"function responce","text":"<pre><code>inline double responce(\n    double target\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-responce_uy","title":"function responce_uy","text":"<pre><code>inline std::tuple&lt; double, double &gt; responce_uy(\n    double target\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-u","title":"function u","text":"<pre><code>inline double u() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-y","title":"function y","text":"<pre><code>inline double y() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-make_control_function","title":"function make_control_function","text":"<pre><code>inline std::function&lt; double(double)&gt; make_control_function()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-operator-stdfunction-double","title":"function operator std::function&lt; double","text":"<pre><code>inline operator std::function&lt; double(\n    double \n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/","title":"cpp_robotics::Spline2D","text":"<p>2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 </p> <p><code>#include &lt;spline.hpp&gt;</code></p> <p>Inherited by cpp_robotics::CatumullRom2D, cpp_robotics::CubicSpline</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-classes","title":"Protected Classes","text":"Name struct segment_info_t struct segment_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#public-functions","title":"Public Functions","text":"Name Spline2D() =default bool is_empty() size_t size() size_t point_num() double length() double length(size_t i) Vector2d position(double length) Vector2d spline_position(double t) Vector2d spline_velocity(double t) Vector2d spline_acceleration(double t)"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-functions","title":"Protected Functions","text":"Name segment_info_t get_segmet_idx(const double t) segment_info_t get_segmet_idx_length(double length)"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-attributes","title":"Protected Attributes","text":"Name std::vector&lt; segment_t &gt; _spline bool _is_empty size_t _size double _all_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-spline2d","title":"function Spline2D","text":"<pre><code>Spline2D() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-is_empty","title":"function is_empty","text":"<pre><code>inline bool is_empty()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-size","title":"function size","text":"<pre><code>inline size_t size()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-point_num","title":"function point_num","text":"<pre><code>inline size_t point_num()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-length","title":"function length","text":"<pre><code>inline double length()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-length_1","title":"function length","text":"<pre><code>inline double length(\n    size_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-position","title":"function position","text":"<pre><code>inline Vector2d position(\n    double length\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-spline_position","title":"function spline_position","text":"<pre><code>inline Vector2d spline_position(\n    double t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-spline_velocity","title":"function spline_velocity","text":"<pre><code>inline Vector2d spline_velocity(\n    double t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-spline_acceleration","title":"function spline_acceleration","text":"<pre><code>inline Vector2d spline_acceleration(\n    double t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-get_segmet_idx","title":"function get_segmet_idx","text":"<pre><code>inline segment_info_t get_segmet_idx(\n    const double t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-get_segmet_idx_length","title":"function get_segmet_idx_length","text":"<pre><code>inline segment_info_t get_segmet_idx_length(\n    double length\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_spline","title":"variable _spline","text":"<pre><code>std::vector&lt; segment_t &gt; _spline;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_is_empty","title":"variable _is_empty","text":"<pre><code>bool _is_empty;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_size","title":"variable _size","text":"<pre><code>size_t _size;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_all_length","title":"variable _all_length","text":"<pre><code>double _all_length;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/","title":"cpp_robotics::StateSpaceSystem","text":"<p>\u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb </p> <p><code>#include &lt;state_space_system.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#public-functions","title":"Public Functions","text":"Name StateSpaceSystem() =default template &lt;typename DerivedA ,typename DerivedB ,typename DerivedC &gt;  StateSpaceSystem(const Eigen::MatrixBase&lt; DerivedA &gt; &amp; A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp; B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp; C, const double Ts) template &lt;typename DerivedA ,typename DerivedB ,typename DerivedC &gt; void set_continuous(const Eigen::MatrixBase&lt; DerivedA &gt; &amp; A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp; B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp; C, const double Ts, const bool skip_state_reset =false) template &lt;typename DerivedA ,typename DerivedB ,typename DerivedC &gt; void set_discrite(const Eigen::MatrixBase&lt; DerivedA &gt; &amp; Ad, const Eigen::MatrixBase&lt; DerivedB &gt; &amp; Bd, const Eigen::MatrixBase&lt; DerivedC &gt; &amp; Cd, const double Ts, const bool skip_state_reset =false) size_t state_size() const size_t input_size() const size_t output_size() const bool is_siso_model() const void set_state_zero() void set_state(const Eigen::VectorXd &amp; x) void set_state(const double &amp; x) auto responce(const Eigen::VectorXd &amp; u) double responce(double u) std::optional&lt; Eigen::MatrixXd &gt; A() const std::optional&lt; Eigen::MatrixXd &gt; B() const double Ts() const Eigen::MatrixXd Ad() const Eigen::MatrixXd Bd() const Eigen::MatrixXd C() const Eigen::MatrixXd Cd() const Eigen::VectorXd x() const Eigen::VectorXd y() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-statespacesystem","title":"function StateSpaceSystem","text":"<pre><code>StateSpaceSystem() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-statespacesystem_1","title":"function StateSpaceSystem","text":"<pre><code>template &lt;typename DerivedA ,\ntypename DerivedB ,\ntypename DerivedC &gt;\ninline StateSpaceSystem(\n    const Eigen::MatrixBase&lt; DerivedA &gt; &amp; A,\n    const Eigen::MatrixBase&lt; DerivedB &gt; &amp; B,\n    const Eigen::MatrixBase&lt; DerivedC &gt; &amp; C,\n    const double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_continuous","title":"function set_continuous","text":"<pre><code>template &lt;typename DerivedA ,\ntypename DerivedB ,\ntypename DerivedC &gt;\ninline void set_continuous(\n    const Eigen::MatrixBase&lt; DerivedA &gt; &amp; A,\n    const Eigen::MatrixBase&lt; DerivedB &gt; &amp; B,\n    const Eigen::MatrixBase&lt; DerivedC &gt; &amp; C,\n    const double Ts,\n    const bool skip_state_reset =false\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_discrite","title":"function set_discrite","text":"<pre><code>template &lt;typename DerivedA ,\ntypename DerivedB ,\ntypename DerivedC &gt;\ninline void set_discrite(\n    const Eigen::MatrixBase&lt; DerivedA &gt; &amp; Ad,\n    const Eigen::MatrixBase&lt; DerivedB &gt; &amp; Bd,\n    const Eigen::MatrixBase&lt; DerivedC &gt; &amp; Cd,\n    const double Ts,\n    const bool skip_state_reset =false\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-state_size","title":"function state_size","text":"<pre><code>inline size_t state_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-input_size","title":"function input_size","text":"<pre><code>inline size_t input_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-output_size","title":"function output_size","text":"<pre><code>inline size_t output_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-is_siso_model","title":"function is_siso_model","text":"<pre><code>inline bool is_siso_model() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state_zero","title":"function set_state_zero","text":"<pre><code>inline void set_state_zero()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state","title":"function set_state","text":"<pre><code>inline void set_state(\n    const Eigen::VectorXd &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state_1","title":"function set_state","text":"<pre><code>inline void set_state(\n    const double &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-responce","title":"function responce","text":"<pre><code>inline auto responce(\n    const Eigen::VectorXd &amp; u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-responce_1","title":"function responce","text":"<pre><code>inline double responce(\n    double u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-a","title":"function A","text":"<pre><code>inline std::optional&lt; Eigen::MatrixXd &gt; A() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-b","title":"function B","text":"<pre><code>inline std::optional&lt; Eigen::MatrixXd &gt; B() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-ad","title":"function Ad","text":"<pre><code>inline Eigen::MatrixXd Ad() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-bd","title":"function Bd","text":"<pre><code>inline Eigen::MatrixXd Bd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-c","title":"function C","text":"<pre><code>inline Eigen::MatrixXd C() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-cd","title":"function Cd","text":"<pre><code>inline Eigen::MatrixXd Cd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-x","title":"function x","text":"<pre><code>inline Eigen::VectorXd x() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-y","title":"function y","text":"<pre><code>inline Eigen::VectorXd y() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/","title":"cpp_robotics::SwerveIk","text":"<p>\u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;swerve_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-types","title":"Public Types","text":"Name using std::array&lt; Vector2d, 4 &gt; VecArray"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-functions","title":"Public Functions","text":"Name SwerveIk(const double width, const double length) SwerveIk(VecArray wheel_place) VecArray calculate(Transformd velocity) VecArray wheel_place() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#using-vecarray","title":"using VecArray","text":"<pre><code>using cpp_robotics::SwerveIk::VecArray =  std::array&lt;Vector2d, 4&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-swerveik","title":"function SwerveIk","text":"<pre><code>inline SwerveIk(\n    const double width,\n    const double length\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-swerveik_1","title":"function SwerveIk","text":"<pre><code>inline SwerveIk(\n    VecArray wheel_place\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-calculate","title":"function calculate","text":"<pre><code>inline VecArray calculate(\n    Transformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-wheel_place","title":"function wheel_place","text":"<pre><code>inline VecArray wheel_place() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/","title":"cpp_robotics::Timer","text":"<p><code>#include &lt;timer.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#public-functions","title":"Public Functions","text":"Name void start() void stop() double second() double millisecond()"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-start","title":"function start","text":"<pre><code>inline void start()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-stop","title":"function stop","text":"<pre><code>inline void stop()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-second","title":"function second","text":"<pre><code>inline double second()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-millisecond","title":"function millisecond","text":"<pre><code>inline double millisecond()\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/","title":"cpp_robotics::TransferFunction","text":"<p>\u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb </p> <p><code>#include &lt;transfer_function.hpp&gt;</code></p> <p>Inherited by cpp_robotics::BandPassFilter, cpp_robotics::ButterworthFilter, cpp_robotics::Differentiator, cpp_robotics::HighPassFilter, cpp_robotics::Integrator, cpp_robotics::LowPassFilter, cpp_robotics::NotchFilter</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#public-classes","title":"Public Classes","text":"Name struct tf_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#protected-classes","title":"Protected Classes","text":"Name class CircularBuffer"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#public-functions","title":"Public Functions","text":"Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts)Construct a new Transfer Function object. TransferFunction(const tf_t &amp; tf_config) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const operator tf_t() const tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#protected-attributes","title":"Protected Attributes","text":"Name std::vector&lt; double &gt; num_array_ std::vector&lt; double &gt; den_array_ std::vector&lt; double &gt; num_ std::vector&lt; double &gt; den_ CircularBuffer&lt; double &gt; u_ CircularBuffer&lt; double &gt; y_ double dt_"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friends","title":"Friends","text":"Name tf_t operator+(double val, const TransferFunction &amp; tf) tf_t operator-(double val, const TransferFunction &amp; tf) tf_t operator*(double val, const TransferFunction &amp; tf) tf_t operator/(double val, const TransferFunction &amp; tf) tf_t operator+(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator-(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator*(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator/(const tf_t &amp; a, const TransferFunction &amp; b) tf_t operator+(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator-(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator*(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator/(const TransferFunction &amp; a, const tf_t &amp; b) tf_t operator+(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator-(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator*(const TransferFunction &amp; a, const TransferFunction &amp; b) tf_t operator/(const TransferFunction &amp; a, const TransferFunction &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const TransferFunction &amp; tf)"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-make_first_order_system","title":"function make_first_order_system","text":"<pre><code>static inline TransferFunction make_first_order_system(\n    const double T,\n    const double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-make_second_order_system","title":"function make_second_order_system","text":"<pre><code>static inline TransferFunction make_second_order_system(\n    const double omega,\n    const double zeta,\n    const double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-transferfunction","title":"function TransferFunction","text":"<pre><code>TransferFunction() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-transferfunction_1","title":"function TransferFunction","text":"<pre><code>inline TransferFunction(\n    std::vector&lt; double &gt; num,\n    std::vector&lt; double &gt; den,\n    const double Ts\n)\n</code></pre> <p>Construct a new Transfer Function object. </p> <p>Parameters: </p> <ul> <li>num \u5206\u5b50\u306e\u4fc2\u6570 \u914d\u5217\u306e\u5148\u982d\u304c\u6700\u9ad8\u6b21\u306e\u4fc2\u6570 </li> <li>den \u5206\u6bcd\u306e\u4fc2\u6570 \u914d\u5217\u306e\u5148\u982d\u304c\u6700\u9ad8\u6b21\u306e\u4fc2\u6570 </li> <li>Ts \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-transferfunction_2","title":"function TransferFunction","text":"<pre><code>inline TransferFunction(\n    const tf_t &amp; tf_config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-set_continuous","title":"function set_continuous","text":"<pre><code>inline void set_continuous(\n    std::vector&lt; double &gt; num,\n    std::vector&lt; double &gt; den,\n    const double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-set_discrite","title":"function set_discrite","text":"<pre><code>inline void set_discrite(\n    std::vector&lt; double &gt; num_disc,\n    std::vector&lt; double &gt; den_disc,\n    const double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre> <p>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset(\n    double state =0\n)\n</code></pre> <p>Reimplemented by: cpp_robotics::Differentiator::reset</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-responce","title":"function responce","text":"<pre><code>inline double responce(\n    double u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-num_deg","title":"function num_deg","text":"<pre><code>inline size_t num_deg(\n    size_t num_idx =0\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-den_deg","title":"function den_deg","text":"<pre><code>inline size_t den_deg(\n    size_t num_idx =0\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-num_array","title":"function num_array","text":"<pre><code>inline std::vector&lt; double &gt; num_array() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-den_array","title":"function den_array","text":"<pre><code>inline std::vector&lt; double &gt; den_array() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-operator-tf_t","title":"function operator tf_t","text":"<pre><code>inline operator tf_t() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-inv","title":"function inv","text":"<pre><code>inline tf_t inv() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-operator","title":"function operator+","text":"<pre><code>inline tf_t operator+(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-operator-","title":"function operator-","text":"<pre><code>inline tf_t operator-(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-operator_1","title":"function operator*","text":"<pre><code>inline tf_t operator*(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-operator_2","title":"function operator/","text":"<pre><code>inline tf_t operator/(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#variable-num_array_","title":"variable num_array_","text":"<pre><code>std::vector&lt; double &gt; num_array_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#variable-den_array_","title":"variable den_array_","text":"<pre><code>std::vector&lt; double &gt; den_array_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#variable-num_","title":"variable num_","text":"<pre><code>std::vector&lt; double &gt; num_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#variable-den_","title":"variable den_","text":"<pre><code>std::vector&lt; double &gt; den_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#variable-u_","title":"variable u_","text":"<pre><code>CircularBuffer&lt; double &gt; u_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#variable-y_","title":"variable y_","text":"<pre><code>CircularBuffer&lt; double &gt; y_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#variable-dt_","title":"variable dt_","text":"<pre><code>double dt_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator","title":"friend operator+","text":"<pre><code>friend tf_t operator+(\n    double val,\n\n    const TransferFunction &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator-","title":"friend operator-","text":"<pre><code>friend tf_t operator-(\n    double val,\n\n    const TransferFunction &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_1","title":"friend operator*","text":"<pre><code>friend tf_t operator*(\n    double val,\n\n    const TransferFunction &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_2","title":"friend operator/","text":"<pre><code>friend tf_t operator/(\n    double val,\n\n    const TransferFunction &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_3","title":"friend operator+","text":"<pre><code>friend tf_t operator+(\n    const tf_t &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator-_1","title":"friend operator-","text":"<pre><code>friend tf_t operator-(\n    const tf_t &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_4","title":"friend operator*","text":"<pre><code>friend tf_t operator*(\n    const tf_t &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_5","title":"friend operator/","text":"<pre><code>friend tf_t operator/(\n    const tf_t &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_6","title":"friend operator+","text":"<pre><code>friend tf_t operator+(\n    const TransferFunction &amp; a,\n\n    const tf_t &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator-_2","title":"friend operator-","text":"<pre><code>friend tf_t operator-(\n    const TransferFunction &amp; a,\n\n    const tf_t &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_7","title":"friend operator*","text":"<pre><code>friend tf_t operator*(\n    const TransferFunction &amp; a,\n\n    const tf_t &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_8","title":"friend operator/","text":"<pre><code>friend tf_t operator/(\n    const TransferFunction &amp; a,\n\n    const tf_t &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_9","title":"friend operator+","text":"<pre><code>friend tf_t operator+(\n    const TransferFunction &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator-_3","title":"friend operator-","text":"<pre><code>friend tf_t operator-(\n    const TransferFunction &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_10","title":"friend operator*","text":"<pre><code>friend tf_t operator*(\n    const TransferFunction &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_11","title":"friend operator/","text":"<pre><code>friend tf_t operator/(\n    const TransferFunction &amp; a,\n\n    const TransferFunction &amp; b\n);\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#friend-operator_12","title":"friend operator&lt;&lt;","text":"<pre><code>friend std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; stream,\n\n    const TransferFunction &amp; tf\n);\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/","title":"cpp_robotics::TransferFunction::CircularBuffer","text":"<p>More...</p> <p><code>#include &lt;transfer_function.hpp&gt;</code></p> <p>Inherits from std::vector&lt; T &gt;</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#public-functions","title":"Public Functions","text":"Name void reset_position() T &amp; at_circular(size_t idx) void insert_front(T val)"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass cpp_robotics::TransferFunction::CircularBuffer;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#function-reset_position","title":"function reset_position","text":"<pre><code>inline void reset_position()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#function-at_circular","title":"function at_circular","text":"<pre><code>inline T &amp; at_circular(\n    size_t idx\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#function-insert_front","title":"function insert_front","text":"<pre><code>inline void insert_front(\n    T val\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/","title":"cpp_robotics::VelocityLimitFilter","text":"<p>\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;velocity_limit_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-functions","title":"Public Functions","text":"Name VelocityLimitFilter(double v_max, double dt) VelocityLimitFilter(double v_max, double dt, std::pair&lt; double, double &gt; limit) VelocityLimitFilter(double v_max, double dt, double gpd, double fb_gain, std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt) virtual void reset() void reset(double u) virtual double filtering(double u) double Ts() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter","title":"function VelocityLimitFilter","text":"<pre><code>inline VelocityLimitFilter(\n    double v_max,\n    double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter_1","title":"function VelocityLimitFilter","text":"<pre><code>inline VelocityLimitFilter(\n    double v_max,\n    double dt,\n    std::pair&lt; double, double &gt; limit\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter_2","title":"function VelocityLimitFilter","text":"<pre><code>inline VelocityLimitFilter(\n    double v_max,\n    double dt,\n    double gpd,\n    double fb_gain,\n    std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-reset_1","title":"function reset","text":"<pre><code>inline void reset(\n    double u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline virtual double filtering(\n    double u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/","title":"cpp_robotics::VelocityLimitFilter::DiffPair","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#public-functions","title":"Public Functions","text":"Name DiffPair(double gpd, double Ts) void reset() void reset(double u) std::tuple&lt; double, double &gt; filtering(double u)"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-diffpair","title":"function DiffPair","text":"<pre><code>inline DiffPair(\n    double gpd,\n    double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-reset_1","title":"function reset","text":"<pre><code>inline void reset(\n    double u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-filtering","title":"function filtering","text":"<pre><code>inline std::tuple&lt; double, double &gt; filtering(\n    double u\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2LinkRobot/","title":"cpp_robotics::XY2LinkRobot","text":"<p><code>#include &lt;xy_2link_robot.hpp&gt;</code></p> <p>Inherits from cpp_robotics::ArmForwardKinematics&lt; XY2LinkRobot &gt;</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2LinkRobot/#public-functions","title":"Public Functions","text":"Name XY2LinkRobot(double l1, double l2) template &lt;typename Vector &gt; void forward_kinematics(const Vector &amp; q, Vector &amp; x)"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2LinkRobot/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::ArmForwardKinematics&lt; XY2LinkRobot &gt;</p> Name ArmForwardKinematics(size_t nq, size_t nx)Construct a new Arm IK object. Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles) Eigen::VectorXd solve_ik(Eigen::VectorXd pos, Eigen::VectorXd joint_angles0) Eigen::VectorXd solve_ik(Eigen::VectorXd pos) Eigen::MatrixXd jacobian(Eigen::VectorXd joint_angles)"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2LinkRobot/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2LinkRobot/#function-xy2linkrobot","title":"function XY2LinkRobot","text":"<pre><code>inline XY2LinkRobot(\n    double l1,\n    double l2\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2LinkRobot/#function-forward_kinematics","title":"function forward_kinematics","text":"<pre><code>template &lt;typename Vector &gt;\ninline void forward_kinematics(\n    const Vector &amp; q,\n    Vector &amp; x\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/","title":"cpp_robotics::iLQR","text":"<p><code>#include &lt;ilqr.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#public-types","title":"Public Types","text":"Name enum class Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#public-functions","title":"Public Functions","text":"Name iLQR(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost, iLQRConfig config =iLQRConfig()) iLQR(const OptimalControlProblem &amp; prob, iLQRConfig config =iLQRConfig()) Result generate_trajectory(const Eigen::VectorXd &amp; x0) const std::vector&lt; Eigen::VectorXd &gt; &amp; get_input() const const std::vector&lt; Eigen::VectorXd &gt; &amp; get_state() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#enum-result","title":"enum Result","text":"Enumerator Value Description SUCCESS 0 MAX_ITER_REACHED FAILED"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#function-ilqr","title":"function iLQR","text":"<pre><code>inline iLQR(\n    OCPDynamics::SharedPtr dynamics,\n    OCPCost::SharedPtr cost,\n    iLQRConfig config =iLQRConfig()\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#function-ilqr_1","title":"function iLQR","text":"<pre><code>inline iLQR(\n    const OptimalControlProblem &amp; prob,\n    iLQRConfig config =iLQRConfig()\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#function-generate_trajectory","title":"function generate_trajectory","text":"<pre><code>inline Result generate_trajectory(\n    const Eigen::VectorXd &amp; x0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#function-get_input","title":"function get_input","text":"<pre><code>inline const std::vector&lt; Eigen::VectorXd &gt; &amp; get_input() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1iLQR/#function-get_state","title":"function get_state","text":"<pre><code>inline const std::vector&lt; Eigen::VectorXd &gt; &amp; get_state() const\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/","title":"cpp_robotics::unit::Unit","text":"<p>\u5358\u4f4d\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-types","title":"Public Types","text":"Name using T value_type using UnitDimType unit_dimention_type using P prefix_type using Unit&lt; T, UnitDimType, P &gt; unit_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-functions","title":"Public Functions","text":"Name Unit() =default constexpr Unit(T val) constexpr T value() const constexpr T raw_value() const constexpr unit_type operator+() const constexpr unit_type operator-() const constexpr unit_type operator+(const unit_type &amp; rhl) const constexpr unit_type operator-(const unit_type &amp; rhl) const constexpr auto operator*(const unit_type &amp; rhl) const constexpr unit_type &amp; operator+=(const unit_type &amp; rhl) constexpr unit_type &amp; operator-=(const unit_type &amp; rhl) template &lt;int R_Tag&gt; constexpr operator Unit&lt; value_type, unit_dimention_type, prefix_type, R_Tag &gt;() const template &lt;class R_P &gt; constexpr operator Unit&lt; value_type, unit_dimention_type, R_P, tag &gt;() const constexpr operator value_type() const constexpr bool operator==(const unit_type &amp; r_value) constexpr bool operator!=(const unit_type &amp; r_value)"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-attributes","title":"Public Attributes","text":"Name constexpr int tag"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T ,\nclass UnitDimType ,\nclass P ,\nint Tag =-1&gt;\nclass cpp_robotics::unit::Unit;\n</code></pre> <p>\u5358\u4f4d\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>T \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u578b </li> <li>UnitDimType \u6b21\u5143 </li> <li>P \u63a5\u982d\u8f9e </li> <li>Tag \u540c\u6b21\u5143\u306e\u5358\u4f4d\u7cfb\u3092\u533a\u5225\u3059\u308b\u30bf\u30b0 </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::value_type =  T;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-unit_dimention_type","title":"using unit_dimention_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::unit_dimention_type =  UnitDimType;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-prefix_type","title":"using prefix_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::prefix_type =  P;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-unit_type","title":"using unit_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::unit_type =  Unit&lt;T, UnitDimType, P&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-unit","title":"function Unit","text":"<pre><code>Unit() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-unit_1","title":"function Unit","text":"<pre><code>inline constexpr Unit(\n    T val\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-value","title":"function value","text":"<pre><code>inline constexpr T value() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-raw_value","title":"function raw_value","text":"<pre><code>inline constexpr T raw_value() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr unit_type operator+() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr unit_type operator-() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_1","title":"function operator+","text":"<pre><code>inline constexpr unit_type operator+(\n    const unit_type &amp; rhl\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr unit_type operator-(\n    const unit_type &amp; rhl\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_2","title":"function operator*","text":"<pre><code>inline constexpr auto operator*(\n    const unit_type &amp; rhl\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_3","title":"function operator+=","text":"<pre><code>inline constexpr unit_type &amp; operator+=(\n    const unit_type &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr unit_type &amp; operator-=(\n    const unit_type &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-unit-value_type-unit_dimention_type-prefix_type-r_tag","title":"function operator Unit&lt; value_type, unit_dimention_type, prefix_type, R_Tag &gt;","text":"<pre><code>template &lt;int R_Tag&gt;\ninline constexpr operator Unit&lt; value_type, unit_dimention_type, prefix_type, R_Tag &gt;() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-unit-value_type-unit_dimention_type-r_p-tag","title":"function operator Unit&lt; value_type, unit_dimention_type, R_P, tag &gt;","text":"<pre><code>template &lt;class R_P &gt;\ninline constexpr operator Unit&lt; value_type, unit_dimention_type, R_P, tag &gt;() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-value_type","title":"function operator value_type","text":"<pre><code>inline constexpr operator value_type() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_4","title":"function operator==","text":"<pre><code>inline constexpr bool operator==(\n    const unit_type &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_5","title":"function operator!=","text":"<pre><code>inline constexpr bool operator!=(\n    const unit_type &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#variable-tag","title":"variable tag","text":"<pre><code>static constexpr int tag = Tag;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/","title":"cpp_robotics::ALConfig","text":"<p><code>#include &lt;al_ilqr.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#public-attributes","title":"Public Attributes","text":"Name size_t max_iter size_t max_ilqr_iter double cost_torelance double constraint_torelance double beta1 double beta2 double alpha_scale size_t max_forward_itr double dual_torelance double penalty_initial double penalty_scale_factor double penalty_max double reg_initial double reg_min double reg_max double reg_scale_factor size_t reg_max_count double eps"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 30;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-max_ilqr_iter","title":"variable max_ilqr_iter","text":"<pre><code>size_t max_ilqr_iter = 100;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-cost_torelance","title":"variable cost_torelance","text":"<pre><code>double cost_torelance = 1e-4;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-constraint_torelance","title":"variable constraint_torelance","text":"<pre><code>double constraint_torelance = 1e-2;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-beta1","title":"variable beta1","text":"<pre><code>double beta1 = 1e-4;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-beta2","title":"variable beta2","text":"<pre><code>double beta2 = 10.0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-alpha_scale","title":"variable alpha_scale","text":"<pre><code>double alpha_scale = 0.5;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-max_forward_itr","title":"variable max_forward_itr","text":"<pre><code>size_t max_forward_itr = 10;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-dual_torelance","title":"variable dual_torelance","text":"<pre><code>double dual_torelance = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-penalty_initial","title":"variable penalty_initial","text":"<pre><code>double penalty_initial = 1e-4;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-penalty_scale_factor","title":"variable penalty_scale_factor","text":"<pre><code>double penalty_scale_factor = 10;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-penalty_max","title":"variable penalty_max","text":"<pre><code>double penalty_max = 1e8;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-reg_initial","title":"variable reg_initial","text":"<pre><code>double reg_initial = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-reg_min","title":"variable reg_min","text":"<pre><code>double reg_min = 1e-8;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-reg_max","title":"variable reg_max","text":"<pre><code>double reg_max = 1e8;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-reg_scale_factor","title":"variable reg_scale_factor","text":"<pre><code>double reg_scale_factor = 1.6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-reg_max_count","title":"variable reg_max_count","text":"<pre><code>size_t reg_max_count = 50;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ALConfig/#variable-eps","title":"variable eps","text":"<pre><code>double eps = 1e-6;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/","title":"cpp_robotics::ActiveSetMethod::Problem","text":"<p><code>#include &lt;active_set_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-functions","title":"Public Functions","text":"Name Problem() =default Problem(size_t x_size_) void add_inequality_constraint(const Eigen::MatrixXd &amp; An, Eigen::VectorXd bn) void add_equality_constraint(const Eigen::MatrixXd &amp; An, Eigen::VectorXd bn)"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-attributes","title":"Public Attributes","text":"Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd A Eigen::VectorXd b size_t max_iter size_t max_iter_get_initial_feasible_x size_t x_size size_t constraint_size double alpha"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-problem","title":"function Problem","text":"<pre><code>Problem() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-problem_1","title":"function Problem","text":"<pre><code>inline Problem(\n    size_t x_size_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-add_inequality_constraint","title":"function add_inequality_constraint","text":"<pre><code>inline void add_inequality_constraint(\n    const Eigen::MatrixXd &amp; An,\n    Eigen::VectorXd bn\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-add_equality_constraint","title":"function add_equality_constraint","text":"<pre><code>inline void add_equality_constraint(\n    const Eigen::MatrixXd &amp; An,\n    Eigen::VectorXd bn\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-c","title":"variable c","text":"<pre><code>Eigen::VectorXd c;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-a","title":"variable A","text":"<pre><code>Eigen::MatrixXd A;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-b","title":"variable b","text":"<pre><code>Eigen::VectorXd b;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 1000;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-max_iter_get_initial_feasible_x","title":"variable max_iter_get_initial_feasible_x","text":"<pre><code>size_t max_iter_get_initial_feasible_x = 1000;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-x_size","title":"variable x_size","text":"<pre><code>size_t x_size = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-constraint_size","title":"variable constraint_size","text":"<pre><code>size_t constraint_size = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-alpha","title":"variable alpha","text":"<pre><code>double alpha = 1.1;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/","title":"cpp_robotics::ActiveSetMethod::Result","text":"<p><code>#include &lt;active_set_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#public-attributes","title":"Public Attributes","text":"Name bool is_solved Eigen::VectorXd x_opt Eigen::VectorXd lambda_opt size_t iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-is_solved","title":"variable is_solved","text":"<pre><code>bool is_solved = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-x_opt","title":"variable x_opt","text":"<pre><code>Eigen::VectorXd x_opt;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-lambda_opt","title":"variable lambda_opt","text":"<pre><code>Eigen::VectorXd lambda_opt;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-iter_cnt","title":"variable iter_cnt","text":"<pre><code>size_t iter_cnt = 0;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/","title":"cpp_robotics::Circle","text":"<p>\u5186\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-functions","title":"Public Functions","text":"Name Circle() =default constexpr Circle(const Vector2d &amp; center, const double r) constexpr bool has_area() const constexpr double area() const constexpr Vector2d angle_pos(const double theta) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-attributes","title":"Public Attributes","text":"Name Vector2d center double r"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-circle","title":"function Circle","text":"<pre><code>Circle() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-circle_1","title":"function Circle","text":"<pre><code>inline constexpr Circle(\n    const Vector2d &amp; center,\n    const double r\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-angle_pos","title":"function angle_pos","text":"<pre><code>inline constexpr Vector2d angle_pos(\n    const double theta\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#variable-center","title":"variable center","text":"<pre><code>Vector2d center;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#variable-r","title":"variable r","text":"<pre><code>double r;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/","title":"cpp_robotics::Constraint","text":"<p>\u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 </p> <p><code>#include &lt;constraint.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-types","title":"Public Types","text":"Name enum uint8_t Type using std::function&lt; double(Eigen::VectorXd)&gt; func_type using std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad_func_type using std::function&lt; Eigen::MatrixXd(Eigen::VectorXd)&gt; hessian_func_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-functions","title":"Public Functions","text":"Name Constraint() Constraint(Type type_, func_type con_) double eval(const Eigen::VectorXd &amp; x) const bool satisfy(const Eigen::VectorXd &amp; x, const double tol) const Eigen::VectorXd grad(Eigen::VectorXd x) Eigen::MatrixXd hessian(Eigen::VectorXd x)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-attributes","title":"Public Attributes","text":"Name Type type func_type con_f std::optional&lt; grad_func_type &gt; con_grad_f std::optional&lt; hessian_func_type &gt; con_hessian_f"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#enum-type","title":"enum Type","text":"Enumerator Value Description Eq Ineq None"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-func_type","title":"using func_type","text":"<pre><code>using cpp_robotics::Constraint::func_type =  std::function&lt;double(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-grad_func_type","title":"using grad_func_type","text":"<pre><code>using cpp_robotics::Constraint::grad_func_type =  std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-hessian_func_type","title":"using hessian_func_type","text":"<pre><code>using cpp_robotics::Constraint::hessian_func_type =  std::function&lt;Eigen::MatrixXd(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-constraint","title":"function Constraint","text":"<pre><code>inline Constraint()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-constraint_1","title":"function Constraint","text":"<pre><code>inline Constraint(\n    Type type_,\n    func_type con_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-eval","title":"function eval","text":"<pre><code>inline double eval(\n    const Eigen::VectorXd &amp; x\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-satisfy","title":"function satisfy","text":"<pre><code>inline bool satisfy(\n    const Eigen::VectorXd &amp; x,\n    const double tol\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-grad","title":"function grad","text":"<pre><code>inline Eigen::VectorXd grad(\n    Eigen::VectorXd x\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-hessian","title":"function hessian","text":"<pre><code>inline Eigen::MatrixXd hessian(\n    Eigen::VectorXd x\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-type","title":"variable type","text":"<pre><code>Type type;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_f","title":"variable con_f","text":"<pre><code>func_type con_f;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_grad_f","title":"variable con_grad_f","text":"<pre><code>std::optional&lt; grad_func_type &gt; con_grad_f;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_hessian_f","title":"variable con_hessian_f","text":"<pre><code>std::optional&lt; hessian_func_type &gt; con_hessian_f;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/","title":"cpp_robotics::ConstraintArray::VariItem","text":"<p>More...</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#public-types","title":"Public Types","text":"Name using std::variant&lt; Type1, Type2 &gt; vari_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#public-functions","title":"Public Functions","text":"Name VariItem(Type1 val) VariItem(Type2 val) vari_type &amp; item()"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Type1 ,\nclass Type2 &gt;\nstruct cpp_robotics::ConstraintArray::VariItem;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#using-vari_type","title":"using vari_type","text":"<pre><code>using cpp_robotics::ConstraintArray::VariItem&lt; Type1, Type2 &gt;::vari_type =  std::variant&lt;Type1, Type2&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#function-variitem","title":"function VariItem","text":"<pre><code>inline VariItem(\n    Type1 val\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#function-variitem_1","title":"function VariItem","text":"<pre><code>inline VariItem(\n    Type2 val\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ConstraintArray_1_1VariItem/#function-item","title":"function item","text":"<pre><code>inline vari_type &amp; item()\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/","title":"cpp_robotics::DCGearedMotorParam","text":"<p>\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </p> <p><code>#include &lt;dc_motor_param.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-functions","title":"Public Functions","text":"Name constexpr DCGearedMotorParam(Volt voltage_, DCMotorParam motor_, GearHeadParam gear_head_, const double optional_gear_ratio_ =1) constexpr Rpm calcu_gear_head_steady_free_velocity(Volt v) const constexpr Rpm calcu_endpoint_steady_free_velocity(Volt v) const constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration(Inertia optional_inertina =0) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-attributes","title":"Public Attributes","text":"Name const Volt voltage const DCMotorParam motor const GearHeadParam gear_head const double optional_gear_ratio"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-dcgearedmotorparam","title":"function DCGearedMotorParam","text":"<pre><code>inline constexpr DCGearedMotorParam(\n    Volt voltage_,\n    DCMotorParam motor_,\n    GearHeadParam gear_head_,\n    const double optional_gear_ratio_ =1\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_gear_head_steady_free_velocity","title":"function calcu_gear_head_steady_free_velocity","text":"<pre><code>inline constexpr Rpm calcu_gear_head_steady_free_velocity(\n    Volt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_endpoint_steady_free_velocity","title":"function calcu_endpoint_steady_free_velocity","text":"<pre><code>inline constexpr Rpm calcu_endpoint_steady_free_velocity(\n    Volt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_endpoint_max_angular_accleleration","title":"function calcu_endpoint_max_angular_accleleration","text":"<pre><code>inline constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration(\n    Inertia optional_inertina =0\n) const\n</code></pre> <p>\u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u304c\u767a\u751f\u3055\u305b\u3089\u308c\u308b\u6700\u5927\u306e\u89d2\u52a0\u901f\u5ea6\u3092\u8a08\u7b97\u3059\u308b</p> <p>optional_inertina: \u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u306e\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-voltage","title":"variable voltage","text":"<pre><code>const Volt voltage;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-motor","title":"variable motor","text":"<pre><code>const DCMotorParam motor;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-gear_head","title":"variable gear_head","text":"<pre><code>const GearHeadParam gear_head;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-optional_gear_ratio","title":"variable optional_gear_ratio","text":"<pre><code>const double optional_gear_ratio;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/","title":"cpp_robotics::DCMotorParam","text":"<p>DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </p> <p><code>#include &lt;dc_motor_param.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-functions","title":"Public Functions","text":"Name constexpr DCMotorParam(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm Rm, Henry Lm, TorqueConstant Kt, BackEmfConstant Ke, Inertia Im, Second curr_set_time =0.1f) constexpr DCMotorParam(const DCMotorParam &amp; ) =default constexpr void set_current_setting_time(Second Tc) constexpr Rpm calcu_steady_free_velocity(Volt v) const constexpr Ampere calcu_stall_current(Volt v) const constexpr Torque calcu_stall_torque(Volt v) const constexpr AngularAcceleration calcu_max_free_angular_acceleration(Volt v) const constexpr Second get_Tm() const constexpr AngularVelocity get_Wi() const constexpr double get_Kip(Volt volt) const constexpr double get_Kii(Volt volt) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-attributes","title":"Public Attributes","text":"Name const Volt nominal_voltage const Rpm free_speed const Ampere free_current const Ohm resistance const Henry inductance const TorqueConstant torque_constant const BackEmfConstant back_emf_constance const FrictionConstant friction_constant const Inertia rotor_inertia const Second time_constant"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-dcmotorparam","title":"function DCMotorParam","text":"<pre><code>inline constexpr DCMotorParam(\n    Volt nominal_voltage,\n    Rpm free_speed,\n    Ampere free_current,\n    Ohm Rm,\n    Henry Lm,\n    TorqueConstant Kt,\n    BackEmfConstant Ke,\n    Inertia Im,\n    Second curr_set_time =0.1f\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-dcmotorparam_1","title":"function DCMotorParam","text":"<pre><code>constexpr DCMotorParam(\n    const DCMotorParam &amp; \n) =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-set_current_setting_time","title":"function set_current_setting_time","text":"<pre><code>inline constexpr void set_current_setting_time(\n    Second Tc\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_steady_free_velocity","title":"function calcu_steady_free_velocity","text":"<pre><code>inline constexpr Rpm calcu_steady_free_velocity(\n    Volt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_stall_current","title":"function calcu_stall_current","text":"<pre><code>inline constexpr Ampere calcu_stall_current(\n    Volt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_stall_torque","title":"function calcu_stall_torque","text":"<pre><code>inline constexpr Torque calcu_stall_torque(\n    Volt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_max_free_angular_acceleration","title":"function calcu_max_free_angular_acceleration","text":"<pre><code>inline constexpr AngularAcceleration calcu_max_free_angular_acceleration(\n    Volt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_tm","title":"function get_Tm","text":"<pre><code>inline constexpr Second get_Tm() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_wi","title":"function get_Wi","text":"<pre><code>inline constexpr AngularVelocity get_Wi() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_kip","title":"function get_Kip","text":"<pre><code>inline constexpr double get_Kip(\n    Volt volt\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_kii","title":"function get_Kii","text":"<pre><code>inline constexpr double get_Kii(\n    Volt volt\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-nominal_voltage","title":"variable nominal_voltage","text":"<pre><code>const Volt nominal_voltage;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-free_speed","title":"variable free_speed","text":"<pre><code>const Rpm free_speed;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-free_current","title":"variable free_current","text":"<pre><code>const Ampere free_current;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-resistance","title":"variable resistance","text":"<pre><code>const Ohm resistance;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-inductance","title":"variable inductance","text":"<pre><code>const Henry inductance;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-torque_constant","title":"variable torque_constant","text":"<pre><code>const TorqueConstant torque_constant;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-back_emf_constance","title":"variable back_emf_constance","text":"<pre><code>const BackEmfConstant back_emf_constance;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-friction_constant","title":"variable friction_constant","text":"<pre><code>const FrictionConstant friction_constant;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-rotor_inertia","title":"variable rotor_inertia","text":"<pre><code>const Inertia rotor_inertia;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-time_constant","title":"variable time_constant","text":"<pre><code>const Second time_constant;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/","title":"cpp_robotics::DubinsPath::PlanningResult","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#public-attributes","title":"Public Attributes","text":"Name double t double p double q Mode mode"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-t","title":"variable t","text":"<pre><code>double t = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-p","title":"variable p","text":"<pre><code>double p = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-q","title":"variable q","text":"<pre><code>double q = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-mode","title":"variable mode","text":"<pre><code>Mode mode = Mode::NONE;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/","title":"cpp_robotics::GearHeadParam","text":"<p>\u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb </p> <p><code>#include &lt;dc_motor_param.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-functions","title":"Public Functions","text":"Name constexpr GearHeadParam(double ratio_, double efficiency_)"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-attributes","title":"Public Attributes","text":"Name const double ratio const double efficiency"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#function-gearheadparam","title":"function GearHeadParam","text":"<pre><code>inline constexpr GearHeadParam(\n    double ratio_,\n    double efficiency_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#variable-ratio","title":"variable ratio","text":"<pre><code>const double ratio;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#variable-efficiency","title":"variable efficiency","text":"<pre><code>const double efficiency;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/","title":"cpp_robotics::KDTree::Node","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#public-attributes","title":"Public Attributes","text":"Name int idx int axis std::unique_ptr&lt; Node &gt;[2] child"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-idx","title":"variable idx","text":"<pre><code>int idx = -1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-axis","title":"variable axis","text":"<pre><code>int axis = -1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-child","title":"variable child","text":"<pre><code>std::unique_ptr&lt; Node &gt;[2] child = {nullptr, nullptr};\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/","title":"cpp_robotics::Line","text":"<p>\u76f4\u7dda\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-functions","title":"Public Functions","text":"Name Line() =default constexpr Line(const Vector2d &amp; p0, const Vector2d &amp; p1) void set(const Vector2d &amp; p0_, const Vector2d &amp; p1_) constexpr double length() const constexpr double angle() const constexpr Vector2d lerp(const double t) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-attributes","title":"Public Attributes","text":"Name Vector2d p0 Vector2d p1"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-line","title":"function Line","text":"<pre><code>Line() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-line_1","title":"function Line","text":"<pre><code>inline constexpr Line(\n    const Vector2d &amp; p0,\n    const Vector2d &amp; p1\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-set","title":"function set","text":"<pre><code>inline void set(\n    const Vector2d &amp; p0_,\n    const Vector2d &amp; p1_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-length","title":"function length","text":"<pre><code>inline constexpr double length() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-angle","title":"function angle","text":"<pre><code>inline constexpr double angle() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector2d lerp(\n    const double t\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#variable-p0","title":"variable p0","text":"<pre><code>Vector2d p0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#variable-p1","title":"variable p1","text":"<pre><code>Vector2d p1;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/","title":"cpp_robotics::MecanumIk::Config","text":"<p><code>#include &lt;mecanum_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#public-attributes","title":"Public Attributes","text":"Name double width double length"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#variable-width","title":"variable width","text":"<pre><code>double width;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#variable-length","title":"variable length","text":"<pre><code>double length;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/","title":"cpp_robotics::OCPConstraintArray::VariItem","text":"<p>More...</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#public-types","title":"Public Types","text":"Name using std::variant&lt; Type1, Type2 &gt; vari_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#public-functions","title":"Public Functions","text":"Name VariItem(Type1 val) VariItem(Type2 val) vari_type &amp; item()"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Type1 ,\nclass Type2 &gt;\nstruct cpp_robotics::OCPConstraintArray::VariItem;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#using-vari_type","title":"using vari_type","text":"<pre><code>using cpp_robotics::OCPConstraintArray::VariItem&lt; Type1, Type2 &gt;::vari_type =  std::variant&lt;Type1, Type2&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#function-variitem","title":"function VariItem","text":"<pre><code>inline VariItem(\n    Type1 val\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#function-variitem_1","title":"function VariItem","text":"<pre><code>inline VariItem(\n    Type2 val\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1OCPConstraintArray_1_1VariItem/#function-item","title":"function item","text":"<pre><code>inline vari_type &amp; item()\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/","title":"cpp_robotics::Omni3Ik::Config","text":"<p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#public-attributes","title":"Public Attributes","text":"Name double radius double first_wheel_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#variable-radius","title":"variable radius","text":"<pre><code>double radius;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#variable-first_wheel_angle","title":"variable first_wheel_angle","text":"<pre><code>double first_wheel_angle = M_PI/6;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/","title":"cpp_robotics::Omni4Ik::Config","text":"<p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#public-attributes","title":"Public Attributes","text":"Name double radius double first_wheel_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#variable-radius","title":"variable radius","text":"<pre><code>double radius;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#variable-first_wheel_angle","title":"variable first_wheel_angle","text":"<pre><code>double first_wheel_angle = M_PI/4;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/","title":"cpp_robotics::PID2::pid_param_t","text":"<p><code>#include &lt;pid2.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#public-attributes","title":"Public Attributes","text":"Name double Ts double gpd double Kp double Ki double Kd double b double c std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-ts","title":"variable Ts","text":"<pre><code>double Ts;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-gpd","title":"variable gpd","text":"<pre><code>double gpd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-kp","title":"variable Kp","text":"<pre><code>double Kp;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-ki","title":"variable Ki","text":"<pre><code>double Ki;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-kd","title":"variable Kd","text":"<pre><code>double Kd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-b","title":"variable b","text":"<pre><code>double b;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-c","title":"variable c","text":"<pre><code>double c;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-output_limit","title":"variable output_limit","text":"<pre><code>std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/","title":"cpp_robotics::PID::pid_param_t","text":"<p><code>#include &lt;pid.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#public-attributes","title":"Public Attributes","text":"Name double Ts double gpd double Kp double Ki double Kd std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-ts","title":"variable Ts","text":"<pre><code>double Ts;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-gpd","title":"variable gpd","text":"<pre><code>double gpd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-kp","title":"variable Kp","text":"<pre><code>double Kp;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-ki","title":"variable Ki","text":"<pre><code>double Ki;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-kd","title":"variable Kd","text":"<pre><code>double Kd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-output_limit","title":"variable output_limit","text":"<pre><code>std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/","title":"cpp_robotics::PSMC::param_t","text":"<p><code>#include &lt;psmc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#public-attributes","title":"Public Attributes","text":"Name double Ts double Kp double Kd double Hs std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-ts","title":"variable Ts","text":"<pre><code>double Ts;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-kp","title":"variable Kp","text":"<pre><code>double Kp;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-kd","title":"variable Kd","text":"<pre><code>double Kd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-hs","title":"variable Hs","text":"<pre><code>double Hs;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-output_limit","title":"variable output_limit","text":"<pre><code>std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/","title":"cpp_robotics::Polynomial","text":"<p>\u591a\u9805\u5f0f </p> <p><code>#include &lt;polynomial.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#public-functions","title":"Public Functions","text":"Name Polynomial() =default Polynomial(std::initializer_list&lt; double &gt; coeff) Polynomial(const std::vector&lt; double &gt; &amp; coeff) template &lt;class IteratorType &gt;  Polynomial(IteratorType begin, IteratorType end) void set_degree(size_t deg) size_t size() const size_t degree() const std::vector&lt; double &gt; coeff() const double &amp; at(size_t i) double at(size_t i) const double &amp; at_degree(size_t i) double at_degree(size_t i) const double &amp; operator[](size_t i) double operator[](size_t i) const double evalute(double x) const void swap(Polynomial &amp; poly) double operator()(double x) const Polynomial operator+() const Polynomial operator-() const Polynomial operator+(double s) const Polynomial operator-(double s) const Polynomial &amp; operator+=(double s)\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b Polynomial &amp; operator-=(double s)\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u6e1b\u7b97\u3059\u308b Polynomial operator*(double s) const\u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 Polynomial &amp; operator*=(double s)\u81ea\u8eab\u3092s\u500d\u3059\u308b Polynomial operator/(double s) const\u591a\u9805\u5f0f\u30921/s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 Polynomial &amp; operator/=(double s)\u81ea\u8eab\u30921/s\u500d\u3059\u308b Polynomial operator*(const Polynomial &amp; p) const\u591a\u9805\u5f0f\u540c\u58eb\u306e\u7a4d\u3092\u53d6\u308b Polynomial &amp; operator*=(const Polynomial &amp; p) Polynomial operator+(Polynomial poly) const\u591a\u9805\u5f0f\u540c\u58eb\u306e\u548c\u3092\u53d6\u308b Polynomial &amp; operator+=(Polynomial poly)\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u52a0\u7b97\u3059\u308b Polynomial operator-(Polynomial poly) const Polynomial &amp; operator-=(Polynomial poly)\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u6e1b\u7b97\u3059\u308b Polynomial expand(std::vector&lt; double &gt; roots)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friends","title":"Friends","text":"Name Polynomial operator*(double s, const Polynomial &amp; poly) \u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 bool operator==(const Polynomial &amp; lhs, const Polynomial &amp; rhs) bool operator!=(const Polynomial &amp; lhs, const Polynomial &amp; rhs)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial","title":"function Polynomial","text":"<pre><code>Polynomial() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_1","title":"function Polynomial","text":"<pre><code>inline Polynomial(\n    std::initializer_list&lt; double &gt; coeff\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_2","title":"function Polynomial","text":"<pre><code>inline Polynomial(\n    const std::vector&lt; double &gt; &amp; coeff\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_3","title":"function Polynomial","text":"<pre><code>template &lt;class IteratorType &gt;\ninline Polynomial(\n    IteratorType begin,\n    IteratorType end\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-set_degree","title":"function set_degree","text":"<pre><code>inline void set_degree(\n    size_t deg\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-size","title":"function size","text":"<pre><code>inline size_t size() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-degree","title":"function degree","text":"<pre><code>inline size_t degree() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-coeff","title":"function coeff","text":"<pre><code>inline std::vector&lt; double &gt; coeff() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at","title":"function at","text":"<pre><code>inline double &amp; at(\n    size_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_1","title":"function at","text":"<pre><code>inline double at(\n    size_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_degree","title":"function at_degree","text":"<pre><code>inline double &amp; at_degree(\n    size_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_degree_1","title":"function at_degree","text":"<pre><code>inline double at_degree(\n    size_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator","title":"function operator[]","text":"<pre><code>inline double &amp; operator[](\n    size_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_1","title":"function operator[]","text":"<pre><code>inline double operator[](\n    size_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-evalute","title":"function evalute","text":"<pre><code>inline double evalute(\n    double x\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\n    Polynomial &amp; poly\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_2","title":"function operator()","text":"<pre><code>inline double operator()(\n    double x\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_3","title":"function operator+","text":"<pre><code>inline Polynomial operator+() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-","title":"function operator-","text":"<pre><code>inline Polynomial operator-() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_4","title":"function operator+","text":"<pre><code>inline Polynomial operator+(\n    double s\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_1","title":"function operator-","text":"<pre><code>inline Polynomial operator-(\n    double s\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_5","title":"function operator+=","text":"<pre><code>inline Polynomial &amp; operator+=(\n    double s\n)\n</code></pre> <p>\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline Polynomial &amp; operator-=(\n    double s\n)\n</code></pre> <p>\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u6e1b\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_6","title":"function operator*","text":"<pre><code>inline Polynomial operator*(\n    double s\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_7","title":"function operator*=","text":"<pre><code>inline Polynomial &amp; operator*=(\n    double s\n)\n</code></pre> <p>\u81ea\u8eab\u3092s\u500d\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_8","title":"function operator/","text":"<pre><code>inline Polynomial operator/(\n    double s\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u30921/s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_9","title":"function operator/=","text":"<pre><code>inline Polynomial &amp; operator/=(\n    double s\n)\n</code></pre> <p>\u81ea\u8eab\u30921/s\u500d\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_10","title":"function operator*","text":"<pre><code>inline Polynomial operator*(\n    const Polynomial &amp; p\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u540c\u58eb\u306e\u7a4d\u3092\u53d6\u308b </p> <p>Parameters: </p> <ul> <li>p </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_11","title":"function operator*=","text":"<pre><code>inline Polynomial &amp; operator*=(\n    const Polynomial &amp; p\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_12","title":"function operator+","text":"<pre><code>inline Polynomial operator+(\n    Polynomial poly\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u540c\u58eb\u306e\u548c\u3092\u53d6\u308b </p> <p>Parameters: </p> <ul> <li>poly </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_13","title":"function operator+=","text":"<pre><code>inline Polynomial &amp; operator+=(\n    Polynomial poly\n)\n</code></pre> <p>\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u52a0\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>poly </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_3","title":"function operator-","text":"<pre><code>inline Polynomial operator-(\n    Polynomial poly\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_4","title":"function operator-=","text":"<pre><code>inline Polynomial &amp; operator-=(\n    Polynomial poly\n)\n</code></pre> <p>\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u6e1b\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>poly </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-expand","title":"function expand","text":"<pre><code>static inline Polynomial expand(\n    std::vector&lt; double &gt; roots\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator","title":"friend operator*","text":"<pre><code>friend Polynomial operator*(\n    double s,\n\n    const Polynomial &amp; poly\n);\n</code></pre> <p>\u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>s </li> <li>poly </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator_1","title":"friend operator==","text":"<pre><code>friend bool operator==(\n    const Polynomial &amp; lhs,\n\n    const Polynomial &amp; rhs\n);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator_2","title":"friend operator!=","text":"<pre><code>friend bool operator!=(\n    const Polynomial &amp; lhs,\n\n    const Polynomial &amp; rhs\n);\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/","title":"cpp_robotics::Quad","text":"<p>\u56db\u89d2\u5f62\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-functions","title":"Public Functions","text":"Name Quad() =default constexpr Quad(const std::array&lt; Vector2d, 4 &gt; &amp; points) constexpr Quad(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2, const Vector2d &amp; p3) void set(const Vector2d &amp; p0_, const Vector2d &amp; p1_, const Vector2d &amp; p2_, const Vector2d &amp; p3_) constexpr bool has_area() const constexpr double area() const constexpr std::array&lt; Vector2d, 4 &gt; vertex() const constexpr std::array&lt; Line, 4 &gt; outline() const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-attributes","title":"Public Attributes","text":"Name Vector2d p0 Vector2d p1 Vector2d p2 Vector2d p3"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad","title":"function Quad","text":"<pre><code>Quad() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad_1","title":"function Quad","text":"<pre><code>inline constexpr Quad(\n    const std::array&lt; Vector2d, 4 &gt; &amp; points\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad_2","title":"function Quad","text":"<pre><code>inline constexpr Quad(\n    const Vector2d &amp; p0,\n    const Vector2d &amp; p1,\n    const Vector2d &amp; p2,\n    const Vector2d &amp; p3\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-set","title":"function set","text":"<pre><code>inline void set(\n    const Vector2d &amp; p0_,\n    const Vector2d &amp; p1_,\n    const Vector2d &amp; p2_,\n    const Vector2d &amp; p3_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-vertex","title":"function vertex","text":"<pre><code>inline constexpr std::array&lt; Vector2d, 4 &gt; vertex() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-outline","title":"function outline","text":"<pre><code>inline constexpr std::array&lt; Line, 4 &gt; outline() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p0","title":"variable p0","text":"<pre><code>Vector2d p0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p1","title":"variable p1","text":"<pre><code>Vector2d p1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p2","title":"variable p2","text":"<pre><code>Vector2d p2;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p3","title":"variable p3","text":"<pre><code>Vector2d p3;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/","title":"cpp_robotics::QuadProg::Param","text":"<p><code>#include &lt;quadprog.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#public-attributes","title":"Public Attributes","text":"Name double tol_step double tol_con double t size_t max_iter bool print_variable"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-tol_step","title":"variable tol_step","text":"<pre><code>double tol_step = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-tol_con","title":"variable tol_con","text":"<pre><code>double tol_con = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-t","title":"variable t","text":"<pre><code>double t = 0.5;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 100;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-print_variable","title":"variable print_variable","text":"<pre><code>bool print_variable = false;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/","title":"cpp_robotics::QuadProg::Result","text":"<p><code>#include &lt;quadprog.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#public-attributes","title":"Public Attributes","text":"Name bool is_solved Eigen::VectorXd x Eigen::VectorXd lambda_ineq Eigen::VectorXd lambda_eq size_t iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-is_solved","title":"variable is_solved","text":"<pre><code>bool is_solved = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-x","title":"variable x","text":"<pre><code>Eigen::VectorXd x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-lambda_ineq","title":"variable lambda_ineq","text":"<pre><code>Eigen::VectorXd lambda_ineq;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-lambda_eq","title":"variable lambda_eq","text":"<pre><code>Eigen::VectorXd lambda_eq;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-iter_cnt","title":"variable iter_cnt","text":"<pre><code>size_t iter_cnt = 0;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/","title":"cpp_robotics::Quaternion","text":"<p>\u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;quaternion.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-functions","title":"Public Functions","text":"Name constexpr Quaternion() constexpr Quaternion(value_type nx, value_type ny, value_type nz, value_type nw) Quaternion get_product(Quaternion q) constexpr Quaternion conjugate() const constexpr value_type norm() const constexpr void normalize() constexpr Quaternion get_normalized() const constexpr void set_rpy(value_type roll, value_type pitch, value_type yaw) constexpr Vector3d get_rpy() const constexpr value_type operator[](const int index) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type z value_type w"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nclass cpp_robotics::Quaternion;\n</code></pre> <p>\u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>FLOATING_TYPE </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Quaternion&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-quaternion","title":"function Quaternion","text":"<pre><code>inline constexpr Quaternion()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-quaternion_1","title":"function Quaternion","text":"<pre><code>inline constexpr Quaternion(\n    value_type nx,\n    value_type ny,\n    value_type nz,\n    value_type nw\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_product","title":"function get_product","text":"<pre><code>inline Quaternion get_product(\n    Quaternion q\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-conjugate","title":"function conjugate","text":"<pre><code>inline constexpr Quaternion conjugate() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-norm","title":"function norm","text":"<pre><code>inline constexpr value_type norm() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-normalize","title":"function normalize","text":"<pre><code>inline constexpr void normalize()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline constexpr Quaternion get_normalized() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-set_rpy","title":"function set_rpy","text":"<pre><code>inline constexpr void set_rpy(\n    value_type roll,\n    value_type pitch,\n    value_type yaw\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_rpy","title":"function get_rpy","text":"<pre><code>inline constexpr Vector3d get_rpy() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\n    const int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-z","title":"variable z","text":"<pre><code>value_type z;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-w","title":"variable w","text":"<pre><code>value_type w;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/","title":"cpp_robotics::Rect","text":"<p>\u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-functions","title":"Public Functions","text":"Name Rect() =default constexpr Rect(const Vector2d &amp; center, const Vector2d &amp; size) void set(const Vector2d &amp; center_, const Vector2d &amp; size_) constexpr bool has_area() const constexpr double area() const constexpr std::array&lt; Vector2d, 4 &gt; vertex() const constexpr std::array&lt; Line, 4 &gt; outline() const constexpr Quad as_quad() const constexpr Quad get_rotated(double angle) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-attributes","title":"Public Attributes","text":"Name Vector2d center Vector2d size"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-rect","title":"function Rect","text":"<pre><code>Rect() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-rect_1","title":"function Rect","text":"<pre><code>inline constexpr Rect(\n    const Vector2d &amp; center,\n    const Vector2d &amp; size\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-set","title":"function set","text":"<pre><code>inline void set(\n    const Vector2d &amp; center_,\n    const Vector2d &amp; size_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-vertex","title":"function vertex","text":"<pre><code>inline constexpr std::array&lt; Vector2d, 4 &gt; vertex() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-outline","title":"function outline","text":"<pre><code>inline constexpr std::array&lt; Line, 4 &gt; outline() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-as_quad","title":"function as_quad","text":"<pre><code>inline constexpr Quad as_quad() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-get_rotated","title":"function get_rotated","text":"<pre><code>inline constexpr Quad get_rotated(\n    double angle\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#variable-center","title":"variable center","text":"<pre><code>Vector2d center;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#variable-size","title":"variable size","text":"<pre><code>Vector2d size;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/","title":"cpp_robotics::SQP::Problem","text":"<p><code>#include &lt;sqp.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#public-attributes","title":"Public Attributes","text":"Name func_type func std::optional&lt; grad_func_type &gt; grad ConstraintArray con bool use_slsqp double tol_step double tol_con size_t max_iter bool print_variable"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-func","title":"variable func","text":"<pre><code>func_type func;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-grad","title":"variable grad","text":"<pre><code>std::optional&lt; grad_func_type &gt; grad;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-con","title":"variable con","text":"<pre><code>ConstraintArray con;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-use_slsqp","title":"variable use_slsqp","text":"<pre><code>bool use_slsqp = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-tol_step","title":"variable tol_step","text":"<pre><code>double tol_step = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-tol_con","title":"variable tol_con","text":"<pre><code>double tol_con = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 100;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-print_variable","title":"variable print_variable","text":"<pre><code>bool print_variable = false;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/","title":"cpp_robotics::SQP::Result","text":"<p><code>#include &lt;sqp.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#public-attributes","title":"Public Attributes","text":"Name bool is_solved Eigen::VectorXd x size_t iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-is_solved","title":"variable is_solved","text":"<pre><code>bool is_solved = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-x","title":"variable x","text":"<pre><code>Eigen::VectorXd x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-iter_cnt","title":"variable iter_cnt","text":"<pre><code>size_t iter_cnt = 0;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/","title":"cpp_robotics::SisoFeedbackSystem::func_list_t","text":"<p><code>#include &lt;siso_system.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#public-attributes","title":"Public Attributes","text":"Name std::function&lt; void(void)&gt; controller_reset std::function&lt; double(double)&gt; controller std::function&lt; void(void)&gt; system_reset std::function&lt; double(double)&gt; system"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-controller_reset","title":"variable controller_reset","text":"<pre><code>std::function&lt; void(void)&gt; controller_reset;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-controller","title":"variable controller","text":"<pre><code>std::function&lt; double(double)&gt; controller;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-system_reset","title":"variable system_reset","text":"<pre><code>std::function&lt; void(void)&gt; system_reset;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-system","title":"variable system","text":"<pre><code>std::function&lt; double(double)&gt; system;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/","title":"cpp_robotics::Spline2D::segment_info_t","text":"<p><code>#include &lt;spline.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#public-attributes","title":"Public Attributes","text":"Name size_t i double t"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#variable-i","title":"variable i","text":"<pre><code>size_t i;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#variable-t","title":"variable t","text":"<pre><code>double t;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/","title":"cpp_robotics::Spline2D::segment_t","text":"<p><code>#include &lt;spline.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#public-attributes","title":"Public Attributes","text":"Name spline::spline_c coeff double length std::vector&lt; double &gt; split_lengths"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#variable-coeff","title":"variable coeff","text":"<pre><code>spline::spline_c coeff;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#variable-length","title":"variable length","text":"<pre><code>double length;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#variable-split_lengths","title":"variable split_lengths","text":"<pre><code>std::vector&lt; double &gt; split_lengths;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/","title":"cpp_robotics::TransferFunction::tf_t","text":"<p><code>#include &lt;transfer_function.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#public-functions","title":"Public Functions","text":"Name tf_t inv() const tf_t operator+(double val) const tf_t operator-(double val) const tf_t operator*(double val) const tf_t operator/(double val) const tf_t operator+(const tf_t &amp; tf) const tf_t operator-(const tf_t &amp; tf) const tf_t operator*(const tf_t &amp; tf) const tf_t operator/(const tf_t &amp; tf) const TransferFunction simulatable()"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#public-attributes","title":"Public Attributes","text":"Name std::vector&lt; double &gt; num std::vector&lt; double &gt; den double Ts"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#friends","title":"Friends","text":"Name tf_t operator+(double val, const tf_t &amp; tf) tf_t operator-(double val, const tf_t &amp; tf) tf_t operator*(double val, const tf_t &amp; tf) tf_t operator/(double val, const tf_t &amp; tf) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; stream, const tf_t &amp; tf)"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-inv","title":"function inv","text":"<pre><code>inline tf_t inv() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator","title":"function operator+","text":"<pre><code>inline tf_t operator+(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator-","title":"function operator-","text":"<pre><code>inline tf_t operator-(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator_1","title":"function operator*","text":"<pre><code>inline tf_t operator*(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator_2","title":"function operator/","text":"<pre><code>inline tf_t operator/(\n    double val\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator_3","title":"function operator+","text":"<pre><code>inline tf_t operator+(\n    const tf_t &amp; tf\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator-_1","title":"function operator-","text":"<pre><code>inline tf_t operator-(\n    const tf_t &amp; tf\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator_4","title":"function operator*","text":"<pre><code>inline tf_t operator*(\n    const tf_t &amp; tf\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-operator_5","title":"function operator/","text":"<pre><code>inline tf_t operator/(\n    const tf_t &amp; tf\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#function-simulatable","title":"function simulatable","text":"<pre><code>inline TransferFunction simulatable()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#variable-num","title":"variable num","text":"<pre><code>std::vector&lt; double &gt; num;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#variable-den","title":"variable den","text":"<pre><code>std::vector&lt; double &gt; den;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#variable-ts","title":"variable Ts","text":"<pre><code>double Ts;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#friend-operator","title":"friend operator+","text":"<pre><code>friend tf_t operator+(\n    double val,\n\n    const tf_t &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#friend-operator-","title":"friend operator-","text":"<pre><code>friend tf_t operator-(\n    double val,\n\n    const tf_t &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#friend-operator_1","title":"friend operator*","text":"<pre><code>friend tf_t operator*(\n    double val,\n\n    const tf_t &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#friend-operator_2","title":"friend operator/","text":"<pre><code>friend tf_t operator/(\n    double val,\n\n    const tf_t &amp; tf\n);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1TransferFunction_1_1tf__t/#friend-operator_3","title":"friend operator&lt;&lt;","text":"<pre><code>friend std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; stream,\n\n    const tf_t &amp; tf\n);\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/","title":"cpp_robotics::Transform","text":"<p>2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;transform.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type using Vector2&lt; value_type &gt; vector_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-functions","title":"Public Functions","text":"Name Transform() =defaultConstruct a new Field Vector 2 object. constexpr Transform(const value_type _x, const value_type _y, const value_type _theta)Construct a new Field Vector 2 object. constexpr Transform(const vector_type &amp; _xy, const value_type _theta)Construct a new Field Vector 2 object. constexpr Transform(const Transform &amp; ) =defaultConstruct a new Field Vector 2 object. constexpr vector_type make_vector2() constxy\u6210\u5206\u306eVector2\u3092\u751f\u6210 constexpr void set(value_type vx, value_type vy, value_type vtheta) value_type distance() const\u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 void rotate(const value_type theta)\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate(const value_type rotX, const value_type rotY, const value_type theta)\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate(vector_type rotPos, const value_type theta)\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void set_polar(const value_type radius, const value_type angle, const value_type robotTheta)\u6975\u5ea7\u6a19\u6307\u5b9a bool is_zero() const bool is_zero_pos() const bool is_zero_angle() const bool has_nan() const constexpr bool operator==(const Transform v) const constexpr bool operator!=(const Transform &amp; v) const constexpr Transform operator+(const Transform &amp; v) const constexpr Transform operator-(const Transform &amp; v) const constexpr Transform &amp; operator+=(const Transform &amp; v) constexpr Transform &amp; operator-=(const Transform &amp; v) constexpr Transform operator+(const vector_type &amp; v) const constexpr Transform operator-(const vector_type &amp; v) const constexpr Transform operator+(const value_type angle) const constexpr Transform operator-(const value_type angle) const constexpr Transform &amp; operator+=(const vector_type &amp; v) constexpr Transform &amp; operator-=(const vector_type &amp; v) constexpr Transform &amp; operator+=(const value_type angle) constexpr Transform &amp; operator-=(const value_type angle) constexpr Transform operator*(const value_type value) const constexpr Transform operator/(const value_type value) const constexpr Transform &amp; operator*=(const value_type value) constexpr Transform &amp; operator/=(const value_type value) value_type &amp; operator[](const int index) constexpr value_type operator[](const int index) const constexpr value_type get_angle(Transform &amp; a, Transform &amp; b)Get the Angle object. value_type get_distance(Transform &amp; a, Transform &amp; b)Get the Distance object. Transform get_lerp(Transform &amp; a, Transform &amp; b, const value_type t)lerp function constexpr Transform origin()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type theta"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Transform;\n</code></pre> <p>2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Transform&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#using-vector_type","title":"using vector_type","text":"<pre><code>using cpp_robotics::Transform&lt; FLOATING_TYPE &gt;::vector_type =  Vector2&lt;value_type&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform","title":"function Transform","text":"<pre><code>Transform() =default\n</code></pre> <p>Construct a new Field Vector 2 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_1","title":"function Transform","text":"<pre><code>inline constexpr Transform(\n    const value_type _x,\n    const value_type _y,\n    const value_type _theta\n)\n</code></pre> <p>Construct a new Field Vector 2 object. </p> <p>Parameters: </p> <ul> <li>x </li> <li>y </li> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_2","title":"function Transform","text":"<pre><code>inline constexpr Transform(\n    const vector_type &amp; _xy,\n    const value_type _theta\n)\n</code></pre> <p>Construct a new Field Vector 2 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_3","title":"function Transform","text":"<pre><code>constexpr Transform(\n    const Transform &amp; \n) =default\n</code></pre> <p>Construct a new Field Vector 2 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-make_vector2","title":"function make_vector2","text":"<pre><code>inline constexpr vector_type make_vector2() const\n</code></pre> <p>xy\u6210\u5206\u306eVector2\u3092\u751f\u6210 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-set","title":"function set","text":"<pre><code>inline constexpr void set(\n    value_type vx,\n    value_type vy,\n    value_type vtheta\n)\n</code></pre> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vtheta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-distance","title":"function distance","text":"<pre><code>inline value_type distance() const\n</code></pre> <p>\u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate","title":"function rotate","text":"<pre><code>inline void rotate(\n    const value_type theta\n)\n</code></pre> <p>\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate_1","title":"function rotate","text":"<pre><code>inline void rotate(\n    const value_type rotX,\n    const value_type rotY,\n    const value_type theta\n)\n</code></pre> <p>\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>rotX </li> <li>rotY </li> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate_2","title":"function rotate","text":"<pre><code>inline void rotate(\n    vector_type rotPos,\n    const value_type theta\n)\n</code></pre> <p>\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>rotPos </li> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-set_polar","title":"function set_polar","text":"<pre><code>inline void set_polar(\n    const value_type radius,\n    const value_type angle,\n    const value_type robotTheta\n)\n</code></pre> <p>\u6975\u5ea7\u6a19\u6307\u5b9a </p> <p>Parameters: </p> <ul> <li>radius </li> <li>angle </li> <li>robotTheta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero","title":"function is_zero","text":"<pre><code>inline bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero_pos","title":"function is_zero_pos","text":"<pre><code>inline bool is_zero_pos() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero_angle","title":"function is_zero_angle","text":"<pre><code>inline bool is_zero_angle() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-has_nan","title":"function has_nan","text":"<pre><code>inline bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator","title":"function operator==","text":"<pre><code>inline constexpr bool operator==(\n    const Transform v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_1","title":"function operator!=","text":"<pre><code>inline constexpr bool operator!=(\n    const Transform &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_2","title":"function operator+","text":"<pre><code>inline constexpr Transform operator+(\n    const Transform &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Transform operator-(\n    const Transform &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_3","title":"function operator+=","text":"<pre><code>inline constexpr Transform &amp; operator+=(\n    const Transform &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_1","title":"function operator-=","text":"<pre><code>inline constexpr Transform &amp; operator-=(\n    const Transform &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_4","title":"function operator+","text":"<pre><code>inline constexpr Transform operator+(\n    const vector_type &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_2","title":"function operator-","text":"<pre><code>inline constexpr Transform operator-(\n    const vector_type &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_5","title":"function operator+","text":"<pre><code>inline constexpr Transform operator+(\n    const value_type angle\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_3","title":"function operator-","text":"<pre><code>inline constexpr Transform operator-(\n    const value_type angle\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_6","title":"function operator+=","text":"<pre><code>inline constexpr Transform &amp; operator+=(\n    const vector_type &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_4","title":"function operator-=","text":"<pre><code>inline constexpr Transform &amp; operator-=(\n    const vector_type &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_7","title":"function operator+=","text":"<pre><code>inline constexpr Transform &amp; operator+=(\n    const value_type angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_5","title":"function operator-=","text":"<pre><code>inline constexpr Transform &amp; operator-=(\n    const value_type angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_8","title":"function operator*","text":"<pre><code>inline constexpr Transform operator*(\n    const value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_9","title":"function operator/","text":"<pre><code>inline constexpr Transform operator/(\n    const value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_10","title":"function operator*=","text":"<pre><code>inline constexpr Transform &amp; operator*=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_11","title":"function operator/=","text":"<pre><code>inline constexpr Transform &amp; operator/=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_12","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\n    const int index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_13","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\n    const int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_angle","title":"function get_angle","text":"<pre><code>static inline constexpr value_type get_angle(\n    Transform &amp; a,\n    Transform &amp; b\n)\n</code></pre> <p>Get the Angle object. </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_distance","title":"function get_distance","text":"<pre><code>static inline value_type get_distance(\n    Transform &amp; a,\n    Transform &amp; b\n)\n</code></pre> <p>Get the Distance object. </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_lerp","title":"function get_lerp","text":"<pre><code>static inline Transform get_lerp(\n    Transform &amp; a,\n    Transform &amp; b,\n    const value_type t\n)\n</code></pre> <p>lerp function </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-origin","title":"function origin","text":"<pre><code>static inline constexpr Transform origin()\n</code></pre> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-theta","title":"variable theta","text":"<pre><code>value_type theta;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/","title":"cpp_robotics::Triangle","text":"<p>\u4e09\u89d2\u5f62\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-functions","title":"Public Functions","text":"Name Triangle() =default constexpr Triangle(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2) void set(const Vector2d &amp; p0_, const Vector2d &amp; p1_, const Vector2d &amp; p2_) constexpr bool has_area() const constexpr double area() const constexpr std::array&lt; Vector2d, 3 &gt; vertex() const constexpr std::array&lt; Line, 3 &gt; outline() const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-attributes","title":"Public Attributes","text":"Name Vector2d p0 Vector2d p1 Vector2d p2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-triangle","title":"function Triangle","text":"<pre><code>Triangle() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-triangle_1","title":"function Triangle","text":"<pre><code>inline constexpr Triangle(\n    const Vector2d &amp; p0,\n    const Vector2d &amp; p1,\n    const Vector2d &amp; p2\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-set","title":"function set","text":"<pre><code>inline void set(\n    const Vector2d &amp; p0_,\n    const Vector2d &amp; p1_,\n    const Vector2d &amp; p2_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-vertex","title":"function vertex","text":"<pre><code>inline constexpr std::array&lt; Vector2d, 3 &gt; vertex() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-outline","title":"function outline","text":"<pre><code>inline constexpr std::array&lt; Line, 3 &gt; outline() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p0","title":"variable p0","text":"<pre><code>Vector2d p0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p1","title":"variable p1","text":"<pre><code>Vector2d p1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p2","title":"variable p2","text":"<pre><code>Vector2d p2;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/","title":"cpp_robotics::Vector2","text":"<p>2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb  More...</p> <p><code>#include &lt;vector2.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-functions","title":"Public Functions","text":"Name Vector2() =defaultConstruct a new Vector 2 object. constexpr Vector2(value_type vx, value_type vy)Construct a new Vector 2 object. constexpr Vector2(const Vector2 &amp; ) =defaultConstruct a new Vector 2 object. constexpr void set(const value_type vx, const value_type vy)\u5024\u306e\u4ee3\u5165 void set_polar(const value_type radius, const value_type theta)\u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 constexpr value_type dot(const Vector2 &amp; v) const constexpr value_type cross(const Vector2 &amp; v) const constexpr value_type norm_sq() const constexpr value_type norm() const\u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 void normalize()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 constexpr value_type angle() const\u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 constexpr Vector2 get_normalized()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 void rotate(const value_type theta)\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 constexpr Vector2 get_rotated(const value_type theta) const\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 constexpr bool is_zero() const constexpr bool has_nan() const constexpr Vector2 yx() const constexpr Vector2 nyx() const constexpr Vector2 ynx() const constexpr Vector2 nxy() const constexpr Vector2 xny() const constexpr Vector2 lerp(const Vector2 &amp; b, const value_type t) const constexpr Vector2 operator+() const constexpr Vector2 operator-() const constexpr bool operator==(const Vector2 &amp; v) const constexpr bool operator!=(const Vector2 &amp; v) const constexpr Vector2 operator+(const Vector2 &amp; v) const constexpr Vector2 operator-(const Vector2 &amp; v) const constexpr Vector2 &amp; operator+=(const Vector2 &amp; v) constexpr Vector2 &amp; operator-=(const Vector2 &amp; v) constexpr Vector2 &amp; operator*=(const value_type value) constexpr Vector2 &amp; operator/=(const value_type value) value_type &amp; operator[](const size_t index) constexpr value_type operator[](const size_t index) const constexpr value_type dot(const Vector2 &amp; a, const Vector2 &amp; b) constexpr value_type angle(const Vector2 &amp; a, const Vector2 &amp; b) constexpr value_type distance(const Vector2 &amp; a, const Vector2 &amp; b) constexpr Vector2 lerp(const Vector2 &amp; a, const Vector2 &amp; b, const value_type t) constexpr Vector2 zero() constexpr Vector2 up() constexpr Vector2 down() constexpr Vector2 right() constexpr Vector2 left()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friends","title":"Friends","text":"Name constexpr friend Vector2 operator/(const Vector2 &amp; v, const value_type value) constexpr friend Vector2 operator*(const Vector2 &amp; v, const Scaler s) constexpr friend Vector2 operator*(const Scaler s, const Vector2 &amp; v)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Vector2;\n</code></pre> <p>2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Vector2&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2","title":"function Vector2","text":"<pre><code>Vector2() =default\n</code></pre> <p>Construct a new Vector 2 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2_1","title":"function Vector2","text":"<pre><code>inline constexpr Vector2(\n    value_type vx,\n    value_type vy\n)\n</code></pre> <p>Construct a new Vector 2 object. </p> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2_2","title":"function Vector2","text":"<pre><code>constexpr Vector2(\n    const Vector2 &amp; \n) =default\n</code></pre> <p>Construct a new Vector 2 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-set","title":"function set","text":"<pre><code>inline constexpr void set(\n    const value_type vx,\n    const value_type vy\n)\n</code></pre> <p>\u5024\u306e\u4ee3\u5165 </p> <p>Parameters: </p> <ul> <li>vx value_type </li> <li>vy </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-set_polar","title":"function set_polar","text":"<pre><code>inline void set_polar(\n    const value_type radius,\n    const value_type theta\n)\n</code></pre> <p>\u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 </p> <p>Parameters: </p> <ul> <li>radius \u534a\u5f84 </li> <li>theta \u89d2\u5ea6[rad] </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-dot","title":"function dot","text":"<pre><code>inline constexpr value_type dot(\n    const Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-cross","title":"function cross","text":"<pre><code>inline constexpr value_type cross(\n    const Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-norm_sq","title":"function norm_sq","text":"<pre><code>inline constexpr value_type norm_sq() const\n</code></pre> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-norm","title":"function norm","text":"<pre><code>inline constexpr value_type norm() const\n</code></pre> <p>\u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-normalize","title":"function normalize","text":"<pre><code>inline void normalize()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-angle","title":"function angle","text":"<pre><code>inline constexpr value_type angle() const\n</code></pre> <p>\u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline constexpr Vector2 get_normalized()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-rotate","title":"function rotate","text":"<pre><code>inline void rotate(\n    const value_type theta\n)\n</code></pre> <p>\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>theta [rad] </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-get_rotated","title":"function get_rotated","text":"<pre><code>inline constexpr Vector2 get_rotated(\n    const value_type theta\n) const\n</code></pre> <p>\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>theta </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-is_zero","title":"function is_zero","text":"<pre><code>inline constexpr bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-has_nan","title":"function has_nan","text":"<pre><code>inline constexpr bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-yx","title":"function yx","text":"<pre><code>inline constexpr Vector2 yx() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-nyx","title":"function nyx","text":"<pre><code>inline constexpr Vector2 nyx() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-ynx","title":"function ynx","text":"<pre><code>inline constexpr Vector2 ynx() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-nxy","title":"function nxy","text":"<pre><code>inline constexpr Vector2 nxy() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-xny","title":"function xny","text":"<pre><code>inline constexpr Vector2 xny() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector2 lerp(\n    const Vector2 &amp; b,\n    const value_type t\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr Vector2 operator+() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Vector2 operator-() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_1","title":"function operator==","text":"<pre><code>inline constexpr bool operator==(\n    const Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_2","title":"function operator!=","text":"<pre><code>inline constexpr bool operator!=(\n    const Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_3","title":"function operator+","text":"<pre><code>inline constexpr Vector2 operator+(\n    const Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr Vector2 operator-(\n    const Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_4","title":"function operator+=","text":"<pre><code>inline constexpr Vector2 &amp; operator+=(\n    const Vector2 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr Vector2 &amp; operator-=(\n    const Vector2 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_5","title":"function operator*=","text":"<pre><code>inline constexpr Vector2 &amp; operator*=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_6","title":"function operator/=","text":"<pre><code>inline constexpr Vector2 &amp; operator/=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_7","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\n    const size_t index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_8","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\n    const size_t index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-dot_1","title":"function dot","text":"<pre><code>static inline constexpr value_type dot(\n    const Vector2 &amp; a,\n    const Vector2 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-angle_1","title":"function angle","text":"<pre><code>static inline constexpr value_type angle(\n    const Vector2 &amp; a,\n    const Vector2 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-distance","title":"function distance","text":"<pre><code>static inline constexpr value_type distance(\n    const Vector2 &amp; a,\n    const Vector2 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-lerp_1","title":"function lerp","text":"<pre><code>static inline constexpr Vector2 lerp(\n    const Vector2 &amp; a,\n    const Vector2 &amp; b,\n    const value_type t\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-zero","title":"function zero","text":"<pre><code>static inline constexpr Vector2 zero()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-up","title":"function up","text":"<pre><code>static inline constexpr Vector2 up()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-down","title":"function down","text":"<pre><code>static inline constexpr Vector2 down()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-right","title":"function right","text":"<pre><code>static inline constexpr Vector2 right()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-left","title":"function left","text":"<pre><code>static inline constexpr Vector2 left()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator","title":"friend operator/","text":"<pre><code>friend constexpr friend Vector2 operator/(\n    const Vector2 &amp; v,\n\n    const value_type value\n);\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator_1","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector2 operator*(\n    const Vector2 &amp; v,\n\n    const Scaler s\n);\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> <li>s </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator_2","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector2 operator*(\n    const Scaler s,\n\n    const Vector2 &amp; v\n);\n</code></pre> <p>Parameters: </p> <ul> <li>s </li> <li>v </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector2</p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/","title":"cpp_robotics::Vector3","text":"<p>3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb  More...</p> <p><code>#include &lt;vector3.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-functions","title":"Public Functions","text":"Name Vector3() =defaultConstruct a new Vector 3 object. constexpr Vector3(value_type vx, value_type vy, value_type vz)Construct a new Vector 3 object. Vector3(const Vector3 &amp; v) =defaultConstruct a new Vector 3 object. void set(value_type vx, value_type vy, value_type vz) constexpr value_type dot(const Vector3 &amp; v) const constexpr Vector3 cross(const Vector3 &amp; v) const constexpr value_type norm_sq() const value_type norm()Get the Magnitude object. void normalize()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector3 get_normalized()Get the Normalized object. constexpr bool is_zero() const constexpr bool has_nan() const constexpr Vector3 lerp(const Vector3 &amp; b, const value_type t) const constexpr Vector3 operator+() const constexpr Vector3 operator-() const bool operator==(const Vector3 &amp; v) const bool operator!=(const Vector3 &amp; v) const constexpr Vector3 operator+(const Vector3 &amp; v) const constexpr Vector3 operator-(const Vector3 &amp; v) const constexpr Vector3 &amp; operator+=(const Vector3 &amp; v) constexpr Vector3 &amp; operator-=(const Vector3 &amp; v) constexpr Vector3 &amp; operator*=(const value_type value) constexpr Vector3 &amp; operator/=(const value_type value) value_type &amp; operator[](const int index) constexpr value_type operator[](const int index) const constexpr value_type dot(const Vector3 &amp; a, const Vector3 &amp; b) value_type distance(const Vector3 &amp; a, const Vector3 &amp; b) constexpr Vector3 lerp(const Vector3 &amp; a, const Vector3 &amp; b, const value_type t) constexpr Vector3 zero() constexpr Vector3 forward() constexpr Vector3 back() constexpr Vector3 up() constexpr Vector3 down() constexpr Vector3 right() constexpr Vector3 left()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type z"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friends","title":"Friends","text":"Name constexpr friend Vector3 operator/(const Vector3 &amp; v, const value_type value) constexpr friend Vector3 operator*(const Vector3 &amp; v, const Scaler s) constexpr friend Vector3 operator*(const Scaler s, const Vector3 &amp; v)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Vector3;\n</code></pre> <p>3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Vector3&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3","title":"function Vector3","text":"<pre><code>Vector3() =default\n</code></pre> <p>Construct a new Vector 3 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3_1","title":"function Vector3","text":"<pre><code>inline constexpr Vector3(\n    value_type vx,\n    value_type vy,\n    value_type vz\n)\n</code></pre> <p>Construct a new Vector 3 object. </p> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3_2","title":"function Vector3","text":"<pre><code>Vector3(\n    const Vector3 &amp; v\n) =default\n</code></pre> <p>Construct a new Vector 3 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-set","title":"function set","text":"<pre><code>inline void set(\n    value_type vx,\n    value_type vy,\n    value_type vz\n)\n</code></pre> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-dot","title":"function dot","text":"<pre><code>inline constexpr value_type dot(\n    const Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-cross","title":"function cross","text":"<pre><code>inline constexpr Vector3 cross(\n    const Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-norm_sq","title":"function norm_sq","text":"<pre><code>inline constexpr value_type norm_sq() const\n</code></pre> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-norm","title":"function norm","text":"<pre><code>inline value_type norm()\n</code></pre> <p>Get the Magnitude object. </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-normalize","title":"function normalize","text":"<pre><code>inline void normalize()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline Vector3 get_normalized()\n</code></pre> <p>Get the Normalized object. </p> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-is_zero","title":"function is_zero","text":"<pre><code>inline constexpr bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-has_nan","title":"function has_nan","text":"<pre><code>inline constexpr bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector3 lerp(\n    const Vector3 &amp; b,\n    const value_type t\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr Vector3 operator+() const\n</code></pre> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Vector3 operator-() const\n</code></pre> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_2","title":"function operator!=","text":"<pre><code>inline bool operator!=(\n    const Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_3","title":"function operator+","text":"<pre><code>inline constexpr Vector3 operator+(\n    const Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr Vector3 operator-(\n    const Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_4","title":"function operator+=","text":"<pre><code>inline constexpr Vector3 &amp; operator+=(\n    const Vector3 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr Vector3 &amp; operator-=(\n    const Vector3 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_5","title":"function operator*=","text":"<pre><code>inline constexpr Vector3 &amp; operator*=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_6","title":"function operator/=","text":"<pre><code>inline constexpr Vector3 &amp; operator/=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_7","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\n    const int index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_8","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\n    const int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-dot_1","title":"function dot","text":"<pre><code>static inline constexpr value_type dot(\n    const Vector3 &amp; a,\n    const Vector3 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-distance","title":"function distance","text":"<pre><code>static inline value_type distance(\n    const Vector3 &amp; a,\n    const Vector3 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-lerp_1","title":"function lerp","text":"<pre><code>static inline constexpr Vector3 lerp(\n    const Vector3 &amp; a,\n    const Vector3 &amp; b,\n    const value_type t\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-zero","title":"function zero","text":"<pre><code>static inline constexpr Vector3 zero()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-forward","title":"function forward","text":"<pre><code>static inline constexpr Vector3 forward()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-back","title":"function back","text":"<pre><code>static inline constexpr Vector3 back()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-up","title":"function up","text":"<pre><code>static inline constexpr Vector3 up()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-down","title":"function down","text":"<pre><code>static inline constexpr Vector3 down()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-right","title":"function right","text":"<pre><code>static inline constexpr Vector3 right()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-left","title":"function left","text":"<pre><code>static inline constexpr Vector3 left()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-z","title":"variable z","text":"<pre><code>value_type z;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator","title":"friend operator/","text":"<pre><code>friend constexpr friend Vector3 operator/(\n    const Vector3 &amp; v,\n\n    const value_type value\n);\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator_1","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector3 operator*(\n    const Vector3 &amp; v,\n\n    const Scaler s\n);\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> <li>s </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator_2","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector3 operator*(\n    const Scaler s,\n\n    const Vector3 &amp; v\n);\n</code></pre> <p>Parameters: </p> <ul> <li>s </li> <li>v </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector3</p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/","title":"cpp_robotics::Vector4","text":"<p>4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb  More...</p> <p><code>#include &lt;vector4.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-functions","title":"Public Functions","text":"Name Vector4() =defaultConstruct a new Vector 4 object. constexpr Vector4(value_type vx, value_type vy, value_type vz, value_type vw)Construct a new Vector 4 object. Vector4(const Vector4 &amp; v) =defaultConstruct a new Vector 4 object. void set(value_type vx, value_type vy, value_type vz, value_type vw) constexpr value_type dot(const Vector4 &amp; v) const constexpr value_type norm_sq() const value_type norm()Get the Magnitude object. void normalize()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector4 get_normalized()Get the Normalized object. constexpr bool is_zero() const constexpr bool has_nan() const constexpr Vector4 lerp(const Vector4 &amp; b, const value_type t) const constexpr Vector4 operator+() const constexpr Vector4 operator-() const bool operator==(const Vector4 &amp; v) const bool operator!=(const Vector4 &amp; v) const constexpr Vector4 operator+(const Vector4 &amp; v) const constexpr Vector4 operator-(const Vector4 &amp; v) const constexpr Vector4 operator*(const value_type value) const constexpr Vector4 operator/(const value_type value) const constexpr Vector4 &amp; operator+=(const Vector4 &amp; v) constexpr Vector4 &amp; operator-=(const Vector4 &amp; v) constexpr Vector4 &amp; operator*=(const value_type value) constexpr Vector4 &amp; operator/=(const value_type value) value_type &amp; operator[](const int index) constexpr value_type operator[](const int index) const constexpr value_type dot(const Vector4 &amp; a, const Vector4 &amp; b) value_type distance(const Vector4 &amp; a, const Vector4 &amp; b) constexpr Vector4 lerp(const Vector4 &amp; a, const Vector4 &amp; b, const value_type t) constexpr Vector4 zero()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type z value_type w"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friends","title":"Friends","text":"Name constexpr friend Vector4 operator*(Scaler s, Vector4 v)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Vector4;\n</code></pre> <p>4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Vector4&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4","title":"function Vector4","text":"<pre><code>Vector4() =default\n</code></pre> <p>Construct a new Vector 4 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4_1","title":"function Vector4","text":"<pre><code>inline constexpr Vector4(\n    value_type vx,\n    value_type vy,\n    value_type vz,\n    value_type vw\n)\n</code></pre> <p>Construct a new Vector 4 object. </p> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> <li>vw </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4_2","title":"function Vector4","text":"<pre><code>Vector4(\n    const Vector4 &amp; v\n) =default\n</code></pre> <p>Construct a new Vector 4 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-set","title":"function set","text":"<pre><code>inline void set(\n    value_type vx,\n    value_type vy,\n    value_type vz,\n    value_type vw\n)\n</code></pre> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> <li>vw </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-dot","title":"function dot","text":"<pre><code>inline constexpr value_type dot(\n    const Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-norm_sq","title":"function norm_sq","text":"<pre><code>inline constexpr value_type norm_sq() const\n</code></pre> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-norm","title":"function norm","text":"<pre><code>inline value_type norm()\n</code></pre> <p>Get the Magnitude object. </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-normalize","title":"function normalize","text":"<pre><code>inline void normalize()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline Vector4 get_normalized()\n</code></pre> <p>Get the Normalized object. </p> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-is_zero","title":"function is_zero","text":"<pre><code>inline constexpr bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-has_nan","title":"function has_nan","text":"<pre><code>inline constexpr bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector4 lerp(\n    const Vector4 &amp; b,\n    const value_type t\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr Vector4 operator+() const\n</code></pre> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Vector4 operator-() const\n</code></pre> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_2","title":"function operator!=","text":"<pre><code>inline bool operator!=(\n    const Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_3","title":"function operator+","text":"<pre><code>inline constexpr Vector4 operator+(\n    const Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr Vector4 operator-(\n    const Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_4","title":"function operator*","text":"<pre><code>inline constexpr Vector4 operator*(\n    const value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_5","title":"function operator/","text":"<pre><code>inline constexpr Vector4 operator/(\n    const value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_6","title":"function operator+=","text":"<pre><code>inline constexpr Vector4 &amp; operator+=(\n    const Vector4 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr Vector4 &amp; operator-=(\n    const Vector4 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_7","title":"function operator*=","text":"<pre><code>inline constexpr Vector4 &amp; operator*=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_8","title":"function operator/=","text":"<pre><code>inline constexpr Vector4 &amp; operator/=(\n    const value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_9","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\n    const int index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_10","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\n    const int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-dot_1","title":"function dot","text":"<pre><code>static inline constexpr value_type dot(\n    const Vector4 &amp; a,\n    const Vector4 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-distance","title":"function distance","text":"<pre><code>static inline value_type distance(\n    const Vector4 &amp; a,\n    const Vector4 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-lerp_1","title":"function lerp","text":"<pre><code>static inline constexpr Vector4 lerp(\n    const Vector4 &amp; a,\n    const Vector4 &amp; b,\n    const value_type t\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-zero","title":"function zero","text":"<pre><code>static inline constexpr Vector4 zero()\n</code></pre> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-z","title":"variable z","text":"<pre><code>value_type z;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-w","title":"variable w","text":"<pre><code>value_type w;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friend-operator","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector4 operator*(\n    Scaler s,\n\n    Vector4 v\n);\n</code></pre> <p>Parameters: </p> <ul> <li>s </li> <li>v </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector4</p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/","title":"cpp_robotics::grid_path_planning_utils::GridNode","text":"<p><code>#include &lt;grid_path_planning_utils.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-functions","title":"Public Functions","text":"Name GridNode() bool operator==(const GridNode &amp; o) bool operator==(const Eigen::Vector2i &amp; o) bool operator&lt;(const GridNode &amp; o) int score()"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-attributes","title":"Public Attributes","text":"Name Eigen::Vector2i pos Eigen::Vector2i parent int cost int hcost"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-gridnode","title":"function GridNode","text":"<pre><code>inline GridNode()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const GridNode &amp; o\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool operator==(\n    const Eigen::Vector2i &amp; o\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator_2","title":"function operator&lt;","text":"<pre><code>inline bool operator&lt;(\n    const GridNode &amp; o\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-score","title":"function score","text":"<pre><code>inline int score()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-pos","title":"variable pos","text":"<pre><code>Eigen::Vector2i pos;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-parent","title":"variable parent","text":"<pre><code>Eigen::Vector2i parent;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-cost","title":"variable cost","text":"<pre><code>int cost;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-hcost","title":"variable hcost","text":"<pre><code>int hcost;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/","title":"cpp_robotics::iLQRConfig","text":"<p><code>#include &lt;ilqr.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#public-attributes","title":"Public Attributes","text":"Name size_t max_iter double cost_torelance double beta1 double beta2 double alpha_scale size_t max_forward_itr double eps"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 100;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#variable-cost_torelance","title":"variable cost_torelance","text":"<pre><code>double cost_torelance = 1e-3;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#variable-beta1","title":"variable beta1","text":"<pre><code>double beta1 = 1e-4;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#variable-beta2","title":"variable beta2","text":"<pre><code>double beta2 = 10.0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#variable-alpha_scale","title":"variable alpha_scale","text":"<pre><code>double alpha_scale = 0.5;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#variable-max_forward_itr","title":"variable max_forward_itr","text":"<pre><code>size_t max_forward_itr = 10;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1iLQRConfig/#variable-eps","title":"variable eps","text":"<pre><code>double eps = 1e-4;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__ad__dynamics/","title":"cpp_robotics::internal::has_ad_dynamics","text":"<p>More...</p> <p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherits from std::false_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__ad__dynamics/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename DerClass ,\ntypename Scalar ,\ntypename  =void&gt;\nstruct cpp_robotics::internal::has_ad_dynamics;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__ad__dynamics_3_01DerClass_00_01Scalar_00_01std_1_1void__686d851a31e114077f2815a392f17995/","title":"cpp_robotics::internal::has_ad_dynamics&lt; DerClass, Scalar, std::void_t&lt; decltype(std::declval&lt; const DerClass &gt;().dynamics(std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;()))&gt;&gt;","text":"<p>More...</p> <p><code>#include &lt;ocp_dynamics.hpp&gt;</code></p> <p>Inherits from std::true_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__ad__dynamics_3_01DerClass_00_01Scalar_00_01std_1_1void__686d851a31e114077f2815a392f17995/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename DerClass ,\ntypename Scalar &gt;\nstruct cpp_robotics::internal::has_ad_dynamics&lt; DerClass, Scalar, std::void_t&lt; decltype(std::declval&lt; const DerClass &gt;().dynamics(std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;()))&gt;&gt;;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__forward__kinematics/","title":"cpp_robotics::internal::has_forward_kinematics","text":"<p>More...</p> <p><code>#include &lt;arm_kinematics.hpp&gt;</code></p> <p>Inherits from std::false_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__forward__kinematics/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename  =void&gt;\nstruct cpp_robotics::internal::has_forward_kinematics;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__forward__kinematics_3_01T_00_01std_1_1void__t_3_01decltydb7be3a894c5ad37b3913fdec2c6fa8d/","title":"cpp_robotics::internal::has_forward_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().forward_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt;","text":"<p>More...</p> <p><code>#include &lt;arm_kinematics.hpp&gt;</code></p> <p>Inherits from std::true_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__forward__kinematics_3_01T_00_01std_1_1void__t_3_01decltydb7be3a894c5ad37b3913fdec2c6fa8d/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct cpp_robotics::internal::has_forward_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().forward_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt;;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__inverse__kinematics/","title":"cpp_robotics::internal::has_inverse_kinematics","text":"<p>More...</p> <p><code>#include &lt;arm_kinematics.hpp&gt;</code></p> <p>Inherits from std::false_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__inverse__kinematics/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename  =void&gt;\nstruct cpp_robotics::internal::has_inverse_kinematics;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__inverse__kinematics_3_01T_00_01std_1_1void__t_3_01declty1fd0005f4dfa696f185201c9c9719bbd/","title":"cpp_robotics::internal::has_inverse_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().inverse_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt;","text":"<p>More...</p> <p><code>#include &lt;arm_kinematics.hpp&gt;</code></p> <p>Inherits from std::true_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1internal_1_1has__inverse__kinematics_3_01T_00_01std_1_1void__t_3_01declty1fd0005f4dfa696f185201c9c9719bbd/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct cpp_robotics::internal::has_inverse_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().inverse_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt;;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/","title":"cpp_robotics::spline::spline_c","text":"<p><code>#include &lt;spline.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#public-attributes","title":"Public Attributes","text":"Name Vector4d xb Vector4d yb"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#variable-xb","title":"variable xb","text":"<pre><code>Vector4d xb;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#variable-yb","title":"variable yb","text":"<pre><code>Vector4d yb;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/","title":"cpp_robotics::unit::Prefix","text":"<p>\u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from PrefixBase</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-types","title":"Public Types","text":"Name using Prefix&lt; N, D &gt; type"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t num constexpr uint32_t den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;uint32_t N,\nuint32_t D&gt;\nstruct cpp_robotics::unit::Prefix;\n</code></pre> <p>\u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>N </li> <li>D </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#using-type","title":"using type","text":"<pre><code>using cpp_robotics::unit::Prefix&lt; N, D &gt;::type =  Prefix&lt;N, D&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#variable-num","title":"variable num","text":"<pre><code>static constexpr uint32_t num = N / std::gcd(N, D);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#variable-den","title":"variable den","text":"<pre><code>static constexpr uint32_t den = D / std::gcd(N, D);\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/","title":"cpp_robotics::UnitType","text":"<p>SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#public-attributes","title":"Public Attributes","text":"Name constexpr int dim1 \u30e1\u30fc\u30c8\u30eb(m) constexpr int dim2 \u30ad\u30ed\u30b0\u30e9\u30e0(kg) constexpr int dim3 \u79d2(s) constexpr int dim4 \u30a2\u30f3\u30da\u30a2(A) constexpr int dim5 \u30b1\u30eb\u30d3\u30f3(K) constexpr int dim6 \u30e2\u30eb(mol) constexpr int dim7 \u30ab\u30f3\u30c7\u30e9(cd)"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;int DIM1,\nint DIM2,\nint DIM3,\nint DIM4,\nint DIM5,\nint DIM6,\nint DIM7&gt;\nstruct cpp_robotics::UnitType;\n</code></pre> <p>SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim1","title":"variable dim1","text":"<pre><code>static constexpr int dim1 = DIM1;\n</code></pre> <p>\u30e1\u30fc\u30c8\u30eb(m) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim2","title":"variable dim2","text":"<pre><code>static constexpr int dim2 = DIM2;\n</code></pre> <p>\u30ad\u30ed\u30b0\u30e9\u30e0(kg) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim3","title":"variable dim3","text":"<pre><code>static constexpr int dim3 = DIM3;\n</code></pre> <p>\u79d2(s) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim4","title":"variable dim4","text":"<pre><code>static constexpr int dim4 = DIM4;\n</code></pre> <p>\u30a2\u30f3\u30da\u30a2(A) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim5","title":"variable dim5","text":"<pre><code>static constexpr int dim5 = DIM5;\n</code></pre> <p>\u30b1\u30eb\u30d3\u30f3(K) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim6","title":"variable dim6","text":"<pre><code>static constexpr int dim6 = DIM6;\n</code></pre> <p>\u30e2\u30eb(mol) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim7","title":"variable dim7","text":"<pre><code>static constexpr int dim7 = DIM7;\n</code></pre> <p>\u30ab\u30f3\u30c7\u30e9(cd) </p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/","title":"cpp_robotics::unit::prefix::pfx_div","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-types","title":"Public Types","text":"Name using Prefix&lt; raw_num, raw_den &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P1 ,\nclass P2 &gt;\nstruct cpp_robotics::unit::prefix::pfx_div;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_div&lt; P1, P2 &gt;::prefix =  Prefix&lt;raw_num, raw_den&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#variable-raw_num","title":"variable raw_num","text":"<pre><code>static constexpr uint32_t raw_num = P1::num * P2::den;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#variable-raw_den","title":"variable raw_den","text":"<pre><code>static constexpr uint32_t raw_den = P1::den * P2::num;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/","title":"cpp_robotics::unit::prefix::pfx_inv","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#public-types","title":"Public Types","text":"Name using Prefix&lt; P::den, P::num &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P &gt;\nstruct cpp_robotics::unit::prefix::pfx_inv;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_inv&lt; P &gt;::prefix =  Prefix&lt;P::den, P::num&gt;;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/","title":"cpp_robotics::unit::prefix::pfx_min","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-types","title":"Public Types","text":"Name using Prefix&lt; raw_num, raw_den &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P1 ,\nclass P2 &gt;\nstruct cpp_robotics::unit::prefix::pfx_min;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_min&lt; P1, P2 &gt;::prefix =  Prefix&lt;raw_num, raw_den&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#variable-raw_num","title":"variable raw_num","text":"<pre><code>static constexpr uint32_t raw_num = std::min(P1::num * P2::den, P2::num * P1::den);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#variable-raw_den","title":"variable raw_den","text":"<pre><code>static constexpr uint32_t raw_den = P1::den * P2::den;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/","title":"cpp_robotics::unit::prefix::pfx_mul","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-types","title":"Public Types","text":"Name using Prefix&lt; raw_num, raw_den &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P1 ,\nclass P2 &gt;\nstruct cpp_robotics::unit::prefix::pfx_mul;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_mul&lt; P1, P2 &gt;::prefix =  Prefix&lt;raw_num, raw_den&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#variable-raw_num","title":"variable raw_num","text":"<pre><code>static constexpr uint32_t raw_num = P2::num * P1::num;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#variable-raw_den","title":"variable raw_den","text":"<pre><code>static constexpr uint32_t raw_den = P2::den * P1::den;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag/","title":"cpp_robotics::unit::tag::is_normal_tag","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from std::false_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;int Tag&gt;\nstruct cpp_robotics::unit::tag::is_normal_tag;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3-1_01_4/","title":"cpp_robotics::unit::tag::is_normal_tag&lt;-1 &gt;","text":"<p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from std::true_type</p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3_010_01_4/","title":"cpp_robotics::unit::tag::is_normal_tag&lt; 0 &gt;","text":"<p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from std::true_type</p> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/a__star_8hpp/","title":"include/cpp_robotics/path_planning/a_star.hpp","text":""},{"location":"doxybook/Files/a__star_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/a__star_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"grid_path_planning_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::vector&lt;Eigen::Vector2i&gt; a_star(const Eigen::Vector2i&amp; start, const Eigen::Vector2i&amp; end, const Eigen::MatrixXi&amp; map)\n{\n    using namespace grid_path_planning_utils;\n\n    if(not contain_in_map(map, start) || not contain_in_map(map, end))\n        return {start};\n\n    const static std::array&lt;Eigen::Vector2i,8&gt; nb = {Eigen::Vector2i{1,0}, {0,1}, {-1,0}, {0,-1},\n                            {1,1}, {-1,1}, {-1,-1}, {1,-1}};\n\n    std::list&lt;GridNode&gt; open;\n    std::list&lt;GridNode&gt; closed;\n    GridNode sn;\n    sn.pos = start;\n    sn.parent = start;\n    sn.cost = 0;\n    sn.hcost = dist(start,end);\n\n    // first step open\n    open.push_back(sn);\n    while(not open.empty())\n    {\n        // \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u9078\u3076\n        // Todo: \u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u308c\u3070\u8907\u6570\u958b\u304f?\n        // \u30b4\u30fc\u30eb\u306b\u5230\u9054\u3059\u308b\u76f4\u524d\u306b\u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u3063\u3066\u3082\u305d\u3093\u306a\u306b\u554f\u984c\u306a\u3044\u6c17\u3082\u3059\u308b\n        auto min_itr = open.begin();\n        int min_score = open.front().score();\n        for(auto i = open.begin(); i != open.end(); i++)\n        {\n            if(min_score &gt; (*i).score())\n            {\n                min_itr = i;\n                min_score = (*i).score();\n            }\n        }\n\n        // \u30b9\u30b3\u30a2\u6700\u5c0f\u30ce\u30fc\u30c9\u3092\u57fa\u6e96\u306b\u3059\u308b\n        GridNode n = *min_itr;\n        open.erase(min_itr);\n\n        // \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u30af\u30ed\u30fc\u30ba\n        closed.push_back(n);\n\n        // \u57fa\u6e96\u30ce\u30fc\u30c9\u304b\u30898\u65b9\u5411\u30aa\u30fc\u30d7\u30f3\n        for(size_t i = 0; i &lt; 8; i++)\n        {\n            Eigen::Vector2i np = n.pos + nb[i];\n            if(np == end)\n            {\n                std::vector&lt;Eigen::Vector2i&gt; path;\n                path.push_back(np);\n                // closed\u304b\u3089\u9006\u9806\u306b\u30d1\u30b9\u3092\u53d6\u5f97\n                Eigen::Vector2i parent = closed.back().pos;\n                for(auto it = closed.rbegin(); it != closed.rend(); it++)\n                {\n                    if((*it).pos == parent)\n                    {\n                        path.insert(path.begin(), (*it).pos);\n                        parent = (*it).parent;\n                    }\n                }\n                return path;\n            }\n            if(is_correct_step(np, map))\n            {\n                GridNode nn;\n                nn.pos = np;\n                nn.parent = n.pos;\n                nn.cost = n.cost + 3; // \uff18\u65b9\u5411\u3069\u306e\u79fb\u52d5\u3067\u3082\u30b3\u30b9\u30c8\u306f\u540c\u7b49\u3068\u3059\u308b\n                Eigen::Vector2i d1 = n.pos-n.parent, d2 = nn.pos-nn.parent;\n                if(d1(0) != d2(0))\n                    nn.cost++; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059\n                if(d1(1) != d2(1))\n                    nn.cost++; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059\n                nn.hcost = dist(np, end);\n                if(not exist(open, closed, nn.pos, nn.cost + nn.hcost))\n                {\n                    open.push_front(nn);\n                } \n            }\n        }\n    }\n\n    return {};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/","title":"include/cpp_robotics/filter/acceleration_limit_filter.hpp","text":""},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f)"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n#include \"integrator.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass AccelerationLimitFilter\n{\npublic:\n    AccelerationLimitFilter(double acc_max, double Ts, double gpd, double Kx, double Kv, std::optional&lt;std::pair&lt;double, double&gt;&gt; limit = std::nullopt):\n        acc_max_(acc_max), Ts_(Ts), gpd_(gpd), Kx_(Kx), Kv_(Kv), limit_(limit), diff_(Ts, gpd), vel_integ_(Ts), pos_integ_(Ts)\n    {\n        reset();\n    }\n\n    // \u76ee\u5b89\u3068\u3057\u3066\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3001\u52a0\u901f\u5ea6\u306b\u3088\u3063\u3066\u30aa\u30fc\u30d0\u30fc\u30b7\u30e5\u30fc\u30c8\u91cf\u304c\u5909\u308f\u308b\u306e\u3067\u6ce8\u610f\n    AccelerationLimitFilter(double acc_max, double Ts, std::optional&lt;std::pair&lt;double, double&gt;&gt; limit = std::nullopt):\n        AccelerationLimitFilter(acc_max, Ts, 0.5/Ts, 1000.0/Ts, 500.0/Ts/std::sqrt(acc_max), limit)\n    {\n    }\n\n    virtual void reset()\n    {\n        y1_ = 0;\n        v1_ = 0;\n        diff_.reset();\n        vel_integ_.reset();\n        pos_integ_.reset();\n    }\n\n    virtual double filtering(double u) \n    {\n        auto[diff2, diff1, pass] = diff_.filtering(u);\n\n        double acc = diff2 - (Kx_*(y1_-pass)) - (Kv_*(v1_-diff1));\n\n        acc = std::clamp(acc, -acc_max_, acc_max_);\n        double vel = vel_integ_.filtering(acc);\n        double pos = pos_integ_.filtering(vel);\n\n        v1_ = vel;\n        y1_ = pos;\n        return pos;\n    }\n\n    double Ts() const { return Ts_; }\n\nprivate:\n    class DiffTri\n    {\n    public:\n        DiffTri(double gpd, double Ts): Ts_(Ts), gpd_(gpd) { reset(); }\n\n        void reset()\n        {\n            u1_ = u2_ = 0;\n            diff21_ = diff22_ = 0;\n            diff11_ = diff12_ = 0;\n            pass2_ = pass1_ = 0;\n        }\n\n        std::tuple&lt;double, double, double&gt; filtering(double u)\n        {\n            const double tau_ = 1/gpd_;\n            const double y1_coeff = (-4*tau_*tau_ + 2*Ts_*Ts_);\n            const double y2_coeff = (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_);\n            const double y_coeff = 2*tau_*tau_ + 4*tau_*Ts_ + Ts_*Ts_; \n            // double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_;\n            // double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_;\n\n            const double prev_diff2 = y1_coeff*diff21_ + y2_coeff*diff22_;\n            const double prev_diff1 = y1_coeff*diff11_ + y2_coeff*diff12_;\n            const double prev_pass  = y1_coeff*pass1_ + y2_coeff*pass2_;\n\n\n            double diff2 = ( 4*(u -2*u1_ + u2_) - prev_diff2) / y_coeff;\n            double diff1 = ( 2*Ts_*(u - u2_) - prev_diff1) / y_coeff;\n            double pass = ( Ts_*Ts_*(u +2*u1_ + u2_) - prev_pass) / y_coeff;\n\n            u2_ = u1_;\n            u1_ = u;\n\n            diff22_ = diff21_;\n            diff21_ = diff2;\n            diff12_ = diff11_;\n            diff11_ = diff1;\n            pass2_ = pass1_;\n            pass1_ = pass;\n\n            return {diff2, diff1, pass};\n        }\n\n    private:\n        double Ts_, gpd_;\n        double u1_, u2_;\n        double diff21_, diff22_;\n        double diff11_, diff12_;\n        double pass1_, pass2_;\n    };\n\n    const double acc_max_;\n    const double Ts_; \n    const double gpd_; \n    const double Kx_; \n    const double Kv_; \n    const std::optional&lt;std::pair&lt;double, double&gt;&gt; limit_;\n\n    DiffTri diff_;\n    Integrator vel_integ_, pos_integ_;\n    double y1_, v1_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/active__set__method_8hpp/","title":"include/cpp_robotics/optimize/active_set_method.hpp","text":""},{"location":"doxybook/Files/active__set__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/active__set__method_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct cpp_robotics::ActiveSetMethod::Problem struct cpp_robotics::ActiveSetMethod::Result"},{"location":"doxybook/Files/active__set__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"./newton_method.hpp\"\n\nnamespace cpp_robotics\n{\n\n// min 1/2 x^T Q x + cx\n// s.t. Ax &lt;= b\n// x \u7b49\u5f0f\u5236\u7d04\u306f2\u3064\u306e\u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u5909\u63db\u3059\u308b\n// o \u7b49\u5f0f\u5236\u7d04\u306f\u5e38\u306b\u30a2\u30af\u30c6\u30a3\u30d6\u3067\u3042\u308b\u3068\u3059\u308b\nclass ActiveSetMethod\n{\npublic:\n    struct Problem\n    {\n        Problem() = default;\n        // Problem(size_t x_size_, size_t constraint_size_)\n        // {\n        //     x_size = x_size_;\n        //     constraint_size = constraint_size_;\n        //     Q = Eigen::MatrixXd::Zero(x_size, x_size);\n        //     c = Eigen::VectorXd::Zero(x_size_);\n        //     A = Eigen::MatrixXd::Zero(constraint_size, x_size_);\n        //     b = Eigen::VectorXd::Zero(constraint_size);\n        // }\n\n        Problem(size_t x_size_)\n        {\n            x_size = x_size_;\n            Q = Eigen::MatrixXd::Zero(x_size, x_size);\n            c = Eigen::VectorXd::Zero(x_size_);\n        }\n\n        // Ax &lt;= b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b\n        void add_inequality_constraint(const Eigen::MatrixXd &amp;An, Eigen::VectorXd bn)\n        {\n            // for(Eigen::MatrixXd::Index i = 0; i &lt; An.rows(); i++)\n            // {\n            //     if(An.row(i).norm() &lt; 1e-9)\n            //         return;\n            // }\n\n            if(A.cols() != 0)\n            {\n                assert(A.cols() == An.cols());\n                Eigen::MatrixXd new_A(A.rows() + An.rows(), A.cols());\n                new_A &lt;&lt; A, An;\n                A = new_A;\n            }\n            else\n            {\n                A = An;\n            }\n\n            if(b.cols() != 0)\n            {\n                Eigen::VectorXd new_b(b.rows() + bn.rows());\n                new_b &lt;&lt; b, bn;\n                b = new_b;\n            }\n            else\n            {\n                b = bn;\n            }\n\n            // std::cout &lt;&lt; \"add A\" &lt;&lt; std::endl &lt;&lt; A &lt;&lt; std::endl;\n            // std::cout &lt;&lt; \"add b\" &lt;&lt; std::endl &lt;&lt; b &lt;&lt; std::endl;\n\n\n            assert(A.rows() == b.rows());\n            constraint_size = A.rows();\n        }\n\n        // Ax = b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b\n        void add_equality_constraint(const Eigen::MatrixXd &amp;An, Eigen::VectorXd bn)\n        {\n            (void) An;\n            (void) bn;\n        }\n\n        Eigen::MatrixXd Q;\n        Eigen::VectorXd c;\n        Eigen::MatrixXd A;\n        Eigen::VectorXd b;\n\n        size_t max_iter = 1000;\n        size_t max_iter_get_initial_feasible_x = 1000;\n\n        size_t x_size = 0; \n        size_t constraint_size = 0;\n\n        double alpha = 1.1;\n    };\n\n    struct Result\n    {\n        bool is_solved = false;\n        Eigen::VectorXd x_opt;\n        Eigen::VectorXd lambda_opt;\n        size_t iter_cnt = 0;\n    };\n\n    Result solve(Problem prob, Eigen::VectorXd x)\n    {\n        prob_ = prob;\n        Result result;\n\n        // \u5236\u7d04\u304c\u306a\u3044\u5834\u5408\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f\n        if(prob_.constraint_size == 0)\n        {\n            auto grad = [&amp;](const Eigen::VectorXd &amp;x) { return (prob_.Q * x + prob_.c); };\n            auto hess = [&amp;](const Eigen::VectorXd &amp;x) { (void) x; return  prob_.Q; };\n            std::tie(result.is_solved, result.x_opt, result.iter_cnt) = \n                newton_method(grad, hess, x, 1e-6, prob_.max_iter);\n            return result;\n        }\n\n        // std::cout &lt;&lt; \"--------------------\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"Q\" &lt;&lt; std::endl &lt;&lt; prob_.Q &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"c\" &lt;&lt; std::endl &lt;&lt; prob_.c &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"A\" &lt;&lt; std::endl &lt;&lt; prob_.A &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"b\" &lt;&lt; std::endl &lt;&lt; prob_.b &lt;&lt; std::endl;\n\n\n        // \u521d\u671f\u5024\u306e\u30c1\u30a7\u30c3\u30af\n        if(not discrimination_feasiblity(x))\n        {\n            // std::cout &lt;&lt; \"\u521d\u671f\u5024\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\" &lt;&lt; std::endl;\n            x = get_initial_feasible_x(x);\n        }\n\n        auto active_idx = active_set_index(x);\n\n        // debug\n        // std::cout &lt;&lt; \"active_idx\" &lt;&lt; std::endl;\n        // std::for_each(active_idx.begin(), active_idx.end(), [&amp;](auto idx)\n        // {\n        //     std::cout &lt;&lt; \"- \" &lt;&lt; idx &lt;&lt; std::endl;\n        // });\n\n        // \u89e3\u7121\u3057\n        if (not discrimination_feasiblity(x))\n        {\n            // std::cout &lt;&lt; \"\u89e3\u7121\u3057 &amp; \u4fee\u6b63\u4e0d\u53ef\u80fd\" &lt;&lt; std::endl;\n            return result;\n        }\n\n        // \u53cd\u5fa9\u8a08\u7b97\n        result.is_solved = false;\n        for(result.iter_cnt = 0; result.iter_cnt &lt; prob_.max_iter; result.iter_cnt++)\n        {\n            if(result.is_solved)\n                break;\n\n            auto [x_hat, lambda_hat] = get_solution(active_idx);\n\n            // std::cout &lt;&lt; \"x_hat = \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; x_hat.transpose() &lt;&lt; std::endl &lt;&lt; std::endl;\n\n            // std::cout &lt;&lt; \"lambda_hat = \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; lambda_hat.transpose() &lt;&lt; std::endl &lt;&lt; std::endl;\n\n            if(not discrimination_feasiblity(x_hat))\n            {\n                // std::cout &lt;&lt; \"\u5b9f\u884c\u4e0d\u53ef\u80fd &amp; x_hat_dash \u4fee\u6b63\" &lt;&lt; std::endl;\n                // \u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5916\u306b\u51fa\u305f\u306e\u3067\u4e2d\u306b\u623b\u3059\n                x = get_x_hat_dash(x_hat, x);\n                x_hat = x;\n                active_idx = active_set_index(x);\n\n                // std::cout &lt;&lt; \"x_hat_dash\" &lt;&lt; std::endl;\n                // std::cout &lt;&lt; x &lt;&lt; std::endl;\n\n            }\n            else\n            {\n                // std::cout &lt;&lt; \"\u5b9f\u884c\u53ef\u80fd\" &lt;&lt; std::endl;\n                // \u6700\u9069\u6027\u306e\u5224\u5225\n                if((lambda_hat.array()&gt;=0.0).count() == lambda_hat.rows())\n                {\n                    // \u30e9\u30e0\u30c0\u304c\u5168\u3066\u8ca0\u306e\u5024\u3067\u306a\u3044 = \u5168\u3066\u306e\u5236\u7d04\u3092\u6e80\u305f\u3059 \n                    result.is_solved = true;\n                }\n                else\n                {\n                    // lambda_i &lt; 0 \u304c\u5b58\u5728\u3059\u308b\u5b9f\u884c\u4e0d\u53ef\u80fd\u89e3\n                    // lambda_hat\u306e\u6700\u5c0f\u5024\u3092\u524a\u9664\u3057\u3066lambda\u3068\u3059\u308b\n                    Eigen::VectorXd::Index min_idx;\n                    lambda_hat.minCoeff(&amp;min_idx);\n                    for(auto itr = active_idx.begin(); itr != active_idx.end(); itr++)\n                    {\n                        if(*itr == static_cast&lt;size_t&gt;(min_idx))\n                        {\n                            active_idx.erase(itr);\n                            break;\n                        }\n                    }\n                    std::sort(active_idx.begin(), active_idx.end());\n                }\n            }\n\n            result.x_opt = x_hat;\n            result.lambda_opt = lambda_hat;\n        }\n\n        return result;\n    }\n\nprivate:\n    auto f(const Eigen::VectorXd &amp;x) const\n    {\n        return (0.5 * x.transpose() * prob_.Q * x + prob_.c * x);\n    }\n\n    auto grad_f(const Eigen::VectorXd &amp;x) const\n    {\n        return (prob_.Q * x + prob_.c);\n    }\n\n    auto g(const Eigen::VectorXd &amp;x) const\n    {\n        return (prob_.A*x - prob_.b);\n    }\n\n    auto grad_g(void) const\n    {\n        return prob_.A;\n    }\n\n    std::vector&lt;size_t&gt; active_set_index(const Eigen::VectorXd &amp;x) const\n    {\n        auto gval = g(x);\n\n        std::vector&lt;size_t&gt; idx;\n        idx.reserve(gval.rows());\n        for(Eigen::VectorXd::Index i = 0; i &lt; gval.rows(); i++)\n        {\n            if(std::abs(gval(i)) &lt; eps_)\n                idx.push_back(i);\n        }\n        return idx;\n    }\n\n    std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt; get_solution(const std::vector&lt;size_t&gt; &amp;active_idx) const\n    {\n        size_t m = prob_.A.rows();\n        size_t n = prob_.A.cols();\n\n        Eigen::VectorXd x_hat, lambda_hat;\n        // std::cout &lt;&lt; \"active_idx.size(): \" &lt;&lt; active_idx.size() &lt;&lt; std::endl;\n        if(active_idx.size() == 0)\n        {\n            // \u6709\u52b9\u5236\u7d04\u306a\u3057\n            x_hat = prob_.Q.inverse() * -prob_.c;\n            lambda_hat = Eigen::VectorXd::Zero(m);\n        }\n        else\n        {\n            // \u6709\u52b9\u5236\u7d04\u3042\u308a\n            Eigen::MatrixXd Aq = Eigen::MatrixXd::Zero(active_idx.size(), prob_.A.cols());\n            Eigen::VectorXd bq = Eigen::VectorXd::Zero(active_idx.size());\n\n            for(size_t i = 0; i &lt; active_idx.size(); i++)\n            {\n                Aq.row(i) = prob_.A.row(active_idx[i]);\n                bq.row(i) = prob_.b.row(active_idx[i]);\n            }\n\n            // std::cout &lt;&lt; \"Aq= \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; Aq &lt;&lt; std::endl &lt;&lt; std::endl;\n            // std::cout &lt;&lt; \"bq= \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; bq &lt;&lt; std::endl &lt;&lt; std::endl;\n\n\n            size_t mq = Aq.rows();\n            // size_t nq = Aq.cols(); // = n\n\n            // tmp_a = | Aq   0   |\n            //         | Q   Aq^T |\n            Eigen::MatrixXd tmp_a = Eigen::MatrixXd::Zero(mq+n, mq+n);\n\n            tmp_a.block(0,  0, mq, n)  = Aq;\n            tmp_a.block(mq, 0, n, n) = prob_.Q;\n            tmp_a.block(mq, n, n,  mq) = Aq.transpose();\n\n            // tmp_b = | bq |\n            //         | c  |\n            Eigen::VectorXd tmp_b = Eigen::VectorXd(mq+n);\n            tmp_b &lt;&lt; bq, -prob_.c;\n\n\n            // std::cout &lt;&lt; \"tmp_a= \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; tmp_a &lt;&lt; std::endl &lt;&lt; std::endl;\n            // std::cout &lt;&lt; \"tmp_b= \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; tmp_b &lt;&lt; std::endl &lt;&lt; std::endl;\n\n            Eigen::VectorXd p_hat = tmp_a.fullPivLu().solve(tmp_b);\n\n            // std::cout &lt;&lt; \"p_hat.size()= \" &lt;&lt; p_hat.size() &lt;&lt; std::endl;\n\n            // std::cout &lt;&lt; \"p_hat= \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; p_hat &lt;&lt; std::endl &lt;&lt; std::endl;\n\n            x_hat = p_hat.head(n);\n            lambda_hat = Eigen::VectorXd::Zero(m);\n            for(size_t i = 0; i &lt; mq; i++)\n            {\n                lambda_hat(active_idx[i]) = p_hat(n + i);\n            }\n\n            // std::cout &lt;&lt; \"x_hat= \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; x_hat &lt;&lt; std::endl &lt;&lt; std::endl;\n\n            // std::cout &lt;&lt; \"lambda_hat= \" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; lambda_hat &lt;&lt; std::endl &lt;&lt; std::endl;\n        }\n        return {x_hat, lambda_hat};\n    }\n\n    // x\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u3067\u3042\u3063\u305f\u5834\u5408\u306b\u5b9f\u884c\u53ef\u80fd\u306ax\u3092\u8fd4\u3059\n    // \u6700\u9069\u6027\u306f\u554f\u308f\u306a\u3044\n    Eigen::VectorXd get_initial_feasible_x(Eigen::VectorXd x)\n    {\n        for(size_t i = 0; i &lt; prob_.max_iter_get_initial_feasible_x; i++)\n        {\n            auto gval = g(x);\n\n            // std::cout &lt;&lt; \"gval:\" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; gval.transpose() &lt;&lt; std::endl;\n\n            size_t max_g_idx = 0;\n            gval.maxCoeff(&amp;max_g_idx);\n\n            // std::cout &lt;&lt; \"max_g_idx: \" &lt;&lt; max_g_idx &lt;&lt; std::endl;\n\n            x -= prob_.alpha * grad_g().row(max_g_idx) * std::abs( (prob_.A.row(max_g_idx) * x - prob_.b.row(max_g_idx))(0) ) / prob_.A.row(max_g_idx).squaredNorm();\n\n            // std::cout &lt;&lt; \"new x:\" &lt;&lt; std::endl;\n            // std::cout &lt;&lt; x.transpose() &lt;&lt; std::endl;\n            if(discrimination_feasiblity(x))\n                break;\n        }\n\n        return x;\n    }\n\n    // x\u304c\u5168\u3066\u306e\u6210\u7d04\u306b\u5bfe\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u304b\u30c1\u30a7\u30c3\u30af\u3059\u308b\n    bool discrimination_feasiblity(const Eigen::VectorXd &amp;x) const\n    {\n        bool is_feasible = true;\n        auto gval = g(x);\n\n        // g(x) &lt;= 0 \u3092\u6e80\u305f\u3055\u306a\u3044\u3082\u306e\u304c\u4e00\u3064\u3067\u3082\u3042\u308c\u3070\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u3044\u308b\n        if((gval.array() &gt; eps_).count() &gt; 0)\n            is_feasible = false;\n        return is_feasible;\n    }\n\n    // x_hat\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd, x\u304c\u5b9f\u884c\u53ef\u80fd\u3060\u3068\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u306ax_hat_dash\u3092\u751f\u6210\u3059\u308b\n    Eigen::VectorXd get_x_hat_dash(Eigen::VectorXd x_hat, Eigen::VectorXd x)\n    {\n        double t = get_t(x_hat, x);\n\n        // std::cout &lt;&lt; \"t = \" &lt;&lt; t &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"x:\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; x.transpose() &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"x_hat:\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; x_hat.transpose() &lt;&lt; std::endl;\n\n        return x + t * (x_hat - x);\n    }\n\n    double get_t(Eigen::VectorXd x_hat, Eigen::VectorXd x)\n    {\n        Eigen::VectorXd gg = prob_.A * (x_hat - x);\n\n        for(Eigen::VectorXd::Index i = 0; i &lt; gg.size(); i++)\n        {\n            if(std::abs(gg(i)) &lt; eps_)\n                gg(i) = eps_;\n        }\n\n        // std::cout &lt;&lt; \"gg:\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; gg.transpose() &lt;&lt; std::endl;\n\n        auto T = -g(x).array() / gg.array();\n        auto T_selected = (T.array() &gt; 0.0); // T_selected\u306f0/1\u306e\u30d0\u30a4\u30ca\u30ea\u578b\n\n        Eigen::VectorXd T_nn(T_selected.count());\n        size_t row = 0;\n        for(Eigen::VectorXd::Index i = 0; i &lt; T.size(); i++)\n        {\n            if(T_selected[i])\n                T_nn(row++) = T(i);\n        }\n\n        // std::cout &lt;&lt; \"-g(x):\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; (-g(x)).transpose() &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"gg:\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; gg.transpose() &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"T:\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; T.transpose() &lt;&lt; std::endl;\n        // std::cout &lt;&lt; \"T_nn:\" &lt;&lt; std::endl;\n        // std::cout &lt;&lt; T_nn.transpose() &lt;&lt; std::endl;\n\n        if(T_selected.count() != 0)\n        {\n            // T_i &gt; 0 \u3092\u6e80\u305f\u3059\u3088\u3046\u305d\u306e\u3046\u3061\u6700\u5c0f\u306eT_i\u3092\u8fd4\u3059\n            return T_nn.minCoeff();\n        }\n\n        return 0.0;\n    }\n\n    Problem prob_;\n    static constexpr double eps_ = 1e-9;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/al__ilqr_8hpp/","title":"include/cpp_robotics/controller/al_ilqr.hpp","text":""},{"location":"doxybook/Files/al__ilqr_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/al__ilqr_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::ALConfig class cpp_robotics::ALiLQR"},{"location":"doxybook/Files/al__ilqr_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/controller/optimal_control_problem.hpp\"\n#include \"cpp_robotics/utility/eigen_utils.hpp\"\n\n// #include &lt;iostream&gt;\n// #define debug(x) std::cout &lt;&lt; \"[\" &lt;&lt;  __func__  &lt;&lt; \"]: \" &lt;&lt; x &lt;&lt; std::endl;\n// #define MAT_SIZE(mat) std::cout &lt;&lt; #mat &lt;&lt; \": \" &lt;&lt; mat.rows() &lt;&lt; \"x\" &lt;&lt; mat.cols() &lt;&lt; std::endl;\n// #define MAT(mat) std::cout &lt;&lt; #mat &lt;&lt; \": \\n\" &lt;&lt; mat &lt;&lt; std::endl;\n\nnamespace cpp_robotics\n{\n\nstruct ALConfig\n{\n    size_t max_iter = 30;\n    size_t max_ilqr_iter = 100;\n\n    // cost torelance\n    double cost_torelance = 1e-4;\n\n    // constraint torelance\n    double constraint_torelance = 1e-2;\n\n    // forward pass line search stopping criteria\n    double beta1 = 1e-4;\n    double beta2 = 10.0;\n\n    // forward pass update rate\n    double alpha_scale = 0.5;\n    size_t max_forward_itr = 10;\n\n    // dual tolerance\n    double dual_torelance = 1e-6;\n\n    // penalty update rate\n    double penalty_initial = 1e-4;\n    double penalty_scale_factor = 10;\n    double penalty_max = 1e8;\n\n    // regularization\n    double reg_initial = 1e-6;\n    double reg_min = 1e-8;\n    double reg_max = 1e8;\n    double reg_scale_factor = 1.6;\n    size_t reg_max_count = 50;\n\n    // finite difference step\n    double eps = 1e-6;\n};\n\nclass ALiLQR\n{\npublic:\n    enum class Result\n    {\n        SUCCESS = 0,\n\n        // failed\n        MAX_INNER_ITER_REACHED,\n        MAX_ITER_REACHED,\n        MAX_PENALTY_EXCEEDED,\n        FAILED\n    };\n\n    ALiLQR(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost, const OCPConstraintArray &amp;constraints = OCPConstraintArray(), ALConfig config = ALConfig()):\n        ALiLQR(OptimalControlProblem(dynamics, cost, constraints), config) {}\n\n    ALiLQR(const OptimalControlProblem &amp;prob, ALConfig config = ALConfig()):\n        prob_(prob), config_(config)\n    {\n        // setup workspace\n        U.resize(prob_.horizon());\n        tmpU.resize(prob_.horizon());\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            U[i].setZero(prob_.input_size());\n            tmpU[i].setZero(prob_.input_size());\n        }\n        X.resize(prob_.horizon() + 1);\n        tmpX.resize(prob_.horizon() + 1);\n        for(size_t i = 0; i &lt; prob_.horizon() + 1; i++)\n        {\n            X[i].setZero(prob_.state_size());\n            tmpX[i].setZero(prob_.state_size());\n        }\n        K.resize(prob_.horizon());\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            K[i].setZero(prob_.input_size(), prob_.state_size());\n        }\n        d.resize(prob_.horizon());\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            d[i].setZero(prob_.input_size());\n        }\n\n        lambdas.resize(prob_.horizon()+1);\n        for(size_t i = 0; i &lt; prob_.horizon()+1; i++)\n        {\n            lambdas[i].setZero(prob_.constraints.size());\n        }\n\n        penaltys.resize(prob_.horizon()+1);\n        for(size_t i = 0; i &lt; prob_.horizon()+1; i++)\n        {\n            penaltys[i].setZero(prob_.constraints.size());\n        }\n\n        constraints_val.resize(prob_.horizon()+1);\n        for(size_t i = 0; i &lt; prob_.horizon()+1; i++)\n        {\n            constraints_val[i].setZero(prob_.constraints.size());\n        }\n\n        fx.setZero(prob_.state_size(), prob_.state_size());\n        fu.setZero(prob_.state_size(), prob_.input_size());\n    }\n\n    Result generate_trajectory(const Eigen::VectorXd &amp;x0)\n    {\n        // slide ws data\n        for(size_t i = 0; i &lt; prob_.horizon()-1; i++)\n        {\n            U[i] = U[i + 1];\n        }\n\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            X[i] = X[i + 1];\n        }\n\n        for(size_t i = 0; i &lt; prob_.horizon()-1; i++)\n        {\n            lambdas[i] = lambdas[i + 1];\n        }\n\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            penaltys[i].setConstant(config_.penalty_initial);\n        }\n\n        // simple iLQR\n        if(not has_constraints())\n        {\n            return ilqr(x0);\n        }\n\n        for(size_t i = 0; i &lt; config_.max_iter; i++)\n        {\n            auto ret = ilqr(x0);\n\n            if(ret == Result::FAILED)\n            {\n                // debug(\"sub iLQR failed\");\n                return ret;\n            }\n\n            update_duals();\n            double u_max = update_penalties();\n\n            if(c_max &lt; config_.constraint_torelance)\n            {\n                // debug(\"constraint torelance reached: \" &lt;&lt; c_max);\n                return Result::SUCCESS;\n            }\n\n            if(u_max &gt;= config_.penalty_max)\n            {\n                // debug(\"max penalty exceeded\");\n                return Result::MAX_PENALTY_EXCEEDED;\n            }\n        }\n\n        // debug(\"max iter reached\");\n        return Result::MAX_ITER_REACHED;\n    }\n\n    const std::vector&lt;Eigen::VectorXd&gt; &amp;get_input() const { return U; }\n    const std::vector&lt;Eigen::VectorXd&gt; &amp;get_state() const { return X; }\n\nprivate:\n    bool has_constraints() const\n    {\n        if (prob_.constraints.size())\n            return true;\n        return false;\n    }\n\n    Result ilqr(const Eigen::VectorXd &amp;x0)\n    {\n        rho = config_.reg_initial;\n        drho = 0.0;\n\n        rollout_trajectory(x0);\n\n        double J = total_cost(X, U);\n        for(size_t itr = 0; itr &lt; config_.max_ilqr_iter; ++itr)\n        {\n            bool backward_done = backward_pass();\n            if(not backward_done)\n            {\n                // debug(\"backward pass failed\");\n                return Result::FAILED;\n            }\n\n            double new_J = forward_pass(x0, J);\n\n            // torelance check\n            if(std::abs(new_J - J) &lt; config_.cost_torelance)\n            {\n                return Result::SUCCESS;\n            }\n            J = new_J;\n        }\n\n        // debug(\"max inner iter reached\");\n        return Result::MAX_INNER_ITER_REACHED;\n    }\n\n    void update_duals()\n    {\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            auto &amp;constraints = prob_.constraints;\n            for(size_t j = 0; j &lt; constraints.size(); j++)\n            {\n                double new_lambda = lambdas[i](j) + penaltys[i](j) * constraints_val[i](j);\n                if(constraints[j]-&gt;type == OCPConstraintType::Ineq)\n                {\n                    lambdas[i](j) = std::max(new_lambda, 0.0);\n                }\n                else\n                {\n                    lambdas[i](j) = new_lambda;\n                }\n            }\n        }\n    }\n\n    double update_penalties()\n    {\n        double max_penalty = 0.0;\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            for(size_t j = 0; j &lt; prob_.constraints.size(); j++)\n            {\n                penaltys[i](j) *= config_.penalty_scale_factor;\n                max_penalty = std::max(max_penalty, penaltys[i](j));\n            }\n        }\n\n        return max_penalty;\n    }\n\n    void increase_regularization()\n    {\n        drho = std::max(drho*config_.reg_scale_factor, config_.reg_scale_factor);\n        rho = std::max(config_.reg_min, rho*drho);\n        rho = std::min(config_.reg_max, rho);\n    }\n\n    void decrease_regularization()\n    {\n        drho = std::min(drho/config_.reg_scale_factor, 1.0/config_.reg_scale_factor);\n        rho = std::max(config_.reg_min, rho*drho);\n    }\n\n    void rollout_trajectory(const Eigen::VectorXd &amp;x0)\n    {\n        X[0] = x0;\n        for (size_t i = 0; i &lt; prob_.horizon(); ++i)\n        {\n            X[i + 1] = prob_.dynamics-&gt;eval(X[i], U[i]);\n        }\n    }\n\n    double total_cost(std::vector&lt;Eigen::VectorXd&gt; &amp;X, std::vector&lt;Eigen::VectorXd&gt; &amp;U)\n    {\n        double J = 0.0;\n        for (size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            J += prob_.cost-&gt;eval(X[i], U[i], i) + arglag_cost(X[i], U[i], i);\n        }\n        // Todo: add terminal arglag term\n        J += prob_.cost-&gt;eval_terminal(X[prob_.horizon()]);\n        return J;\n    }\n\n    double arglag_cost(const Eigen::VectorXd &amp;X, const Eigen::VectorXd &amp;U, size_t i)\n    {\n        if(not has_constraints())\n        {\n            return 0.0;\n        }\n        auto &amp;constraints = prob_.constraints;\n        Eigen::VectorXd tmp_constraint_val = constraints.eval_all_vec(X, U);\n        Eigen::VectorXd Ivec(constraints.size());\n        double c_max_dummy;\n        Iuvec(tmp_constraint_val, i, Ivec, c_max_dummy);\n        double cost = ((lambdas[i].transpose() + 0.5*tmp_constraint_val.transpose()*Ivec.asDiagonal()) * tmp_constraint_val)[0];\n        return cost;\n    }\n\n    void Iuvec(const Eigen::VectorXd &amp;constraint_val, size_t i, Eigen::VectorXd &amp;Iuvec, double &amp;c_max)\n    {\n        auto &amp;constraints = prob_.constraints;\n        for(size_t j = 0; j &lt; constraints.size(); j++)\n        {\n            if(constraints[j]-&gt;type == OCPConstraintType::Ineq)\n            {\n                if(constraint_val(j) &lt; 0.0 &amp;&amp; std::abs(lambdas[i][j]) &lt; config_.dual_torelance)\n                {\n                    Iuvec[j] = 0.0;\n                }\n                else\n                {\n                    Iuvec[j] = penaltys[i][j];\n                    c_max = std::max(c_max, constraint_val(j));\n                }\n            }\n            else\n            {\n                Iuvec[j] = penaltys[i][j];\n                c_max = std::max(c_max, std::abs(constraint_val(j)));\n            }\n        }\n    }\n\n    bool backward_pass()\n    {\n        auto &amp;constraints = prob_.constraints;\n        Eigen::VectorXd Ivec(constraints.size());\n\n        // Todo: add terminal constraints term\n        Vx = prob_.cost-&gt;jacobian_x_terminal(X.back());\n        Vxx = prob_.cost-&gt;hessian_xx_terminal(X.back());\n\n        size_t rho_increase_count = 0;\n        c_max = 0.0;\n        dV1 = 0.0;\n        dV2 = 0.0;\n        Eigen::MatrixXd Quu_reg;\n        Eigen::MatrixXd Quu_inv;\n        Eigen::MatrixXd cx(constraints.size(),  prob_.state_size());\n        Eigen::MatrixXd cu(constraints.size(),  prob_.input_size());\n        for(int i = static_cast&lt;int&gt;(prob_.horizon()) - 1; i &gt;= 0;)\n        {\n            fx = prob_.dynamics-&gt;jacobian_x(X[i], U[i]);\n            fu = prob_.dynamics-&gt;jacobian_u(X[i], U[i]);\n\n            // argumented lagrangian\n            if(has_constraints())\n            {\n                constraints_val[i] = constraints.eval_all_vec(X[i], U[i]);\n                for(size_t j = 0; j &lt; constraints.size(); j++)\n                {\n                    cx.row(j) = constraints[j]-&gt;grad_x(X[i], U[i]);\n                }\n\n                for(size_t j = 0; j &lt; constraints.size(); j++)\n                {\n                    cu.row(j) = constraints[j]-&gt;grad_u(X[i], U[i]);\n                }\n\n                Iuvec(constraints_val[i], i, Ivec, c_max);\n                Qx  = prob_.cost-&gt;jacobian_x(X[i], U[i], i) + fx.transpose() * Vx + cx.transpose() * (lambdas[i] + Ivec.asDiagonal() * constraints_val[i]);\n                Qu  = prob_.cost-&gt;jacobian_u(X[i], U[i], i) + fu.transpose() * Vx + cu.transpose() * (lambdas[i] + Ivec.asDiagonal() * constraints_val[i]);\n                Qxx = prob_.cost-&gt;hessian_xx(X[i], U[i], i) + fx.transpose() * Vxx * fx + cx.transpose() * Ivec.asDiagonal() * cx;\n                Quu = prob_.cost-&gt;hessian_uu(X[i], U[i], i) + fu.transpose() * Vxx * fu + cu.transpose() * Ivec.asDiagonal() * cu;\n                Qux = prob_.cost-&gt;hessian_ux(X[i], U[i], i) + fu.transpose() * Vxx * fx + cu.transpose() * Ivec.asDiagonal() * cx;\n            }\n            else\n            {\n                Qx  = prob_.cost-&gt;jacobian_x(X[i], U[i], i) + fx.transpose() * Vx;\n                Qu  = prob_.cost-&gt;jacobian_u(X[i], U[i], i) + fu.transpose() * Vx;\n                Qxx = prob_.cost-&gt;hessian_xx(X[i], U[i], i) + fx.transpose() * Vxx * fx;\n                Quu = prob_.cost-&gt;hessian_uu(X[i], U[i], i) + fu.transpose() * Vxx * fu;\n                Qux = prob_.cost-&gt;hessian_ux(X[i], U[i], i) + fu.transpose() * Vxx * fx;\n            }\n\n            // Quu_reg = Quu + rho * I;\n            // Quu_inv = Quu_reg.inverse();\n            // K[i] = -Quu_inv * Qux;\n            // d[i] = -Quu_inv * Qu;\n            Quu_reg = Quu;\n            for(int j = 0; j &lt; Quu.rows(); j++)\n            {\n                Quu_reg(j, j) += rho;\n            }\n            Eigen::LLT&lt;Eigen::MatrixXd&gt; Quu_chol(Quu_reg);\n            if(Quu_chol.info() == Eigen::Success)\n            {\n                // du = K*dx + d\n                K[i] = -Quu_chol.solve(Qux);\n                d[i] = -Quu_chol.solve(Qu);\n            }\n            else\n            {\n                // debug(\"Quu is not positive definite\");\n                increase_regularization();\n                rho_increase_count++;\n\n                if(rho_increase_count &gt; config_.reg_max_count)\n                {\n                    // debug(\"rho increase count exceeded\");\n                    return false;\n                }\n                continue;\n            }\n\n            // update Vx, Vxx\n            Vxx = Qxx + (K[i].transpose()*Quu*K[i]) + K[i].transpose()*Qux + Qux.transpose()*K[i];\n            Vx = Qx + K[i].transpose()*Quu*d[i] + K[i].transpose()*Qu + Qux.transpose()*d[i];\n\n            // calclate dV1, dV2\n            dV1 += (d[i].transpose()*Qu)[0];\n            dV2 += (0.5*d[i].transpose()*Quu*d[i])[0];\n\n            // next for loop\n            i--;\n        }\n\n        // debug(\"decrease regularization\");\n        decrease_regularization();\n\n        return true;\n    }\n\n    double forward_pass(const Eigen::VectorXd &amp;x0, const double J)\n    {\n        double alpha = 1.0;\n\n        tmpX[0] = x0;\n        for(size_t j = 0; j &lt; config_.max_forward_itr; j++)\n        {\n            for(size_t i = 0; i &lt; prob_.horizon(); i++)\n            {\n                tmpU[i] = U[i] + K[i]*(tmpX[i]-X[i]) + alpha * d[i];\n                tmpX[i + 1] = prob_.dynamics-&gt;eval(tmpX[i], tmpU[i]);\n            }\n\n            double new_J = total_cost(tmpX, tmpU);\n            double dV1_ = alpha * dV1;\n            double dV2_ = alpha*alpha * dV2;\n            double z = (new_J - J) / (dV1_ + dV2_);\n            // line search\n            if (config_.beta1 &lt;= z &amp;&amp; z &lt;= config_.beta2)\n            {\n                U = tmpU;\n                X = tmpX;\n                return new_J; // update\n            }\n            alpha *= config_.alpha_scale;\n        }\n        return J; // already optimal\n    }\n\n    const OptimalControlProblem prob_;\n    ALConfig config_;\n\n    // workspace\n    std::vector&lt;Eigen::VectorXd&gt; U, X, tmpU, tmpX;\n    std::vector&lt;Eigen::MatrixXd&gt; K;\n    std::vector&lt;Eigen::VectorXd&gt; d;\n    Eigen::VectorXd Vx;\n    Eigen::MatrixXd Vxx;\n    Eigen::MatrixXd Qx, Qu, Qxx, Quu, Qux, Quxu;\n    Eigen::MatrixXd fx, fu;\n    double dV1, dV2;\n\n    std::vector&lt;Eigen::VectorXd&gt; constraints_val;\n    std::vector&lt;Eigen::VectorXd&gt; lambdas, penaltys;\n    double rho;\n    double drho;\n    double c_max;\n};\n\n// class ALTRO : private detail::ALiLQR&lt;DiscreteNonlinearOCP&gt;\n// {\n//     using ALiLQR = detail::ALiLQR&lt;DiscreteNonlinearOCP&gt;;\n// public:\n//     using ALTROResult = detail::Result;\n//     using Config = ALiLQR::Config;\n\n//     ALTRO(const DiscreteNonlinearOCP &amp;model):\n//         ALiLQR(model)\n//     {\n\n//     }\n\n//     ALTROResult generate_trajectory(const Eigen::VectorXd &amp;x0)\n//     {\n//         // if infeasible\n\n//         auto ret = ALiLQR::generate_trajectory(x0);\n\n//         projection();\n\n//         return ALTROResult::SUCCESS;\n//     }\n\n//     using ALiLQR::get_input;\n//     using ALiLQR::get_state;\n\n// private:\n//     void projection()\n//     {\n\n//     }\n\n//     void line_search()\n//     {\n\n//     }\n\n// };\n\n\n} // namespace cpp_robotics\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/angle__range_8hpp/","title":"include/cpp_robotics/utility/angle_range.hpp","text":""},{"location":"doxybook/Files/angle__range_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/angle__range_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b"},{"location":"doxybook/Files/angle__range_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\nclass AngleRange\n{\npublic:\n    using range_pair_t = std::pair&lt;double, double&gt;;\n    constexpr static double PI = M_PI;\n    AngleRange() = default;\n\n    void add_range(const AngleRange &amp;range)\n    {\n        for(auto r : range.ranges_)\n        {\n            add_range(r.first, r.second);\n        }\n    }\n    void add_range(double start, double end)\n    {\n        if(start == end)\n            return;\n\n        // \u4e00\u822c\u89d2\u306b\u5206\u5272\u3057\u3066\u633f\u5165\u3059\u308b\n        if(start &gt; end)\n            std::swap(start, end);\n\n        double diff = end - start;\n        start = normalize_angle_positive(start);\n        end = start + diff;\n\n        if(diff &gt; 2*PI)\n        {\n            // \u4e00\u5468\u56de\u3063\u3066\u308b\n            ranges_.push_back({0, 2*PI});\n        }\n        else\n        {\n            if(end &gt; 2*PI)\n            {\n                ranges_.push_back({start, 2*PI});\n                ranges_.push_back({0, end - 2*PI});\n            }\n            else\n            {\n                ranges_.push_back({start, end});\n            }\n        }\n\n        // ranges_\u306e\u7d50\u5408\u30fb\u5206\u5272\n        join_start:\n        for(size_t look = 0; look &lt; ranges_.size(); look++)\n        {\n            for(size_t dest = 0; dest &lt; ranges_.size(); dest++)\n            {\n                if(look != dest)\n                {\n                    // \u7bc4\u56f2\u304c\u304b\u3076\u3063\u3066\u305f\u3089\u7d50\u5408\u3059\u308b\n                    if(in_range_part(ranges_[look], ranges_[dest].first))\n                    {\n                        if(ranges_[look].second &lt; ranges_[dest].second)\n                            ranges_[look].second = ranges_[dest].second;\n                        ranges_.erase(ranges_.begin()+dest);\n                        goto join_start;\n                    }\n                    if(in_range_part(ranges_[look], ranges_[dest].second))\n                    {\n                        if(ranges_[look].first &gt; ranges_[dest].first)\n                            ranges_[look].first = ranges_[dest].first;\n                        ranges_.erase(ranges_.begin()+dest);\n                        goto join_start;\n                    }\n                }\n            }\n        }\n\n        std::sort(ranges_.begin(), ranges_.end(), [](auto a, auto b){ return a.first &lt; b.first; });\n    }\n\n    size_t size() const { return ranges_.size(); }\n\n    AngleRange invert() const\n    {\n        AngleRange ret;\n\n        if(size() == 0)\n        {\n            ret.add_range(0.0, 2*PI);\n            return ret;\n        }\n\n        for(size_t i = 0; i &lt; size()-1; i++)\n        {\n            ret.add_range(ranges_[i].second, ranges_[i+1].first);\n        }\n        ret.add_range(ranges_.back().second, ranges_.front().first + 2*PI);\n\n        return ret;\n    }\n\n    // \u5f15\u6570\u306e\u89d2\u5ea6\u306b\u5bfe\u3057\u7bc4\u56f2\u306e\u4e2d\u3067\u4e00\u756a\u8fd1\u3044\u89d2\u5ea6\u3092\u8a08\u7b97\u3059\u308b\n    double most_near_by(double angle)\n    {\n        angle = normalize_angle_positive(angle);\n        if(in_range(angle))\n            return angle;\n\n        auto inv_ranges = this-&gt;invert().ranges_;\n        // 2pi\u3092\u307e\u305f\u3050\u5834\u5408\u306f\u9023\u7d50\u3055\u305b\u308b\n        if(inv_ranges.front().first == 0.0 &amp;&amp; inv_ranges.back().second == 2*PI)\n        {\n            range_pair_t new_back = \n            {\n                inv_ranges.back().first,\n                2*PI + inv_ranges.front().second\n            };\n            inv_ranges.erase(inv_ranges.begin());\n            inv_ranges.back() = new_back;\n            if(angle &lt; inv_ranges.front().first)\n                angle += 2*PI;\n        }\n\n        for(auto &amp; ir : inv_ranges)\n        {\n            if(in_range_part(ir, angle))\n            {\n                if(std::abs(shortest_angular_distance(angle, ir.first)) &lt; std::abs(shortest_angular_distance(angle, ir.second)))\n                {\n                    return normalize_angle_positive(ir.first);\n                }\n                else\n                {\n                    return normalize_angle_positive(ir.second);\n                }\n            }\n        }\n\n        // error\n        return normalize_angle_positive(angle);\n    }\n\n    inline bool in_range_part(range_pair_t &amp;range, double angle)\n    {\n        if(range.first &lt;= angle &amp;&amp; angle &lt;= range.second)\n            return true;\n        return false;\n    }\n\n    bool in_range(double angle)\n    {\n        angle = normalize_angle_positive(angle);\n        for(auto range : ranges_)\n        {\n            if(in_range_part(range, angle))\n                return true;\n        }\n        return false;\n    }\n\n    std::vector&lt;range_pair_t&gt; ranges() const { return ranges_; }\n\nprivate:\n    double normalize_angle_positive(double angle)\n    {\n        return std::fmod(std::fmod(angle, 2*PI) + 2*PI, 2*PI);\n    }\n\n    double normalize_angle(double angle)\n    {\n        double a = normalize_angle_positive(angle);\n        if (a &gt; PI)\n            a -= 2*PI;\n        return a;\n    }\n\n    double shortest_angular_distance(double from, double to)\n    {\n        return normalize_angle(to-from);\n    }\n\n    void debug()\n    {\n        printf(\"debug\\n\");\n        for(auto range : ranges_)\n        {\n            printf(\"(%8.2f, %8.2f)\\n\", range.first, range.second);\n        }\n        printf(\"\\n\");\n    }\nprivate:\n    std::vector&lt;range_pair_t&gt; ranges_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/arm__kinematics_8hpp/","title":"include/cpp_robotics/arm_kinematics/arm_kinematics.hpp","text":""},{"location":"doxybook/Files/arm__kinematics_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::internal"},{"location":"doxybook/Files/arm__kinematics_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::internal::has_forward_kinematics struct cpp_robotics::internal::has_inverse_kinematics struct cpp_robotics::internal::has_forward_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().forward_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt; struct cpp_robotics::internal::has_inverse_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().inverse_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt; class cpp_robotics::ArmKinematics class cpp_robotics::ArmForwardKinematics class cpp_robotics::ArmInverseKinematics"},{"location":"doxybook/Files/arm__kinematics_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/optimize/derivative.hpp\"\n#include \"cpp_robotics/optimize/quasi_newton_method.hpp\"\n#include \"cpp_robotics/optimize/steepest_descent_method.hpp\"\n#include \"cpp_robotics/algorithm/auto_diff.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace internal\n{\n\ntemplate&lt;typename T, typename = void&gt;\nstruct has_forward_kinematics : std::false_type {};\n\ntemplate&lt;typename T, typename = void&gt;\nstruct has_inverse_kinematics : std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct has_forward_kinematics&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().forward_kinematics(std::declval&lt;Eigen::VectorXd&gt;(), std::declval&lt;Eigen::VectorXd&amp;&gt;()))&gt;&gt; : std::true_type {};\n\ntemplate&lt;typename T&gt;\nstruct has_inverse_kinematics&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().inverse_kinematics(std::declval&lt;Eigen::VectorXd&gt;(), std::declval&lt;Eigen::VectorXd&amp;&gt;()))&gt;&gt; : std::true_type {};\n\n}\n\ntemplate&lt;class Derived&gt;\nclass ArmKinematics\n{\npublic:\n    ArmKinematics(size_t nq, size_t nx):\n        nq_(nq), nx_(nx), adq_(nq), adx_(nx)\n    {\n        static_assert(internal::has_forward_kinematics&lt;Derived&gt;::value, \"Derived class must have forward_kinematics method\");\n        static_assert(internal::has_inverse_kinematics&lt;Derived&gt;::value, \"Derived class must have inverse_kinematics method\");\n    }\n\n    Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles)\n    {\n        return static_cast&lt;Derived*&gt;(this)-&gt;forward_kinematics(joint_angles);\n    }\n\n    Eigen::VectorXd solve_ik(Eigen::VectorXd pos, Eigen::VectorXd joint_angles0)\n    {\n        return static_cast&lt;Derived*&gt;(this)-&gt;inverse_kinematics(pos, joint_angles0);\n    }\n\n    Eigen::MatrixXd jacobian(Eigen::VectorXd joint_angles)\n    {\n        adq_ = joint_angles;\n        static_cast&lt;Derived*&gt;(this)-&gt;forward_kinematics(adq_, adx_);\n        Eigen::MatrixXd J(nx_, nq_);\n        for(size_t i = 0; i &lt; nq_; ++i)\n        {\n            J.col(i) = adx_[i].derivatives();\n        }\n        return J;\n    }\n\nprivate:\n    size_t nq_;\n    size_t nx_;\n    ADVectorXd adq_, adx_;\n};\n\ntemplate&lt;class Derived&gt;\nclass ArmForwardKinematics\n{\npublic:\n    ArmForwardKinematics(size_t nq, size_t nx):\n        nq_(nq), nx_(nx), adq_(nq), adx_(nx) {}\n\n    Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles)\n    {\n        Eigen::VectorXd x(nx_);\n        static_cast&lt;Derived*&gt;(this)-&gt;forward_kinematics(joint_angles, x);\n        return x;\n    }\n\n    Eigen::VectorXd solve_ik(Eigen::VectorXd pos, Eigen::VectorXd joint_angles0)\n    {\n        if(joint_angles0.size() == 0)\n            joint_angles0 = Eigen::VectorXd::Zero(nq_);\n\n        auto eval_func = [&amp;](Eigen::VectorXd q)\n        {\n            return (solve_fk(q) - pos).squaredNorm();\n        };\n\n        auto jacobian_func = [&amp;](Eigen::VectorXd q)\n        {\n            return derivative(eval_func, q);\n        };\n\n        auto [ret, rx, rcnt] = quasi_newton_method(eval_func, jacobian_func, joint_angles0);\n        return rx;\n    }\n\n    Eigen::VectorXd solve_ik(Eigen::VectorXd pos)\n    {\n        return solve_ik(pos, Eigen::VectorXd::Zero(nq_));\n    }\n\n    Eigen::MatrixXd jacobian(Eigen::VectorXd joint_angles)\n    {\n        adq_ = joint_angles;\n        static_cast&lt;Derived*&gt;(this)-&gt;forward_kinematics(adq_, adx_);\n        Eigen::MatrixXd J(nx_, nq_);\n        for(size_t i = 0; i &lt; nq_; ++i)\n        {\n            J.col(i) = adx_[i].derivatives();\n        }\n        return J;\n    }\n\nprivate:\n    size_t nq_;\n    size_t nx_;\n    ADVectorXd adq_, adx_;\n};\n\ntemplate&lt;class Derived&gt;\nclass ArmInverseKinematics\n{\npublic:\n    ArmInverseKinematics(size_t nq, size_t nx):\n        nq_(nq), nx_(nx), adq_(nq), adx_(nx) \n    {\n        static_assert(internal::has_inverse_kinematics&lt;Derived&gt;::value, \"Derived class must have inverse_kinematics method\");\n    }\n\n    Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles, Eigen::VectorXd pos0)\n    {\n        auto eval_func = [&amp;](Eigen::VectorXd x)\n        {\n            return (solve_ik(x) - joint_angles).squaredNorm();\n        };\n\n        auto jacobian_func = [&amp;](Eigen::VectorXd x)\n        {\n            return derivative(eval_func, x);\n        };\n\n        auto [ret, rx, rcnt] = quasi_newton_method(eval_func, jacobian_func, pos0);\n        return rx;\n    }\n\n    Eigen::VectorXd solve_fk(Eigen::VectorXd joint_angles)\n    {\n        return solve_fk(joint_angles, Eigen::VectorXd::Zero(nx_));\n    }\n\n    Eigen::VectorXd solve_ik(Eigen::VectorXd pos)\n    {\n        Eigen::VectorXd q(nq_);\n        static_cast&lt;Derived*&gt;(this)-&gt;inverse_kinematics(pos, q);\n        return q;\n    }\n\n    Eigen::MatrixXd jacobian(Eigen::VectorXd joint_angles)\n    {\n        adq_ = joint_angles;\n        static_cast&lt;Derived*&gt;(this)-&gt;forward_kinematics(adq_, adx_);\n        Eigen::MatrixXd J(nx_, nq_);\n        for(size_t i = 0; i &lt; nq_; ++i)\n        {\n            J.col(i) = adx_[i].derivatives();\n        }\n        return J;\n    }\n\nprivate:\n    size_t nq_;\n    size_t nx_;\n    ADVectorXd adq_, adx_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/auto__diff_8hpp/","title":"include/cpp_robotics/algorithm/auto_diff.hpp","text":""},{"location":"doxybook/Files/auto__diff_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/auto__diff_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::ADVector"},{"location":"doxybook/Files/auto__diff_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;unsupported/Eigen/AutoDiff&gt;\n#include &lt;functional&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class DerType = Eigen::VectorXd&gt;\nusing ADScalar = Eigen::AutoDiffScalar&lt;DerType&gt;;\n\ntemplate&lt;class DerType, int NX&gt;\nclass ADVector : public Eigen::Matrix&lt;ADScalar&lt;DerType&gt;, NX, 1&gt;\n{\npublic:\n    using Scalar = ADScalar&lt;DerType&gt;;\n    using RealVector = Eigen::Matrix&lt;double, NX, 1&gt;;\n\n    ADVector(const size_t dim): \n        Eigen::Matrix&lt;ADScalar&lt;DerType&gt;, NX, 1&gt;(dim) \n    {\n        for(size_t i = 0; i &lt; dim; i++)\n        {\n            this-&gt;operator()(i).value() = 0;\n            this-&gt;operator()(i).derivatives() = Eigen::VectorXd::Unit(dim, i);\n        }\n    }\n\n    ADVector(const DerType &amp;x)\n    {\n        Eigen::Matrix&lt;ADScalar&lt;DerType&gt;, NX, 1&gt;::resize(x.size());\n        for(int i = 0; i &lt; x.size(); i++)\n        {\n            this-&gt;operator()(i).value() = x(i);\n            this-&gt;operator()(i).derivatives() = Eigen::VectorXd::Unit(x.size(), i);\n        }\n    }\n\n    ADVector(const size_t dim, const size_t all_dim, const size_t start)\n    {\n        Eigen::Matrix&lt;ADScalar&lt;DerType&gt;, NX, 1&gt;::resize(dim);\n        for(size_t i = 0; i &lt; dim; i++)\n        {\n            this-&gt;operator()(i).value() = 0;\n            this-&gt;operator()(i).derivatives() = Eigen::VectorXd::Unit(all_dim, start + i);\n        }\n    }\n\n    ADVector(const size_t dim, const size_t all_dim, const size_t start, const DerType &amp;x)\n    {   \n        assert(static_cast&lt;long int&gt;(dim) == x.size());\n        Eigen::Matrix&lt;ADScalar&lt;DerType&gt;, NX, 1&gt;::resize(dim);\n        for(size_t i = 0; i &lt; dim; i++)\n        {\n            this-&gt;operator()(i).value() = x(i);\n            this-&gt;operator()(i).derivatives() = Eigen::VectorXd::Unit(all_dim, start + i);\n        }\n    }\n\n    ADVector&amp; operator=(const RealVector &amp;x)\n    {\n        assert(static_cast&lt;long int&gt;(this-&gt;size()) == x.size());\n        for(int i = 0; i &lt; x.size(); i++)\n        {\n            this-&gt;operator()(i).value() = x(i);\n        }\n        return *this;\n    }\n\n    RealVector real_cast() const\n    {\n        RealVector result(this-&gt;size());\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            result(i) = this-&gt;operator()(i).value();\n        }\n        return result;\n    }\n\n    ADVector operator+(const ADVector&amp; other) const\n    {\n        assert(this-&gt;size() == other.size());\n        ADVector result = *this;\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            result(i) += other(i);\n        }\n        return result;\n    }\n\n    ADVector operator-(const ADVector&amp; other) const\n    {\n        assert(this-&gt;size() == other.size()); \n        ADVector result = *this;\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            result(i) -= other(i);\n        }\n        return result;\n    }\n\n    void operator +=(const ADVector&amp; other)\n    {\n        assert(this-&gt;size() == other.size());\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            this-&gt;operator()(i) += other(i);\n        }\n    }\n\n    void operator -=(const ADVector&amp; other)\n    {\n        assert(this-&gt;size() == other.size());\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            this-&gt;operator()(i) -= other(i);\n        }\n    }\n\n    template&lt;class SScalar&gt;\n    ADVector operator*(const SScalar&amp; scalar) const\n    {\n        ADVector result = *this;\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            result(i) *= scalar;\n        }\n        return result;\n    }\n\n    template&lt;class SScalar&gt;\n    friend ADVector operator*(const SScalar&amp; scalar, const ADVector&amp; vec)\n    {\n        return vec * scalar;\n    }\n\n    template&lt;class SScalar&gt;\n    void operator *=(const SScalar&amp; scalar)\n    {\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            this-&gt;operator()(i) *= scalar;\n        }\n    }\n\n    template&lt;class SScalar&gt;\n    ADVector operator/(const SScalar&amp; scalar) const\n    {\n        ADVector result = *this;\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            result(i) /= scalar;\n        }\n        return result;\n    }\n\n    template&lt;class SScalar&gt;\n    void operator /=(const SScalar&amp; scalar)\n    {\n        for(int i = 0; i &lt; this-&gt;size(); ++i)\n        {\n            this-&gt;operator()(i) /= scalar;\n        }\n    }\n};\n\nusing ADVectorXd = ADVector&lt;Eigen::VectorXd, Eigen::Dynamic&gt;;\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/band__pass__filter_8hpp/","title":"include/cpp_robotics/filter/band_pass_filter.hpp","text":""},{"location":"doxybook/Files/band__pass__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/band__pass__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/band__pass__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n//               2*zeta*omega*s\n// G(s) = ------------------------------ \u3092\u53cc\u4e00\u6b21\u5909\u63db\n//         s^2 + 2*zeta*omega*s + omega^2\nclass BandPassFilter : public TransferFunction\n{\npublic:\n    BandPassFilter(double omega, double zeta, double dt):\n        omega_(omega), zeta_(zeta)\n    {\n        TransferFunction::set_continuous({(2*zeta_*omega_),0}, {1,(2*zeta_*omega_),(omega*omega)}, dt);\n    }\n\n    double filtering(double u) { return responce(u); } \n\n    double omega() const { return omega_; }\n\n    double zeta() const { return zeta_; }\nprivate:\n    const double omega_;\n    const double zeta_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/barrier__method_8hpp/","title":"include/cpp_robotics/optimize/barrier_method.hpp","text":""},{"location":"doxybook/Files/barrier__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/barrier__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"constraint.hpp\"\n#include \"derivative.hpp\"\n#include \"quasi_newton_method.hpp\"\n\nnamespace cpp_robotics\n{\n\n// \u5236\u7d04\u306e\u5883\u754c\u3067\u76ee\u7684\u95a2\u6570\u304c\u767a\u6563\u3059\u308b\u305f\u3081\u7b49\u5f0f\u5236\u7d04\u306f\u4f7f\u7528\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044\n// \u307e\u305f\u4e0d\u7b49\u5f0f\u5236\u7d04\u3067\u3082g(x)=0\u306e\u5883\u754c\u3092\u307e\u305f\u3050\u3053\u3068\u306f\u51fa\u6765\u306a\u3044\u306e\u3067x_init\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5185\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; barrier_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init = 10.0, const double tol = 1e-3, const size_t max_iter = 1000)\n{\n    Eigen::VectorXd x = x_init;\n    double r = r_init;\n    std::function&lt;double(const Eigen::VectorXd &amp;)&gt; ext_f = \n    [&amp;](const Eigen::VectorXd &amp; x)\n    {\n        double y = f(x);\n\n        for(auto &amp; con : constraint)\n        {\n            switch(con.type)\n            {\n                case Constraint::Type::Eq:\n                    // \u7121\u8996\n                    break;\n                case Constraint::Type::Ineq:\n                    y += r * std::log(std::abs(con.con_f(x))); // / std::pow(, 2);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        return y;\n    };\n\n    auto grad = [&amp;](Eigen::VectorXd x)\n    {\n        return derivative(ext_f, x);\n    };\n\n    for(size_t i = 0; i &lt; max_iter; i++)\n    {\n        auto [step_result, new_x, sub_itr_cnt] = quasi_newton_method(ext_f, grad, x, tol, 1);\n        if(std::abs(r * constraint.eval_sum(new_x)) &lt; tol)\n            return {true, new_x, i};\n\n        x = new_x;\n        r *= 1.5;\n    }\n    return {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/bfgs_8hpp/","title":"include/cpp_robotics/optimize/bfgs.hpp","text":""},{"location":"doxybook/Files/bfgs_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/bfgs_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic void bfgs_step(Eigen::MatrixXd &amp;hess, Eigen::VectorXd s, Eigen::VectorXd y)\n{\n    double sy, sBs;\n    Eigen::VectorXd Bs;\n\n    Bs.noalias() = hess * s;\n    sBs = s.dot(Bs);\n    sy = s.dot(y);\n\n    hess += -( Bs * Bs.transpose() )/sBs + ( y*y.transpose() )/( sy );\n}\n\nstatic void powells_modified_bfgs_step(Eigen::MatrixXd &amp;hess, Eigen::VectorXd s, Eigen::VectorXd y, Eigen::VectorXd dgg, double gamma = 0.2)\n{\n    // y_tilde\n    if(s.transpose()*y &lt; gamma * s.transpose()*hess*s)\n    {\n        double sy, sBs;\n        Eigen::VectorXd Bs;\n\n        Bs.noalias() = hess * s;\n        sBs = s.dot(Bs);\n        sy = s.dot(y);\n\n        double beta = (1-gamma)*sBs / ( sBs - sy );\n        y = beta*y + (1-beta)*hess*s;\n    }\n\n    // 0 &lt; sy\u306b\u306a\u308b\u307e\u3067y\u3092\u4fee\u6b63\n    const double lnrm = 1e-12;\n    double w = 1e-6;\n    int i = 0;\n    if(s.dot(y) &lt; lnrm)\n    {\n        Eigen::VectorXd v(y.size());\n        while(s.dot(y) &lt; lnrm)\n        {\n            for(int i = 0; i &lt; y.size(); i++)\n            {\n                if(y(i)*w &lt; lnrm &amp;&amp; y(i)*s(i) &lt; lnrm)\n                    v(i) = dgg(i);\n                else\n                    v(i) = 0;\n            }\n            y += w*v;\n            w*= 1.1;\n\n            if(1000 &lt; ++i)\n            {\n                break;\n            }\n        }\n    }\n\n    bfgs_step(hess, s, y);\n}\n\nstatic void powells_modified_bfgs_step(Eigen::MatrixXd &amp;hess, Eigen::VectorXd s, Eigen::VectorXd y, double gamma = 0.2)\n{\n    powells_modified_bfgs_step(hess, s, y, Eigen::VectorXd::Zero(y.size()), gamma);\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/bode_8hpp/","title":"include/cpp_robotics/system/bode.hpp","text":""},{"location":"doxybook/Files/bode_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/bode_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include \"./transfer_function.hpp\"\n#ifdef CR_USE_MATPLOTLIB\n#include \"../third_party/matplotlib-cpp/matplotlibcpp.h\"\n#endif\n#include \"../utility/space.hpp\"\n#include \"../vector/vector2.hpp\"\n#include \"../utility/math_utils.hpp\"\n#include \"./polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; bode(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500), bool gain_db_mode = true, bool phase_deg_mode = true)\n{\n    size_t n = omegas.size();\n    std::vector&lt;double&gt; gain_db(n), phase_deg(n);\n\n    Vector2d num_vec, den_vec;\n    auto num_array = tf.num_array();\n    auto den_array = tf.den_array();\n\n    Polynomial num_poly(num_array.begin(), num_array.end());\n    Polynomial den_poly(den_array.begin(), den_array.end());\n\n    for(size_t i = 0; i &lt; n; i++)\n    {\n        // gain\n        {\n            num_vec = Vector2d::zero();\n            den_vec = Vector2d::zero();\n\n            for(size_t n = 0; n &lt; num_poly.size(); n++)\n            {\n                size_t deg = num_poly.degree() - n;\n\n                int dir;\n                bool is_real;\n                switch(deg%4)\n                {\n                    case 0:\n                        dir = 1;\n                        is_real = true;\n                        break;\n                    case 1:\n                        dir = 1;\n                        is_real = false;\n                        break;\n                    case 2:\n                        dir = -1;\n                        is_real = true;\n                        break;\n                    case 3:\n                        dir = -1;\n                        is_real = false;\n                        break;\n                }\n\n                if(is_real)\n                    num_vec.x += dir * num_poly[n] * std::pow(omegas[i], deg);\n                else\n                    num_vec.y += dir * num_poly[n] * std::pow(omegas[i], deg);\n            }\n\n            for(size_t n = 0; n &lt; den_poly.size(); n++)\n            {\n                size_t deg = den_poly.degree() - n;\n\n                int dir;\n                bool is_real;\n                switch(deg%4)\n                {\n                    case 0:\n                        dir = 1;\n                        is_real = true;\n                        break;\n                    case 1:\n                        dir = 1;\n                        is_real = false;\n                        break;\n                    case 2:\n                        dir = -1;\n                        is_real = true;\n                        break;\n                    case 3:\n                        dir = -1;\n                        is_real = false;\n                        break;\n                }\n\n                if(is_real)\n                    den_vec.x += dir * den_poly[n] * std::pow(omegas[i], deg);\n                else\n                    den_vec.y += dir * den_poly[n] * std::pow(omegas[i], deg);\n            }\n\n            double gain = num_vec.norm() / den_vec.norm(); \n            if(gain_db_mode)\n                gain_db[i] = 20 * std::log10(gain);\n            else\n                gain_db[i] = gain;\n        }\n\n        // phase\n        {\n            num_vec = Vector2d::zero();\n            den_vec = Vector2d::zero();\n            for(size_t didx = 0; didx &lt; tf.num_array().size(); didx++)\n            {\n                size_t deg = tf.num_deg(didx);\n                if(deg == 0)\n                {\n                    num_vec.x += tf.num_array()[didx];\n                }\n                else\n                {\n                    double s = std::pow(omegas[i], deg);\n                    num_vec.y += s * tf.num_array()[didx];\n                }\n            }\n\n            for(size_t didx = 0; didx &lt; tf.den_array().size(); didx++)\n            {\n                size_t deg = tf.den_deg(didx);\n                if(deg == 0)\n                {\n                    den_vec.x += tf.den_array()[didx];\n                }\n                else\n                {\n                    double s = std::pow(omegas[i], deg);\n                    den_vec.y += s * tf.den_array()[didx];\n                }\n            }\n\n            double phase = std::atan(num_vec.y/num_vec.x) - std::atan(den_vec.y/den_vec.x);\n            if(phase_deg_mode)\n                phase_deg[i] = degrees(phase);\n            else\n                phase_deg[i] = phase;\n        }\n\n    }\n\n    return {gain_db, phase_deg};\n}\n\n#ifdef CR_USE_MATPLOTLIB\nstatic void bode_plot(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500))\n{\n    namespace plt = matplotlibcpp;\n    auto [g, ph] = bode(tf, omegas);\n\n    plt::subplot(2, 1, 1);\n    plt::ylabel(\"Magnitude(dB)\");\n    plt::semilogx(omegas, g);\n    plt::xlim(std::pow(10,-2), std::pow(10,2));\n    plt::ylim(-60, 30);\n    plt::grid(true, \"both\");\n\n    plt::subplot(2, 1, 2);\n    plt::xlabel(\"Frequency(rad/s)\");\n    plt::ylabel(\"Phase(deg)\");\n    plt::semilogx(omegas, ph);\n    plt::xlim(std::pow(10,-2), std::pow(10,2));\n    plt::grid(true, \"both\");\n\n    plt::show();\n}\n#endif\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/bracketing__serach_8hpp/","title":"include/cpp_robotics/optimize/bracketing_serach.hpp","text":""},{"location":"doxybook/Files/bracketing__serach_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/bracketing__serach_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic double bracketing_serach(std::function&lt;double(Eigen::VectorXd)&gt; func, std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt; grad, const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;d, double gamma = 0.3, double tau = 0.9, const size_t max_iter = 1000)\n{\n    auto line_func = [&amp;](double v){ return func(x + v*d); };\n\n    double a = 1;\n    double b = grad(x).dot(d);\n    double lf0 = line_func(0);\n    for(size_t i = 0; i &lt; max_iter; i++){\n        if(line_func(a) &lt;= lf0 + gamma * a * b){\n            return a;\n        }\n        a = tau * a;\n    }\n    return a;\n}\n\nstatic double bracketing_serach(std::function&lt;double(double)&gt; func, const double init = 1.0, const double beta = 0.9, const size_t max_iter = 1000)\n{\n    double a = init;\n    double fval = func(a);\n    double new_fval;\n\n    for(size_t i = 0; i &lt; max_iter; i++)\n    {\n        new_fval = func(a*beta);\n\n        if(new_fval &gt; fval)\n            return a;\n        a *= beta;\n        fval = new_fval;\n    }\n\n    return a;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/butterworth__filter_8hpp/","title":"include/cpp_robotics/filter/butterworth_filter.hpp","text":""},{"location":"doxybook/Files/butterworth__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/butterworth__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::ButterworthFilter \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/butterworth__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n#include \"cpp_robotics/system/polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass ButterworthFilter : public TransferFunction\n{\npublic:\n    ButterworthFilter(double omega, size_t n, double dt):\n        omega_(omega), n_(n)\n    {\n        Polynomial den_poly({1});\n        if(n % 2)\n        {\n            den_poly *= Polynomial{1/omega_, 1};\n            // n\u304c\u5947\u6570\n            for(size_t k = 1; k &lt;= (n-1)/2; k++)\n            {\n                int num = 2*k + n - 1;\n                int den = 2*n;\n                const double k1 = -2.0*std::cos((double)(num) / (double)(den) * M_PI);\n                den_poly *= Polynomial{1/omega_/omega_, k1/omega, 1};\n            }\n        }\n        else\n        {\n            // n\u304c\u5076\u6570\n            for(size_t k = 1; k &lt;= n/2; k++)\n            {\n                int num = 2*k + n - 1;\n                int den = 2*n;\n                const double k1 = -2.0*std::cos((double)(num) / (double)(den) * M_PI);\n                den_poly *= Polynomial{1/omega_/omega_, k1/omega, 1};\n            }\n        }\n\n        std::cout &lt;&lt; den_poly &lt;&lt; std::endl;\n        TransferFunction::set_continuous({1}, den_poly.coeff(), dt);\n    }\n\n    double filtering(double u) { return responce(u); } \n\n    double omega() const { return omega_; }\n\n    size_t n() const { return n_; }\n\nprivate:\n    const double omega_;\n    const size_t n_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/chassis_8hpp/","title":"include/cpp_robotics/chassis.hpp","text":""},{"location":"doxybook/Files/chassis_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"chassis/mecanum_ik.hpp\"\n#include \"chassis/omni_ik.hpp\"\n#include \"chassis/swerve_ik.hpp\"\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/constraint_8hpp/","title":"include/cpp_robotics/optimize/constraint.hpp","text":""},{"location":"doxybook/Files/constraint_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/constraint_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408"},{"location":"doxybook/Files/constraint_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n#include &lt;optional&gt;\n#include &lt;numeric&gt;\n#include &lt;variant&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"derivative.hpp\"\n\nnamespace cpp_robotics\n{\n\nstruct Constraint\n{\n    using func_type = std::function&lt;double(Eigen::VectorXd)&gt;;\n    using grad_func_type = std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\n    using hessian_func_type = std::function&lt;Eigen::MatrixXd(Eigen::VectorXd)&gt;;\n\n    enum Type : uint8_t\n    {\n        // g(x) = 0\n        Eq,\n\n        // g(x) &lt;= 0\n        Ineq,\n\n        // undefined\n        None\n    };\n\n    Type type;\n    func_type con_f;\n    std::optional&lt;grad_func_type&gt; con_grad_f;\n    std::optional&lt;hessian_func_type&gt; con_hessian_f;\n\n    Constraint():\n        type(Type::None), con_f([](Eigen::VectorXd x) { (void)x; return 0; }) {}\n    Constraint(Type type_, func_type con_):\n        type(type_), con_f(con_) {}\n\n    double eval(const Eigen::VectorXd &amp;x) const\n    {\n        return con_f(x);\n    }\n\n    bool satisfy(const Eigen::VectorXd &amp;x, const double tol) const\n    {\n        const double val = eval(x);\n        if(type == Type::Eq)\n        {\n            return std::abs(val) &lt; tol;\n        }\n        else\n        {\n            return val &lt; tol;\n        }\n    }\n\n    Eigen::VectorXd grad(Eigen::VectorXd x)\n    {\n        if(con_grad_f)\n            return con_grad_f.value()(x);\n\n        return derivative(con_f, x);\n    }\n\n    Eigen::MatrixXd hessian(Eigen::VectorXd x)\n    {\n        if(con_hessian_f)\n            return con_hessian_f.value()(x);\n\n        return approx_hessian(con_f, x);\n    }\n};\n\nclass ConstraintArray : public std::vector&lt;Constraint&gt;\n{\n    template&lt;class Type1, class Type2&gt;\n    struct VariItem\n    {\n        using vari_type = std::variant&lt;Type1, Type2&gt;;\n        // VariItem() = default;\n        VariItem(Type1 val) { val_ = val; }\n        VariItem(Type2 val) { val_ = val; }\n\n        vari_type &amp;item() { return val_; } \n\n    private:\n        vari_type val_;\n    };\npublic:\n    // std::vector&lt;Constraint&gt;::size_type size() const\n    // {\n    //     return this-&gt;size();\n    // }\n\n    ConstraintArray() = default;\n    ConstraintArray(std::initializer_list&lt;Constraint&gt; con):\n        vector(con.begin(), con.end()) {}\n\n    ConstraintArray(std::initializer_list&lt;VariItem&lt;Constraint, ConstraintArray&gt;&gt; cons)\n    {\n        for(auto c : cons)\n        {\n            if(std::holds_alternative&lt;Constraint&gt;(c.item()))\n            {\n                auto &amp; cval = std::get&lt;Constraint&gt;(c.item());\n                this-&gt;insert(this-&gt;end(), cval);\n            }\n            else\n            {\n                auto &amp; cary = std::get&lt;ConstraintArray&gt;(c.item());\n                this-&gt;insert(this-&gt;end(), cary.begin(), cary.end());\n            }\n        }\n    }\n\n    std::vector&lt;double&gt; eval(const Eigen::VectorXd &amp;x) const\n    {\n        std::vector&lt;double&gt; val(this-&gt;size());\n        for(size_t i = 0; i &lt; this-&gt;size(); i++)\n        {\n\n            val[i] = this-&gt;at(i).eval(x);\n        }\n        return val;\n    }\n\n    double eval_sum(const Eigen::VectorXd &amp;x) const\n    {\n        auto val = eval(x);\n        return std::accumulate(val.begin(), val.end(), 0.0);\n    }\n\n    bool all_satisfy(const Eigen::VectorXd &amp;x, const double tol) const\n    {\n        bool satisfy = true;\n\n        for(auto &amp; con : *this)\n        {\n            if(not con.satisfy(x, tol))\n            {\n                // std::cout &lt;&lt; \"not satisfy\" &lt;&lt; std::endl;\n                satisfy = false;\n            }\n            // else\n            // {\n                // std::cout &lt;&lt; \"satisfy\" &lt;&lt; std::endl;\n                // \n            // }\n        }\n        return satisfy;\n    }\n\n    std::vector&lt;Constraint&gt;::size_type eq_constraint_size() const\n    {\n        std::vector&lt;Constraint&gt;::size_type num = 0;\n        for(auto &amp; con : *this)\n        {\n            if(con.type == Constraint::Type::Eq)\n                num++;\n        }\n        return num;\n    }\n\n    std::vector&lt;Constraint&gt;::size_type ineq_constraint_size() const\n    {\n        std::vector&lt;Constraint&gt;::size_type num = 0;\n        for(auto &amp; con : *this)\n        {\n            if(con.type == Constraint::Type::Ineq)\n                num++;\n        }\n        return num;\n    }\n\n    std::vector&lt;Constraint&gt; gen_eq_constraint_list() const\n    {\n        std::vector&lt;Constraint&gt; ret;\n        for(auto &amp; con : *this)\n        {\n            if(con.type == Constraint::Type::Eq)\n                ret.push_back(con);\n        }\n        return ret;\n    }\n\n    std::vector&lt;Constraint&gt; gen_ineq_constraint_list() const\n    {\n        std::vector&lt;Constraint&gt; ret;\n        for(auto &amp; con : *this)\n        {\n            if(con.type == Constraint::Type::Ineq)\n                ret.push_back(con);\n        }\n        return ret;\n    }\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/controller_8hpp/","title":"include/cpp_robotics/controller.hpp","text":""},{"location":"doxybook/Files/controller_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"controller/pid.hpp\"\n#include \"controller/pid2.hpp\"\n#include \"controller/psmc.hpp\"\n#include \"controller/nctf.hpp\"\n\n// #include \"controller/pfc.hpp\"\n// #include \"controller/pure_pursuit.hpp\"\n\n// // \u3053\u3053\u304b\u3089\u6642\u9593\u304b\u304b\u308b\n// #include \"controller/lqr.hpp\" // + 7.0s\n// #include \"controller/modern_control.hpp\" // +1.7s\n// #include \"controller/vrft.hpp\" // +4.0s\n// #include \"controller/linear_mpc.hpp\" // +2.6s\n// #include \"controller/linear_regulator_mpc.hpp\" // +2.6s\n// #include \"controller/ocp_dynamics.hpp\"\n// #include \"controller/ocp_cost.hpp\"\n// #include \"controller/ocp_constraint.hpp\"\n// #include \"controller/optimal_control_problem.hpp\"\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/cpp__support_8hpp/","title":"include/cpp_robotics/utility/cpp_support.hpp","text":""},{"location":"doxybook/Files/cpp__support_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/cpp__support_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n\n// platform\n#if defined(linux) || defined(__linux) || defined(__linux__)\n#  define CPP_ROBOTICS_PLATFORM_LINUX\n\n#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)\n#  define CPP_ROBOTICS_PLATFORM_WINDOWS\n#endif\n\n// C++ version\n#ifdef __cplusplus\n\n#  if (__cplusplus &gt;= 201103L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201103L)\n#    define CPP_ROBOTICS_CPP11_OR_GREATER\n#  endif\n\n#  if (__cplusplus &gt;= 201402L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201402L)\n#    define CPP_ROBOTICS_CPP14_OR_GREATER\n#  endif\n\n#  if (__cplusplus &gt;= 201703L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)\n#    define CPP_ROBOTICS_CPP17_OR_GREATER\n#  endif\n\n#  if (__cplusplus &gt;= 202002L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 202002L)\n#    define CPP_ROBOTICS_CPP20_OR_GREATER\n#  endif\n\n#endif\n\n#include &lt;string_view&gt;\n\n// #ifdef CPP_ROBOTICS_CPP20_OR_GREATER\n// #include &lt;format&gt;\n// #endif\n\nnamespace cpp_robotics\n{\n\ntemplate &lt;class ForwardIterator&gt;\nconstexpr ForwardIterator shift_left(ForwardIterator first,\n                                        ForwardIterator last,\n                                        typename std::iterator_traits&lt;ForwardIterator&gt;::difference_type n)\n{\n    if (n &lt;= 0)\n        return last;\n    if (n &gt;= last - first)\n        return first;\n\n    ForwardIterator it = first;\n    ForwardIterator nlast = std::prev(last, n);\n    while (it != nlast)\n    {\n        ForwardIterator nit = std::next(it, n);\n        *it = *nit;\n        it++;\n    }\n    return first + (last - first - n);\n}\n\ntemplate &lt;class ForwardIterator&gt;\nconstexpr ForwardIterator shift_right(ForwardIterator first,\n                                        ForwardIterator last,\n                                        typename std::iterator_traits&lt;ForwardIterator&gt;::difference_type n)\n{\n    if (n &lt;= 0)\n        return first;\n    if (n &gt;= last - first)\n        return last;\n\n    ForwardIterator it = std::prev(last, n);\n    ForwardIterator nfirst = std::prev(first, 1);\n    while (it != nfirst)\n    {\n        ForwardIterator nit = std::next(it, n);\n        *nit = *it;\n        it--;\n    }\n\n    return first + n;\n}\n\ntemplate &lt;typename... Args&gt;\nstd::string c_format(const std::string &amp;format, Args const&amp;... args)\n{\n#pragma GCC diagnostic ignored \"-Wformat-security\"\n    size_t len = std::snprintf(nullptr, 0, format.c_str(), args...);\n    std::vector&lt;char&gt; buf(len + 1);\n    std::snprintf(&amp;buf[0], len + 1, format.c_str(), args...);\n    return std::string{&amp;buf[0], &amp;buf[0] + len};\n#pragma GCC diagnostic warning \"-Wformat-security\"\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dc__motor__list_8hpp/","title":"include/cpp_robotics/motor/dc_motor_list.hpp","text":""},{"location":"doxybook/Files/dc__motor__list_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/dc__motor__list_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./dc_motor_param.hpp\"\n\nnamespace cpp_robotics\n{\n\ninline constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param(\n    18_V,\n    20400_rpm,\n    2.8_A,\n    1265_mmNm,\n    156_A,\n    7.088e-5_H,\n    2.46e-5 // \u9069\u5f53\n);\n\ninline constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param(\n    18_V,\n    18400_rpm,\n    2.7_A,\n    1216_mmNm, \n    130_A,\n    5.872e-5_H,\n    2.46e-5 // \u9069\u5f53\n);\n\ninline constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param(\n    12_V,\n    9100_rpm,\n    0.8_A,\n    450_mmNm, \n    36_A,\n    1.820e-4_H,\n    2.46e-5 // \u9069\u5f53\n);\n\n// inline constexpr DCMotorParam RS_540SH_6527  \n// {\n//     1.658e+0_ohm, \n//     7.371e-5_H, \n//     3.899e-3_Nm_per_A, \n//     6.239e-3_Nm, \n//     3.745e-2_Vs_per_rad\n// };\n\ninline constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param(\n    6_V,\n    12500_rpm,\n    0.56_A,\n    77.5_mmNm, \n    18_A,\n    1.521e-4_H,\n    2.46e-5 // \u9069\u5f53\n);\n\ninline constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param(\n    18_V,\n    17500_rpm,\n    0.23_A,\n    76.9_mmNm, \n    7.91_A,\n    1.521e-4_H,\n    2.46e-5 // \u9069\u5f53\n);\n\n// inline constexpr DCMotorParam RS_385PH_2465  \n// {\n//     3.067e+1_ohm, \n//     1.128e-3_H, \n//     1.189e-2_Nm_per_A, \n//     3.219e-3_Nm, \n//     1.330e-1_Vs_per_rad\n// };\n\ninline constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param(\n    18_V,\n    3520_rpm,\n    755_mA,\n    0.0609_ohm,\n    0.0226_mH,\n    46e-3_Nm_per_A,\n    1.38\n);  \n\n// http://suzakugiken.jp/goods/30144/catalog-IG32.pdf\n// http://suzakugiken.jp/goods/30335/catalog-IG36P.pdf\n// http://suzakugiken.jp/goods/30045/catalog-IG42C.pdf\n\ninline constexpr GearHeadParam IG42C_4  = { 1/4.0f, 0.8f };\ninline constexpr GearHeadParam IG42C_14 = { 1/14.0f, 0.7f };\ninline constexpr GearHeadParam IG42C_17 = { 1/17.0f, 0.7f };\ninline constexpr GearHeadParam IG32_27  = { 1/27.0f, 0.7f };\ninline constexpr GearHeadParam IG32_71  = { 1/71.0f, 0.6f };\ninline constexpr GearHeadParam IG32_100 = { 1/100.0f, 0.6f };\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dc__motor__param_8hpp/","title":"include/cpp_robotics/motor/dc_motor_param.hpp","text":""},{"location":"doxybook/Files/dc__motor__param_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb"},{"location":"doxybook/Files/dc__motor__param_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb"},{"location":"doxybook/Files/dc__motor__param_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cpp_robotics/unit.hpp\"\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics\n{\n\ninline namespace unit\n{\nusing TorqueConstant = unit_assem::unit_div&lt;Torque, Ampere&gt;::unit;\nusing BackEmfConstant = unit_assem::unit_div&lt;Volt, AngularVelocity&gt;::unit;\nusing FrictionConstant = unit_assem::unit_mul&lt;Torque, Second&gt;::unit;\n}\n\nGENERATE_UNIT_SUFFIX(cpp_robotics::TorqueConstant, Nm_per_A)\nGENERATE_UNIT_SUFFIX(cpp_robotics::BackEmfConstant, Vs_per_rad)\nGENERATE_UNIT_SUFFIX(cpp_robotics::FrictionConstant, Nms)\n\n\nstruct DCMotorParam\n{\n    const Volt nominal_voltage;               // \u516c\u79f0\u96fb\u5727[V]\n    const Rpm free_speed;                     // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]\n    const Ampere free_current;                // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]\n    const Ohm resistance;                     // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm]             (\u516c\u79f0\u96fb\u5727 / \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41)\n    const Henry inductance;                   // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H]\n    const TorqueConstant torque_constant;     // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A]            (\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af)/(\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41 - \u7121\u8ca0\u8377\u96fb\u6d41)\n    const BackEmfConstant back_emf_constance; // \u9006\u6c17\u96fb\u529b\u5b9a\u6570[V/(rad/s)]      (\u516c\u79f0\u96fb\u5727 - \u62b5\u6297*\u7121\u8ca0\u8377\u96fb\u6d41)/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]\n    const FrictionConstant friction_constant; // \u7c98\u6027\u4fc2\u6570[Nms]               (\u30c8\u30eb\u30af\u640d\u5931/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]) \u30c8\u30eb\u30af\u640d\u5931 = \u7121\u8ca0\u8377\u6642\u96fb\u6d41*\u30c8\u30eb\u30af\u5b9a\u6570\n    const Inertia rotor_inertia;              // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2]\n    const Second time_constant;               // \u96fb\u6c17\u7684\u6642\u5b9a\u6570[s]             (\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9/\u62b5\u6297)\n\n    constexpr DCMotorParam(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm Rm, Henry Lm, TorqueConstant Kt, BackEmfConstant Ke, Inertia Im, Second curr_set_time = 0.1f):\n        nominal_voltage(nominal_voltage),\n        free_speed(free_speed),\n        free_current(free_current),\n        resistance(Rm),\n        inductance(Lm),\n        torque_constant(Kt),\n        back_emf_constance(Ke),\n        friction_constant((free_current*torque_constant) / (AngularVelocity)(free_speed)),\n        rotor_inertia(Im),\n        time_constant(inductance/resistance)\n    {\n        set_current_setting_time(curr_set_time);\n    }\n    constexpr DCMotorParam(const DCMotorParam&amp;) = default;\n\n    constexpr void set_current_setting_time(Second Tc)\n    {\n        if((double)Tc &gt; 0.0f)\n            current_setting_time_ = Tc;\n        corner_frequency_ = 3.0f / current_setting_time_;\n        current_p_gain_base_ = (inductance*corner_frequency_).value();\n        current_i_gain_base_ = (resistance*corner_frequency_).value();\n    }\n\n    constexpr Rpm calcu_steady_free_velocity(Volt v) const\n    {\n        return free_speed * ((double)v / (double)nominal_voltage);\n    }\n\n    constexpr Ampere calcu_stall_current(Volt v) const\n    {\n        return v / resistance;\n    }\n\n    constexpr Torque calcu_stall_torque(Volt v) const\n    {\n        return calcu_stall_current(v) * torque_constant;\n    }\n\n    constexpr AngularAcceleration calcu_max_free_angular_acceleration(Volt v) const\n    {\n        return calcu_stall_torque(v) / rotor_inertia;\n    }\n\n    constexpr Second get_Tm() const { return time_constant; }\n    constexpr AngularVelocity get_Wi() const { return corner_frequency_; }\n    constexpr double get_Kip(Volt volt) const { return current_p_gain_base_ / volt.value(); }\n    constexpr double get_Kii(Volt volt) const { return current_i_gain_base_ / volt.value(); }\n\nprivate:\n    Second current_setting_time_ = 0.1_s;\n    AngularVelocity corner_frequency_ = 0;\n    double current_p_gain_base_ = 0;\n    double current_i_gain_base_ = 0;\n};\n\nstruct GearHeadParam\n{\n    const double ratio;\n    const double efficiency;\n    constexpr GearHeadParam(double ratio_, double efficiency_):\n        ratio(ratio_), efficiency(efficiency_) {}\n};\n\nstruct DCGearedMotorParam\n{\n    constexpr DCGearedMotorParam(Volt voltage_, DCMotorParam motor_, GearHeadParam gear_head_, const double optional_gear_ratio_ = 1):\n        voltage(voltage_),\n        motor(motor_),\n        gear_head(gear_head_),\n        optional_gear_ratio(optional_gear_ratio_)\n    {\n\n    }\n\n    constexpr Rpm calcu_gear_head_steady_free_velocity(Volt v) const\n    {\n        return motor.calcu_steady_free_velocity(v) * gear_head.ratio;\n    }\n\n    constexpr Rpm calcu_endpoint_steady_free_velocity(Volt v) const\n    {\n        return calcu_gear_head_steady_free_velocity(v) * optional_gear_ratio;\n    }\n\n    constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration(Inertia optional_inertina = 0) const\n    {\n        return motor.calcu_stall_torque(voltage) / (motor.rotor_inertia + (optional_inertina * std::pow(gear_head.ratio*optional_gear_ratio, 2))) * gear_head.ratio;\n    }\n\n    const Volt voltage;\n    const DCMotorParam motor;\n    const GearHeadParam gear_head;\n    const double optional_gear_ratio;\n};\n\ninline constexpr DCMotorParam generate_mabuchi_motor_param(\n    Volt nominal_voltage,  // \u516c\u79f0\u96fb\u5727[V]\n    Rpm free_speed,        // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]\n    Ampere free_current,   // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]\n    Torque stall_torque,   // \u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af[Nm]\n    Ampere stall_current,  // \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41[A]\n    Henry inductance,      // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] (\u8a08\u6e2c\u3059\u308b)\n    Inertia rotor_inertia  // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2] (\u8a08\u6e2c\u3059\u308b)\n)\n{\n    const auto R = nominal_voltage/stall_current;\n    return DCMotorParam(\n        nominal_voltage,\n        free_speed,\n        free_current,\n        R,\n        inductance,\n        stall_torque / (stall_current - free_current),\n        (nominal_voltage - R*free_current) / (AngularVelocity)(free_speed),\n        rotor_inertia\n    );\n}\n\ninline constexpr DCMotorParam generate_maxon_brush_motor_param(\n    Volt nominal_voltage,  // \u516c\u79f0\u96fb\u5727[V]\n    Rpm free_speed,        // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]\n    Ampere free_current,   // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]\n    Ohm resistance,        // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm]\n    Henry inductance,      // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H]\n    TorqueConstant Kt,     // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A]\n    Inertia rotor_inertia  // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2] (\u8a08\u6e2c\u3059\u308b)\n)\n{\n    return DCMotorParam(\n        nominal_voltage,\n        free_speed,\n        free_current,\n        resistance,\n        inductance,\n        Kt,\n        (nominal_voltage - resistance*free_current) / (AngularVelocity)(free_speed),\n        rotor_inertia\n    );\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/delay__filter_8hpp/","title":"include/cpp_robotics/filter/delay_filter.hpp","text":""},{"location":"doxybook/Files/delay__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/delay__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/delay__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n\nnamespace cpp_robotics\n{\n\nclass DelayFilter\n{\npublic:\n    DelayFilter(double delay_time, double Ts)\n    {\n        delay_sample_cnt_ = std::floor(delay_time/Ts);\n        delay_table_.resize(delay_sample_cnt_);\n    }\n\n    virtual void reset()\n    {\n        for(auto &amp;val : delay_table_)\n        {\n            val = 0;\n        }\n    }\n\n    virtual double filtering(double u)\n    {\n        if(delay_table_.size() == 0)\n            return u;\n\n        for(int i = delay_table_.size() - 2; i &gt;= 0; i--)\n        {\n            delay_table_[i+1] = delay_table_[i];\n        }\n        delay_table_[0] = u;\n        return delay_table_.back();\n    }\n\nprivate:\n    size_t delay_sample_cnt_;\n    std::vector&lt;double&gt; delay_table_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/derivative_8hpp/","title":"include/cpp_robotics/optimize/derivative.hpp","text":""},{"location":"doxybook/Files/derivative_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/derivative_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;limits&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic double derivative(std::function&lt;double(double)&gt; f, double x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n    // \u4e2d\u592e\u5dee\u5206\n    return ( f(x + eps) - f(x - eps) ) / (2.0*eps);\n}\n\nstatic Eigen::VectorXd derivative(std::function&lt;double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n    Eigen::VectorXd J(x.rows());\n    Eigen::VectorXd diff(x.rows());\n    for(Eigen::VectorXd::Index i = 0; i &lt; x.rows(); i++)\n    {\n        diff.setZero();\n        diff(i) = eps;\n        // \u4e2d\u592e\u5dee\u5206\n        J(i) = ( f(x + diff) - f(x - diff) ) / (2.0*eps);\n    }\n    return J;\n}\n\nstatic Eigen::MatrixXd derivative(std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n    Eigen::MatrixXd J;\n    Eigen::VectorXd J_col;\n    Eigen::VectorXd diff(x.rows());\n    for(Eigen::VectorXd::Index i = 0; i &lt; x.rows(); i++)\n    {\n        diff.setZero();\n        diff(i) = eps;\n        // \u4e2d\u592e\u5dee\u5206\n        J_col = ( f(x + diff) - f(x - diff) ) / (2.0*eps);\n        if(i == 0)\n        {\n            J = Eigen::MatrixXd::Zero(J_col.rows(), x.rows());\n        }\n        J.col(i) = J_col;\n    }\n    return J;\n}\n\nstatic double second_derivative(std::function&lt;double(double)&gt; f, double x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n    // \u4e2d\u592e2\u968e\u5dee\u5206\n    return ( f(x + eps) - 2*f(x) + f(x - eps) ) / std::pow(eps,2);\n}\n\nstatic Eigen::MatrixXd second_derivative(std::function&lt;double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n    int n = x.size();\n    Eigen::MatrixXd H(n, n);\n    Eigen::VectorXd e_i(n);\n    Eigen::VectorXd e_j(n);\n    for (int i = 0; i &lt; n; ++i) \n    {\n        for (int j = 0; j &lt; n; ++j) \n        {\n            e_i.setZero();\n            e_j.setZero();\n            e_i[i] = eps;\n            e_j[j] = eps;\n\n            double f_ij = f(x + e_i + e_j) - f(x + e_i - e_j) - f(x - e_i + e_j) + f(x - e_i - e_j);\n            H(i, j) = f_ij / (4 * eps * eps);\n        }\n    }\n    return H;\n}\n\nstatic Eigen::MatrixXd mixed_derivative(std::function&lt;double(Eigen::VectorXd, Eigen::VectorXd)&gt; f, Eigen::VectorXd x, Eigen::VectorXd y, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n    int n = x.size();\n    int m = y.size();\n    Eigen::MatrixXd H(n, m);\n    Eigen::VectorXd e_i(n);\n    Eigen::VectorXd e_j(m);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        for (int j = 0; j &lt; m; j++) \n        {\n            e_i.setZero();\n            e_j.setZero();\n            e_i[i] = eps;\n            e_j[j] = eps;\n\n            double f_ij = f(x + e_i, y + e_j) - f(x + e_i, y - e_j) - f(x - e_i, y + e_j) + f(x - e_i, y - e_j);\n            H(i, j) = f_ij / (4 * eps * eps);\n        }\n    }\n    return H;\n}\n\nstatic Eigen::MatrixXd approx_hessian(std::function&lt;double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n    auto j = derivative(f, x, eps);\n    return j * j.transpose();\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/differentiator_8hpp/","title":"include/cpp_robotics/filter/differentiator.hpp","text":""},{"location":"doxybook/Files/differentiator_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/differentiator_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668"},{"location":"doxybook/Files/differentiator_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass Differentiator : public TransferFunction\n{\npublic:\n    Differentiator(double omega, double dt): \n        omega_(omega)\n    {\n        TransferFunction::set_continuous({omega_, 0}, {1, omega_}, dt);\n    }\n\n    virtual void reset(double state = 0) override\n    {\n        for(auto &amp;u : u_)\n            u = 0;\n        for(auto &amp;y : y_)\n            y = state;\n        u_.reset_position();\n        y_.reset_position();\n        reset_request = true;\n    }\n\n    void reset_test(double state = 0, double input = 0)\n    {\n        for(auto &amp;u : u_)\n            u = input;\n        for(auto &amp;y : y_)\n            y = state;\n        u_.reset_position();\n        y_.reset_position();\n    }\n\n    double filtering(double u) \n    {\n        if(reset_request)\n        {\n            reset_test(0, u);\n            reset_request = false;\n        }\n        return responce(u);\n    } \n\n    double omega() const { return omega_; }\nprivate:\n    const double omega_;\n    bool reset_request = true;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_2ea8a390efb1067dce8bd4c72d5b1bee/","title":"include/cpp_robotics/utility","text":""},{"location":"doxybook/Files/dir_2ea8a390efb1067dce8bd4c72d5b1bee/#files","title":"Files","text":"Name include/cpp_robotics/utility/angle_range.hpp include/cpp_robotics/utility/cpp_support.hpp include/cpp_robotics/utility/eigen_utils.hpp include/cpp_robotics/utility/math_utils.hpp include/cpp_robotics/utility/random.hpp include/cpp_robotics/utility/singleton.hpp include/cpp_robotics/utility/space.hpp include/cpp_robotics/utility/timer.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_36b0cd5dd5e5d52e27c3e8401d5f16d3/","title":"include/cpp_robotics/vector","text":""},{"location":"doxybook/Files/dir_36b0cd5dd5e5d52e27c3e8401d5f16d3/#files","title":"Files","text":"Name include/cpp_robotics/vector/quaternion.hpp include/cpp_robotics/vector/transform.hpp include/cpp_robotics/vector/vector2.hpp include/cpp_robotics/vector/vector3.hpp include/cpp_robotics/vector/vector4.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_4247061a1141e797ef60959306008361/","title":"include/cpp_robotics/geometry","text":""},{"location":"doxybook/Files/dir_4247061a1141e797ef60959306008361/#files","title":"Files","text":"Name include/cpp_robotics/geometry/geometry_stream.hpp include/cpp_robotics/geometry/intersect.hpp include/cpp_robotics/geometry/shape.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_5df22cf9cb50dfe3ed59678e8c651195/","title":"include/cpp_robotics/controller","text":""},{"location":"doxybook/Files/dir_5df22cf9cb50dfe3ed59678e8c651195/#files","title":"Files","text":"Name include/cpp_robotics/controller/al_ilqr.hpp include/cpp_robotics/controller/ilqr.hpp include/cpp_robotics/controller/linear_mpc.hpp include/cpp_robotics/controller/linear_regulator_mpc.hpp include/cpp_robotics/controller/lqr.hpp include/cpp_robotics/controller/modern_control.hpp include/cpp_robotics/controller/nctf.hpp include/cpp_robotics/controller/ocp_constraint.hpp include/cpp_robotics/controller/ocp_cost.hpp include/cpp_robotics/controller/ocp_dynamics.hpp include/cpp_robotics/controller/optimal_control_problem.hpp include/cpp_robotics/controller/pfc.hpp include/cpp_robotics/controller/pid.hpp include/cpp_robotics/controller/pid2.hpp include/cpp_robotics/controller/psmc.hpp include/cpp_robotics/controller/pure_pursuit.hpp include/cpp_robotics/controller/vrft.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_638b28e3ebdf4d55edeb748f267e8fbb/","title":"include/cpp_robotics/system","text":""},{"location":"doxybook/Files/dir_638b28e3ebdf4d55edeb748f267e8fbb/#files","title":"Files","text":"Name include/cpp_robotics/system/bode.hpp include/cpp_robotics/system/discret.hpp include/cpp_robotics/system/dynamics_integrate.hpp include/cpp_robotics/system/nyquist.hpp include/cpp_robotics/system/polynomial.hpp include/cpp_robotics/system/siso_system.hpp include/cpp_robotics/system/state_space_system.hpp include/cpp_robotics/system/system_transformation.hpp include/cpp_robotics/system/time_responce.hpp include/cpp_robotics/system/transfer_function.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/","title":"include/cpp_robotics","text":""},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/#directories","title":"Directories","text":"Name include/cpp_robotics/algorithm include/cpp_robotics/arm_kinematics include/cpp_robotics/chassis include/cpp_robotics/controller include/cpp_robotics/filter include/cpp_robotics/geometry include/cpp_robotics/motor include/cpp_robotics/optimize include/cpp_robotics/path_planning include/cpp_robotics/system include/cpp_robotics/unit include/cpp_robotics/utility include/cpp_robotics/vector"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/#files","title":"Files","text":"Name include/cpp_robotics/chassis.hpp include/cpp_robotics/controller.hpp include/cpp_robotics/filter.hpp include/cpp_robotics/geometry.hpp include/cpp_robotics/matplotlibcpp.hpp include/cpp_robotics/motor.hpp include/cpp_robotics/system.hpp include/cpp_robotics/unit.hpp include/cpp_robotics/utility.hpp include/cpp_robotics/vector.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_7bcfe98e8dae4febd37c27ec0976d9c8/","title":"include/cpp_robotics/arm_kinematics","text":""},{"location":"doxybook/Files/dir_7bcfe98e8dae4febd37c27ec0976d9c8/#files","title":"Files","text":"Name include/cpp_robotics/arm_kinematics/arm_kinematics.hpp include/cpp_robotics/arm_kinematics/xy_2link_robot.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_87a81676224789efbbd31189f8c15377/","title":"include/cpp_robotics/motor","text":""},{"location":"doxybook/Files/dir_87a81676224789efbbd31189f8c15377/#files","title":"Files","text":"Name include/cpp_robotics/motor/dc_motor_list.hpp include/cpp_robotics/motor/dc_motor_param.hpp include/cpp_robotics/motor/motor_tf.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_b08c5c51b4051026c781f1fcc98ccd3c/","title":"include/cpp_robotics/path_planning","text":""},{"location":"doxybook/Files/dir_b08c5c51b4051026c781f1fcc98ccd3c/#files","title":"Files","text":"Name include/cpp_robotics/path_planning/a_star.hpp include/cpp_robotics/path_planning/dubins_path.hpp include/cpp_robotics/path_planning/grid_path_planning_utils.hpp include/cpp_robotics/path_planning/minimum_jerk_model.hpp include/cpp_robotics/path_planning/spline.hpp include/cpp_robotics/path_planning/wave_propagation.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_bc9ad42d08f7b854efebf7d8aa67e9d1/","title":"include/cpp_robotics/chassis","text":""},{"location":"doxybook/Files/dir_bc9ad42d08f7b854efebf7d8aa67e9d1/#files","title":"Files","text":"Name include/cpp_robotics/chassis/mecanum_ik.hpp include/cpp_robotics/chassis/omni_ik.hpp include/cpp_robotics/chassis/swerve_ik.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_c2aadae018d07499e272ef7425a31e4f/","title":"include/cpp_robotics/algorithm","text":""},{"location":"doxybook/Files/dir_c2aadae018d07499e272ef7425a31e4f/#files","title":"Files","text":"Name include/cpp_robotics/algorithm/auto_diff.hpp include/cpp_robotics/algorithm/icp.hpp include/cpp_robotics/algorithm/k_means_method.hpp include/cpp_robotics/algorithm/kdtree.hpp include/cpp_robotics/algorithm/mahalanobis.hpp include/cpp_robotics/algorithm/poly_regression.hpp include/cpp_robotics/algorithm/transformation.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_d44c64559bbebec7f509842c48db8b23/","title":"include","text":""},{"location":"doxybook/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Name include/cpp_robotics <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_d46e09745d41c5a7827c5b81f13e5fde/","title":"include/cpp_robotics/filter","text":""},{"location":"doxybook/Files/dir_d46e09745d41c5a7827c5b81f13e5fde/#files","title":"Files","text":"Name include/cpp_robotics/filter/acceleration_limit_filter.hpp include/cpp_robotics/filter/band_pass_filter.hpp include/cpp_robotics/filter/butterworth_filter.hpp include/cpp_robotics/filter/delay_filter.hpp include/cpp_robotics/filter/differentiator.hpp include/cpp_robotics/filter/extended_kalman_filter.hpp include/cpp_robotics/filter/filter_state_holder.hpp include/cpp_robotics/filter/high_pass_filter.hpp include/cpp_robotics/filter/integrator.hpp include/cpp_robotics/filter/kalman_filter.hpp include/cpp_robotics/filter/low_pass_filter.hpp include/cpp_robotics/filter/notch_filter.hpp include/cpp_robotics/filter/velocity_limit_filter.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_dbe6a3823a6e2aee897d3ebf7d75d548/","title":"include/cpp_robotics/optimize","text":""},{"location":"doxybook/Files/dir_dbe6a3823a6e2aee897d3ebf7d75d548/#files","title":"Files","text":"Name include/cpp_robotics/optimize/active_set_method.hpp include/cpp_robotics/optimize/barrier_method.hpp include/cpp_robotics/optimize/bfgs.hpp include/cpp_robotics/optimize/bracketing_serach.hpp include/cpp_robotics/optimize/constraint.hpp include/cpp_robotics/optimize/derivative.hpp include/cpp_robotics/optimize/golden_serach.hpp include/cpp_robotics/optimize/least_squares_method.hpp include/cpp_robotics/optimize/lsei_transition.hpp include/cpp_robotics/optimize/newton_method.hpp include/cpp_robotics/optimize/no_constraint_method.hpp include/cpp_robotics/optimize/penalty_method.hpp include/cpp_robotics/optimize/quadprog.hpp include/cpp_robotics/optimize/quasi_newton_method.hpp include/cpp_robotics/optimize/sqp.hpp include/cpp_robotics/optimize/steepest_descent_method.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dir_f159f485fcf409cdce5089fe647e40f4/","title":"include/cpp_robotics/unit","text":""},{"location":"doxybook/Files/dir_f159f485fcf409cdce5089fe647e40f4/#files","title":"Files","text":"Name include/cpp_robotics/unit/si_unit.hpp include/cpp_robotics/unit/unit_core.hpp <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/discret_8hpp/","title":"include/cpp_robotics/system/discret.hpp","text":""},{"location":"doxybook/Files/discret_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/discret_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class cpp_robotics::DiscretTransferFunction"},{"location":"doxybook/Files/discret_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/../unsupported/Eigen/MatrixFunctions&gt;\n#include &lt;tuple&gt;\n#include \"./polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass Discret\n{\nprivate:\n    template&lt;typename Derived&gt;\n    static auto expm(const Eigen::MatrixBase&lt;Derived&gt; &amp;A)\n    {\n        assert(A.cols() == A.rows());\n        return A.exp();\n    }\n\n    template&lt;typename Derived&gt;\n    static auto integral_expm(const Eigen::MatrixBase&lt;Derived&gt; &amp;A, const double &amp;Ts, size_t hdiv = 1000)\n    {\n        assert(A.cols() == A.rows());\n\n        // \u30b7\u30f3\u30d7\u30bd\u30f3\u6cd5\u3067\u7a4d\u5206\n        const double h = Ts / (double)(hdiv);\n        Derived S = expm(A*0) + expm(A*Ts);\n\n        for(size_t i = 1; i &lt; hdiv; i += 2)\n        {\n            S += 4 * expm(A*h*i);\n        }\n\n        for(size_t i = 2; i &lt; hdiv; i += 2)\n        {\n            S += 2 * expm(A*h*i);\n        }\n        S *= h/3;\n        return S;\n    }\n\npublic:\n    template&lt;typename Derived&gt;\n    static auto discretize_a(const Eigen::MatrixBase&lt;Derived&gt; &amp;A, const double Ts)\n    {\n        assert(A.cols() == A.rows());\n        return static_cast&lt;Derived&gt;((A*Ts).exp());\n    }\n\n    template&lt;typename Derived1, typename Derived2&gt;\n    static auto discretize_b(const Eigen::MatrixBase&lt;Derived1&gt; &amp;A, const Eigen::MatrixBase&lt;Derived2&gt; &amp;B, const double &amp;Ts, size_t hdiv = 1000)\n    {\n        assert(A.rows() == A.cols());\n        assert(A.rows() == B.rows());\n\n        Eigen::FullPivLU&lt;Derived1&gt; lu_decomp(A);\n        auto rank = lu_decomp.rank();\n\n        if(rank == A.rows())\n        {\n            if constexpr (Derived1::SizeAtCompileTime==Eigen::Dynamic)\n            {\n                Derived1 I = Derived1::Identity(A.rows(), A.cols());\n                return static_cast&lt;Derived2&gt;(A.inverse() * (expm(A*Ts) - I) * B);\n            }\n            else\n            {\n                return static_cast&lt;Derived2&gt;(A.inverse() * (expm(A*Ts) - Derived1::Identity()) * B);\n            }\n        }\n\n        return static_cast&lt;Derived2&gt;(integral_expm(A, Ts, hdiv)*B);\n    }\n\n    template&lt;typename Derived1, typename Derived2&gt;\n    static auto discritize(const Eigen::MatrixBase&lt;Derived1&gt; &amp;A, const Eigen::MatrixBase&lt;Derived2&gt; &amp;B, const double &amp;Ts, size_t hdiv = 1000)\n    {\n        return std::tuple{\n            discretize_a(A, Ts),\n            discretize_b(A, B, Ts, hdiv)\n        };\n    }\n};\n\nclass DiscretTransferFunction\n{\nprivate:\n\npublic:\n    static std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; discritize(const std::vector&lt;double&gt; &amp;num, const std::vector&lt;double&gt; &amp;den, const double Ts)\n    {\n        assert(num.size() &lt;= den.size()); // \u30d7\u30ed\u30d1\u30fc\n\n        size_t dim = den.size();\n        Polynomial num_poly, den_poly;\n\n        // (2(z-1))^{num_size}*(T(z+1))^{den_size}\u3092\u5c55\u958b\u3057\u305f\u591a\u9805\u5f0f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u3059\n        auto z_poly = [&amp;](size_t num_size, size_t den_size)\n        {\n            std::vector&lt;double&gt; roots(num_size+den_size, -1);\n            for(size_t i = 0; i &lt; num_size; i++)\n            {\n                roots[i] = +1;\n            }\n\n            return std::pow(2.0, num_size)*std::pow(Ts, den_size) * Polynomial::expand(roots);\n        };\n\n        for(size_t i = 0; i &lt; den.size(); i++)\n        {\n            den_poly += den[i] * z_poly(den.size()-1-i, i);\n        }\n\n        for(size_t i = 0; i &lt; num.size(); i++)\n        {\n            num_poly += num[i] * z_poly(num.size()-1-i, i+(den.size()-num.size()));\n        }\n\n        return {num_poly.coeff(), den_poly.coeff()};\n    }\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dubins__path_8hpp/","title":"include/cpp_robotics/path_planning/dubins_path.hpp","text":""},{"location":"doxybook/Files/dubins__path_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/dubins__path_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::DubinsPath Dubins\u30d1\u30b9"},{"location":"doxybook/Files/dubins__path_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cpp_robotics/utility.hpp\"\n#include \"cpp_robotics/vector/transform.hpp\"\n#include &lt;optional&gt;\n#include &lt;functional&gt;\n\nnamespace cpp_robotics\n{\n\nclass DubinsPath\n{\npublic:\n    enum class Mode\n    {\n        LRL,\n        RLR,\n        LSL,\n        LSR,\n        RSL,\n        RSR,\n\n        NONE\n    };\n\n    DubinsPath(Transformd start, Transformd end, double cavature):\n        start_(start), end_(end), cavature_(cavature)\n    {\n        auto distance = (end-start).make_vector2().get_rotated(-start.theta);\n        double angle_distance = shortest_angular_distance(start.theta, end.theta);\n        planning_from_origin({distance, angle_distance});\n        all_length_ = plan_.t + plan_.p + plan_.q;\n        build_pos_function();\n    }\n\n    double length() const { return all_length_; }\n    double segment_length(size_t i) const\n    {\n        assert(i &lt; 3);\n        switch(i)\n        {\n            case 0: return plan_.t;\n            case 1: return plan_.p;\n            case 2: return plan_.q;\n        }\n        return 0;\n    }\n\n    Transformd position(double len) const\n    {\n        len = std::clamp(len, 0.0, all_length_);\n        if(len == 0)\n            return start_;\n        for(size_t i = 0; i &lt; 3; i++)\n        {\n            if(len &lt; segment_length(i))\n            {\n                return pos_func_list_[i](len);\n            }\n            len -= segment_length(i);\n        }\n        return end_;\n    }\n\n    std::string path_type() const\n    {\n        switch (plan_.mode)\n        {\n        case Mode::LRL: return \"LRL\";\n        case Mode::RLR: return \"RLR\";\n        case Mode::LSL: return \"LSL\";\n        case Mode::LSR: return \"LSR\";\n        case Mode::RSL: return \"RSL\";\n        case Mode::RSR: return \"RSR\";\n\n        default:\n            return \"NONE\";\n        }\n    }\n\nprivate:\n    struct PlanningResult\n    {\n        double t = 0;\n        double p = 0;\n        double q = 0;\n        Mode mode = Mode::NONE;\n    };\n\n    void planning_from_origin(Transformd origin_to_goal)\n    {\n        const auto dist = origin_to_goal.make_vector2();\n\n        const double D = dist.norm();\n        const double d = D / cavature_;\n\n        const double theta = mod2pi(dist.angle());\n        const double alpha = mod2pi(-theta);\n        const double beta = mod2pi(origin_to_goal.theta - theta);\n\n        auto planner_bind = [this](auto mem_fn)\n        {\n            return std::bind(mem_fn, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);\n        };\n\n        std::array planners = \n        {\n            planner_bind(&amp;DubinsPath::LRL),\n            planner_bind(&amp;DubinsPath::RLR),\n            planner_bind(&amp;DubinsPath::LSL),\n            planner_bind(&amp;DubinsPath::LSR),\n            planner_bind(&amp;DubinsPath::RSL),\n            planner_bind(&amp;DubinsPath::RSR)\n        };\n\n        double bcost = std::numeric_limits&lt;double&gt;::max();\n\n        std::optional&lt;PlanningResult&gt; pret;\n\n        for(auto &amp;planner : planners)\n        {\n            if(auto ret = planner(alpha, beta, d); ret.has_value())\n            {\n                auto [t,p,q,mode] = ret.value();\n                double cost = t+p+q;\n                if(cost &lt; bcost)\n                {\n                    plan_ = ret.value();\n                    bcost = cost;\n                }\n            }\n        }\n    }\n\n    std::optional&lt;PlanningResult&gt; LSL(double alpha, double beta, double d)\n    {\n        const double sa = std::sin(alpha);\n        const double sb = std::sin(beta);\n        const double ca = std::cos(alpha);\n        const double cb = std::cos(beta);\n        const double c_ab = std::cos(alpha - beta);\n\n        const double tmp0 = d + sa - sb;\n\n        const double p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sa - sb));\n        if (p_squared &lt; 0)\n            return std::nullopt;\n        const double tmp1 = std::atan2((cb - ca), tmp0);\n        const double t = mod2pi(-alpha + tmp1);\n        const double p = std::sqrt(p_squared);\n        const double q = mod2pi(beta - tmp1);\n\n        return PlanningResult{t, p, q, Mode::LSL};\n    }\n\n    std::optional&lt;PlanningResult&gt; RSR(double alpha, double beta, double d)\n    {\n        const double sa = std::sin(alpha);\n        const double sb = std::sin(beta);\n        const double ca = std::cos(alpha);\n        const double cb = std::cos(beta);\n        const double c_ab = std::cos(alpha - beta);\n\n        const double tmp0 = d - sa + sb;\n        const double p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sb - sa));\n        if (p_squared &lt; 0)\n            return std::nullopt;\n        const double tmp1 = std::atan2((ca - cb), tmp0);\n        const double t = mod2pi(alpha - tmp1);\n        const double p = std::sqrt(p_squared);\n        const double q = mod2pi(-beta + tmp1);\n\n        return PlanningResult{t, p, q, Mode::RSR};\n    }\n\n    std::optional&lt;PlanningResult&gt; LSR(double alpha, double beta, double d)\n    {\n        const double sa = std::sin(alpha);\n        const double sb = std::sin(beta);\n        const double ca = std::cos(alpha);\n        const double cb = std::cos(beta);\n        const double c_ab = std::cos(alpha - beta);\n\n        const double p_squared = -2 + (d * d) + (2 * c_ab) + (2 * d * (sa + sb));\n        if (p_squared &lt; 0)\n            return std::nullopt;\n        const double p = std::sqrt(p_squared);\n        const double tmp2 = std::atan2((-ca - cb), (d + sa + sb)) - std::atan2(-2.0, p);\n        const double t = mod2pi(-alpha + tmp2);\n        const double q = mod2pi(-mod2pi(beta) + tmp2);\n\n        return PlanningResult{t, p, q, Mode::LSR};\n    }\n\n    std::optional&lt;PlanningResult&gt; RSL(double alpha, double beta, double d)\n    {\n        const double sa = std::sin(alpha);\n        const double sb = std::sin(beta);\n        const double ca = std::cos(alpha);\n        const double cb = std::cos(beta);\n        const double c_ab = std::cos(alpha - beta);\n\n        const double p_squared = (d * d) - 2 + (2 * c_ab) - (2 * d * (sa + sb));\n        if (p_squared &lt; 0)\n            return std::nullopt;\n        const double p = std::sqrt(p_squared);\n        const double tmp2 = std::atan2((ca + cb), (d - sa - sb)) - std::atan2(2.0, p);\n        const double t = mod2pi(alpha - tmp2);\n        const double q = mod2pi(beta - tmp2);\n\n        return PlanningResult{t, p, q, Mode::RSL};\n    }\n\n    std::optional&lt;PlanningResult&gt; RLR(double alpha, double beta, double d)\n    {\n        const double sa = std::sin(alpha);\n        const double sb = std::sin(beta);\n        const double ca = std::cos(alpha);\n        const double cb = std::cos(beta);\n        const double c_ab = std::cos(alpha - beta);\n\n        const double tmp_rlr = (6.0 - d * d + 2.0 * c_ab + 2.0 * d * (sa - sb)) / 8.0;\n        if (std::abs(tmp_rlr) &gt; 1.0)\n            return std::nullopt;\n\n        const double p = mod2pi(2 * M_PI - std::acos(tmp_rlr));\n        const double t = mod2pi(alpha - std::atan2(ca - cb, d - sa + sb) + mod2pi(p / 2.0));\n        const double q = mod2pi(alpha - beta - t + mod2pi(p));\n        return PlanningResult{t, p, q, Mode::LRL};\n    }\n\n    std::optional&lt;PlanningResult&gt; LRL(double alpha, double beta, double d)\n    {\n        const double sa = std::sin(alpha);\n        const double sb = std::sin(beta);\n        const double ca = std::cos(alpha);\n        const double cb = std::cos(beta);\n        const double c_ab = std::cos(alpha - beta);\n\n        const double tmp_lrl = (6.0 - d * d + 2 * c_ab + 2 * d * (- sa + sb)) / 8.0;\n        if (std::abs(tmp_lrl) &gt; 1)\n            return std::nullopt;\n        const double p = mod2pi(2 * M_PI - std::acos(tmp_lrl));\n        const double t = mod2pi(-alpha - std::atan2(ca - cb, d + sa - sb) + p / 2.);\n        const double q = mod2pi(mod2pi(beta) - alpha - t + mod2pi(p));\n\n        return PlanningResult{t, p, q, Mode::LRL};\n    }\n\n    double mod2pi(double theta)\n    {\n        return theta - 2.0 * M_PI * std::floor(theta / 2.0 / M_PI);\n    }\n\n    enum class SegmentType\n    {\n        L, S, R, NONE\n    };\n\n    void build_pos_function()\n    {\n        Transformd start = start_;\n        for(size_t i = 0; i &lt; 3; i++)\n        {\n            switch(get_segment_type(i))\n            {\n                case SegmentType::L:\n                    {\n                        pos_func_list_[i] = [this, start](double len)\n                        {\n                            const double r = 1/cavature_;\n                            const double theta = len/r;\n\n                            Vector2d rot_origin = start.make_vector2() + Vector2d(r,0).get_rotated(start.theta + M_PI/2);\n\n                            Transformd pos = start;\n                            pos.rotate(rot_origin, theta);\n                            pos.theta += theta;\n                            return pos;\n                        };\n                    }\n                    break;\n\n                case SegmentType::R:\n                    {\n                        pos_func_list_[i] = [this, start](double len)\n                        {\n                            const double r = 1/cavature_;\n                            const double theta = len/r;\n                            Vector2d rot_origin = start.make_vector2() + Vector2d(r,0).get_rotated(start.theta - M_PI/2);\n\n                            Transformd pos = start;\n                            pos.rotate(rot_origin, -theta);\n                            pos.theta += -theta;\n                            return pos;\n                        };\n                    }\n                    break;\n\n                case SegmentType::S:\n                    {\n                        pos_func_list_[i] = [this, start](double len)\n                        {\n                            Transformd diff(Vector2d(len,0).get_rotated(start.theta), 0);\n                            return start + diff;\n                        };\n                    }\n                    break;\n\n                default:\n                    pos_func_list_[i] = [this](double len)\n                    {\n                        (void) len;\n                        return start_;\n                    };\n            }\n            start = pos_func_list_[i](segment_length(i));\n        }\n    }\n\n    SegmentType get_segment_type(size_t seg)\n    {\n        switch(seg)\n        {\n            case 0:\n                {\n                    switch(plan_.mode)\n                    {\n                        case Mode::LRL:\n                        case Mode::LSL:\n                        case Mode::LSR:\n                            return SegmentType::L;\n                        case Mode::RLR:\n                        case Mode::RSL:\n                        case Mode::RSR:\n                            return SegmentType::R;\n                        default:\n                            return SegmentType::NONE;\n                    }\n                }\n                break;\n\n            case 1:\n                {\n                    switch(plan_.mode)\n                    {\n                        case Mode::RLR:\n                            return SegmentType::L;\n                        case Mode::LRL:\n                            return SegmentType::R;\n                        case Mode::LSL:\n                        case Mode::LSR:\n                        case Mode::RSL:\n                        case Mode::RSR:\n                            return SegmentType::S;\n                        default:\n                            return SegmentType::NONE;\n                    }\n                }\n                break;\n\n            case 2:\n                {\n                    switch(plan_.mode)\n                    {\n                        case Mode::LRL:\n                        case Mode::LSL:\n                        case Mode::RSL:\n                            return SegmentType::L;\n                        case Mode::RLR:\n                        case Mode::LSR:\n                        case Mode::RSR:\n                            return SegmentType::R;\n                        default:\n                            return SegmentType::NONE;\n                    }\n                }\n                break;\n\n            default:\n                return SegmentType::NONE;\n        }\n\n    }\n\nprivate:\n    Transformd start_, end_;\n    double cavature_;\n\n    PlanningResult plan_;\n    double all_length_ = 0;\n    std::array&lt;std::function&lt;Transformd(double)&gt;, 3&gt; pos_func_list_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/dynamics__integrate_8hpp/","title":"include/cpp_robotics/system/dynamics_integrate.hpp","text":""},{"location":"doxybook/Files/dynamics__integrate_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/dynamics__integrate_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class T&gt;\nstatic T integrate_forward_euler(double dt, const T &amp;x, const T &amp;u, std::function&lt;T(const T&amp;, const T&amp;)&gt; dynamics)\n{\n    return x + dt*dynamics(x, u);\n}\n\ntemplate&lt;class T&gt;\nstatic T integrate_modified_euler(double dt, const T &amp;x, const T &amp;u, std::function&lt;T(const T&amp;, const T&amp;)&gt; dynamics)\n{\n    T k1 = dynamics(x, u);\n    T k2 = dynamics(x+dt*k1, u);\n\n    return x + dt*(k1+k2)/2;\n}\n\ntemplate&lt;class T&gt;\nstatic T integrate_rk4(double dt, const T &amp;x, const T &amp;u, std::function&lt;T(const T&amp;, const T&amp;)&gt; dynamics)\n{\n    T k1 = dynamics(x, u);\n    T k2 = dynamics(x + dt / 2 * k1, u);\n    T k3 = dynamics(x + dt / 2 * k2, u);\n    T k4 = dynamics(x + dt * k3, u);\n    return x + dt / 6 * (k1 + 2 * k2 + 2 * k3 + k4);\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/eigen__utils_8hpp/","title":"include/cpp_robotics/utility/eigen_utils.hpp","text":""},{"location":"doxybook/Files/eigen__utils_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/eigen__utils_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\n// \u884c\u5217\u304c\u6b63\u5b9a\u5024\u304b\u3069\u3046\u304b\ntemplate&lt;typename MatrixType&gt;\nbool isPositiveDefinite(const MatrixType&amp; matrix) {\n    Eigen::LLT&lt;MatrixType&gt; llt(matrix);\n    if(llt.info() == Eigen::NumericalIssue) {\n        return false;\n    }\n    return true;\n}\n\n// \u7591\u4f3c\u9006\u884c\u5217\ntemplate&lt;typename MatrixType&gt;\nMatrixType pseudo_inverse(const MatrixType &amp;a, double epsilon = std::numeric_limits&lt;double&gt;::epsilon()) //, Eigen::MatrixXd W = Eigen::MatrixXd())\n{\n    unsigned int svd_option;\n    if (a.rows() == a.cols())\n    {\n        svd_option = Eigen::ComputeFullU | Eigen::ComputeFullV; // for square matrix\n    }\n    else\n    {\n        svd_option = Eigen::ComputeThinU | Eigen::ComputeThinV; // for non-square matrix\n    }\n\n    Eigen::JacobiSVD&lt; MatrixType &gt; svd(a ,svd_option);\n    double tolerance = epsilon * std::max(a.cols(), a.rows()) *svd.singularValues().array().abs()(0);\n    return svd.matrixV() *  (svd.singularValues().array().abs() &gt; tolerance).select(svd.singularValues().array().inverse(), 0).matrix().asDiagonal() * svd.matrixU().adjoint();\n}\n\n// Singularity-Robust Inverse SR\u9006\u884c\u5217\ntemplate&lt;typename MatrixType&gt;\nMatrixType sr_inverse(const MatrixType &amp;a, double w0 = 1e-2, Eigen::MatrixXd W = Eigen::MatrixXd())\n{\n    auto r = a.rows();\n    auto c = a.cols();\n    if(W.rows() != c|| W.cols() != c)\n    {\n        W = Eigen::MatrixXd::Identity(c,c);\n    }\n\n    double w = std::sqrt((a*(a.transpose())).determinant());\n\n    double lambda = 0;\n    if(w &lt; w0)\n        lambda = std::pow((1-w/w0),2);\n\n    auto a1 = (a*W*(a.transpose()) + lambda * Eigen::MatrixXd::Identity(r,r)).inverse();\n    Eigen::MatrixXd a_sr = W*a.transpose()*a1;\n\n    return a_sr;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/","title":"include/cpp_robotics/filter/extended_kalman_filter.hpp","text":""},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::ExtendedKalmanFilter"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;optional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/optimize/derivative.hpp\"\n\nnamespace cpp_robotics\n{\n\n/*\n[\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf]\n- \u4e88\u6e2c\n    \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\n    x = f(x, u)\n\n    \u30e2\u30c7\u30eb\u7dda\u5f62\u8fd1\u4f3c\n    F = \\partial f(x,u) / \\partial x | x=x, u=u\n    H = \\partial h(x) / \\partial x | x=x\n\n    \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = FPF^T + Q\n\n- \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\n    S = HPH^T + R\n    K = PH^T(S)^-1\n\n    \u72b6\u614b\u63a8\u5b9a\n    x = x + K(z - h(x))\n\n    \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = P - KST^T\n*/\n\nclass ExtendedKalmanFilter\n{\npublic:\n    Eigen::VectorXd x;\n    Eigen::MatrixXd F;\n    Eigen::MatrixXd B;\n    Eigen::MatrixXd H;\n    Eigen::MatrixXd Q;\n    Eigen::MatrixXd R;\n    Eigen::MatrixXd P;\n\n    ExtendedKalmanFilter(const double dt, size_t input_size, size_t state_size, size_t observe_size, std::optional&lt;double&gt; correction_threshold = std::nullopt):\n        dt_(dt), input_size_(input_size), state_size_(state_size), observe_size_(observe_size), mn_threshold_(correction_threshold)\n    {\n        x = Eigen::VectorXd::Zero(state_size_);\n        F = Eigen::MatrixXd::Zero(state_size, state_size);\n        B = Eigen::MatrixXd::Zero(state_size, input_size);\n        H = Eigen::MatrixXd::Zero(observe_size, state_size);\n        Q = Eigen::MatrixXd::Zero(state_size, state_size);\n        R = Eigen::MatrixXd::Zero(observe_size, observe_size);\n        P = Eigen::MatrixXd::Zero(state_size, state_size);\n    };\n\n    void reset(Eigen::VectorXd new_x, Eigen::MatrixXd new_P)\n    {\n        x = new_x;\n        P = new_P;\n    }\n\n    Eigen::VectorXd filtering(Eigen::VectorXd u, Eigen::VectorXd z)\n    {\n        system_noise_conv(Q, x, u);\n        observe_noise_conv(R, x, z);\n        linearized_system_matrix(F, x, u);\n        linearized_observe_matrix(H, x, z);\n\n        // \u72b6\u614b\u4e88\u6e2c\n        x = system(x, u);\n\n        // \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217\n        P = F*P*F.transpose() + Q;\n\n        // \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97\n        Eigen::MatrixXd S = H*P*H.transpose() + R;\n        Eigen::MatrixXd K = P*H.transpose()*S.inverse();\n\n        // \u72b6\u614b\u66f4\u65b0\n        Eigen::VectorXd xdiff = K*(z - observe(x));\n        double mahalanobis_distance = std::sqrt( xdiff.dot( P.inverse()*xdiff ) );\n        if(not mn_threshold_ || (mn_threshold_ &amp;&amp; mahalanobis_distance &lt; mn_threshold_.value()))\n        {\n            x += xdiff;\n            // \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n            P -= K*S*K.transpose();\n        }\n\n        return x;\n    }\n\n    double dt() const { return dt_; }\n    Eigen::VectorXd get_x() const { return x; }\n    Eigen::MatrixXd get_P() const { return P; }\n\n    virtual Eigen::VectorXd system(Eigen::VectorXd x, Eigen::VectorXd u) = 0;\n\n    virtual Eigen::VectorXd observe(Eigen::VectorXd x) = 0;\n\n    virtual void system_noise_conv(Eigen::MatrixXd &amp;Q, Eigen::VectorXd x, Eigen::VectorXd u) = 0;\n\n    virtual void observe_noise_conv(Eigen::MatrixXd &amp;R, Eigen::VectorXd x, Eigen::VectorXd z) = 0;\n\n    virtual void linearized_system_matrix(Eigen::MatrixXd &amp;F, Eigen::VectorXd x, Eigen::VectorXd u)\n    {\n        F = derivative([&amp;](const Eigen::VectorXd &amp;x_dash){ return system(x_dash, u); }, x);\n    };\n\n    virtual void linearized_observe_matrix(Eigen::MatrixXd &amp;H, Eigen::VectorXd x, Eigen::VectorXd z)\n    {\n        (void) z;\n        H = derivative(std::bind(&amp;ExtendedKalmanFilter::observe, this, std::placeholders::_1), x);\n    }\n\nprotected:\n    // \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593[s]\n    const double dt_;\n\n    const size_t input_size_;\n    const size_t state_size_;\n    const size_t observe_size_;\n    std::optional&lt;double&gt; mn_threshold_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/filter_8hpp/","title":"include/cpp_robotics/filter.hpp","text":""},{"location":"doxybook/Files/filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"filter/low_pass_filter.hpp\"\n#include \"filter/differentiator.hpp\"\n#include \"filter/integrator.hpp\"\n#include \"filter/low_pass_filter.hpp\"\n#include \"filter/high_pass_filter.hpp\"\n#include \"filter/notch_filter.hpp\"\n#include \"filter/band_pass_filter.hpp\"\n#include \"filter/delay_filter.hpp\"\n#include \"filter/velocity_limit_filter.hpp\"\n#include \"filter/acceleration_limit_filter.hpp\"\n#include \"filter/filter_state_holder.hpp\"\n// #include \"filter/kalman_filter.hpp\"\n\n// // \u6642\u9593\u304b\u304b\u308b\n// #include \"filter/extended_kalman_filter.hpp\" // +2.3s\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/filter__state__holder_8hpp/","title":"include/cpp_robotics/filter/filter_state_holder.hpp","text":""},{"location":"doxybook/Files/filter__state__holder_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/filter__state__holder_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9"},{"location":"doxybook/Files/filter__state__holder_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;optional&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class BASE_FILTER_TYPE&gt;\nclass FilterStateHolder : public BASE_FILTER_TYPE\n{\npublic:\n    using BASE_FILTER_TYPE::BASE_FILTER_TYPE;\n    void set_input(double u)\n    {\n        u_ = u;\n    }\n\n    double filtering()\n    {\n        y_ = BASE_FILTER_TYPE::filtering(u);\n        return y_;\n    }\n\n    double u() const { return u_; }\n    double y() const { return y_; }\nprivate:\n    double u_ = 0, y_ = 0;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/geometry_8hpp/","title":"include/cpp_robotics/geometry.hpp","text":""},{"location":"doxybook/Files/geometry_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"geometry/shape.hpp\"\n#include \"geometry/intersect.hpp\"\n#include \"geometry/geometry_stream.hpp\"\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/geometry__stream_8hpp/","title":"include/cpp_robotics/geometry/geometry_stream.hpp","text":""},{"location":"doxybook/Files/geometry__stream_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/geometry__stream_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;iostream&gt;\n#include \"../vector/vector2.hpp\"\n#include \"../vector/vector3.hpp\"\n#include \"../vector/vector4.hpp\"\n#include \"../vector/transform.hpp\"\n\nnamespace cpp_robotics\n{\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Vector2d&amp; v)\n{\n    os &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \")\";\n    return os;\n}\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Vector3d&amp; v)\n{\n    os &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z &lt;&lt; \")\";\n    return os;\n}\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Vector4d&amp; v)\n{\n    os &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z &lt;&lt; \", \" &lt;&lt; v.w &lt;&lt; \")\";\n    return os;\n}\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Transformd&amp; v)\n{\n    os &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.theta &lt;&lt; \")\";\n    return os;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/golden__serach_8hpp/","title":"include/cpp_robotics/optimize/golden_serach.hpp","text":""},{"location":"doxybook/Files/golden__serach_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/golden__serach_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics \n{\n\nstatic double golden_search(std::function&lt;double(double)&gt; f, double low, double high, const double tol = 1e-6, const size_t max_iter = 100)\n{\n    constexpr double r = (-1.0 + std::sqrt(5)) / 2.0;\n    double a1 = low + (1.0 - r) * (high - low);\n    double a2 = low + (r) * (high - low);\n    double f1 = f(a1);\n    double f2 = f(a2);\n\n    for(size_t i = 0; i &lt; max_iter; i++)\n    {\n        if(std::abs(high - low) &lt; tol)\n            return 0.5 * (low + high);\n\n        if(f1 &lt; f2)\n        {\n            high = a2;\n            a2 = a1;\n            a1 = low + (1.0 - r) * (high - low);\n            f2 = f1;\n            f1 = f(a1);\n        }\n        else\n        {\n            low = a1;\n            a1 = a2;\n            a2 = low + (r) * (high - low);\n            f1 = f2;\n            f2 = f(a2);\n        }\n    }\n    return 0.5 * (low + high);\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/","title":"include/cpp_robotics/path_planning/grid_path_planning_utils.hpp","text":""},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::grid_path_planning_utils::GridNode"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics::grid_path_planning_utils\n{\n\nstruct GridNode\n{\n    GridNode():\n        cost(0), hcost(0)\n    {\n        pos.setZero();\n        parent.setZero();\n    }\n    bool operator == (const GridNode&amp; o ) { return pos == o.pos; }\n    bool operator == (const Eigen::Vector2i&amp; o ) { return pos == o; }\n    bool operator &lt; (const GridNode&amp; o ) { return hcost + cost &lt; o.hcost + o.cost; }\n    Eigen::Vector2i pos, parent;\n    int cost, hcost;\n    int score() { return cost + hcost; }\n};\n\nstatic bool contain_in_map(const Eigen::MatrixXi&amp; map, const Eigen::Vector2i&amp; p)\n{\n    if(0 &lt;= p(0) &amp;&amp; p(0) &lt; map.rows() &amp;&amp; 0 &lt;= p(1) &amp;&amp; p(1) &lt; map.cols())\n        return true;\n    return false;\n}\n\nstatic int dist(const Eigen::Vector2i&amp; pos, const Eigen::Vector2i&amp; end)\n{\n    const Eigen::Vector2i d = end - pos;\n    return std::min(std::abs(d(0)) , std::abs(d(0))); // 8\u65b9\u5411\u79fb\u52d5\u3092\u60f3\u5b9a https://qiita.com/2dgames_jp/items/f29e915357c1decbc4b7#%E6%8E%A2%E7%B4%A2%E3%82%92%E9%96%8B%E5%A7%8B\n}\n\ntemplate&lt;typename T&gt;\nbool in_range_open(T x, T min, T max) \n{\n    return ((min &lt; x &amp;&amp; x &lt; max) ? true : false);\n}\n\nbool is_valid(const Eigen::Vector2i&amp; pos, size_t row, size_t col)\n{\n    if(in_range_open&lt;int&gt;(pos(0), -1, row) &amp;&amp; in_range_open&lt;int&gt;(pos(1), -1, col))\n        return true;\n    return false;\n}\n\nbool is_wall(const Eigen::Vector2i&amp; pos, size_t row, size_t col)\n{\n    if(in_range_open&lt;int&gt;(pos(0), -1, row) &amp;&amp; in_range_open&lt;int&gt;(pos(1), -1, col))\n        return true;\n    return false;\n}\n\nbool is_correct_step(const Eigen::Vector2i&amp; pos, const Eigen::MatrixXi&amp; map)\n{\n    if(is_valid(pos, map.rows(), map.cols()))\n    {\n        if(not map(pos(0), pos(1)))\n            return true;\n    }\n    return false;\n}\n\nbool exist(std::list&lt;GridNode&gt; &amp;open, std::list&lt;GridNode&gt; &amp;closed, const Eigen::Vector2i&amp; p, int cost) {\n    std::list&lt;GridNode&gt;::iterator i;\n    i = std::find( closed.begin(), closed.end(), p );\n    if( i != closed.end() ) { // \u65e2\u306bclosed\u5185\u306b\u5b58\u5728\u3059\u308b\n        if( ( *i ).cost + ( *i ).hcost &lt; cost ) return true; // \u5b58\u5728\u3059\u308b\u306e\u3067true\u3092\u8fd4\u3059\n        else { closed.erase( i ); return false; } // \u5b58\u5728\u3059\u308b\u304c\u65b0\u3057\u304f\u898b\u3064\u304b\u3063\u305f\u307b\u3046\u304c\u30b3\u30b9\u30c8\u304c\u5c0f\u3055\u3044\u306e\u3067\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u306b\u6d88\u3057\u3066\u3001false\u3092\u8fd4\u3059\n    }\n    i = std::find( open.begin(), open.end(), p );\n    if( i != open.end() ) { // open\u5185\u306b\u5b58\u5728\u3059\u308b\n        if( ( *i ).cost + ( *i ).hcost &lt; cost ) return true; // \u4e0a\u306b\u540c\u3058\n        else { open.erase( i ); return false; }\n    }\n    return false; // \u5b58\u5728\u3057\u306a\u3044\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/high__pass__filter_8hpp/","title":"include/cpp_robotics/filter/high_pass_filter.hpp","text":""},{"location":"doxybook/Files/high__pass__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/high__pass__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/high__pass__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n// G(s) = s / (s + omega)\n// \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e\nclass HighPassFilter: public TransferFunction\n{\npublic:\n    HighPassFilter(double omega, double dt):\n        omega_(omega)\n    {\n        TransferFunction::set_continuous({1, 0}, {1, omega_}, dt);\n    }\n\n    double filtering(double u) { return responce(u); } \n\n    double omega() const { return omega_; }\nprivate:\n    const double omega_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/icp_8hpp/","title":"include/cpp_robotics/algorithm/icp.hpp","text":""},{"location":"doxybook/Files/icp_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/icp_8hpp/#source-code","title":"Source code","text":"<pre><code>// https://clientver2.hatenablog.com/entry/2015/11/27/160814\n// http://nghiaho.com/?page_id=671\n\n#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"./kdtree.hpp\"\n#include \"./transformation.hpp\"\n\nnamespace cpp_robotics\n{\n\n// dest\u3092\u56de\u8ee2\u3055\u305b\u3066src\u306b\u91cd\u306d\u308b\u6642\u306e\u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u8a08\u7b97\u3059\u308b\ntemplate&lt;int DIM&gt;\nstatic std::pair&lt;Eigen::Matrix&lt;double, DIM, DIM&gt;, Eigen::Matrix&lt;double, DIM, 1&gt;&gt; \n    calcu_transformatoin(\n        std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; dest,\n        std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; fixed)\n{\n    assert(fixed.size() == dest.size());\n    using vector_type = Eigen::Matrix&lt;double, DIM, 1&gt;;\n    using matrix_type = Eigen::Matrix&lt;double, DIM, DIM&gt;;\n\n    const size_t dim = dest[0].size();\n    const size_t len = fixed.size();\n\n    // detrend\n    vector_type mean_fixed = vector_type::Zero();\n    vector_type mean_dest = vector_type::Zero();\n    for(auto &amp; v : fixed)\n        mean_fixed += v/static_cast&lt;double&gt;(len);\n    for(auto &amp; v : fixed)\n        v -= mean_fixed;\n\n    for(auto &amp; v : dest)\n        mean_dest += v/static_cast&lt;double&gt;(len);\n    for(auto &amp; v : dest)\n        v -= mean_dest;\n\n    // \u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u6c42\u3081\u308b\n    Eigen::Matrix&lt;double, DIM, DIM&gt; H = Eigen::Matrix&lt;double, DIM, DIM&gt;::Zero();\n\n    for(size_t i = 0; i &lt; len; i++)\n    {\n        H += dest[i] * fixed[i].transpose(); \n    }\n\n    Eigen::JacobiSVD svd(H, Eigen::ComputeFullU | Eigen::ComputeFullV);\n\n    matrix_type R = svd.matrixV() * svd.matrixU().transpose();\n    vector_type T = (-R*mean_dest) + mean_fixed;\n    return {R, T};\n}\n\n// Todo: R, T\u3092\u8fd4\u3059\u3088\u3046\u306b\u3059\u308b\n// Todo: \u7d42\u4e86\u6761\u4ef6\u3064\u3051\u308b\ntemplate&lt;int DIM&gt;\nstatic std::tuple&lt;std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt;, Eigen::MatrixXd, size_t&gt; \n    icp(\n        std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; dest,\n        const std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; &amp;fixed,\n        double eps = 1e-4,\n        size_t max_iter = 100) \n{\n    const size_t dim = dest[0].size();\n    KDTree&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; kdtree(fixed, dim);\n    Eigen::MatrixXd H = Eigen::MatrixXd::Identity(dim+1, dim+1);\n\n    size_t i = 0;\n    for(; i &lt; max_iter; i++)\n    {\n        // \u70b9\u7fa4\u73fe\u5728\u306e\u72b6\u614b\u3067\u70b9\u7fa4\u306e\u5bfe\u5fdc\u3092\u53d6\u308b\n        auto nerghbor_idx = kdtree.nn_search(dest);\n        std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; target(nerghbor_idx.size());\n        for(size_t j = 0; j &lt; nerghbor_idx.size(); j++)\n        {\n            // std::cout &lt;&lt; nerghbor_idx[j] &lt;&lt; std::endl;\n            target[j] = fixed[nerghbor_idx[j]];\n            // target[j] = fixed[j]; // debug\n        }\n\n        // \u70b9\u7fa4\u306e\u5bfe\u5fdc\u3067\u79fb\u52d5\u91cf\u3092\u8a08\u7b97\u3059\u308b\n        auto [R, T] = calcu_transformatoin(dest, target);\n\n        // \u79fb\u52d5\u3055\u305b\u308b\n        for(size_t j = 0; j &lt; dest.size(); j++)\n        {\n            dest[j] = R*dest[j] + T;\n        }\n\n        // homogeneous transformation\u884c\u5217\u306e\u66f4\u65b0\n        Eigen::MatrixXd Ht = homogeneous(R, T);\n        H *= Ht;\n\n        // \u53ce\u675f\u5224\u5b9a\n    }\n    return {dest, H, i};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/ilqr_8hpp/","title":"include/cpp_robotics/controller/ilqr.hpp","text":""},{"location":"doxybook/Files/ilqr_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/ilqr_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::iLQRConfig class cpp_robotics::iLQR"},{"location":"doxybook/Files/ilqr_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"optimal_control_problem.hpp\"\n\nnamespace cpp_robotics\n{\n\nstruct iLQRConfig\n{\n    size_t max_iter = 100;\n\n    // cost torelance\n    double cost_torelance = 1e-3;\n\n    // forward pass line search stopping criteria\n    double beta1 = 1e-4;\n    double beta2 = 10.0;\n\n    // forward pass update rate\n    double alpha_scale = 0.5;\n    size_t max_forward_itr = 10;\n\n    // finite difference step\n    double eps = 1e-4;\n};\n\nclass iLQR\n{\npublic:\n    enum class Result\n    {\n        SUCCESS = 0,\n        MAX_ITER_REACHED,\n        FAILED\n    };\n\n    iLQR(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost, iLQRConfig config = iLQRConfig()):\n        iLQR(OptimalControlProblem(dynamics, cost), config) {}\n\n    // Note: constraints are ignored\n    iLQR(const OptimalControlProblem &amp;prob, iLQRConfig config = iLQRConfig()):\n        prob_(prob), config_(config)\n    {\n        // setup workspace\n        U.resize(prob_.horizon());\n        tmpU.resize(prob_.horizon());\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            U[i].setZero(prob_.input_size());\n            tmpU[i].setZero(prob_.input_size());\n        }\n        X.resize(prob_.horizon() + 1);\n        tmpX.resize(prob_.horizon() + 1);\n        for(size_t i = 0; i &lt; prob_.horizon() + 1; i++)\n        {\n            X[i].setZero(prob_.state_size());\n            tmpX[i].setZero(prob_.state_size());\n        }\n        K.resize(prob_.horizon());\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            K[i].setZero(prob_.input_size(), prob_.state_size());\n        }\n        d.resize(prob_.horizon());\n        for(size_t i = 0; i &lt; prob_.horizon(); i++)\n        {\n            d[i].setZero(prob_.input_size());\n        }\n\n        fx.setZero(prob_.state_size(), prob_.state_size());\n        fu.setZero(prob_.state_size(), prob_.input_size());\n    }\n\n    Result generate_trajectory(const Eigen::VectorXd &amp;x0)\n    {\n        rollout_trajectory(x0);\n\n        double J = total_cost(X, U);\n        for(size_t itr = 0; itr &lt; config_.max_iter; ++itr)\n        {\n            bool backward_done = backward_pass();\n            double new_J = forward_pass(x0, J);\n            if(std::abs(new_J - J) &lt; config_.cost_torelance)\n            {\n                return Result::SUCCESS;\n            }\n            J = new_J;\n        }\n\n        return Result::MAX_ITER_REACHED;\n    }\n\n    const std::vector&lt;Eigen::VectorXd&gt; &amp;get_input() const { return U; }\n    const std::vector&lt;Eigen::VectorXd&gt; &amp;get_state() const { return X; }\n\nprivate:\n    void rollout_trajectory(const Eigen::VectorXd &amp;x0)\n    {\n        X[0] = x0;\n        for (size_t i = 0; i &lt; prob_.horizon(); ++i)\n        {\n            X[i + 1] = prob_.dynamics-&gt;eval(X[i], U[i]);\n        }\n    }\n\n    double total_cost(std::vector&lt;Eigen::VectorXd&gt; &amp;X, std::vector&lt;Eigen::VectorXd&gt; &amp;U)\n    {\n        double J = 0.0;\n        for (size_t i = 0; i &lt; prob_.horizon(); ++i)\n        {\n            J += prob_.cost-&gt;eval(X[i], U[i], i);\n        }\n        J += prob_.cost-&gt;eval_terminal(X[prob_.horizon()]);\n        return J;\n    }\n\n    bool backward_pass()\n    {\n        auto &amp;constraints = prob_.constraints;\n        Vx = prob_.cost-&gt;jacobian_x_terminal(X.back());\n        Vxx = prob_.cost-&gt;hessian_xx_terminal(X.back());\n\n        dV1 = 0.0;\n        dV2 = 0.0;\n        Eigen::MatrixXd Quu_inv;\n        for(int i = static_cast&lt;int&gt;(prob_.horizon()) - 1; i &gt;= 0; i--)\n        {\n            // Eigen::MatrixXd fx = diff.fx(X[i], U[i]);\n            // Eigen::MatrixXd fu = diff.fu(X[i], U[i]);\n            fx = prob_.dynamics-&gt;jacobian_x(X[i], U[i]);\n            fu = prob_.dynamics-&gt;jacobian_u(X[i], U[i]);\n\n            Qx  = prob_.cost-&gt;jacobian_x(X[i], U[i], i) + fx.transpose() * Vx;\n            Qu  = prob_.cost-&gt;jacobian_u(X[i], U[i], i) + fu.transpose() * Vx;\n            Qxx = prob_.cost-&gt;hessian_xx(X[i], U[i], i) + fx.transpose() * Vxx * fx;\n            Quu = prob_.cost-&gt;hessian_uu(X[i], U[i], i) + fu.transpose() * Vxx * fu;\n            Qux = prob_.cost-&gt;hessian_ux(X[i], U[i], i) + fu.transpose() * Vxx * fx;\n\n            // du = K*dx + d\n            // \u5236\u7d04\u304c\u306a\u3044\u5834\u5408\n            Quu_inv = Quu.inverse();\n            K[i] = -Quu_inv * Qux;\n            d[i] = -Quu_inv * Qu;\n\n            // update Vx, Vxx\n            Vxx = Qxx + (K[i].transpose()*Quu*K[i]) + K[i].transpose()*Qux + Qux.transpose()*K[i];\n            Vx = Qx + K[i].transpose()*Quu*d[i] + K[i].transpose()*Qu + Qux.transpose()*d[i];\n\n            // calclate dV1, dV2\n            dV1 += (d[i].transpose()*Qu)[0];\n            dV2 += (0.5*d[i].transpose()*Quu*d[i])[0];\n        }\n\n        return true;\n    }\n\n    double forward_pass(const Eigen::VectorXd &amp;x0, const double J)\n    {\n        double alpha = 1.0;\n\n        tmpX[0] = x0;\n        for(size_t j = 0; j &lt; config_.max_forward_itr; j++)\n        {\n            for(size_t i = 0; i &lt; prob_.horizon(); i++)\n            {\n                tmpU[i] = U[i] + K[i]*(tmpX[i]-X[i]) + alpha * d[i];\n\n                // rollout\n                tmpX[i + 1] = prob_.dynamics-&gt;eval(tmpX[i], tmpU[i]);\n            }\n\n            double new_J = total_cost(tmpX, tmpU);\n            double dV1_ = alpha * dV1;\n            double dV2_ = alpha*alpha * dV2;\n            double z = (new_J - J) / (dV1_ + dV2_);\n            // line search\n            if (config_.beta1 &lt;= z &amp;&amp; z &lt;= config_.beta2)\n            {\n                U = tmpU;\n                X = tmpX;\n                return new_J; // update\n            }\n            alpha *= config_.alpha_scale;\n        }\n        return J; // already optimal\n    }\n\n    const OptimalControlProblem prob_;\n    iLQRConfig config_;\n\n    // workspace\n    std::vector&lt;Eigen::VectorXd&gt; U, X, tmpU, tmpX;\n    std::vector&lt;Eigen::MatrixXd&gt; K;\n    std::vector&lt;Eigen::VectorXd&gt; d;\n    Eigen::VectorXd Vx;\n    Eigen::MatrixXd Vxx;\n    Eigen::MatrixXd Qx, Qu, Qxx, Quu, Qux, Quxu;\n    Eigen::MatrixXd fx, fu;\n    double dV1, dV2;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/integrator_8hpp/","title":"include/cpp_robotics/filter/integrator.hpp","text":""},{"location":"doxybook/Files/integrator_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/integrator_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Integrator \u7a4d\u5206\u5668"},{"location":"doxybook/Files/integrator_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n// G(s) = 1 / s\n// \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e\nclass Integrator : public TransferFunction\n{\npublic:\n    Integrator(double dt)\n    {\n        TransferFunction::set_continuous({1}, {1, 0}, dt);\n    }\n\n    double filtering(double u) { return responce(u); } \n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/intersect_8hpp/","title":"include/cpp_robotics/geometry/intersect.hpp","text":""},{"location":"doxybook/Files/intersect_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/intersect_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;optional&gt;\n#include \"./shape.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace detail\n{\n    static double distance_sq(const Vector2d &amp;begin, const Vector2d &amp;end, const Vector2d &amp;p)\n    {\n        const double l2 = (begin - end).norm_sq();\n\n        if (l2 == 0.0)\n        {\n            return (begin - p).norm_sq();\n        }\n\n        const double t = std::clamp&lt;double&gt;((p - begin).dot(end - begin) / l2, 0.0, 1.0);\n\n        const Vector2d projection = begin + t * (end - begin);\n\n        return (p - projection).norm_sq();\n    }\n}\n\nbool intersect(const Vector2d&amp; a, const Vector2d&amp; b)\n{\n    return (a == b);\n}\n\nbool intersect(const Vector2d&amp; a, const Line&amp; b)\n{\n    return approx_zero(detail::distance_sq(b.p0, b.p1, a));\n}\n\nbool intersect(const Vector2d&amp; a, const Rect&amp; b)\n{\n    const auto tv = b.size/2;\n    return ((b.center.x-tv.x &lt; a.x &amp;&amp; a.x &lt; b.center.x+tv.x) &amp;&amp;\n            (b.center.y-tv.y &lt; a.y &amp;&amp; a.y &lt; b.center.y+tv.y));\n}\n\nbool intersect(const Vector2d&amp; a, const Circle&amp; b)\n{\n    return (b.center-a).norm_sq() &lt;= square(b.r);\n}\n\n// bool intersect(const Vector2d&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Vector2d&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n\nbool intersect(const Line&amp; a, const Vector2d&amp; b)\n{\n    return intersect(b, a);\n}\n\n// bool intersect(const Line &amp;a, const Line &amp;b)\n// {\n//     return false; // Todo\n// }\n\nbool intersect(const Line&amp; a, const Circle&amp; b)\n{\n    const Vector2d ab = a.p1 - a.p0;\n    const Vector2d ac = b.center - a.p0;\n    const Vector2d bc = b.center - a.p1;\n    const double e = ac.dot(ab);\n    const double rr = b.r * b.r;\n\n    if (e &lt;= 0.0)\n    {\n        return ac.dot(ac) &lt;= rr;\n    }\n\n    const double f = ab.dot(ab);\n\n    if (e &gt;= f)\n    {\n        return bc.dot(bc) &lt;= rr;\n    }\n\n    return (ac.dot(ac) - e * e / f) &lt;= rr;\n}\n\n// bool intersect(const Line&amp; a, const Rect&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Line&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Line&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\nbool intersect(const Rect&amp; a, const Vector2d&amp; b)\n{\n    return intersect(b, a); \n}\n\n// bool intersect(const Rect&amp; a, const Line&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Rect&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Circle&amp; b)\n// {\n//     return false; // Todo\n// }\n\nbool intersect(const Circle&amp; a, const Vector2d&amp; b)\n{\n    return intersect(b, a);\n}\n\n// bool intersect(const Circle&amp; a, const Line&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Rect&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Circle&amp; b)\n// {\n//     return false; // Todo\n// }\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Vector2d&amp; b)\n{\n    if(a == b)\n        return std::vector&lt;Vector2d&gt;{a};\n    return std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Line&amp; b)\n{\n    double l = detail::distance_sq(b.p0, b.p1, a);\n    if(approx_zero(l))\n        return std::vector&lt;Vector2d&gt;{a};\n    return std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Rect&amp; b)\n{\n    for(auto &amp;line : b.outline())\n    {\n        auto v = intersect_at(a, line);\n        if(v)\n            return v;\n    }\n    return std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Circle&amp; b)\n{\n    if(approx_eq((b.center - a).norm(), b.r))\n        return std::vector&lt;Vector2d&gt;{a};\n    return std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Line&amp; a, const Vector2d&amp; b)\n{\n    return intersect_at(b, a);\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Line&amp; a, const Line&amp; b)\n{\n    const Vector2d r = a.p1 - a.p0;\n    const Vector2d s = b.p1 - b.p0;\n    const Vector2d qp = b.p0 - a.p0;\n    const double rxs = r.x * s.y - r.y * s.x;\n    const double qpxr = qp.x * r.y - qp.y * r.x;\n    const double qpxs = qp.x * s.y - qp.y * s.x;\n    const bool rxs_is_zero = approx_zero(rxs);\n\n    if (rxs_is_zero &amp;&amp; approx_zero(qpxr))\n    {\n        const double qpr = qp.dot(r);\n        const double pqs = (a.p0 - b.p0).dot(s);\n        if ((0 &lt;= qpr &amp;&amp; qpr &lt;= r.dot(r)) || (0 &lt;= pqs &amp;&amp; pqs &lt;= s.dot(s)))\n        {\n            // Two lines are overlapping            \n            return std::nullopt;\n        }\n        // Two lines are collinear but disjoint.\n        return std::nullopt;\n    }\n\n    if (rxs_is_zero &amp;&amp; !approx_zero(qpxr))\n    {\n        // Two lines are parallel and non-intersecting.\n        return std::nullopt;\n    }\n\n    const double t = qpxs / rxs;\n    const double u = qpxr / rxs;\n    if ((!rxs_is_zero) &amp;&amp; (0.0 &lt;= t &amp;&amp; t &lt;= 1.0) &amp;&amp; (0.0 &lt;= u &amp;&amp; u &lt;= 1.0))\n    {\n        // An intersection was found\n        return std::vector&lt;Vector2d&gt;{ (a.p0 + t * r) };\n    }\n\n    // Two line segments are not parallel but do not intersect\n    return std::nullopt;\n}\n\n// std::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Line&amp; a, const Circle&amp; b)\n// {\n//     return std::nullopt; // Todo\n// }\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Rect&amp; a, const Vector2d&amp; b)\n{\n    return intersect_at(b, a);\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Circle&amp; a, const Vector2d&amp; b)\n{\n    return intersect_at(b, a);\n}\n\n// std::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Circle&amp; a, const Line&amp; b)\n// {\n//     return intersect_at(b, a);\n// }\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/k__means__method_8hpp/","title":"include/cpp_robotics/algorithm/k_means_method.hpp","text":""},{"location":"doxybook/Files/k__means__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/k__means__method_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::KMeansMethod K-means\u6cd5"},{"location":"doxybook/Files/k__means__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class PointType&gt;\nclass KMeansMethod\n{\npublic:\n    using point_t = PointType;\n    KMeansMethod() = default;\n\n    std::vector&lt;size_t&gt; fit(std::vector&lt;point_t&gt; &amp;data_set, size_t cluster_size, size_t max_iter = 1000)\n    {\n        cluster_size_ = cluster_size;\n        point_t zero_point = get_zero_point(data_set[0]);\n        label_.resize(data_set.size());\n        std::vector&lt;size_t&gt; prev_label(data_set.size(), 0);\n\n        // \u30e9\u30d9\u30eb\u306e\u521d\u671f\u5024\u751f\u6210\n        size_t cnt = 0;\n        for(auto &amp;label : label_)\n        {\n            label = cnt++;\n            cnt %= cluster_size_;\n        }\n\n        cluster_center_.resize(cluster_size_);\n\n        for(size_t i = 0; i &lt; max_iter; i++)\n        {\n            // \u30af\u30e9\u30b9\u30bf\u306e\u91cd\u5fc3\u3092\u8a08\u7b97\n            std::vector&lt;std::vector&lt;point_t&gt;&gt; dist_(cluster_size_);\n            for(auto &amp;dist_item : dist_)\n            {\n                dist_item.reserve(data_set.size() / cluster_size_);\n            }\n            for(size_t p_idx = 0; p_idx &lt; data_set.size(); p_idx++)\n            {\n                dist_[label_[p_idx]].push_back(data_set[p_idx]);\n            }\n            for(size_t c_idx = 0; c_idx &lt; cluster_size_; c_idx++)\n            {\n                cluster_center_[c_idx] = std::accumulate(dist_[c_idx].begin(), dist_[c_idx].end(), zero_point) / (double)dist_[c_idx].size();\n            }\n\n            // \u7dcf\u5f53\u308a\u3067\u30e9\u30d9\u30eb\u3092\u5404\u30af\u30e9\u30b9\u30bf\u91cd\u5fc3\u306b\u8fd1\u3044\u3082\u306e\u306b\u5909\u66f4\u3059\u308b\n            for(size_t p_idx = 0; p_idx &lt; data_set.size(); p_idx++)\n            {\n                label_[p_idx] = predict(data_set[p_idx]);\n            }\n\n            // \u30e9\u30d9\u30eb\u304c\u5909\u5316\u3057\u306a\u304b\u3063\u305f\u3089\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3092\u7d42\u4e86\n            if(prev_label == label_)\n                break;\n        }\n\n        return label_;\n    }\n\n    size_t predict(const point_t &amp;x)\n    {\n        auto min_itr = std::min_element(cluster_center_.begin(), cluster_center_.end(), [&amp;](auto &amp;a, auto &amp;b){\n            return (a-x).norm() &lt; (b-x).norm();\n        });\n        return std::distance(cluster_center_.begin(), min_itr);\n    }\n\nprivate:\n    point_t get_zero_point(const point_t &amp;tmp)\n    {\n        (void) tmp;\n        return point_t();\n    }\n\nprivate:\n    std::vector&lt;size_t&gt; label_;\n    std::vector&lt;point_t&gt; cluster_center_;\n    size_t cluster_size_;\n};\n\n// \u52d5\u7684\u306aEigen\u306e\u30d9\u30af\u30c8\u30eb\u306f\u521d\u671f\u5316\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5b9f\u614b\u3092\u6301\u305f\u306a\u3044\u306e\u3067\u7279\u6b8a\u5316\ntemplate&lt;&gt;\nEigen::VectorXd KMeansMethod&lt;Eigen::VectorXd&gt;::get_zero_point(const Eigen::VectorXd &amp;tmp)\n{\n    return Eigen::VectorXd::Zero(tmp.size());\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/kalman__filter_8hpp/","title":"include/cpp_robotics/filter/kalman_filter.hpp","text":""},{"location":"doxybook/Files/kalman__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/kalman__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/kalman__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\n/*\n[\u30e2\u30c7\u30eb]\nx(t) = F*x(t-1) + G*u(t) + w(t)\nz(t) = H*x(t) + v(t)\n\nx: \u72b6\u614b\u91cf (n*1)\nu: \u5236\u5fa1\u91cf (r*1)\nz: \u89b3\u6e2c\u91cf (p*1)\nF: \u72b6\u614b\u9077\u79fb\u884c\u5217 (n*n)\nG: \u5236\u5fa1\u884c\u5217 (n*r)\nH: \u89b3\u6e2c\u884c\u5217 (p*n)\n\nQ: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (n*n)\nw: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba (n*1) \n    N[0, Q]\u306b\u5f93\u3046\nR: \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (p*p)\nv: \u89b3\u6e2c\u30ce\u30a4\u30ba (p*1)\n    N[0, R]\u306b\u5f93\u3046\n\n[\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf]\n- \u4e88\u6e2c\n    \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\n    x = Fx + Gu\n\n    \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = FPF^T + Q\n\n- \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\n    K = PH^T(HPH^T + R)^-1\n\n    \u72b6\u614b\u63a8\u5b9a\n    x = x + K(z - Hx)\n\n    \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = (I -KH)P\n\n*/\n\ntemplate&lt;typename FLOATING_TYPE, size_t STATE_SIZE, size_t INPUT_SIZE, size_t OBSERVE_SIZE&gt;\nclass KalmanFilter\n{\npublic:\n    using value_type = FLOATING_TYPE;\n    static constexpr size_t state_size = STATE_SIZE;\n    static constexpr size_t input_size = INPUT_SIZE;\n    static constexpr size_t observe_size = OBSERVE_SIZE;\n\n    using x_vec_t = Eigen::Matrix&lt;value_type, state_size, 1&gt;;\n    using u_vec_t = Eigen::Matrix&lt;value_type, input_size, 1&gt;;\n    using z_vec_t = Eigen::Matrix&lt;value_type, observe_size, 1&gt;;\n\n    using f_mat_t = Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n    using g_mat_t = Eigen::Matrix&lt;value_type, state_size, input_size&gt;;\n    using h_mat_t = Eigen::Matrix&lt;value_type, observe_size, state_size&gt;;\n\n    using q_mat_t = Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n    using r_mat_t = Eigen::Matrix&lt;value_type, observe_size, observe_size&gt;;\n\n    using p_mat_t = Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n\n    f_mat_t F;\n    g_mat_t G;\n    h_mat_t H;\n    q_mat_t Q;\n    r_mat_t R;\n\n    KalmanFilter() = default;\n\n    void reset(x_vec_t x, p_mat_t P)\n    {\n        x_ = x;\n        P_ = P;\n    }\n\n    x_vec_t filtering(u_vec_t u, z_vec_t z)\n    {\n        // \u72b6\u614b\u4e88\u6e2c x = Fx + Bu\n        x_ = F*x_ + G*u;\n\n        // \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q\n        P_ = F*P_*(F.transpose()) + Q;\n\n        // \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97 K = PH^T(HPH^T + R)^-1\n        auto K = P_*H.transpose() * (R + H*P_*H.transpose()).inverse();\n\n        // \u72b6\u614b\u66f4\u65b0 x = x + K(z - Hx)\n        x_ += K*(z - H*x_);\n\n        // \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I - KH)P\n        auto I = Eigen::Matrix&lt;value_type, state_size, state_size&gt;::Identity();\n\n        P_ = (I - K*H)*P_;\n\n        return x_;\n    }\n\n    x_vec_t get_x() { return x_; } // \u63a8\u5b9a\u3057\u305f\u72b6\u614b\n    p_mat_t get_P() { return P_; } // \u5171\u5206\u6563\u884c\u5217\n\nprivate:\n    // \u72b6\u614b\u91cf\n    x_vec_t x_;\n    // \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    p_mat_t P_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/kdtree_8hpp/","title":"include/cpp_robotics/algorithm/kdtree.hpp","text":""},{"location":"doxybook/Files/kdtree_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/kdtree_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::KDTree k-d\u6728"},{"location":"doxybook/Files/kdtree_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;memory&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class POINT_T&gt;\nclass KDTree\n{\npublic:\n    using point_type = POINT_T;\n\n    KDTree() = default;\n    KDTree(std::vector&lt;point_type&gt; point, size_t dimention)\n    {\n        build(point, dimention);\n    }\n\n    void clear()\n    {\n        root_.reset();\n    }\n\n    void build(std::vector&lt;point_type&gt; point, size_t dimention)\n    {\n        dimention_ = dimention;\n        points_ = point;\n        pidx_.resize(points_.size());\n        std::iota(pidx_.begin(), pidx_.end(), 0);\n        root_ = build_recursive(pidx_.begin(), pidx_.end(), 0);\n    }\n\n    size_t nn_search(const point_type &amp;point) const\n    {\n        size_t ret = 0;\n        double min_dist = std::numeric_limits&lt;double&gt;::max();\n        nn_search_recursive(root_, point, ret, min_dist);\n        return ret;\n    }\n\n    std::vector&lt;size_t&gt; nn_search(const std::vector&lt;point_type&gt; &amp;point) const\n    {\n        std::vector&lt;size_t&gt; ret(point.size());\n        for(size_t i = 0; i &lt; point.size(); i++)\n        {\n            ret[i] = nn_search(point[i]);\n        }\n        return ret;\n    }\n\n    std::vector&lt;size_t&gt; knn_search(const point_type &amp;point, size_t k) const\n    {\n        std::vector&lt;std::pair&lt;size_t, double&gt;&gt; pair_ret;\n        pair_ret.reserve(k+1);\n        knn_search_recursive(root_, point, k, pair_ret);\n        std::vector&lt;size_t&gt; ret(pair_ret.size());\n        for(size_t i = 0; i &lt; pair_ret.size(); i++)\n        {\n            ret[i] = pair_ret[i].first;\n        }\n        return ret;\n    }\n\n    std::vector&lt;size_t&gt; radius_search(const point_type &amp;point, double radius) const\n    {\n        std::vector&lt;size_t&gt; ret;\n        radius_search_recursive(root_, point, radius, ret);\n        return ret;\n    }\n\n    std::vector&lt;point_type&gt; get_points(const std::vector&lt;size_t&gt; &amp;idx) const\n    {\n        std::vector&lt;point_type&gt; ret(idx.size());\n\n        for(size_t i = 0; i &lt; idx.size(); i++)\n        {\n            ret[i] = points_[idx[i]];\n        }\n\n        return ret;\n    }\n\n    std::vector&lt;point_type&gt; knn_search_points(const point_type &amp;point, size_t k) const\n    {\n        auto idx = knn_search(point, k);\n        return get_points(idx);\n    }\n\n    std::vector&lt;point_type&gt; radius_search_points(const point_type &amp;point, double radius) const\n    {\n        auto idx = radius_search(point, radius);\n        return get_points(idx);\n    }\n\n    void debug_node()\n    {\n        debug_node_recursive(root_, 0);\n    }\n\nprivate:\n    struct Node\n    {\n        // \u5143\u306e\u70b9\u7fa4\u3067\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n        int idx = -1;\n\n        // \u5206\u5272\u8ef8\u65b9\u5411\n        int axis = -1;\n\n        // \u5b50\u30ce\u30fc\u30c9\n        std::unique_ptr&lt;Node&gt; child[2] = {nullptr, nullptr};\n    };\n\n    std::unique_ptr&lt;Node&gt; build_recursive(std::vector&lt;size_t&gt;::iterator start, std::vector&lt;size_t&gt;::iterator end, size_t depth)\n    {\n        if(start == end)\n            return nullptr;\n\n        const size_t axis = depth % dimention_;\n        const size_t mid = (std::distance(start, end)-1) / 2;\n\n        std::nth_element(start, start + mid, end, [&amp;](size_t a, size_t b){\n            return points_[a][axis] &lt; points_[b][axis];\n        });\n\n        std::unique_ptr&lt;Node&gt; node_ = std::make_unique&lt;Node&gt;();\n        node_-&gt;idx = *(start + mid);\n        node_-&gt;axis = axis;\n\n        node_-&gt;child[0] = build_recursive(start, start + mid, depth+1);\n        node_-&gt;child[1] = build_recursive(start+mid+1, end, depth+1);\n\n        return node_;\n    }\n\n    void nn_search_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, const point_type &amp;point, size_t &amp;guess, double &amp;min_dist) const\n    {\n        if(node == nullptr)\n            return;\n\n        auto p = points_[node-&gt;idx];\n\n        const double dist = distance(point, p);\n        if(dist &lt; min_dist)\n        {\n            min_dist = dist;\n            guess = node-&gt;idx;\n        }\n\n        const int axis = node-&gt;axis;\n        const int dir = point[axis] &lt; p[axis] ? 0 : 1;\n        nn_search_recursive(node-&gt;child[dir], point, guess, min_dist);\n\n        if(dist &lt; min_dist)\n            nn_search_recursive(node-&gt;child[dir], point, guess, min_dist);\n    }\n\n    void knn_search_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, const point_type &amp;point, size_t k, std::vector&lt;std::pair&lt;size_t, double&gt;&gt; &amp;result) const\n    {\n        if(node == nullptr)\n            return;\n\n        auto p = points_[node-&gt;idx];\n\n        const double dist = distance(point, p);\n        auto val = std::make_pair(node-&gt;idx, dist);\n\n        // dist\u3067\u6607\u9806\u30bd\u30fc\u30c8\u3057\u3066\u5e38\u306bk\u500b\u4ee5\u4e0b\u3092\u4fdd\u6301\u3059\u308b\n        auto it = std::find_if(std::begin(result), std::end(result),\n            [&amp;](const auto&amp; elem){ return val.second &lt; elem.second; });\n        result.insert(it, val);\n        if (result.size() &gt; k)\n            result.resize(k);\n\n        const int axis = node-&gt;axis;\n        const int dir = point[axis] &lt; p[axis] ? 0 : 1;\n        knn_search_recursive(node-&gt;child[dir], point, k, result);\n\n        const double diff = fabs(point[axis] - p[axis]);\n        if (result.size() &lt; k || diff &lt; result.back().second)\n            knn_search_recursive(node-&gt;child[!dir], point, k, result);\n    }\n\n    void radius_search_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, const point_type &amp;point, double radius, std::vector&lt;size_t&gt; &amp;result) const\n    {\n        if(node == nullptr)\n            return;\n\n        auto p = points_[node-&gt;idx];\n        double dist = distance(p, point);\n        if(dist &lt; radius)\n        {\n            result.push_back(node-&gt;idx);\n        }\n\n        const int axis = node-&gt;axis;\n        const int dir = point[axis] &lt; p[axis] ? 0 : 1;\n        radius_search_recursive(node-&gt;child[dir], point, radius, result);\n\n        const double diff = fabs(point[axis] - p[axis]);\n        if (diff &lt; radius)\n            radius_search_recursive(node-&gt;child[!dir], point, radius, result);\n    }\n\n    void debug_node_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, size_t depth)\n    {\n        if(node == nullptr)\n            return;\n\n        for(size_t i = 0; i &lt; depth; i++)\n            printf(\"  \");\n        printf(\"%d\\n\", node-&gt;idx);\n\n        debug_node_recursive(node-&gt;child[0], depth+1);\n        debug_node_recursive(node-&gt;child[1], depth+1);\n    }\n\n    double distance(const point_type &amp;a, const point_type &amp;b) const\n    {\n        double len_sq = 0;\n        for(size_t i = 0; i &lt; dimention_; i++)\n        {\n            len_sq += std::pow(a[i]-b[i], 2);\n        }\n        return std::sqrt(len_sq);\n    }\n\n    size_t dimention_;\n    std::vector&lt;point_type&gt; points_;\n    std::vector&lt;size_t&gt; pidx_;\n    std::unique_ptr&lt;Node&gt; root_ = nullptr;\n\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/least__squares__method_8hpp/","title":"include/cpp_robotics/optimize/least_squares_method.hpp","text":""},{"location":"doxybook/Files/least__squares__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/least__squares__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\n// min || Ax - b ||^2\n//  x\nEigen::VectorXd leastsq(const Eigen::MatrixXd &amp;A, const Eigen::VectorXd &amp;b)\n{\n    return (A.transpose()*A).partialPivLu().solve(A.transpose()*b);\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/linear__mpc_8hpp/","title":"include/cpp_robotics/controller/linear_mpc.hpp","text":""},{"location":"doxybook/Files/linear__mpc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/linear__mpc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::LinearMPC \u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9"},{"location":"doxybook/Files/linear__mpc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;utility&gt;\n#include &lt;optional&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize/quadprog.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass LinearMPC\n{\npublic:\n    LinearMPC(const Eigen::MatrixXd &amp;Ad, const Eigen::MatrixXd &amp;Bd, const Eigen::MatrixXd &amp;Q, const Eigen::MatrixXd &amp;R, const Eigen::MatrixXd &amp;Qf, const size_t N, std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit = std::nullopt):\n        Ad_(Ad), Bd_(Bd), Q_(Q), R_(R), Qf_(Qf), N_(N), u_limit_(u_limit)\n    {\n        // \u6b63\u65b9\u884c\u5217\n        assert(Ad_.rows() == Ad_.cols());\n        assert(Q_.rows()  == Q_.cols());\n        assert(Qf_.rows() == Qf_.cols());\n        assert(R_.rows()  == R_.cols());\n\n        // \n        assert(Ad_.rows() == Bd_.rows());\n        assert(Q_.rows() == Qf_.rows());\n        assert(Ad_.rows() == Q_.rows());\n        assert(Bd_.cols() == R_.cols());\n\n        input_size_ = Bd_.cols();\n        state_size_ = Ad_.rows();\n\n        // N\u30b9\u30c6\u30c3\u30d7\u5206\u306e\u884c\u5217\u8868\u73fe\n        Ad_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_);\n        Eigen::MatrixXd Bd_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, input_size_*N_);\n        Eigen::MatrixXd Q_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_*N_);\n        Eigen::MatrixXd R_mat_ = Eigen::MatrixXd::Zero(input_size_*N_, input_size_*N_);\n\n        Eigen::MatrixXd tmp = Ad_;\n        for(size_t i = 0; i &lt; N_; i++)\n        {\n            Ad_mat_.block(state_size_*i, 0, state_size_, state_size_) = tmp;\n            tmp *= Ad_;\n        }\n\n        tmp = Bd_;\n        for(size_t i = 0; i &lt; N_; i++)\n        {\n            // \u53f3\u4e0b\u65b9\u5411\u306b\u57cb\u3081\u3066\u3044\u304f\n            for(size_t j = 0; j &lt; N_-i; j++)\n            {\n                Bd_mat_.block(state_size_*(i+j), input_size_*j, state_size_, input_size_) = tmp;\n            }\n            tmp = Ad_ * tmp;\n        }\n\n        for(size_t i = 0; i &lt; N_-1; i++)\n        {\n            Q_mat_.block(state_size_*i, state_size_*i, state_size_, state_size_) = Q_;\n        }\n        Q_mat_.block(state_size_*(N_-1), state_size_*(N_-1), state_size_, state_size_) = Qf_;\n\n        for(size_t i = 0; i &lt; N_; i++)\n        {\n            R_mat_.block(input_size_*i, input_size_*i, input_size_, input_size_) = R_;\n        }\n\n        H_ = Bd_mat_.transpose()*Q_mat_*Bd_mat_ + R_mat_;\n        g_ = -Bd_mat_.transpose()*Q_mat_;\n        qp_solver_.Q = H_;\n\n        if(u_limit_)\n        {\n            // Todo infinity\u304c\u3042\u3063\u305f\u3089\u5236\u9650\u306a\u3057\u3068\u3044\u3046\u3053\u3068\u3067G_mat_, h_mat_\u306b\u3044\u308c\u306a\u3044\u64cd\u4f5c\u3092\u3059\u308b\n            Eigen::MatrixXd G_mat_ = Eigen::MatrixXd::Zero(input_size_*N_*2, input_size_*N_);\n            Eigen::VectorXd h_mat_ = Eigen::VectorXd::Zero(input_size_*N_*2);\n\n            G_mat_.block(0,0,input_size_*N_, input_size_*N_) = Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\n            G_mat_.block(input_size_*N_,0,input_size_*N_, input_size_*N_) = -Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\n\n            auto &amp;[umin, umax] = u_limit_.value();\n            for(size_t i = 0; i &lt; N_; i++)\n            {\n                h_mat_.segment(input_size_*i, input_size_) = umax;\n                h_mat_.segment(input_size_*(N_+i), input_size_) = -umin;\n            }\n\n            qp_solver_.A = G_mat_;\n            qp_solver_.b = h_mat_;\n        }\n\n        U_ = Eigen::VectorXd::Zero(input_size_*N_);\n    }\n\n    // void set_initial_input(const std::vector&lt;Eigen::VectorXd&gt; &amp;u0)\n    // {\n    //     assert(u0.size() == N_);\n    // }\n\n    std::tuple&lt;bool, Eigen::VectorXd&gt; control(const Eigen::VectorXd &amp;x0, const std::vector&lt;Eigen::VectorXd&gt; &amp;x_ref, bool warm_start = true)\n    {\n        assert(x0.size() == (Eigen::VectorXd::Index)(state_size_));\n\n        Eigen::VectorXd eps_mat = -Ad_mat_*x0;\n        for(size_t i = 0; i &lt; N_; i++)\n        {\n            eps_mat.block(i*state_size_, 0, state_size_, 1) += x_ref[i];\n        }\n\n        qp_solver_.c = (g_*eps_mat).transpose();\n        latest_qp_result_ = qp_solver_.solve(U_);\n\n        if(latest_qp_result_.is_solved)\n        {\n            if(warm_start)\n            {\n                U_ = latest_qp_result_.x;\n            }\n\n            return {true, latest_qp_result_.x.head(input_size_)};\n        }\n        else\n        {\n            std::cout &lt;&lt; \"???\" &lt;&lt; std::endl;\n        }\n\n        return {false, Eigen::VectorXd::Zero(input_size_)};\n    }\n\n    std::tuple&lt;bool, Eigen::VectorXd&gt; control(const Eigen::VectorXd &amp;x0, const Eigen::VectorXd &amp;x_ref, bool warm_start = true)\n    {\n        return control(x0, std::vector(N_, x_ref), warm_start);\n    }\n\n    QuadProg::Result latest_qp_result() const { return latest_qp_result_; }\n\n    Eigen::MatrixXd Ad() const { return Ad_; }\n    Eigen::MatrixXd Bd() const { return Bd_; }\n    Eigen::MatrixXd Q() const { return Q_; }\n    Eigen::MatrixXd R() const { return R_; }\n    Eigen::MatrixXd Qf() const { return Qf_; }\n    size_t N() const { return N_; }\n\nprivate:\n    // \u30b7\u30b9\u30c6\u30e0\n    const Eigen::MatrixXd Ad_;\n    const Eigen::MatrixXd Bd_;\n    const Eigen::MatrixXd Q_;\n    const Eigen::MatrixXd R_;\n    const Eigen::MatrixXd Qf_;\n    const size_t N_;\n    const std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit_;\n    size_t input_size_;\n    size_t state_size_;\n\n    Eigen::MatrixXd Ad_mat_;\n\n    // QP\u30bd\u30eb\u30d0\u7528\u306e\u8a55\u4fa1\u95a2\u6570\u306e\uff12\u6b21\u5f62\u8868\u73fe\n    Eigen::MatrixXd H_;\n    Eigen::MatrixXd g_;\n\n    // QP\u30bd\u30eb\u30d0\n    QuadProg qp_solver_;\n    Eigen::VectorXd U_;\n    QuadProg::Result latest_qp_result_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/","title":"include/cpp_robotics/controller/linear_regulator_mpc.hpp","text":""},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::LinearRegulatorMPC"},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;utility&gt;\n#include &lt;optional&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize/quadprog.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass LinearRegulatorMPC\n{\npublic:\n    LinearRegulatorMPC(const Eigen::MatrixXd &amp;Ad, const Eigen::MatrixXd &amp;Bd, const Eigen::MatrixXd &amp;Q, const Eigen::MatrixXd &amp;R, const Eigen::MatrixXd &amp;Qf, const size_t N, std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit = std::nullopt):\n        Ad_(Ad), Bd_(Bd), Q_(Q), R_(R), Qf_(Qf), N_(N), u_limit_(u_limit)\n    {\n        // \u6b63\u65b9\u884c\u5217\n        assert(Ad_.rows() == Ad_.cols());\n        assert(Q_.rows()  == Q_.cols());\n        assert(Qf_.rows() == Qf_.cols());\n        assert(R_.rows()  == R_.cols());\n\n        // \n        assert(Ad_.rows() == Bd_.rows());\n        assert(Q_.rows() == Qf_.rows());\n        assert(Ad_.rows() == Q_.rows());\n        assert(Bd_.cols() == R_.cols());\n\n        input_size_ = Bd_.cols();\n        state_size_ = Ad_.rows();\n\n        // N\u30b9\u30c6\u30c3\u30d7\u5206\u306e\u884c\u5217\u8868\u73fe\n        Eigen::MatrixXd Ad_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_);\n        Eigen::MatrixXd Bd_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, input_size_*N_);\n        Eigen::MatrixXd Q_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_*N_);\n        Eigen::MatrixXd R_mat_ = Eigen::MatrixXd::Zero(input_size_*N_, input_size_*N_);\n\n        Eigen::MatrixXd tmp = Ad_;\n        for(size_t i = 0; i &lt; N_; i++)\n        {\n            Ad_mat_.block(state_size_*i, 0, state_size_, state_size_) = tmp;\n            tmp *= Ad_;\n        }\n\n        tmp = Bd_;\n        for(size_t i = 0; i &lt; N_; i++)\n        {\n            // \u53f3\u4e0b\u65b9\u5411\u306b\u57cb\u3081\u3066\u3044\u304f\n            for(size_t j = 0; j &lt; N_-i; j++)\n            {\n                Bd_mat_.block(state_size_*(i+j), input_size_*j, state_size_, input_size_) = tmp;\n            }\n            tmp = Ad_ * tmp;\n        }\n\n        for(size_t i = 0; i &lt; N_-1; i++)\n        {\n            Q_mat_.block(state_size_*i, state_size_*i, state_size_, state_size_) = Q_;\n        }\n        Q_mat_.block(state_size_*(N_-1), state_size_*(N_-1), state_size_, state_size_) = Qf_;\n\n        for(size_t i = 0; i &lt; N_; i++)\n        {\n            R_mat_.block(input_size_*i, input_size_*i, input_size_, input_size_) = R_;\n        }\n\n        H_ = Bd_mat_.transpose()*Q_mat_*Bd_mat_ + R_mat_;\n        g_ = Bd_mat_.transpose()*Q_mat_*Ad_mat_;\n        qp_solver_.Q = H_;\n\n        if(u_limit_)\n        {\n            // Todo infinity\u304c\u3042\u3063\u305f\u3089\u5236\u9650\u306a\u3057\u3068\u3044\u3046\u3053\u3068\u3067G_mat_, h_mat_\u306b\u3044\u308c\u306a\u3044\u64cd\u4f5c\u3092\u3059\u308b\n            Eigen::MatrixXd G_mat_ = Eigen::MatrixXd::Zero(input_size_*N_*2, input_size_*N_);\n            Eigen::VectorXd h_mat_ = Eigen::VectorXd::Zero(input_size_*N_*2);\n\n            G_mat_.block(0,0,input_size_*N_, input_size_*N_) = Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\n            G_mat_.block(input_size_*N_,0,input_size_*N_, input_size_*N_) = -Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\n\n            auto &amp;[umin, umax] = u_limit_.value();\n            for(size_t i = 0; i &lt; N_; i++)\n            {\n                h_mat_.segment(input_size_*i, input_size_) = umax;\n                h_mat_.segment(input_size_*(N_+i), input_size_) = -umin;\n            }\n\n            qp_solver_.A = G_mat_;\n            qp_solver_.b = h_mat_;\n        }\n\n        U_ = Eigen::VectorXd::Zero(input_size_*N_);\n    }\n\n    void set_initial_input(const std::vector&lt;Eigen::VectorXd&gt; &amp;u0)\n    {\n        assert(u0.size() == N_);\n    }\n\n    std::tuple&lt;bool, Eigen::VectorXd&gt; control(const Eigen::VectorXd &amp;x0, bool warm_start = true)\n    {\n        assert(x0.size() == (Eigen::VectorXd::Index)(state_size_));\n\n        qp_solver_.c = (g_*x0).transpose();\n        latest_qp_result_ = qp_solver_.solve(U_);\n\n        if(latest_qp_result_.is_solved)\n        {\n            if(warm_start)\n            {\n                U_ = latest_qp_result_.x;\n            }\n\n            return {true, latest_qp_result_.x.head(input_size_)};\n        }\n        else\n        {\n            std::cout &lt;&lt; \"???\" &lt;&lt; std::endl;\n        }\n\n        return {false, Eigen::VectorXd::Zero(input_size_)};\n    }\n\n    QuadProg::Result latest_qp_result() const { return latest_qp_result_; }\n\n    Eigen::MatrixXd Ad() const { return Ad_; }\n    Eigen::MatrixXd Bd() const { return Bd_; }\n    Eigen::MatrixXd Q() const { return Q_; }\n    Eigen::MatrixXd R() const { return R_; }\n    Eigen::MatrixXd Qf() const { return Qf_; }\n    size_t N() const { return N_; }\n\nprivate:\n    // \u30b7\u30b9\u30c6\u30e0\n    const Eigen::MatrixXd Ad_;\n    const Eigen::MatrixXd Bd_;\n    const Eigen::MatrixXd Q_;\n    const Eigen::MatrixXd R_;\n    const Eigen::MatrixXd Qf_;\n    const size_t N_;\n    const std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit_;\n    size_t input_size_;\n    size_t state_size_;\n\n    // QP\u30bd\u30eb\u30d0\u7528\u306e\u8a55\u4fa1\u95a2\u6570\u306e\uff12\u6b21\u5f62\u8868\u73fe\n    Eigen::MatrixXd H_;\n    Eigen::MatrixXd g_;\n\n    // QP\u30bd\u30eb\u30d0\n    QuadProg qp_solver_;\n    Eigen::VectorXd U_;\n    QuadProg::Result latest_qp_result_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/low__pass__filter_8hpp/","title":"include/cpp_robotics/filter/low_pass_filter.hpp","text":""},{"location":"doxybook/Files/low__pass__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/low__pass__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc"},{"location":"doxybook/Files/low__pass__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n// G(s) = omega / (s + omega)\nclass LowPassFilter : public TransferFunction\n{\npublic:\n    LowPassFilter(double omega, double dt):\n        omega_(omega)\n    {\n        TransferFunction::set_continuous({omega_}, {1, omega_}, dt);\n    }\n\n    double filtering(double u) { return responce(u); } \n\n    double omega() const { return omega_; }\nprivate:\n    const double omega_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/lqr_8hpp/","title":"include/cpp_robotics/controller/lqr.hpp","text":""},{"location":"doxybook/Files/lqr_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/lqr_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;optional&gt;\n\nnamespace cpp_robotics\n{\n\nstatic std::optional&lt;Eigen::MatrixXd&gt; solve_riccati_arimoto_potter(const Eigen::MatrixXd &amp;A,\n                                                                    const Eigen::MatrixXd &amp;B,\n                                                                    const Eigen::MatrixXd &amp;Q,\n                                                                    const Eigen::MatrixXd &amp;R)\n{\n    const uint dim_x = A.rows();\n    const uint dim_u = B.cols();\n    Eigen::MatrixXd Ham = Eigen::MatrixXd::Zero(2 * dim_x, 2 * dim_x);\n    Ham &lt;&lt; A, -B * R.inverse() * B.transpose(), -Q, -A.transpose();\n    Eigen::EigenSolver&lt;Eigen::MatrixXd&gt; Eigs(Ham);\n    Eigen::MatrixXcd eigvec = Eigen::MatrixXcd::Zero(2 * dim_x, dim_x);\n    int j = 0;\n    for (size_t i = 0; i &lt; 2 * dim_x; ++i)\n    {\n        if (Eigs.eigenvalues()[i].real() &lt; 0.0)\n        {\n            eigvec.col(j) = Eigs.eigenvectors().block(0, i, 2 * dim_x, 1);\n            j++;\n        }\n    }\n    Eigen::MatrixXcd Vs_1, Vs_2;\n    Vs_1 = eigvec.block(0, 0, dim_x, dim_x);\n    Vs_2 = eigvec.block(dim_x, 0, dim_x, dim_x);\n    return (Vs_2 * Vs_1.inverse()).real();\n}\n\n// \u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306e\u884c\u5217\u3068\u30d9\u30af\u30c8\u30eb\u3068\u91cd\u307f\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b\nstatic Eigen::MatrixXd lqr(const Eigen::MatrixXd &amp;A,\n                            const Eigen::MatrixXd &amp;B,\n                            const Eigen::MatrixXd &amp;Q,\n                            const Eigen::MatrixXd &amp;R)\n{\n    auto P = solve_riccati_arimoto_potter(A, B, Q, R);\n    return R.inverse() * B.transpose() * P.value();\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/lsei__transition_8hpp/","title":"include/cpp_robotics/optimize/lsei_transition.hpp","text":""},{"location":"doxybook/Files/lsei__transition_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/lsei__transition_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace cpp_robotics\n{\n\n// min || Cx + d ||_2^2 \n//  to\n// min 1/2 x^TQx + c^Tx\n// https://jp.mathworks.com/help/optim/ug/least-squares-model-fitting-algorithms.html#buc5ri4\nstd::tuple&lt;Eigen::MatrixXd, Eigen::VectorXd&gt; lsi2qp(const Eigen::MatrixXd &amp;C, const Eigen::VectorXd &amp;d)\n{\n    return {2*C.transpose()*C, (2*C.transpose()*d)};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/mahalanobis_8hpp/","title":"include/cpp_robotics/algorithm/mahalanobis.hpp","text":""},{"location":"doxybook/Files/mahalanobis_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/mahalanobis_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\ndouble mahalanobis(const Eigen::VectorXd &amp;a, const Eigen::VectorXd &amp;b, const Eigen::MatrixXd cov_inv)\n{\n    auto diff = a-b;\n    return std::sqrt( diff.dot( cov_inv*diff ) );\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/math__utils_8hpp/","title":"include/cpp_robotics/utility/math_utils.hpp","text":""},{"location":"doxybook/Files/math__utils_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570"},{"location":"doxybook/Files/math__utils_8hpp/#defines","title":"Defines","text":"Name M_PI"},{"location":"doxybook/Files/math__utils_8hpp/#macros-documentation","title":"Macros Documentation","text":""},{"location":"doxybook/Files/math__utils_8hpp/#define-m_pi","title":"define M_PI","text":"<pre><code>#define M_PI 3.141592653589793238462643383279\n</code></pre>"},{"location":"doxybook/Files/math__utils_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n\n#ifndef M_PI\n#define M_PI 3.141592653589793238462643383279\n#endif \n\nnamespace cpp_robotics\n{\n    inline namespace constants\n    {\n        constexpr double PI         = 3.1415926535897932384626433832795;\n\n        constexpr double HALF_PI    = PI / 2.0;\n\n        constexpr double TWO_PI     = PI * 2.0;\n\n        constexpr double DEG_TO_RAD = PI / 180.0;\n\n        constexpr double RAD_TO_DEG = 180.0 / PI;\n\n        constexpr double EULER      = 2.718281828459045235360287471352;\n\n        constexpr double GRAVITY    = 9.807;\n\n        constexpr double Nm2gfm     = (1/GRAVITY);\n\n        constexpr double gfm2Nm     = GRAVITY;\n\n        constexpr double mNm2gfcm   = (Nm2gfm * 100);\n\n        constexpr double gfcm2mNm   = (gfm2Nm / 100);\n    }\n\n    template&lt;typename T&gt;\n    static constexpr bool in_range_open(T x, T min, T max) \n    {\n        return ((min &lt; x &amp;&amp; x &lt; max) ? true : false);\n    }\n\n    template&lt;typename T&gt;\n    static constexpr bool in_range(T x, T min, T max) \n    {\n        return ((min &lt;= x &amp;&amp; x &lt;= max) ? true : false);\n    }\n\n    template&lt;typename T&gt;\n    static constexpr int sgn(T x) \n    {\n        return (x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0);\n    }\n\n    template&lt;typename T&gt;\n    static constexpr double radians(T deg) \n    {\n        return (deg*DEG_TO_RAD);\n    }\n\n    template&lt;typename T&gt;\n    static constexpr double degrees(T rad)\n    {\n        return (rad*RAD_TO_DEG);\n    }\n\n    static inline double normalize_angle_positive(double angle)\n    {\n        return std::fmod(std::fmod(angle, TWO_PI) + TWO_PI, TWO_PI);\n    }\n\n    static inline double normalize_angle(double angle)\n    {\n        double a = normalize_angle_positive(angle);\n        if (a &gt; PI)\n            a -= TWO_PI;\n        return a;\n    }\n\n    static inline double shortest_angular_distance(double from, double to)\n    {\n        return normalize_angle(to-from);\n    }\n\n    static inline double nearest_angle(double from, double to)\n    {\n        return from + normalize_angle(to-from);\n    }\n\n\nconstexpr inline double square(const double x) { return x*x; }\nconstexpr inline double cubic(const double x) { return x*x*x; }\nconstexpr inline double lerp(const double a, const double b, const double t) { return a + (b-a)*t; }\nconstexpr inline double approx_eq(const double a, const double b) { return (std::abs(a-b) &lt; 1e-12); }\nconstexpr inline double approx_zero(const double a) { return (std::abs(a) &lt; 1e-12); }\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/matplotlibcpp_8hpp/","title":"include/cpp_robotics/matplotlibcpp.hpp","text":""},{"location":"doxybook/Files/matplotlibcpp_8hpp/#source-code","title":"Source code","text":"<pre><code>#include &lt;cpp_robotics/third_party/matplotlib-cpp/matplotlibcpp.h&gt;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/mecanum__ik_8hpp/","title":"include/cpp_robotics/chassis/mecanum_ik.hpp","text":""},{"location":"doxybook/Files/mecanum__ik_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/mecanum__ik_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::MecanumIk::Config"},{"location":"doxybook/Files/mecanum__ik_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/vector/transform.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass MecanumIk\n{\npublic:\n    struct Config\n    {\n        double width;\n        double length;\n    };\n\n    MecanumIk(double width, double length):\n        MecanumIk(Config{width, length}) {}\n\n    MecanumIk(Config config):\n        config_(config)\n    {\n        const double norm = (config_.width + config_.length)/2.0;\n        conv_mat_ &lt;&lt; \n            -1,  1, norm,\n            -1, -1, norm,\n             1, -1, norm,\n             1,  1, norm;\n    }\n\n    std::array&lt;double, 4&gt; calculate(Transformd velocity)\n    {\n        std::array&lt;double, 4&gt; wv;\n        Eigen::Map&lt;Eigen::Vector4d&gt; wv_vec(wv.data());\n        Eigen::Vector3d v(velocity.x, velocity.y, velocity.theta);\n        wv_vec = conv_mat_ * v;\n        return wv;\n    }\n\n    Config config() const { return config_; }\n\nprivate:\n    Config config_;\n    Eigen::Matrix&lt;double, 4, 3&gt; conv_mat_;\n};\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/minimum__jerk__model_8hpp/","title":"include/cpp_robotics/path_planning/minimum_jerk_model.hpp","text":""},{"location":"doxybook/Files/minimum__jerk__model_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/minimum__jerk__model_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace cpp_robotics\n{\n\nstatic double normalized_mjm_position(double t)\n{\n    double t3 = t * t * t;\n    return ( ((6.0*t - 15.0)*t + 10.0)*t3 );\n}\n\nstatic double normalized_mjm_velocity(double t)\n{\n    double t2 = t * t;\n    return ( ((30.0*t - 60.0)*t + 30.0)*t2 );\n}\n\nstatic double normalized_mjm_acceleration(double t)\n{\n    return ( ((120.0*t - 180.0)*t + 60.0)*t );\n}\n\nstatic double normalized_mjm_jerk(double t)\n{\n    return (360.0*t - 360.0)*t + 60.0;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/modern__control_8hpp/","title":"include/cpp_robotics/controller/modern_control.hpp","text":""},{"location":"doxybook/Files/modern__control_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/modern__control_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"../system/state_space_system.hpp\"\n#include \"../system/polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n    static Eigen::MatrixXd controllability_matrix(const Eigen::MatrixXd&amp; A, const Eigen::VectorXd&amp; B)\n    {\n        assert(A.rows() == A.cols());\n        assert(A.rows() == B.size());\n        const int dim = A.rows();\n\n        Eigen::MatrixXd Uc(dim, dim);\n        Eigen::VectorXd colv = B;\n\n        for(int i = 0; i &lt; dim; i++)\n        {\n            Uc.col(i) = colv;\n            colv = A * colv;\n        }\n\n        return Uc;\n    }\n\n    static bool is_controllable(const Eigen::MatrixXd&amp; A, const Eigen::VectorXd&amp; B)\n    {\n        const int dim = A.rows();\n        Eigen::FullPivLU&lt;Eigen::MatrixXd&gt; lu(controllability_matrix(A, B));\n        return (lu.rank() == dim);\n    }\n\n    static bool is_controllable(const StateSpaceSystem&amp; sys)\n    {\n        return is_controllable(sys.A().value(), sys.B().value());\n    }\n\n    static Eigen::MatrixXd observability_matrix(const Eigen::MatrixXd&amp; A, const Eigen::RowVectorXd&amp; C)\n    {\n        assert(A.rows() == A.cols());\n        assert(A.rows() == C.size());\n        const int dim = A.rows();\n\n        Eigen::MatrixXd Uo(dim, dim);\n        Eigen::RowVectorXd colv = C;\n\n        for(int i = 0; i &lt; dim; i++)\n        {\n            Uo.row(i) = colv;\n            colv = colv * A;\n        }\n\n        return Uo;\n    }\n\n    static bool is_observable(const Eigen::MatrixXd&amp; A, const Eigen::RowVectorXd&amp; C)\n    {\n        const int dim = A.rows();\n        Eigen::FullPivLU&lt;Eigen::MatrixXd&gt; lu(observability_matrix(A, C));\n        return (lu.rank() == dim);\n    }\n\n    static bool is_observable(const StateSpaceSystem&amp; sys)\n    {\n        return is_observable(sys.A().value(), sys.C());\n    }\n\n    enum class CanonicalizeMode\n    {\n        // MODEL,\n        COMPANION,\n        OBSERBAVLE,\n        CONTROLLABLE\n    };\n\n    // https://www.mathworks.com/help/control/ug/canonical-state-space-realizations.html\n    static std::tuple&lt;Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd&gt; canonicalize_system(const Eigen::MatrixXd&amp; A, const Eigen::MatrixXd&amp; B, const Eigen::MatrixXd&amp; C, CanonicalizeMode mode = CanonicalizeMode::COMPANION)\n    {\n        // if(mode == MODEL)\n        // else\n        if(mode == CanonicalizeMode::CONTROLLABLE || mode == CanonicalizeMode::COMPANION || mode == CanonicalizeMode::OBSERBAVLE)\n        {\n            if(mode == CanonicalizeMode::CONTROLLABLE)\n            {\n                auto [A_tilda, B_tilda, C_tilda] = canonicalize_system(A, B, C, CanonicalizeMode::COMPANION);\n                return {\n                    A_tilda.transpose(),\n                    C_tilda.transpose(),\n                    B_tilda.transpose()\n                };\n            }\n            else\n            {\n                Eigen::MatrixXd Uc = controllability_matrix(A, B);\n                Eigen::MatrixXd Ucinv = Uc.inverse();\n                return {\n                    Ucinv*A*Uc,\n                    Ucinv*B,\n                    C*Uc\n                };\n            }\n        }\n\n        return canonicalize_system(A, B, C, CanonicalizeMode::COMPANION);\n    }\n\n    static std::tuple&lt;Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd&gt; canonicalize_system(const StateSpaceSystem&amp; sys, CanonicalizeMode mode = CanonicalizeMode::COMPANION)\n    {\n        return canonicalize_system(sys.A().value(), sys.B().value(), sys.C(), mode);\n    }\n\n    // https://ossyaritoori.hatenablog.com/entry/2018/05/16/%E6%A5%B5%E9%85%8D%E7%BD%AE%E3%81%AE%E5%AE%9F%E8%A3%85%EF%BC%9A%E3%82%A2%E3%83%83%E3%82%AB%E3%83%BC%E3%83%9E%E3%83%B3%E6%B3%95%E3%81%AEMATLAB%E5%AE%9F%E8%A3%85#Outline\n    static Eigen::VectorXd place(const StateSpaceSystem&amp; sys, std::vector&lt;double&gt; poles)\n    {\n        assert(sys.state_size() == poles.size());\n        assert(sys.is_siso_model());\n\n        auto pole_poly = Polynomial::expand(poles);\n\n        auto Uc = controllability_matrix(sys.A().value(), sys.B().value());\n\n        Eigen::MatrixXd tmp = Eigen::MatrixXd::Zero(sys.state_size(), sys.state_size());\n        Eigen::MatrixXd An = Eigen::MatrixXd::Identity(sys.state_size(), sys.state_size());\n\n        for(size_t i = 0; i &lt; sys.state_size(); i++)\n        {\n            tmp += pole_poly.at_degree(i)*An;\n            An *= sys.A().value();\n        }\n        tmp += An;\n\n        return (Uc.inverse() * tmp).row(sys.state_size()-1);\n    }\n\n    // \u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\\tilda{A}\u306e\u4fc2\u6570\u6bd4\u8f03\u306b\u3088\u308a\u6975\u914d\u7f6e\u3092\u884c\u3046\n    // https://www.youtube.com/watch?v=yiFgI6Oos88\n//     static Eigen::VectorXd place(const StateSpaceSystem&amp; sys, std::vector&lt;double&gt; poles)\n//     {\n\n//     }\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/motor_8hpp/","title":"include/cpp_robotics/motor.hpp","text":""},{"location":"doxybook/Files/motor_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"motor/dc_motor_param.hpp\"\n#include \"motor/dc_motor_list.hpp\"\n#include \"motor/motor_tf.hpp\"\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/motor__tf_8hpp/","title":"include/cpp_robotics/motor/motor_tf.hpp","text":""},{"location":"doxybook/Files/motor__tf_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/motor__tf_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./dc_motor_param.hpp\"\n#include \"../system/transfer_function.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic TransferFunction make_motor_vel_tf(const DCMotorParam &amp;motor, const double dt)\n{\n    return TransferFunction({motor.torque_constant}, {motor.inductance*motor.rotor_inertia, motor.resistance*motor.rotor_inertia, motor.torque_constant*motor.back_emf_constance}, dt);\n}\n\nstatic TransferFunction make_motor_pos_tf(const DCMotorParam &amp;motor, const double dt)\n{\n    auto vel_tf = make_motor_vel_tf(motor, dt);\n    auto new_den = vel_tf.den_array();\n    new_den.push_back(0);\n    return TransferFunction(vel_tf.num_array(), new_den, dt);\n}\n\nstatic TransferFunction make_geared_motor_vel_tf(const DCGearedMotorParam &amp;geared_motor, const double dt)\n{\n    auto &amp;motor = geared_motor.motor;\n    auto &amp;gear_head = geared_motor.gear_head;\n    return TransferFunction({motor.torque_constant * gear_head.ratio }, {motor.inductance*motor.rotor_inertia, motor.resistance*motor.rotor_inertia, motor.torque_constant*motor.back_emf_constance}, dt);\n}\n\nstatic TransferFunction make_geared_motor_pos_tf(const DCGearedMotorParam &amp;geared_motor, const double dt)\n{\n    auto vel_tf = make_geared_motor_vel_tf(geared_motor, dt);\n    auto new_den = vel_tf.den_array();\n    new_den.push_back(0);\n    return TransferFunction(vel_tf.num_array(), new_den, dt);\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/nctf_8hpp/","title":"include/cpp_robotics/controller/nctf.hpp","text":""},{"location":"doxybook/Files/nctf_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/nctf_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668"},{"location":"doxybook/Files/nctf_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include \"./pid.hpp\"\n#include \"../filter/differentiator.hpp\"\n#include \"../filter/integrator.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass NctfController\n{\npublic:\n    static std::function&lt;double(double)&gt; make_simple_nct(double max_velocity, double slope)\n    {\n        return [=](double e){ return -max_velocity*std::tanh(e*slope/max_velocity); };\n    }\n\n    NctfController(double max_velocity, double nct_slope, PID::pid_param_t pid_param, double dt):\n        NctfController(make_simple_nct(max_velocity, nct_slope), pid_param, dt)\n    {\n\n    }\n\n    NctfController(std::function&lt;double(double)&gt; nct, PID::pid_param_t pid_param, double dt):\n        nct_(nct),\n        diff_(pid_param.gpd, dt),\n        pid_(pid_param),\n        itg_(dt),\n        pid_param_(pid_param)\n    {\n\n    }\n\n    void reset()\n    {\n        diff_.reset();\n        pid_.reset();\n    }\n\n    double nct_error = 0;\n    double control(double target, double state) { return control(target-state); }\n    double control(double e)\n    {\n        double state_e_dot = diff_.filtering(e);\n        double nct_e_dot = nct_(e);\n        nct_error = -(nct_e_dot - state_e_dot);\n        return pid_.calculate(nct_error);\n    }\n\n    std::function&lt;double(double)&gt; nct() const\n    {\n        return nct_;\n    }\n\nprivate:\n    std::function&lt;double(double)&gt; nct_;\n    Differentiator diff_;\n    PID pid_;\n    Integrator itg_;\n    PID::pid_param_t pid_param_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/newton__method_8hpp/","title":"include/cpp_robotics/optimize/newton_method.hpp","text":""},{"location":"doxybook/Files/newton__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/newton__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; newton_method(std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, std::function&lt;Eigen::MatrixXd(const Eigen::VectorXd &amp;)&gt; hesse, Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000)\n{\n    Eigen::VectorXd x = x_init;\n    Eigen::VectorXd dx;\n\n    for(size_t i = 0; i &lt; max_iter; i++)\n    {\n        dx = grad(x);\n\n        if(dx.norm() &lt; tol)\n        {\n            return {true, x, i};\n        }\n\n        x -= (hesse(x).inverse() * dx);\n    }\n\n    return {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/no__constraint__method_8hpp/","title":"include/cpp_robotics/optimize/no_constraint_method.hpp","text":""},{"location":"doxybook/Files/no__constraint__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#include &lt;cpp_robotics/optimize/golden_serach.hpp&gt;\n#include &lt;cpp_robotics/optimize/derivative.hpp&gt;\n#include &lt;cpp_robotics/optimize/steepest_descent_method.hpp&gt;\n#include &lt;cpp_robotics/optimize/newton_method.hpp&gt;\n#include &lt;cpp_robotics/optimize/quasi_newton_method.hpp&gt;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/notch__filter_8hpp/","title":"include/cpp_robotics/filter/notch_filter.hpp","text":""},{"location":"doxybook/Files/notch__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/notch__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/notch__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n//         s^2 + d*2*zeta*omega*s + omega^2\n// G(s) = -------------------------------- \u3092\u53cc\u4e00\u6b21\u5909\u63db\n//          s^2 + 2*zeta*omega*s + omega^2\nclass NotchFilter : public TransferFunction\n{\npublic:\n    NotchFilter(double omega, double zeta, double d, double dt):\n        omega_(omega), zeta_(zeta), d_(d)\n    {\n        TransferFunction::set_continuous({1, (d_*2*zeta_*omega_), (omega_*omega_)}, {1, (2*zeta_*omega_), (omega_*omega_)}, dt);\n    }\n\n    double filtering(double u) { return responce(u); } \n\n    double omega() const { return omega_; }\n\n    double zeta() const { return zeta_; }\n\n    double d() const { return d_; }\nprivate:\n    const double omega_;\n    const double zeta_;\n    const double d_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/nyquist_8hpp/","title":"include/cpp_robotics/system/nyquist.hpp","text":""},{"location":"doxybook/Files/nyquist_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/nyquist_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include \"./transfer_function.hpp\"\n#ifdef CR_USE_MATPLOTLIB\n#include \"../third_party/matplotlib-cpp/matplotlibcpp.h\"\n#endif\n#include \"../utility/space.hpp\"\n#include \"../vector/vector2.hpp\"\n#include \"../utility/math_utils.hpp\"\n#include \"./bode.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; nyquist(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500))\n{\n    size_t n = omegas.size();\n    std::vector&lt;double&gt; Re(n), Im(n);\n    auto [g, ph] = bode(tf, omegas, false, false);\n\n    Vector2d tmp;\n    for(size_t i = 0; i &lt; n; i++)\n    {\n        tmp.x = g[i];\n        tmp.y = 0;\n        tmp.rotate(ph[i]);\n        Re[i] = tmp.x;\n        Im[i] = tmp.y;\n    }\n\n    return {Re, Im};\n}\n\n#ifdef CR_USE_MATPLOTLIB\nstatic void nyquist_plot(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500))\n{\n    namespace plt = matplotlibcpp;\n    auto [Re, Im] = nyquist(tf, omegas);\n\n    plt::plot(Re, Im);\n    plt::set_aspect(1.0);\n    plt::xlabel(\"Re\");\n    plt::ylabel(\"Im\");\n    plt::xlim(-1.3*Re[0], 1.3*Re[0]);\n    plt::ylim(-1.3*Re[0], 1.3*Re[0]);\n    plt::grid(true, \"both\");\n\n    plt::show();\n}\n#endif\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/ocp__constraint_8hpp/","title":"include/cpp_robotics/controller/ocp_constraint.hpp","text":""},{"location":"doxybook/Files/ocp__constraint_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/ocp__constraint_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::OCPConstraint class cpp_robotics::OCPConstraintArray class cpp_robotics::OCPFunctionalConstraint class cpp_robotics::OCPInputIndexedBoundConstraint class cpp_robotics::OCPStateIndexedBoundConstraint"},{"location":"doxybook/Files/ocp__constraint_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize/derivative.hpp&gt;\n#include &lt;variant&gt;\n#include &lt;optional&gt;\n#include &lt;memory&gt;\n\nnamespace cpp_robotics\n{\n\nenum OCPConstraintType : uint8_t\n{\n    Eq, // g(x) = 0\n    Ineq // g(x) &lt;= 0\n};\n\nclass OCPConstraint\n{\npublic:\n    using SharedPtr = std::shared_ptr&lt;OCPConstraint&gt;;\n\n    double eps = 1e-6;\n    OCPConstraintType type;\n\n    OCPConstraint():\n        type(OCPConstraintType::Eq) {}\n    OCPConstraint(OCPConstraintType type):\n        type(type) {}\n\n    virtual double eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const = 0;\n\n    bool satisfy(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const double tol) const\n    {\n        const double val = eval(x, u);\n        if(type == OCPConstraintType::Eq)\n        {\n            return std::abs(val) &lt; tol;\n        }\n        else\n        {\n            return val &lt; tol;\n        }\n    }\n\n    virtual Eigen::VectorXd grad_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const\n    {\n        return derivative([&amp;](const Eigen::VectorXd &amp;x){ return eval(x, u); }, x, eps);\n    }\n\n    virtual Eigen::VectorXd grad_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const\n    {\n        return derivative([&amp;](const Eigen::VectorXd &amp;u){ return eval(x, u); }, u, eps);\n    }\n\n    virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const\n    {\n        return second_derivative([&amp;](const Eigen::VectorXd &amp;x){ return eval(x, u); }, x, eps);\n    }\n\n    virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const\n    {\n        return second_derivative([&amp;](const Eigen::VectorXd &amp;u){ return eval(x, u); }, u, eps);\n    }\n\n    virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const\n    {\n        Eigen::MatrixXd Q(u.size(), x.size());\n\n        for (int c = 0; c &lt; x.size(); c++)\n        {\n            for (int r = 0; r &lt; u.size(); r++)\n            {\n                Eigen::VectorXd e_u = Eigen::VectorXd::Zero(u.size());\n                Eigen::VectorXd e_x = Eigen::VectorXd::Zero(x.size());\n                e_u[r] = eps;\n                e_x[c] = eps;\n\n                double f_rc = eval(x + e_x, u + e_u) - eval(x + e_x, u - e_u) - eval(x - e_x, u + e_u) + eval(x - e_x, u - e_u);\n                Q(r, c) = f_rc / (4 * eps * eps);\n            }\n        }\n\n        return Q;\n    }\n};\n\nclass OCPConstraintArray : public std::vector&lt;OCPConstraint::SharedPtr&gt;\n{\n    template&lt;class Type1, class Type2&gt;\n    struct VariItem\n    {\n        using vari_type = std::variant&lt;Type1, Type2&gt;;\n        VariItem(Type1 val) { val_ = val; }\n        VariItem(Type2 val) { val_ = val; }\n\n        vari_type &amp;item() { return val_; } \n\n    private:\n        vari_type val_;\n    };\npublic:\n    OCPConstraintArray() = default;\n    OCPConstraintArray(std::initializer_list&lt;OCPConstraint::SharedPtr&gt; con):\n        vector(con.begin(), con.end()) {}\n\n    OCPConstraintArray(std::initializer_list&lt;VariItem&lt;OCPConstraint::SharedPtr, OCPConstraintArray&gt;&gt; cons)\n    {\n        for(auto c : cons)\n        {\n            if(std::holds_alternative&lt;OCPConstraint::SharedPtr&gt;(c.item()))\n            {\n                auto &amp; cval = std::get&lt;OCPConstraint::SharedPtr&gt;(c.item());\n                this-&gt;insert(this-&gt;end(), cval);\n            }\n            else\n            {\n                auto &amp; cary = std::get&lt;OCPConstraintArray&gt;(c.item());\n                this-&gt;insert(this-&gt;end(), cary.begin(), cary.end());\n            }\n        }\n    }\n\n    using vector::push_back;\n    void push_back(const OCPConstraintArray &amp;cons)\n    {\n        this-&gt;insert(this-&gt;end(), cons.begin(), cons.end());\n    }\n\n    Eigen::VectorXd eval_all_vec(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const\n    {\n        Eigen::VectorXd ret(size());\n        for (size_t i = 0; i &lt; size(); i++)\n        {\n            ret[i] = at(i)-&gt;eval(x, u);\n        }\n        return ret;\n    }\n\n    std::vector&lt;double&gt; eval_all(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u)\n    {\n        std::vector&lt;double&gt; ret(size());\n        for (size_t i = 0; i &lt; size(); i++)\n        {\n            ret[i] = at(i)-&gt;eval(x, u);\n        }\n        return ret;\n    }\n};\n\nclass OCPFunctionalConstraint : public OCPConstraint\n{\npublic:\n    using func_t = std::function&lt;double(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt;;\n    using grad_func_t = std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt;;\n    using hessian_func_t = std::function&lt;Eigen::MatrixXd(const Eigen::VectorXd &amp;, const Eigen::VectorXd &amp;)&gt;;\n\n    OCPFunctionalConstraint(OCPConstraintType type, func_t f):\n        OCPConstraint(type), f(f) {}\n\n    func_t f;\n    std::optional&lt;grad_func_t&gt; f_grad_x;\n    std::optional&lt;grad_func_t&gt; f_grad_u;\n    std::optional&lt;hessian_func_t&gt; f_hessian_xx;\n    std::optional&lt;hessian_func_t&gt; f_hessian_ux;\n    std::optional&lt;hessian_func_t&gt; f_hessian_uu;\n\n    double eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        return f(x, u);\n    }\n\n    Eigen::VectorXd grad_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        if(f_grad_x)\n            return f_grad_x.value()(x, u);\n        return OCPConstraint::grad_x(x, u);\n    }\n\n    Eigen::VectorXd grad_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        if(f_grad_u)\n            return f_grad_u.value()(x, u);\n        return OCPConstraint::grad_u(x, u);\n    }\n\n    Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        if(f_hessian_xx)\n            return f_hessian_xx.value()(x, u);\n        return OCPConstraint::hessian_xx(x, u);\n    }\n\n    Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        if(f_hessian_uu)\n            return f_hessian_uu.value()(x, u);\n        return OCPConstraint::hessian_uu(x, u);\n    }\n\n    Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        if(f_hessian_ux)\n            return f_hessian_ux.value()(x, u);\n        return OCPConstraint::hessian_ux(x, u);\n    }\n};\n\nclass OCPInputIndexedBoundConstraint : public OCPConstraint\n{\npublic:\n    enum BoundType : uint8_t\n    {\n        Lower,\n        Upper\n    };\n    OCPInputIndexedBoundConstraint(BoundType type, size_t index, double bound_val, double scale = 1.0):\n        OCPConstraint(OCPConstraintType::Ineq), type_(type), index_(index), bound_val_(bound_val), scale_(scale) {}\n\n    double eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) x;\n        if(type_ == BoundType::Lower)\n        {\n            return scale_ * (bound_val_ - u[index_]); // lb &lt;= u\n        }\n        else\n        {\n            return scale_ * (u[index_] - bound_val_); // u &lt;= ub\n        }\n    }\n\n    Eigen::VectorXd grad_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) u;\n        return Eigen::VectorXd::Zero(x.size());\n    }\n\n    Eigen::VectorXd grad_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) x;\n        Eigen::VectorXd grad = Eigen::VectorXd::Zero(u.size());\n        if(type_ == BoundType::Lower)\n        {\n            grad[index_] = -scale_;\n        }\n        else\n        {\n            grad[index_] = scale_;\n        }\n        return grad;\n    }\n\n    Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) u;\n        return Eigen::MatrixXd::Zero(x.size(), x.size());\n    }\n\n    Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) x;\n        return Eigen::MatrixXd::Zero(u.size(), u.size());\n    }\n\n    Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        return Eigen::MatrixXd::Zero(u.size(), x.size());\n    }\n\nprivate:\n    BoundType type_;\n    size_t index_;\n    double bound_val_;\n    double scale_;\n};\n\nclass OCPStateIndexedBoundConstraint : public OCPConstraint\n{\npublic:\n    enum BoundType : uint8_t\n    {\n        Lower,\n        Upper\n    };\n    OCPStateIndexedBoundConstraint(BoundType type, size_t index, double bound_val, double scale = 1.0):\n        OCPConstraint(OCPConstraintType::Ineq), type_(type), index_(index), bound_val_(bound_val), scale_(scale) {}\n\n    double eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) u;\n        if(type_ == BoundType::Lower)\n        {\n            return scale_ * (bound_val_ - x[index_]); // lb &lt;= x\n        }\n        else\n        {\n            return scale_ * (x[index_] - bound_val_); // x &lt;= ub\n        }\n    }\n\n    Eigen::VectorXd grad_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) u;\n        Eigen::VectorXd grad = Eigen::VectorXd::Zero(x.size());\n        if(type_ == BoundType::Lower)\n        {\n            grad[index_] = -scale_;\n        }\n        else\n        {\n            grad[index_] = scale_;\n        }\n        return grad;\n    }\n\n    Eigen::VectorXd grad_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) x;\n        return Eigen::VectorXd::Zero(u.size());\n    }\n\n    Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) u;\n        return Eigen::MatrixXd::Zero(x.size(), x.size());\n    }\n\n    Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        (void) x;\n        return Eigen::MatrixXd::Zero(u.size(), u.size());\n    }\n\n    Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) const override\n    {\n        return Eigen::MatrixXd::Zero(u.size(), x.size());\n    }\n\nprivate:\n    BoundType type_;\n    size_t index_;\n    double bound_val_;\n    double scale_;\n};\n\nstatic OCPConstraintArray OCPInputBoundConstraints(const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, double slope = 10.0)\n{\n    assert(lb.size() == ub.size());\n\n    const size_t input_size = lb.size();\n\n    OCPConstraintArray constraints;\n    for(size_t i = 0; i &lt; input_size; i++)\n    {\n        // lb &lt;= u\n        constraints.push_back(\n            std::make_shared&lt;OCPInputIndexedBoundConstraint&gt;(OCPInputIndexedBoundConstraint::BoundType::Lower, i, lb[i], slope));\n\n        // u &lt;= ub\n        constraints.push_back(\n            std::make_shared&lt;OCPInputIndexedBoundConstraint&gt;(OCPInputIndexedBoundConstraint::BoundType::Upper, i, ub[i], slope));\n    }\n    return constraints;\n}\n\nstatic OCPConstraintArray OCPStateBoundConstrants(const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, double slope = 10.0)\n{\n    assert(lb.size() == ub.size());\n\n    const size_t state_size = lb.size();\n\n    OCPConstraintArray constraints;\n    for(size_t i = 0; i &lt; state_size; i++)\n    {\n        // lb &lt;= x\n        constraints.push_back(\n            std::make_shared&lt;OCPStateIndexedBoundConstraint&gt;(OCPStateIndexedBoundConstraint::BoundType::Lower, i, lb[i], slope));\n\n        // x &lt;= ub\n        constraints.push_back(\n            std::make_shared&lt;OCPStateIndexedBoundConstraint&gt;(OCPStateIndexedBoundConstraint::BoundType::Upper, i, ub[i], slope));\n    }\n    return constraints;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/ocp__cost_8hpp/","title":"include/cpp_robotics/controller/ocp_cost.hpp","text":""},{"location":"doxybook/Files/ocp__cost_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/ocp__cost_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::OCPCost class cpp_robotics::OCPCostQuadratic class cpp_robotics::OCPCostServoQuadratic"},{"location":"doxybook/Files/ocp__cost_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize/derivative.hpp&gt;\n#include &lt;cpp_robotics/controller/ocp_dynamics.hpp&gt;\n#include &lt;memory&gt;\n\n#include &lt;iostream&gt;\n\nnamespace cpp_robotics\n{\n\nclass OCPCost\n{\npublic:\n    using SharedPtr = std::shared_ptr&lt;OCPCost&gt;;\n\n    double eps = 1e-6;\n    OCPCost(size_t nx, size_t nu, size_t horizon):\n        nx_(nx), nu_(nu), horizon_(horizon){}\n\n    OCPCost(std::shared_ptr&lt;OCPDynamics&gt; model):\n        OCPCost(model-&gt;state_size(), model-&gt;input_size(), model-&gt;horizon()){}\n\n    virtual double eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const = 0;\n\n    virtual double eval_terminal(const Eigen::VectorXd &amp;x) const = 0;\n\n    virtual Eigen::VectorXd jacobian_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const\n    {\n        return derivative(\n            std::bind(&amp;OCPCost::eval, this, std::placeholders::_1, u, i), x, eps);\n    }\n\n    virtual Eigen::VectorXd jacobian_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const\n    {\n        return derivative(\n            std::bind(&amp;OCPCost::eval, this, x, std::placeholders::_1, i), u, eps);\n    }\n\n    virtual Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const\n    {\n        return second_derivative(\n            std::bind(&amp;OCPCost::eval, this, std::placeholders::_1, u, i), x, eps);\n    }\n\n    virtual Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const\n    {\n        return second_derivative(\n            std::bind(&amp;OCPCost::eval, this, x, std::placeholders::_1, i), u, eps);\n    }\n\n    virtual Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const\n    {\n        return mixed_derivative(\n            std::bind(&amp;OCPCost::eval, this, std::placeholders::_1, std::placeholders::_2, i), x, u, eps);\n    }\n\n    virtual Eigen::VectorXd jacobian_x_terminal(const Eigen::VectorXd &amp;x) const\n    {\n        return derivative(\n            std::bind(&amp;OCPCost::eval_terminal, this, std::placeholders::_1), x, eps);\n    }\n\n    virtual Eigen::MatrixXd hessian_xx_terminal(const Eigen::VectorXd &amp;x) const\n    {\n        return second_derivative(\n            std::bind(&amp;OCPCost::eval_terminal, this, std::placeholders::_1), x, eps);\n    }\n\n    bool is_terminal(const size_t i) const\n    {\n        return i == horizon();\n    }\n    size_t state_size() const { return nx_; }\n    size_t input_size() const { return nu_; }\n    size_t horizon() const { return horizon_; }\n\nprivate:\n    const size_t nx_;\n    const size_t nu_;\n    const size_t horizon_;\n};\n\nclass OCPCostQuadratic : public OCPCost\n{\npublic:\n    OCPCostQuadratic(OCPDynamics::SharedPtr model):\n        OCPCostQuadratic(model-&gt;state_size(), model-&gt;input_size(), model-&gt;horizon()){}\n\n    OCPCostQuadratic(size_t nx, size_t nu, size_t horizon):\n        OCPCost(nx, nu, horizon)\n    {\n        Q = Eigen::MatrixXd::Zero(nx, nx);\n        R = Eigen::MatrixXd::Zero(nu, nu);\n        Qf = Eigen::MatrixXd::Zero(nx, nx);\n    }\n\n    double eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        return (0.5 * x.transpose() * Q * x + 0.5*u.transpose() * R * u)(0);\n    }\n\n    Eigen::VectorXd jacobian_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) u;\n        return Q * x;\n    }\n\n    Eigen::VectorXd jacobian_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) x;\n        return R * u;\n    }\n\n    Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) u;\n        (void) x;\n        return Q;\n    }\n\n    Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) x;\n        (void) u;\n        return R;\n    }\n\n    Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        return Eigen::MatrixXd::Zero(u.rows(), x.rows());\n    }\n\n    double eval_terminal(const Eigen::VectorXd &amp;x) const override\n    {\n        return (0.5 * x.transpose() * Qf * x)(0);\n    }\n\n    Eigen::VectorXd jacobian_x_terminal(const Eigen::VectorXd &amp;x) const override\n    {\n        return Qf * x;\n    }\n\n    Eigen::MatrixXd hessian_xx_terminal(const Eigen::VectorXd &amp;x) const override\n    {\n        (void) x;\n        return Qf;\n    }\n\n    Eigen::MatrixXd Q;\n    Eigen::MatrixXd R;\n    Eigen::MatrixXd Qf;\n};\n\nclass OCPCostServoQuadratic : public OCPCost\n{\npublic:\n    OCPCostServoQuadratic(OCPDynamics::SharedPtr model):\n        OCPCostServoQuadratic(model-&gt;state_size(), model-&gt;input_size(), model-&gt;horizon()){}\n\n    OCPCostServoQuadratic(size_t nx, size_t nu, size_t horizon):\n        OCPCost(nx, nu, horizon)\n    {\n        Q = Eigen::MatrixXd::Zero(nx, nx);\n        R = Eigen::MatrixXd::Zero(nu, nu);\n        Qf = Eigen::MatrixXd::Zero(nx, nx);\n        x_ref.resize(horizon+1);\n        for(size_t i = 0; i &lt; horizon+1; i++)\n        {\n            x_ref[i] = Eigen::MatrixXd::Zero(nx, 1);\n        }\n    }\n\n    void set_x_ref_const(const Eigen::VectorXd &amp;x_ref)\n    {\n        for(size_t i = 0; i &lt; horizon()+1; i++)\n        {\n            this-&gt;x_ref[i] = x_ref;\n        }\n    }\n\n    double eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        auto e = x - x_ref[i];\n        return (0.5 * e.transpose() * Q * e + 0.5*u.transpose() * R * u)(0);\n    }\n\n    Eigen::VectorXd jacobian_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) u;\n        return Q * (x - x_ref[i]);\n    }\n\n    Eigen::VectorXd jacobian_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) x;\n        return R * u;\n    }\n\n    Eigen::MatrixXd hessian_xx(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) u;\n        (void) x;\n        return Q;\n    }\n\n    Eigen::MatrixXd hessian_uu(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        (void) x;\n        (void) u;\n        return R;\n    }\n\n    Eigen::MatrixXd hessian_ux(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const size_t i) const override\n    {\n        (void) i;\n        return Eigen::MatrixXd::Zero(u.rows(), x.rows());\n    }\n\n    double eval_terminal(const Eigen::VectorXd &amp;x) const override\n    {\n        auto e = x - x_ref[horizon()];\n        return (0.5 * e.transpose() * Qf * e)(0);\n    }\n\n    Eigen::VectorXd jacobian_x_terminal(const Eigen::VectorXd &amp;x) const override\n    {\n        auto e = x - x_ref[horizon()];\n        return Qf * e;\n    }\n\n    Eigen::MatrixXd hessian_xx_terminal(const Eigen::VectorXd &amp;x) const override\n    {\n        (void) x;\n        return Qf;\n    }\n\n    Eigen::MatrixXd Q;\n    Eigen::MatrixXd R;\n    Eigen::MatrixXd Qf;\n    std::vector&lt;Eigen::MatrixXd&gt; x_ref;\n};\n\n} // namespace cpp_robotics\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/ocp__dynamics_8hpp/","title":"include/cpp_robotics/controller/ocp_dynamics.hpp","text":""},{"location":"doxybook/Files/ocp__dynamics_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::internal"},{"location":"doxybook/Files/ocp__dynamics_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::OCPDynamics class cpp_robotics::OCPDiscreteLinearDynamics class cpp_robotics::OCPContinuousLinearDynamics class cpp_robotics::OCPDiscreteNonlinearDynamics class cpp_robotics::OCPContinuousNonlinearDynamics struct cpp_robotics::internal::has_ad_dynamics struct cpp_robotics::internal::has_ad_dynamics&lt; DerClass, Scalar, std::void_t&lt; decltype(std::declval&lt; const DerClass &gt;().dynamics(std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;()))&gt;&gt; class cpp_robotics::OCPContinuousNonlinearDynamicsAD"},{"location":"doxybook/Files/ocp__dynamics_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize/derivative.hpp&gt;\n#include &lt;cpp_robotics/system/discret.hpp&gt;\n#include &lt;cpp_robotics/algorithm/auto_diff.hpp&gt;\n#include &lt;cpp_robotics/system/dynamics_integrate.hpp&gt;\n#include &lt;memory&gt;\n\nnamespace cpp_robotics\n{\n\nclass OCPDynamics\n{\npublic:\n    using SharedPtr = std::shared_ptr&lt;OCPDynamics&gt;;\n\n    double eps = 1e-6;\n    OCPDynamics(size_t nx, size_t nu, size_t horizon):\n        nx_(nx), nu_(nu), horizon_(horizon) {}\n\n    virtual Eigen::VectorXd eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) = 0;\n\n    virtual Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) \n    {\n        return derivative(std::bind(&amp;OCPDynamics::eval, this, std::placeholders::_1, u), x, eps);\n    }\n\n    virtual Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u)\n    {\n        return derivative(std::bind(&amp;OCPDynamics::eval, this, x, std::placeholders::_1), u, eps);\n    }\n\n    size_t state_size() const { return nx_; }\n    size_t input_size() const { return nu_; }\n    size_t horizon() const { return horizon_; }\n\nprivate:\n    const size_t nx_;\n    const size_t nu_;\n    const size_t horizon_;\n};\n\nclass OCPDiscreteLinearDynamics : public OCPDynamics\n{\npublic:\n    OCPDiscreteLinearDynamics(const size_t nx, const size_t nu, const size_t horizon):\n        OCPDynamics(nx, nu, horizon),\n        A(Eigen::MatrixXd::Zero(nx, nx)),\n        B(Eigen::MatrixXd::Zero(nx, nu)){}\n\n    OCPDiscreteLinearDynamics(const Eigen::MatrixXd &amp;A, const Eigen::MatrixXd &amp;B, size_t horizon):\n        OCPDynamics(A.rows(), B.cols(), horizon),\n        A(A),\n        B(B){}\n\n    Eigen::VectorXd eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        return A * x + B * u;\n    }\n\n    Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        (void) x;\n        (void) u;\n        return A;\n    }\n\n    Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        (void) x;\n        (void) u;\n        return B;\n    }\n\nprivate:\n    Eigen::MatrixXd A;\n    Eigen::MatrixXd B;\n};\n\nclass OCPContinuousLinearDynamics : public OCPDynamics\n{\npublic:\n    OCPContinuousLinearDynamics(const size_t nx, const size_t nu, const size_t horizon):\n        OCPDynamics(nx, nu, horizon){}\n\n    OCPContinuousLinearDynamics(const Eigen::MatrixXd &amp;Acon, const Eigen::MatrixXd &amp;Bcon, double dt, size_t horizon):\n        OCPDynamics(Acon.rows(), Bcon.cols(), horizon)\n    {\n        set_continuous_dynamics(Acon, Bcon, dt);\n    }\n\n    void set_continuous_dynamics(const Eigen::MatrixXd &amp;Acon, const Eigen::MatrixXd &amp;Bcon, double dt)\n    {\n        std::tie(A, B) = Discret::discritize(Acon, Bcon, dt);\n    }\n\n    Eigen::VectorXd eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        return A * x + B * u;\n    }\n\n    Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        (void) x;\n        (void) u;\n        return A;\n    }\n\n    Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        (void) x;\n        (void) u;\n        return B;\n    }\n\nprivate:\n    Eigen::MatrixXd A;\n    Eigen::MatrixXd B;\n};\n\nclass OCPDiscreteNonlinearDynamics : public OCPDynamics\n{\npublic:\n    OCPDiscreteNonlinearDynamics(size_t nx, size_t nu, size_t horizon):\n        OCPDynamics(nx, nu, horizon){}\n};\n\nenum class OCPIntegrationMethod\n{\n    ForwardEuler,\n    ModifiedEuler,\n    RK4,\n};\n\nclass OCPContinuousNonlinearDynamics : public OCPDynamics\n{\npublic:\n    OCPContinuousNonlinearDynamics(OCPIntegrationMethod method, size_t nx, size_t nu, size_t horizon, double dt):\n        OCPDynamics(nx, nu, horizon), method_(method), dt_(dt) {}\n\n    virtual Eigen::VectorXd dynamics(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) = 0;\n\n    Eigen::VectorXd eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        Eigen::VectorXd x_next(state_size());\n        std::function&lt;Eigen::VectorXd(const Eigen::VectorXd&amp;, const Eigen::VectorXd&amp;)&gt; dynf = \n            std::bind(&amp;OCPContinuousNonlinearDynamics::dynamics, this, std::placeholders::_1, u);\n        switch (method_)\n        {\n            case OCPIntegrationMethod::ForwardEuler:\n                x_next = integrate_forward_euler(dt_, x, u, dynf);\n                break;\n            case OCPIntegrationMethod::ModifiedEuler:\n                x_next =  integrate_modified_euler(dt_, x, u, dynf);\n                break;\n            case OCPIntegrationMethod::RK4:\n                x_next =  integrate_rk4(dt_, x, u, dynf);\n                break;\n        }\n        return x_next;\n    }\n\n    double dt() const { return dt_; }\nprivate:\n    const OCPIntegrationMethod method_;\n    double dt_;\n};\n\nnamespace internal\n{\n\ntemplate&lt;typename DerClass, typename Scalar, typename = void&gt;\nstruct has_ad_dynamics : std::false_type {};\n\ntemplate&lt;typename DerClass, typename Scalar&gt;\nstruct has_ad_dynamics&lt;DerClass, Scalar,\n    std::void_t&lt;decltype(\n        std::declval&lt;const DerClass&gt;().dynamics(\n            std::declval&lt;const Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;&amp;&gt;(),\n            std::declval&lt;const Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;&amp;&gt;(),\n            std::declval&lt;Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;&amp;&gt;()\n        )\n    )&gt;\n&gt; : std::true_type {};\n\n}\n\ntemplate&lt;class Derived&gt;\nclass OCPContinuousNonlinearDynamicsAD : public OCPDynamics\n{\npublic:\n    OCPContinuousNonlinearDynamicsAD(OCPIntegrationMethod method, size_t nx, size_t nu, size_t horizon, double dt):\n        OCPDynamics(nx, nu, horizon), method_(method), dt_(dt),\n        x_(nx, nx + nu, 0), u_(nu, nx + nu, nx), dx_(nx, nx + nu, 0), x_next_(nx, nx + nu, 0)\n    {\n        static_assert(internal::has_ad_dynamics&lt;Derived, Eigen::VectorXd::Scalar&gt;::value, \n            \"Derived class must implement void dynamics(const VectorX&lt;Scalar&gt; &amp;x, const VectorX&lt;Scalar&gt; &amp;u, VectorX&lt;Scalar&gt; &amp;dx) for double\");\n        static_assert(internal::has_ad_dynamics&lt;Derived, ADVectorXd::Scalar&gt;::value, \n            \"Derived class must implement void dynamics(const VectorX&lt;Scalar&gt; &amp;x, const VectorX&lt;Scalar&gt; &amp;u, VectorX&lt;Scalar&gt; &amp;dx) for ADScalar\");\n    }\n\n    Eigen::VectorXd eval(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        Eigen::VectorXd x_next(state_size());\n        Eigen::VectorXd dx(state_size());\n        std::function&lt;Eigen::VectorXd(const Eigen::VectorXd&amp;, const Eigen::VectorXd&amp;)&gt; dynf = \n            [&amp;](auto &amp;x, auto &amp;u){ static_cast&lt;const Derived*&gt;(this)-&gt;dynamics(x, u, dx); return dx; };\n        switch(method_)\n        {\n            case OCPIntegrationMethod::ForwardEuler:\n                x_next = integrate_forward_euler(dt_, x, u, dynf);\n                break;\n            case OCPIntegrationMethod::ModifiedEuler:\n                x_next =  integrate_modified_euler(dt_, x, u, dynf);\n                break;\n            case OCPIntegrationMethod::RK4:\n                x_next =  integrate_rk4(dt_, x, u, dynf);\n                break;\n        }\n        return x_next;\n    }\n\n    Eigen::MatrixXd jacobian_x(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        eval_ad(x, u);\n        Eigen::MatrixXd J_fx(state_size(), state_size());\n        for (size_t i = 0; i &lt; state_size(); i++)\n            J_fx.row(i) = x_next_[i].derivatives().head(state_size());\n        return J_fx;\n    }\n\n    Eigen::MatrixXd jacobian_u(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u) override\n    {\n        eval_ad(x, u);\n        Eigen::MatrixXd J_fu(state_size(), input_size());\n        for (size_t i = 0; i &lt; state_size(); i++)\n            J_fu.row(i) = x_next_[i].derivatives().tail(input_size());\n        return J_fu;\n    }\n\nprivate:\n    void eval_ad(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u)\n    {\n        x_ = x;\n        u_ = u;\n        std::function&lt;ADVectorXd(const ADVectorXd&amp;, const ADVectorXd&amp;)&gt; dynf = \n            [&amp;](auto &amp;x, auto &amp;u) { static_cast&lt;const Derived*&gt;(this)-&gt;dynamics(x, u, dx_); return dx_; };\n        switch(method_)\n        {\n            case OCPIntegrationMethod::ForwardEuler:\n                x_next_ = integrate_forward_euler(dt_, x_, u_, dynf);\n                break;\n            case OCPIntegrationMethod::ModifiedEuler:\n                x_next_ = integrate_modified_euler(dt_, x_, u_, dynf);\n                break;\n            case OCPIntegrationMethod::RK4:\n                x_next_ = integrate_rk4(dt_, x_, u_, dynf);\n                break;\n        }\n    }\n\n    const OCPIntegrationMethod method_;\n    const double dt_;\n    ADVectorXd x_, u_, dx_, x_next_; \n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/omni__ik_8hpp/","title":"include/cpp_robotics/chassis/omni_ik.hpp","text":""},{"location":"doxybook/Files/omni__ik_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/omni__ik_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni3Ik::Config class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni4Ik::Config"},{"location":"doxybook/Files/omni__ik_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/vector/transform.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass Omni3Ik\n{\npublic:\n    struct Config\n    {\n        double radius;\n        double first_wheel_angle = M_PI/6;\n    };\n\n    Omni3Ik(double radius, double first_wheel_angle = M_PI/6):\n        Omni3Ik(Config{radius, first_wheel_angle}) {}\n\n    Omni3Ik(Config config):\n        config_(config)\n    {\n        for(size_t i = 0; i &lt; 3; i++)\n        {\n            const double wheel_angle = config_.first_wheel_angle + (i* 2*M_PI/3);\n            conv_mat_(i, 0) = -std::sin(wheel_angle);\n            conv_mat_(i, 1) =  std::cos(wheel_angle);\n            conv_mat_(i, 2) = config_.radius;\n\n        }\n    }\n\n    std::array&lt;double, 3&gt; calculate(Transformd velocity)\n    {\n        std::array&lt;double, 3&gt; wv;\n        Eigen::Map&lt;Eigen::Vector3d&gt; wv_vec(wv.data());\n        Eigen::Vector3d v(velocity.x, velocity.y, velocity.theta);\n        wv_vec = conv_mat_ * v;\n        return wv;\n    }\n\n    Config config() const { return config_; }\n\nprivate:\n    Config config_;\n    Eigen::Matrix&lt;double, 3, 3&gt; conv_mat_;\n};\n\nclass Omni4Ik\n{\npublic:\n    struct Config\n    {\n        double radius;\n        double first_wheel_angle = M_PI/4;\n    };\n\n    Omni4Ik(double radius, double first_wheel_angle = M_PI/4):\n        Omni4Ik(Config{radius, first_wheel_angle}) {}\n\n    Omni4Ik(Config config):\n        config_(config)\n    {\n        for(size_t i = 0; i &lt; 4; i++)\n        {\n            const double wheel_angle = config_.first_wheel_angle + (i* M_PI/2);\n            conv_mat_(i, 0) = -std::sin(wheel_angle);\n            conv_mat_(i, 1) =  std::cos(wheel_angle);\n            conv_mat_(i, 2) = config_.radius;\n\n        }\n    }\n\n    std::array&lt;double, 4&gt; calculate(Transformd velocity)\n    {\n        std::array&lt;double, 4&gt; wv;\n        Eigen::Map&lt;Eigen::Vector4d&gt; wv_vec(wv.data());\n        Eigen::Vector3d v(velocity.x, velocity.y, velocity.theta);\n        wv_vec = conv_mat_ * v;\n        return wv;\n    }\n\n    Config config() const { return config_; }\n\nprivate:\n    Config config_;\n    Eigen::Matrix&lt;double, 4, 3&gt; conv_mat_;\n};\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/optimal__control__problem_8hpp/","title":"include/cpp_robotics/controller/optimal_control_problem.hpp","text":""},{"location":"doxybook/Files/optimal__control__problem_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/optimal__control__problem_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::OptimalControlProblem"},{"location":"doxybook/Files/optimal__control__problem_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/controller/ocp_dynamics.hpp&gt;\n#include &lt;cpp_robotics/controller/ocp_cost.hpp&gt;\n#include &lt;cpp_robotics/controller/ocp_constraint.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass OptimalControlProblem\n{\npublic:\n    std::shared_ptr&lt;OCPDynamics&gt; dynamics;\n    std::shared_ptr&lt;OCPCost&gt; cost;\n    OCPConstraintArray constraints;\n\n    OptimalControlProblem() = default;\n    OptimalControlProblem(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost):\n        dynamics(dynamics), cost(cost) {}\n    OptimalControlProblem(OCPDynamics::SharedPtr dynamics, OCPCost::SharedPtr cost, const OCPConstraintArray &amp;constraints):\n        dynamics(dynamics), cost(cost), constraints(constraints) {}\n\n    size_t input_size() const { return dynamics-&gt;input_size(); }\n    size_t state_size() const { return dynamics-&gt;state_size(); }\n    size_t horizon() const { return dynamics-&gt;horizon(); }\n\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/penalty__method_8hpp/","title":"include/cpp_robotics/optimize/penalty_method.hpp","text":""},{"location":"doxybook/Files/penalty__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/penalty__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"constraint.hpp\"\n#include \"derivative.hpp\"\n#include \"quasi_newton_method.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; penalty_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init = 1.0, const double tol = 1e-3, const size_t max_iter = 1000)\n{\n    Eigen::VectorXd x = x_init;\n    double r = r_init;\n    std::function&lt;double(const Eigen::VectorXd &amp;)&gt; ext_f = \n    [&amp;](const Eigen::VectorXd &amp; x)\n    {\n        double y = f(x);\n\n        for(auto &amp; con : constraint)\n        {\n            switch(con.type)\n            {\n                case Constraint::Type::Eq:\n                    y += r*std::pow(con.con_f(x), 2);\n                    break;\n                case Constraint::Type::Ineq:\n                    y += r*std::pow(std::max(0.0, con.con_f(x)), 2);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        return y;\n    };\n\n    auto ext_grad = [&amp;](Eigen::VectorXd x)\n    {\n        return derivative(ext_f, x);\n    };\n\n    for(size_t i = 0; i &lt; max_iter; i++)\n    {\n        auto [step_result, new_x, sub_itr_cnt] = quasi_newton_method(ext_f, ext_grad, x, tol, 1);\n        if(std::abs(r * constraint.eval_sum(new_x)) &lt; tol)\n            return {true, new_x, i};\n\n        x = new_x;\n        r += 1;\n    }\n    return {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/pfc_8hpp/","title":"include/cpp_robotics/controller/pfc.hpp","text":""},{"location":"doxybook/Files/pfc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pfc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SISOPFC"},{"location":"doxybook/Files/pfc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// https://hamachannel.hatenablog.com/entry/2018/01/13/233521\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n\nnamespace cpp_robotics\n{\n\nclass SISOPFC\n{\npublic:\n\n    SISOPFC(const Eigen::MatrixXd&amp; Ad, const Eigen::VectorXd&amp; Bd, const Eigen::VectorXd&amp; Cd, const double delay, const double target_responce_time, const double dt):\n        A(Ad), B(Bd), C(Cd), delay_(delay), target_responce_time_(target_responce_time), dt_(dt), prev_input_(0)\n    {\n        h1 = std::ceil(target_responce_time_ / (dt_ * 3));\n        h2 = std::ceil(target_responce_time_ / (dt_ * 2));\n        h3 = std::ceil(target_responce_time_ / (dt_ * 1));\n\n        lh &lt;&lt;\n            (1.0 - std::exp(-3.0 * (double)(h1) * dt_ / target_responce_time_)),\n            (1.0 - std::exp(-3.0 * (double)(h2) * dt_ / target_responce_time_)),\n            (1.0 - std::exp(-3.0 * (double)(h3) * dt_ / target_responce_time_));\n\n        CAh1 = CAh2 = CAh3 = C.transpose().eval();\n        for(size_t i = 0; i &lt; h1; i++)\n            CAh1 *= A;\n        for (size_t i = 0; i &lt; h2; i++)\n            CAh2 *= A;\n        for (size_t i = 0; i &lt; h3; i++)\n            CAh3 *= A;\n\n        G_inv.setZero();\n        Eigen::RowVectorXd tmp = C.transpose();\n        for (size_t i = 0; i &lt; h1; i++)\n        {\n            if(i &gt; 0)\n                tmp *= A;\n            double ele = tmp.dot(B);\n            double t1 = dt_ * (h1-1-i);\n            double t2 = t1 * t1;\n            G_inv(0, 0) += ele;\n            G_inv(0, 1) += ele * t1;\n            G_inv(0, 2) += ele * t2;\n        }\n\n        tmp = C.transpose();\n        for (size_t i = 0; i &lt; h2; i++)\n        {\n            if (i &gt; 0)\n                tmp *= A;\n            double ele = tmp.dot(B);\n            double t1 = dt_ * (h2-1-i);\n            double t2 = t1 * t1;\n            G_inv(1, 0) += ele;\n            G_inv(1, 1) += ele * t1;\n            G_inv(1, 2) += ele * t2;\n        }\n        tmp = C.transpose();\n        for (size_t i = 0; i &lt; h3; i++)\n        {\n            if (i &gt; 0)\n                tmp *= A;\n            double ele = tmp.dot(B);\n            double t1 = dt_ * (h3-1 - i);\n            double t2 = t1 * t1;\n            G_inv(2, 0) += ele;\n            G_inv(2, 1) += ele * t1;\n            G_inv(2, 2) += ele * t2;\n        }\n\n        G_inv = G_inv.inverse().eval();\n        xm = Eigen::VectorXd::Zero(A.cols());\n    }\n\n    double calculate(std::function&lt;double(double)&gt; ref_target, double now_state)\n    {\n        return calculate(ref_target, now_state, prev_input_);\n    }\n\n    double calculate(std::function&lt;double(double)&gt; ref_target, double now_state, double prev_input)\n    {\n        Eigen::Vector3d SV_future;\n        Eigen::Vector3d SF;\n\n        xm = A * xm + B * prev_input;\n        double y = C.dot(xm);\n\n        double now_tsarget = ref_target(delay_);\n\n        SV_future &lt;&lt;\n            ref_target(delay_ + h1 * dt_) - now_tsarget,\n            ref_target(delay_ + h2 * dt_) - now_tsarget,\n            ref_target(delay_ + h3 * dt_) - now_tsarget;\n\n        SF &lt;&lt;\n            CAh1.dot(xm),\n            CAh2.dot(xm),\n            CAh3.dot(xm);\n\n        auto buf = G_inv * (SV_future + (now_tsarget - now_state) * lh - SF + Eigen::Vector3d::Constant(y));\n        prev_input_ = std::clamp&lt;double&gt;(buf(0), -12, 12);\n\n        return prev_input_;\n    }\n\n    double prev_input() const { return prev_input_; }\nprivate:\n    Eigen::Matrix3d G_inv;\n    Eigen::MatrixXd A;\n    Eigen::VectorXd B, xm, MV_pre;\n    Eigen::VectorXd C;\n    Eigen::RowVectorXd CAh1, CAh2, CAh3;\n    Eigen::Vector3d lh;\n    size_t h1, h2, h3;\n    double delay_;\n    double target_responce_time_, dt_;\n    double prev_input_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/pid2_8hpp/","title":"include/cpp_robotics/controller/pid2.hpp","text":""},{"location":"doxybook/Files/pid2_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pid2_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PID2 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 struct cpp_robotics::PID2::pid_param_t"},{"location":"doxybook/Files/pid2_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\nclass PID2\n{\npublic:\n    struct pid_param_t\n    {\n        double Ts;\n        double gpd;\n        double Kp, Ki, Kd;\n        double b, c;\n        std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit;\n    };\n\n    static PID2 create_PI_D(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit = std::nullopt)\n    {\n        pid_param_t param = \n        {\n            .Ts = Ts,\n            .gpd = gpd,\n            .Kp = Kp,\n            .Ki = Ki,\n            .Kd = Kd,\n            .b = 1,\n            .c = 0,\n            .output_limit = output_limit\n        };\n\n        return PID2(param);\n    }\n\n    static PID2 create_I_PD(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit = std::nullopt)\n    {\n        pid_param_t param = \n        {\n            .Ts = Ts,\n            .gpd = gpd,\n            .Kp = Kp,\n            .Ki = Ki,\n            .Kd = Kd,\n            .b = 0,\n            .c = 0,\n            .output_limit = output_limit\n        };\n\n        return PID2(param);\n    }\n\n    static PID2 create_feed_foward_pid2(double Ts, double gpd, double Kpff, double Kdff, double Kpfb, double Kifb, double Kdfb, std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit = std::nullopt)\n    {\n        pid_param_t param = \n        {\n            .Ts = Ts,\n            .gpd = gpd,\n            .Kp = Kpfb,\n            .Ki = Kifb,\n            .Kd = Kdfb,\n            .b = (Kpff+Kpfb)/Kpfb,\n            .c = (Kdff+Kdfb)/Kdfb,\n            .output_limit = output_limit\n        };\n\n        return PID2(param);\n    }\n\n    PID2(pid_param_t param)\n    {\n        set_param(param);\n        reset();\n    }\n\n    void set_param(pid_param_t param)\n    {\n        param_ = param;\n    }\n\n    void reset()\n    {\n        u1_ = 0;\n        u2_ = 0;\n        r1_ = 0;\n        r2_ = 0;\n        y1_ = 0;\n        y2_ = 0;\n    }\n\n    double calculate(double target, double present)\n    {\n        double &amp;r = target;\n        double &amp;y = present;\n        auto &amp;[Ts, gpd, Kp, Ki, Kd, b, c, output_limit] = param_;\n\n        double u = ( Kp*( (4.0+2.0*gpd*Ts)*(b*r-y) - 8.0*(b*r1_-y1_) + (4.0-2.0*gpd*Ts)*(b*r2_-y2_) )\n                    +Ki*Ts*( (2.0+gpd*Ts)*(r-y) +2.0*gpd*Ts*(r1_-y1_) - (2.0-gpd*Ts)*(r2_-y2_) ) \n                    +4.0*Kd*gpd*( (c*r-y) - 2.0*(c*r1_-y1_) + (c*r2_-y2_) ) \n                    + 8.0*u1_ -(4.0-2.0*gpd*Ts)*u2_) / (4.0+2.0*gpd*Ts);\n\n        if(output_limit)\n        {\n            u = std::clamp(u, output_limit.value().first, output_limit.value().second);\n        }\n\n        r2_ = r1_;\n        r1_ = r;\n        y2_ = y1_;\n        y1_ = y;\n\n        u2_ = u1_;\n        u1_ = u;\n\n        return u;\n    }\n\nprivate:\n    pid_param_t param_;\n    double u1_, u2_;\n    double r1_, r2_;\n    double y1_, y2_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/pid_8hpp/","title":"include/cpp_robotics/controller/pid.hpp","text":""},{"location":"doxybook/Files/pid_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pid_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PID PID\u5236\u5fa1\u5668 struct cpp_robotics::PID::pid_param_t"},{"location":"doxybook/Files/pid_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\nclass PID\n{\npublic:\n    struct pid_param_t\n    {\n        double Ts;\n        double gpd;\n        double Kp, Ki, Kd;\n        std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit;\n    };\n\n    PID(pid_param_t param)\n    {\n        set_param(param);\n        reset();\n    }\n\n    void set_param(pid_param_t param)\n    {\n        param_ = param;\n    }\n\n    void reset()\n    {\n        u1_ = 0;\n        u2_ = 0;\n        e1_ = 0;\n        e2_ = 0;\n    }\n\n    double calculate(double error)\n    {\n        auto &amp;[Ts, gpd, Kp, Ki, Kd, output_limit] = param_;\n\n        double u = ( 2.0*Ts*(Ki+Kp*gpd)*(error-e2_) + Ki*gpd*Ts*Ts*(error+2.0*e1_+e2_) +\n                    4.0*(Kd*gpd+Kp)*(error-2.0*e1_+e2_) - (4.0-2.0*gpd*Ts)*u2_ + 8.0*u1_) / (4.0+2.0*gpd*Ts);\n\n        e2_ = e1_;\n        e1_ = error;\n\n        u2_ = u1_;\n        u1_ = u;\n\n        if(output_limit)\n        {\n            u = std::clamp(u, output_limit.value().first, output_limit.value().second);\n        }\n\n        return u;\n    }\n\nprivate:\n    pid_param_t param_;\n    double u1_, u2_;\n    double e1_, e2_;\n};\n\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/poly__regression_8hpp/","title":"include/cpp_robotics/algorithm/poly_regression.hpp","text":""},{"location":"doxybook/Files/poly__regression_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/poly__regression_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/system/polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nPolynomial poly_regression(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y, const size_t degree)\n{\n    Eigen::MatrixXd XT, Y;\n\n    assert(x.size() == y.size());\n    const size_t data_num = x.size();\n    XT.resize(degree + 1, data_num);\n    Y.resize(data_num, 1);\n\n    for (size_t j = 0; j &lt; x.size(); j++)\n    {\n        XT(0, j) = 1;\n        for (size_t i = 0; i &lt; degree; i++)\n        {\n            XT(i + 1, j) = XT(i, j) * x[j];\n        }\n    }\n\n    for (size_t i = 0; i &lt; y.size(); i++)\n    {\n        Y(i) = y[i];\n    }\n\n    std::vector&lt;double&gt; coeff(degree + 1);\n    Eigen::Map&lt;Eigen::VectorXd&gt; coeff_vec(coeff.data(), degree + 1);\n    coeff_vec = (XT * XT.transpose()).inverse() * (XT * Y);\n    return Polynomial(coeff);\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/polynomial_8hpp/","title":"include/cpp_robotics/system/polynomial.hpp","text":""},{"location":"doxybook/Files/polynomial_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/polynomial_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Polynomial \u591a\u9805\u5f0f"},{"location":"doxybook/Files/polynomial_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;cassert&gt;\n#include &lt;cpp_robotics/utility/cpp_support.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n// _coeff.front()\u304c\u6700\u9ad8\u6b21\u6570\n// _coeff.back()\u304c\u6b21\u65700\nstruct Polynomial\n{\n    Polynomial() = default;\n\n    Polynomial(std::initializer_list&lt;double&gt; coeff):\n        _coeff(coeff.begin(), coeff.end())\n    {\n        check_degree();\n    }\n\n    Polynomial(const std::vector&lt;double&gt; &amp;coeff):\n        _coeff(coeff)\n    {\n        check_degree();\n    }\n\n    template&lt;class IteratorType&gt;\n    Polynomial(IteratorType begin, IteratorType end):\n        _coeff(begin, end)\n    {\n        check_degree();\n    }\n\n    // (x-a1)(x-a2)...(x-aN)\u306e{a...aN}\u3092\u5f15\u6570\u306b\u3068\u308a\u5c55\u958b\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059\n    static Polynomial expand(std::vector&lt;double&gt; roots)\n    {\n        std::vector&lt;double&gt; coeff, buf;\n        coeff.reserve(roots.size()+1);\n        buf.reserve(roots.size());\n        coeff.resize(1);\n\n        coeff[0] = 1;\n        for(auto &amp;c : roots)\n        {\n\n            // (x^m+a*x^m-1 ... c) * x\u3092\u8a08\u7b97\u3059\u308b\n            buf = coeff;\n            coeff.push_back(0);\n\n            // (x^m+a*x^m-1 ... c) * d\u3092\u8a08\u7b97\u3059\u308b\n            for(auto &amp;bval : buf)\n                bval *= -c;\n\n            // (x^m+a*x^m-1 ... c) * d\u3092\u52a0\u7b97\u3059\u308b\n            for(size_t i = 0; i &lt; buf.size(); i++)\n            {\n                coeff[i+1] += buf[i];\n            }\n        }\n\n        return Polynomial{coeff};\n    }\n\n    void set_degree(size_t deg) { _coeff.resize(deg + 1); }\n    size_t size() const { return _coeff.size(); }\n    size_t degree() const { return size() ? (size() - 1) : 0; }\n    //size_t degree_at(size_t i) const { return size() ? (degree() - i) : 0; }\n\n    std::vector&lt;double&gt; coeff() const { return _coeff; }\n\n    double &amp;at(size_t i) { return _coeff[i]; }\n    double  at(size_t i) const { return _coeff[i]; }\n\n    double &amp;at_degree(size_t i) { return _coeff[degree()-i]; }\n    double  at_degree(size_t i) const { return _coeff[degree()-i]; }\n\n    double &amp;operator [](size_t i) { return at(i); }\n    double operator [](size_t i) const { return at(i); }\n\n    double evalute(double x) const\n    {\n        assert(_coeff.size() != 0);\n\n        double xn = 1;\n        double y = _coeff.back();\n        for(auto it = _coeff.rbegin()+1; it != _coeff.rend(); it++)\n        {\n            y = y*x + (*it);\n        }\n\n        return y;\n    }\n\n    // /**\n    //  * @brief \u591a\u9805\u5f0f\u3092n\u968e\u5fae\u5206\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059\n    //  * \n    //  * @param i \n    //  * @return Polynomial \n    //  */\n    // Polynomial polyder(size_t i) const\n    // {\n    //     assert(degree() &gt; 0);\n\n    //     if(i == 0)\n    //         return *this;\n    //     if(i &gt; degree())\n    //         return {0};\n\n    //     Polynomial dpol = *this;\n\n    //     for(size_t c = 0; c &lt; dpol.size(); c++)\n    //     {\n    //         if(c &gt;= i)\n    //         {\n    //             size_t nc = 1;\n    //             for(size_t r = 0; r &lt; i; r++)\n    //             {\n    //                 nc *= (c - r);\n    //             }\n    //             dpol[c] *= static_cast&lt;double&gt;(nc);\n    //         }\n\n    //     }\n    //     dpol._coeff.erase(dpol._coeff.begin(), dpol._coeff.begin()+i);\n\n\n    //     // size_t deg = dpol.degree();\n    //     // dpol._coeff.resize(dpol.size() - i);\n\n    //     // for(size_t c = 0; c &lt; dpol.size(); c++)\n    //     // {\n    //     //     size_t nc = 1;\n    //     //     for(size_t r = 0; r &lt; i; r++)\n    //     //     {\n    //     //         nc *= (deg - c - r);\n    //     //     }\n    //     //     dpol[c] *= static_cast&lt;double&gt;(nc);\n    //     // }\n\n    //     return dpol;\n    // }\n\n    // Polynomial polyint(double C = 0) const\n    // {\n    //     Polynomial ipol = *this;\n\n    //     for(size_t i = 0; i &lt; ipol.size(); i++)\n    //     {\n    //         double ndeg = static_cast&lt;double&gt;(i + 1);\n    //         ipol[i] /= ndeg;\n    //     }\n\n    //     ipol._coeff.insert(ipol._coeff.begin(), C);\n\n    //     return ipol;\n    // }\n\n    void swap(Polynomial &amp;poly)\n    {\n        Polynomial tmp = *this;\n        *this = poly;\n        poly = tmp;\n    }\n\n    double operator()(double x) const\n    {\n        return evalute(x);\n    }\n\n    Polynomial operator +() const\n    {\n        return *this;\n    }\n\n    Polynomial operator -() const\n    {\n        Polynomial ret = *this;\n        for(auto &amp;c : ret._coeff)\n            c *= -1;\n        return ret;\n    }\n\n    Polynomial operator +(double s) const\n    {\n        Polynomial ret = *this;\n        ret[ret.degree()] += s;\n        ret.check_degree();\n        return ret;\n    }\n\n    Polynomial operator -(double s) const\n    {\n        Polynomial ret = *this;\n        ret[ret.degree()] -= s;\n        ret.check_degree();\n        return ret;\n    }\n\n    Polynomial&amp; operator +=(double s)\n    {\n        this-&gt;at(this-&gt;degree()) += s;\n        this-&gt;check_degree();\n        return *this;\n    }\n\n    Polynomial&amp; operator -=(double s)\n    {\n        this-&gt;at(this-&gt;degree()) -= s;\n        this-&gt;check_degree();\n        return *this;\n    }\n\n    Polynomial operator *(double s) const\n    {\n        Polynomial ret = *this;\n        for(auto &amp;c : ret._coeff)\n            c *= s;\n        ret.check_degree();\n        return ret;\n    }\n\n    friend Polynomial operator *(double s, const Polynomial &amp;poly)\n    {\n        return poly * s;\n    }\n\n    Polynomial&amp; operator *=(double s)\n    {\n        *this = *this * s;\n        return *this;\n    }\n\n    Polynomial operator /(double s) const\n    {\n        Polynomial ret = *this;\n        for(auto &amp;c : ret._coeff)\n            c /= s;\n        ret.check_degree();\n        return ret;\n    }\n\n    Polynomial&amp; operator /=(double s)\n    {\n        *this = *this / s;\n        return *this;\n    }\n\n    Polynomial operator *(const Polynomial &amp;p) const\n    {\n        std::vector&lt;double&gt; new_coeff(this-&gt;degree() + p.degree() + 1);\n        size_t new_deg = new_coeff.size()-1;\n\n        std::vector&lt;double&gt; c0 = this-&gt;coeff();\n        std::vector&lt;double&gt; c1 = p.coeff();\n\n        for(size_t i0 = 0; i0 &lt; c0.size(); i0++)\n        {\n            for(size_t i1 = 0; i1 &lt; c1.size(); i1++)\n            {\n                size_t deg0 = this-&gt;degree() - i0;\n                size_t deg1 = p.degree() - i1;\n\n                size_t deg = new_deg - (deg0 + deg1);\n\n                new_coeff[deg] += c0[i0] * c1[i1];\n            }\n        }\n        Polynomial new_p(new_coeff);\n        return new_p;\n    }\n\n    Polynomial&amp; operator *=(const Polynomial &amp;p)\n    {\n        *this = *this * p;\n        return *this;\n    }\n\n    Polynomial operator +(Polynomial poly) const\n    {\n        Polynomial ret = *this;\n        if(ret.degree() &lt; poly.degree())\n        {\n            ret.swap(poly);\n        }\n\n        for (auto [it, rit] =\n                std::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()};\n                it != poly._coeff.rend(); it++, rit++)\n        {\n            *rit += *it;\n        }\n        ret.check_degree();\n        return ret;\n    }\n\n    Polynomial&amp; operator +=(Polynomial poly)\n    {\n        *this = *this + poly;\n        return *this;\n    }\n\n    Polynomial operator -(Polynomial poly) const\n    {\n        Polynomial ret = *this;\n        int pm = 1;\n        if(ret.degree() &lt; poly.degree())\n        {\n            ret.swap(poly);\n            pm = -1;\n        }\n\n        for (auto [it, rit] =\n                std::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()};\n                it != poly._coeff.rend(); it++, rit++)\n        {\n            *rit -= *it;\n        }\n        ret.check_degree();\n        return pm*ret;\n    }\n\n    Polynomial&amp; operator -=(Polynomial poly)\n    {\n        *this = *this - poly;\n        return *this;\n    }\n\n    friend bool operator==(const Polynomial&amp; lhs, const Polynomial&amp; rhs)\n    {\n        return lhs._coeff == rhs._coeff;\n    }\n\n    friend bool operator!=(const Polynomial&amp; lhs, const Polynomial&amp; rhs)\n    {\n        return lhs._coeff != rhs._coeff;\n    }\n\nprivate:\n    void check_degree()\n    {\n        while(size())\n        {\n            if(_coeff[0] != 0)\n                return;\n            _coeff.erase(_coeff.begin());\n        }\n    }\n\n    std::vector&lt;double&gt; _coeff;\n};\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Polynomial&amp; v)\n{\n    os &lt;&lt; \"( \";\n\n    bool is_outputed = false;\n    for(size_t i = 0; i &lt; v.size(); i++)\n    {\n        double coeff = v.coeff()[i];\n        size_t deg = v.degree() - i;\n        if(coeff != 0)\n        {\n            if(is_outputed)\n            {\n                if(coeff &gt;= 0)\n                    os &lt;&lt; \" + \";\n                else\n                    os &lt;&lt; \" - \";\n            }\n\n            os &lt;&lt; std::abs(coeff);\n            if(deg &gt; 0)\n                os &lt;&lt; \"x^\" + std::to_string(deg);\n\n            is_outputed = true;\n        }\n    }\n\n    os &lt;&lt; \" )\";\n    return os;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/psmc_8hpp/","title":"include/cpp_robotics/controller/psmc.hpp","text":""},{"location":"doxybook/Files/psmc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/psmc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PSMC struct cpp_robotics::PSMC::param_t"},{"location":"doxybook/Files/psmc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;array&gt;\n#include &lt;utility&gt;\n#include &lt;cpp_robotics/utility/cpp_support.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass PSMC\n{\npublic:\n    struct param_t\n    {\n        double Ts;\n        double Kp, Kd;\n        double Hs;\n        std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit;\n    };\n\n    PSMC()\n    {\n        reset();\n    }\n\n    PSMC(param_t param):\n        param_(param)\n    {\n        reset();\n    }\n\n    PSMC(double p, double d, double Hs, double dt)\n    {\n        param_.Kp = p;\n        param_.Kd = d;\n        param_.Hs = Hs;\n        param_.Ts = dt;\n        reset();\n    }\n\n    PSMC(double p, double d, double Hs, double min_output, double max_output, double dt)\n    {\n        param_.Kp = p;\n        param_.Kd = d;\n        param_.Hs = Hs;\n        param_.output_limit = std::pair(min_output, max_output);\n        param_.Ts = dt;\n        reset();\n    }\n\n    void reset()\n    {\n        for(size_t i = 0; i &lt; 2; i++)\n        {\n            target_val_[i] = now_val_[i] = error_[i] = 0.0;\n        }\n    }\n\n    void set_param(param_t param)\n    {\n        param_ = param;\n    }\n\n    double calculate(double target_val, double now_val)\n    {\n        double target_velocity, now_velocity;\n\n        target_velocity = (target_val - target_val_[0])/param_.Ts;\n        now_velocity =  (now_val - now_val_[0])/param_.Ts;\n\n        return calculate(target_val, now_val, target_velocity, now_velocity);\n    }\n\n    double calculate(double target_val, double now_val, double target_velocity, double now_velocity)\n    {\n        double s, u, f, e;\n\n        // coeff\n        double ua, ub;\n        double ea;\n\n        shift_right(target_val_.begin(), target_val_.begin(), 1);\n        target_val_[0] = target_val;\n        shift_right(now_val_.begin(), now_val_.begin(), 1);\n        now_val_[0] = now_val;\n\n        s = (target_val_[0] - now_val_[0]) + param_.Hs*(target_velocity - now_velocity);\n\n        ua = (param_.Kd + param_.Kp*param_.Ts)/(param_.Hs + param_.Ts);\n        ub = (param_.Kp*param_.Hs - param_.Kd)/(param_.Hs + param_.Ts);\n        u = ua*s + ub*error_[0];\n\n        if(param_.output_limit)\n            f = std::clamp(u, param_.output_limit.value().first, param_.output_limit.value().second);\n        else\n            f = u;\n\n        ea = param_.Kd + param_.Kp*param_.Ts;\n        e = (param_.Kd * error_[0] + param_.Ts*f) / ea;\n\n        shift_right(error_.begin(), error_.begin(), 1);\n        error_[0] = e;\n\n        return f;\n    }\n\n    double &amp;Kp() { return param_.Kp; }\n    double &amp;Kd() { return param_.Kd; }\n    double &amp;Hs() { return param_.Hs; }\n\nprivate:\n    param_t param_;\n\n    std::array&lt;double, 2&gt; target_val_;\n    std::array&lt;double, 2&gt; now_val_;\n    std::array&lt;double, 2&gt; error_;\n};\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/pure__pursuit_8hpp/","title":"include/cpp_robotics/controller/pure_pursuit.hpp","text":""},{"location":"doxybook/Files/pure__pursuit_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pure__pursuit_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668"},{"location":"doxybook/Files/pure__pursuit_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include \"../vector/vector2.hpp\"\n\nnamespace cpp_robotics\n{\n\n// https://myenigma.hatenablog.com/entry/2017/06/05/111007\n// https://sd08419ttic.hatenablog.com/entry/2020/03/22/152044\n// https://www.youtube.com/watch?v=zMdoLO4kRKg\n// https://www.coursera.org/lecture/intro-self-driving-cars/lesson-2-geometric-lateral-control-pure-pursuit-44N7x\n// https://www.youtube.com/watch?v=34CSRIlHMNk\n\nclass PurePursuit\n{\npublic:\n    // K\u306f\u6b63\u306e\u5b9f\u6570\u30010\u306b\u8fd1\u3044\u307b\u3069\u30ed\u30d0\u30b9\u30c8\u6027\u304c\u843d\u3061\u308b\n    PurePursuit(double K):\n        K_(K) {}\n\n    void set_K(double K)\n    {\n        K_ = K;\n    }\n\n    std::tuple&lt;bool, double&gt; control(std::function&lt;Vector2d(double)&gt; traj_ref, double traj_progress, Vector2d pos_present, double vel, double angle_present)\n    {\n        vel = std::abs(vel);\n\n        // lookahead\n        double L = K_ * vel;\n\n        // lookahead\u5ea7\u6a19\n        Vector2d pos_ref = traj_ref(traj_progress + L);\n\n        double omega = 0.0f;\n        const double pos_diff = (pos_ref-pos_present).norm();\n        if(std::abs(vel) &gt; 1e-2 &amp;&amp; pos_diff &gt; 0.001f)\n        {\n            // Yaw\u65b9\u5411\u30a8\u30e9\u30fc\n            double raw_dir_err = ((pos_ref - pos_present).angle()) - angle_present;\n            double dir_err = raw_dir_err;\n\n            // Yaw\u65b9\u5411\u5236\u5fa1\u91cf\n            omega = (2.0f * vel * std::sin(dir_err)) / L;\n            return {true, omega};\n        }\n\n        return {false, 0.0f};\n    }\n\nprivate:\n    double K_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/quadprog_8hpp/","title":"include/cpp_robotics/optimize/quadprog.hpp","text":""},{"location":"doxybook/Files/quadprog_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/quadprog_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 struct cpp_robotics::QuadProg::Param struct cpp_robotics::QuadProg::Result"},{"location":"doxybook/Files/quadprog_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;tuple&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n// #include &lt;unsupported/Eigen/IterativeSolvers&gt;\n#include &lt;cassert&gt;\n#include \"constraint.hpp\"\n#include \"derivative.hpp\"\n#include \"bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\n// min 1/2 x^T Q x + c^T x\n// s.t. Aeq x = b, Ax &lt;= b\n\nclass QuadProg\n{\npublic:\n    Eigen::MatrixXd Q;\n    Eigen::VectorXd c;\n    Eigen::MatrixXd Aeq;\n    Eigen::VectorXd beq;\n    Eigen::MatrixXd A;\n    Eigen::VectorXd b;\n\n    struct Param\n    {\n        // \u30b9\u30c6\u30c3\u30d7\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6\n        double tol_step = 1e-6;\n\n        // \u5236\u7d04\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6\n        double tol_con = 1e-6;\n\n        // \u30b2\u30a4\u30f3\n        double t = 0.5;\n\n        // \u6700\u5927\u53cd\u5fa9\u56de\u6570\n        size_t max_iter = 100;\n\n        bool print_variable = false;\n    };\n    Param param;\n\n    struct Result\n    {\n        bool is_solved = false;\n        Eigen::VectorXd x;\n        Eigen::VectorXd lambda_ineq;\n        Eigen::VectorXd lambda_eq;\n        size_t iter_cnt = 0;\n    };\n\n    void set_problem_size(const size_t valiable_size, const size_t ineq_constraint_size, const size_t eq_constraint_size)\n    {\n        Q.conservativeResize(valiable_size, valiable_size);\n        c.conservativeResize(valiable_size);\n        Aeq.conservativeResize(eq_constraint_size, valiable_size);\n        beq.conservativeResize(eq_constraint_size);\n        A.conservativeResize(ineq_constraint_size, valiable_size);\n        b.conservativeResize(ineq_constraint_size);\n    }\n\n    void debug_prog()\n    {\n        std::cout &lt;&lt; \"///// debug /////\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Q\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; Q &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"c\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; c &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Aeq\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; Aeq &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"beq\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; beq &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; A &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"b\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; b &lt;&lt; std::endl;\n\n    }\n\n    Result solve(Eigen::VectorXd x_init)\n    {\n        const auto [tol_step, tol_con, t, max_iter, print_variable] = param;\n        Result result;\n        // Size check\n        assert(Q.rows() == Q.cols());\n        assert(c.rows() == Q.rows());\n        assert(x_init.size() == Q.rows());\n\n        // \u5909\u6570\u306e\u30b5\u30a4\u30ba\n        const size_t n = Q.rows(); \n\n        if(Aeq.rows() != 0)\n        {\n            assert(Aeq.cols() == (int)n);\n            assert(Aeq.rows() == beq.rows());\n        }\n        const size_t m = Aeq.rows();\n\n        if(A.rows() != 0)\n        {\n            assert(A.cols() == (int)n);\n            assert(A.rows() == b.rows());\n        }\n        const size_t l = A.rows();\n\n        auto preprossesing = [&amp;]()\n        {\n            for(int i = 0; i &lt; Aeq.rows(); i++)\n            {\n                if(not Aeq.row(i).allFinite() || not std::isfinite(beq(i)))\n                {\n                    Aeq.row(i).setZero();\n                    beq(i) = 0;\n                }\n            }\n            for(int i = 0; i &lt; A.rows(); i++)\n            {\n                if(not A.row(i).allFinite() || not std::isfinite(b(i)))\n                {\n                    A.row(i).setZero();\n                    b(i) = 0;\n                }\n            }\n        };\n        preprossesing();\n\n        Eigen::VectorXd x(n);\n\n        double rho = l; // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u5e73\u5747\u76f8\u88dc\u6027\u6b8b\u5dee\n        Eigen::VectorXd s = Eigen::VectorXd::Ones(l); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30b9\u30e9\u30c3\u30af\u5909\u6570\n        Eigen::VectorXd u = Eigen::VectorXd::Ones(l); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570\n        Eigen::VectorXd v = Eigen::VectorXd::Zero(m); // \u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570\n        Eigen::VectorXd foom = grad_lagrange(x, u, v); // KKT\u6761\u4ef61\u6b21\u306e\u6700\u9069\u6027\n\n        for(size_t i = 0; i &lt; max_iter; i++)\n        {\n            Eigen::MatrixXd P = Eigen::MatrixXd::Zero(n + 2*l + m, n + 2*l + m);\n            Eigen::VectorXd r = Eigen::VectorXd::Zero(n + 2*l + m);\n\n            P.block(0,0,n,n) = Q;\n            r.segment(0,n) = Q*x + c;\n\n            // \u4e0d\u7b49\u5f0f\u5236\u7d04\n            if(l&gt;0)\n            {\n                P.block(0, n+l, n, l) = A.transpose();\n                P.block(n,0,l,n) = A;\n                P.block(n,n,l,l) = Eigen::MatrixXd::Identity(l,l);\n                P.block(n+l, n, l,l) = u.asDiagonal();\n                P.block(n+l, n+l, l,l) = s.asDiagonal();\n\n                r.segment(0,n) += A.transpose() * u;\n                r.segment(n,l) = A*x - b + s;\n                r.segment(n+l,l) = -rho*Eigen::VectorXd::Ones(l) + Eigen::VectorXd(u.array()*s.array());\n            }\n\n            // \u7b49\u5f0f\u5236\u7d04\n            if(m&gt;0)\n            {\n                P.block(n + 2*l, 0, m, n) = Aeq;\n                P.block(0, n + 2*l, n, m) = Aeq.transpose();\n\n                r.segment(0,n) += Aeq.transpose() * v;\n                r.segment(n+2*l,m) = Aeq*x - beq;\n            }\n\n            // \u9023\u7acb\u4e00\u6b21\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f\n            Eigen::VectorXd delta = P.fullPivLu().solve(-r);\n\n            Eigen::VectorXd dx = delta.segment(0,n);\n            Eigen::VectorXd ds = delta.segment(n,l);\n            Eigen::VectorXd du = delta.segment(n+l,l);\n            Eigen::VectorXd dv = delta.segment(n+2*l,m);\n\n            if(print_variable)\n            {\n                std::cout &lt;&lt; \"//////////////// \" &lt;&lt; i &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"x\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; x &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"dx\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; dx &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"s\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; s &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"ds\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; ds &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"u\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; u &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"du\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; du &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"v\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; v &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"dv\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; dv &lt;&lt; std::endl;\n            }\n\n            // \u66f4\u65b0\n            x += dx;\n            if(l&gt;0)\n            {\n                s += ds;\n                u += du;\n                rho = t * (u.dot(s)) / l;\n            }\n            if(m&gt;0)\n            {\n                v += dv;\n            }\n\n            // Todo \u6700\u9069\u6027\u3068\u5236\u7d04\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\n            Eigen::VectorXd new_foom = grad_lagrange(x, u, v);\n            if(dx.norm() &lt;= tol_step*(1.0+x.norm()) &amp;&amp; (new_foom - foom).norm() &lt;= tol_con*(1.0+foom.norm()))\n            {\n                result.is_solved = true;\n                result.x = x;\n                result.lambda_ineq = u;\n                result.lambda_eq = v;\n                result.iter_cnt = i;\n                return result;\n            }\n            foom = new_foom;\n        }\n\n        result.is_solved = false;\n        result.x = x;\n        result.lambda_ineq = u;\n        result.lambda_eq = v;\n        result.iter_cnt = max_iter;\n        return result;\n    }\n\n    double evaluate(const Eigen::VectorXd &amp;x)\n    {\n        return 0.5*(x.transpose()*Q).dot(x) + c.dot(x);\n    }\n\n    Eigen::VectorXd grad_lagrange(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const Eigen::VectorXd &amp;v)\n    {\n        Eigen::VectorXd gl;\n        gl = Q*x + c;\n\n        if(u.size() &gt; 0)\n            gl += A.transpose()*u;\n\n        if(v.size() &gt; 0)\n            gl += Aeq.transpose()*v;\n        return gl;\n    }\n\n    bool satisfy(const Eigen::MatrixXd &amp;x, double eps = 1e-5)\n    {\n        bool satisfy = true;\n\n        if(Aeq.rows())\n        {\n            Eigen::VectorXd d = Aeq*x - beq;\n            for(Eigen::MatrixXd::Index i = 0; i &lt; d.size(); i++)\n            {\n                if(eps &lt; std::abs(d(i)))\n                    satisfy = false;\n            }\n        }\n\n        if(A.rows())\n        {\n            Eigen::VectorXd d = A*x - b;\n            for(Eigen::MatrixXd::Index i = 0; i &lt; d.size(); i++)\n            {\n                if(eps &lt; d(i))\n                    satisfy = false;\n            }\n        }\n\n        return satisfy;\n    }\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/quasi__newton__method_8hpp/","title":"include/cpp_robotics/optimize/quasi_newton_method.hpp","text":""},{"location":"doxybook/Files/quasi__newton__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/quasi__newton__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"./bfgs.hpp\"\n#include \"./bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; quasi_newton_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000)\n{\n    size_t n = x_init.rows();\n    Eigen::VectorXd x = x_init;\n    Eigen::VectorXd dx, gx, y;\n    Eigen::MatrixXd B = Eigen::MatrixXd::Identity(n, n);\n\n    gx = grad(x);\n    for(size_t i = 0; i &lt; max_iter; i++)\n    {\n        dx = - B.inverse() * grad(x);\n\n        if(dx.norm() &lt; tol)\n        {\n            return {true, x, i};\n        }\n\n        // \u7591\u4f3c\u30d8\u30c3\u30bb\u884c\u5217\u306e\u66f4\u65b0\n        // BFGS\u6cd5\n        double a = bracketing_serach([&amp;](double v){ return f(x + v*dx); }); // \u76f4\u7dda\u63a2\u7d22\n        x += a * dx;\n        y = -gx;\n        gx = grad(x);\n        y += gx;\n        powells_modified_bfgs_step(B, a*dx, y);\n    }\n\n    return {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/quaternion_8hpp/","title":"include/cpp_robotics/vector/quaternion.hpp","text":"<p>More...</p>"},{"location":"doxybook/Files/quaternion_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/quaternion_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9"},{"location":"doxybook/Files/quaternion_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author: Takumi Odashima (Kotakkucu@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-10-10</p> <p>Copyright: Copyright (c) 2021 </p>"},{"location":"doxybook/Files/quaternion_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./vector3.hpp\"\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Quaternion;\nusing Quaternionf = Quaternion&lt;float&gt;;\nusing Quaterniond = Quaternion&lt;double&gt;;\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nclass Quaternion\n{\npublic:\n    using value_type = FLOATING_TYPE;\n    value_type x;\n    value_type y;\n    value_type z;\n    value_type w;\n\n    constexpr Quaternion():\n        x(0.0f), y(0.0f), z(0.0f), w(1.0f)\n    {\n    }\n\n    constexpr Quaternion(value_type nx, value_type ny, value_type nz, value_type nw):\n        x(nx), y(ny), z(nz), w(nw)\n    {\n    }\n\n    Quaternion get_product(Quaternion q)\n    {\n        return Quaternion(w * q.w - x * q.x - y * q.y - z * q.z,   // new w\n                          w * q.x + x * q.w + y * q.z - z * q.y,   // new x\n                          w * q.y - x * q.z + y * q.w + z * q.x,   // new y\n                          w * q.z + x * q.y - y * q.x + z * q.w);  // new z\n    }\n\n    constexpr Quaternion conjugate() const { return Quaternion(w, -x, -y, -z); }\n\n    constexpr value_type norm() const { return sqrt(w * w + x * x + y * y + z * z); }\n\n    constexpr void normalize()\n    {\n        value_type m = norm();\n        w /= m;\n        x /= m;\n        y /= m;\n        z /= m;\n    }\n\n    constexpr Quaternion get_normalized() const\n    {\n        Quaternion r(w, x, y, z);\n        r.normalize();\n        return r;\n    }\n\n    constexpr void set_rpy(value_type roll, value_type pitch, value_type yaw)\n    {\n        double cos_roll = cos(roll / 2.0);\n        double sin_roll = sin(roll / 2.0);\n        double cos_pitch = cos(pitch / 2.0);\n        double sin_pitch = sin(pitch / 2.0);\n        double cos_yaw = cos(yaw / 2.0);\n        double sin_yaw = sin(yaw / 2.0);\n\n        w = cos_roll * cos_pitch * cos_yaw + sin_roll * sin_pitch * sin_yaw;\n        x = sin_roll * cos_pitch * cos_yaw - cos_roll * sin_pitch * sin_yaw;\n        y = cos_roll * sin_pitch * cos_yaw + sin_roll * cos_pitch * sin_yaw;\n        z = cos_roll * cos_pitch * sin_yaw - sin_roll * sin_pitch * cos_yaw;\n    }\n\n    constexpr Vector3d get_rpy() const\n    {\n        value_type xx = x * x;\n        value_type xy = x * y;\n        value_type xz = x * z;\n        value_type xw = x * w;\n        value_type yy = y * y;\n        value_type yz = y * z;\n        value_type yw = y * w;\n        value_type zz = z * z;\n        value_type zw = z * w;\n        value_type ww = w * w;\n        return Vector3d{std::atan2(2.0f * (zw + xy), xx - yy - zz + ww),\n                std::asin(2.0f * (xz - yw)),\n                std::atan2(2.0f * (yz + xw), xx + yy - zz - ww)};\n    }\n\n    constexpr value_type operator [](const int index) const\n    {\n        assert(0 &lt;= index &amp;&amp; index &lt; 4);\n        if (index == 0) return x;\n        if (index == 1) return y;\n        if (index == 2) return z;\n        return w;\n    }\n};\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/random_8hpp/","title":"include/cpp_robotics/utility/random.hpp","text":""},{"location":"doxybook/Files/random_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/random_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668"},{"location":"doxybook/Files/random_8hpp/#source-code","title":"Source code","text":"<pre><code># pragma once\n\n#include &lt;cmath&gt;\n#include &lt;random&gt;\n#include \"cpp_robotics/utility/singleton.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace internal\n{\ntemplate&lt;class Method&gt;\nclass RandomEngineWrapper\n{\npublic:\n    using engine_method_t = Method;\n\n    RandomEngineWrapper():\n        engine_((*Singleton&lt;std::random_device&gt;::get_shared_instance())()){}\n\n    engine_method_t&amp; get_engine()\n    {\n        return engine_;\n    }\n\nprivate:\n    engine_method_t engine_;\n};\n}\n\ntemplate&lt;class Distribution, class EngineMethod = std::mt19937&gt;\nclass RandomGenerator : public Distribution\n{\npublic:\n    using distribution_t = Distribution;\n    using engine_method_t = EngineMethod;\n\n    template&lt;typename ...Arg&gt;\n    RandomGenerator(Arg ...arg):\n        distribution_t(arg...)\n    {\n        engine_wrapper_ = Singleton&lt;engine_t&gt;::get_shared_instance();\n    }\n\n    typename distribution_t::result_type value()\n    {\n        auto &amp;dist = *(distribution_t*)(this);\n        return dist(engine_wrapper_-&gt;get_engine());\n    }\n\nprivate:\n    using engine_t = internal::RandomEngineWrapper&lt;engine_method_t&gt;;\n    typename Singleton&lt;engine_t&gt;::shared_t engine_wrapper_;\n};\n\nusing UniformIntRandomEngine = RandomGenerator&lt;std::uniform_int_distribution&lt;&gt;&gt;;\nusing UniformRealRandomEngine = RandomGenerator&lt;std::uniform_real_distribution&lt;&gt;&gt;;\n\nusing BernoulliRandomEngine = RandomGenerator&lt;std::bernoulli_distribution&gt;;\nusing BinomialRandomEngine = RandomGenerator&lt;std::binomial_distribution&lt;&gt;&gt;;\nusing GeometricRandomEngine = RandomGenerator&lt;std::geometric_distribution&lt;&gt;&gt;;\nusing NegativeBinomialRandomEngine = RandomGenerator&lt;std::negative_binomial_distribution&lt;&gt;&gt;;\n\n\nusing PoissonRandomEngine = RandomGenerator&lt;std::poisson_distribution&lt;&gt;&gt;;\nusing ExponentialRandomEngine = RandomGenerator&lt;std::exponential_distribution&lt;&gt;&gt;;\nusing GammaRandomEngine = RandomGenerator&lt;std::gamma_distribution&lt;&gt;&gt;;\nusing WeibullRandomEngine = RandomGenerator&lt;std::weibull_distribution&lt;&gt;&gt;;\nusing ExtremeValueRandomEngine = RandomGenerator&lt;std::extreme_value_distribution&lt;&gt;&gt;;\n\n\n\nusing NormalRandomEngine = RandomGenerator&lt;std::normal_distribution&lt;&gt;&gt;;\n\nusing LognormalRandomEngine = RandomGenerator&lt;std::lognormal_distribution&lt;&gt;&gt;;\nusing ChiSquaredRandomEngine = RandomGenerator&lt;std::chi_squared_distribution&lt;&gt;&gt;;\nusing CauchyRandomEngine = RandomGenerator&lt;std::cauchy_distribution&lt;&gt;&gt;;\nusing FisherFRandomEngine = RandomGenerator&lt;std::fisher_f_distribution&lt;&gt;&gt;;\nusing StudentTRandomEngine = RandomGenerator&lt;std::student_t_distribution&lt;&gt;&gt;;\n\nusing DiscreteRandomEngine = RandomGenerator&lt;std::discrete_distribution&lt;&gt;&gt;;\nusing PiecewiseConstantRandomEngine = RandomGenerator&lt;std::piecewise_constant_distribution&lt;&gt;&gt;;\nusing PiecewiseLinearRandomEngine = RandomGenerator&lt;std::piecewise_linear_distribution&lt;&gt;&gt;;\n\ntemplate&lt;typename Real = double&gt;\nstatic Real gererate_random()\n{\n    using engine_t = internal::RandomEngineWrapper&lt;std::mt19937&gt;;\n    auto engine_wrapper = Singleton&lt;engine_t&gt;::get_shared_instance();\n    constexpr std::size_t bits = std::numeric_limits&lt;Real&gt;::digits;\n    return std::generate_canonical&lt;Real, bits&gt;(engine_wrapper-&gt;get_engine());\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/shape_8hpp/","title":"include/cpp_robotics/geometry/shape.hpp","text":""},{"location":"doxybook/Files/shape_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/shape_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9"},{"location":"doxybook/Files/shape_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include \"../vector/vector2.hpp\"\n\nnamespace cpp_robotics\n{\n\nstruct Line\n{\n    Vector2d p0, p1;\n\n    Line() = default;\n    constexpr Line(const Vector2d&amp; p0, const Vector2d&amp; p1): p0(p0), p1(p1) {}\n\n    void set(const Vector2d&amp; p0_, const Vector2d&amp; p1_) {p0 = p0_; p1 = p1_;}\n\n    constexpr double length() const { return (p1-p0).norm(); }\n\n    constexpr double angle() const { return (p1-p0).angle(); }\n\n    constexpr Vector2d lerp(const double t) const { return Vector2d::lerp(p0, p1, t); }\n};\n\nstruct Quad\n{\n    Vector2d p0, p1, p2, p3;\n\n    Quad() = default;\n    constexpr Quad(const std::array&lt;Vector2d, 4&gt; &amp;points): p0(points[0]), p1(points[1]), p2(points[2]), p3(points[3]) {}\n    constexpr Quad(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2, const Vector2d &amp;p3): p0(p0), p1(p1), p2(p2), p3(p3) {} \n\n    void set(const Vector2d &amp;p0_, const Vector2d &amp;p1_, const Vector2d &amp;p2_, const Vector2d &amp;p3_)\n    {\n        p0 = p0_;\n        p1 = p1_;\n        p2 = p2_;\n        p3 = p3_;\n    }\n\n    constexpr bool has_area() const\n    {\n        return !approx_zero(area());\n    }\n\n    constexpr double area() const\n    {\n        // \u4e09\u89d2\u5f62\u306e\u9762\u7a4d2\u500b\n        // 01 02\n        const double a1 = std::abs((p2.x - p0.x) * (p1.y - p0.y) - (p1.x - p0.x) * (p2.y - p0.y));\n\n        // 31 32\n        const double a2 = std::abs((p2.x - p3.x) * (p1.y - p3.y) - (p1.x - p3.x) * (p2.y - p3.y));\n        return 0.5*(a1 + a2);\n    }\n\n    constexpr std::array&lt;Vector2d, 4&gt; vertex() const\n    {\n        return {p0, p1, p2, p3};\n    }\n\n    constexpr std::array&lt;Line, 4&gt; outline() const\n    {\n        const auto vtx = vertex();\n        return {\n            Line{vtx[0], vtx[1]},\n            Line{vtx[1], vtx[2]},\n            Line{vtx[2], vtx[3]},\n            Line{vtx[3], vtx[0]}\n        };\n    }\n};\n\nstruct Rect\n{\n    Vector2d center;\n    Vector2d size;\n\n    Rect() = default;\n    constexpr Rect(const Vector2d&amp; center, const Vector2d&amp; size): center(center), size(size) {}\n\n    void set(const Vector2d&amp; center_, const Vector2d&amp; size_) { center = center_; size = size_; }\n\n    constexpr bool has_area() const\n    {\n        return !approx_zero(area());\n    }\n\n    constexpr double area() const\n    {\n        return size.x*size.y;\n    }\n\n    constexpr std::array&lt;Vector2d, 4&gt; vertex() const\n    {\n        Vector2d tv(size.x/2, size.y/2);\n        return {\n            center + tv,\n            center + tv.nxy(),\n            center - tv,\n            center + tv.xny()\n        };\n    }\n\n    constexpr std::array&lt;Line, 4&gt; outline() const\n    {\n        const auto vtx = vertex();\n        return {\n            Line{vtx[0], vtx[1]},\n            Line{vtx[1], vtx[2]},\n            Line{vtx[2], vtx[3]},\n            Line{vtx[3], vtx[0]}\n        };\n    }\n\n    constexpr Quad as_quad() const\n    {\n        return Quad{vertex()};\n    }\n\n    constexpr Quad get_rotated(double angle) const\n    {\n        const Vector2d tv(size.x / 2, size.y / 2);\n        return Quad\n        {\n            center + tv.get_rotated(angle),  center + tv.nxy().get_rotated(angle),\n            center + -tv.get_rotated(angle), center + tv.xny().get_rotated(angle)\n        };\n    }\n};\n\nstruct Triangle\n{\n    Vector2d p0, p1, p2;\n\n    Triangle() = default;\n    // constexpr Triangle(const std::array&lt;Vector2d, 3&gt; &amp;points): points(points) {}\n    constexpr Triangle(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2): p0(p0), p1(p1), p2(p2) {} \n\n    void set(const Vector2d &amp;p0_, const Vector2d &amp;p1_, const Vector2d &amp;p2_)\n    {\n        p0 = p0_;\n        p1 = p1_;\n        p2 = p2_;\n    }\n\n    constexpr bool has_area() const\n    {\n        return !approx_zero(area());\n    }\n\n    constexpr double area() const\n    {\n        return std::abs((p2.x - p0.x) * (p1.y - p0.y) - (p1.x - p0.x) * (p2.y - p0.y)) * 0.5;\n    }\n\n    constexpr std::array&lt;Vector2d, 3&gt; vertex() const\n    {\n        return {p0, p1, p2};\n    }\n\n    constexpr std::array&lt;Line, 3&gt; outline() const\n    {\n        const auto vtx = vertex();\n        return {\n            Line{vtx[0], vtx[1]},\n            Line{vtx[1], vtx[2]},\n            Line{vtx[2], vtx[0]}\n        };\n    }\n};\n\nstruct Circle\n{\n    Vector2d center;\n    double r;\n\n    Circle() = default;\n    constexpr Circle(const Vector2d&amp; center, const double r): center(center), r(r) {}\n\n    constexpr bool has_area() const\n    {\n        return !approx_zero(area());\n    }\n\n    constexpr double area() const\n    {\n        return square(r)*PI;\n    }\n\n    constexpr Vector2d angle_pos(const double theta) const {\n        return center + Vector2d(r*std::cos(theta), r*std::sin(theta));\n    }\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/si__unit_8hpp/","title":"include/cpp_robotics/unit/si_unit.hpp","text":""},{"location":"doxybook/Files/si__unit_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit_dimention unit_dim_assem"},{"location":"doxybook/Files/si__unit_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./unit_core.hpp\"\n\nnamespace cpp_robotics\n{\n\ninline namespace unit\n{\nnamespace unit_dimention\n{\n    using no_dimention = UnitType&lt;0, 0, 0, 0, 0, 0, 0&gt;;\n\n    // \u57fa\u672c\u5358\u4f4d\n    using metere   = UnitType&lt;1, 0, 0, 0, 0, 0, 0&gt;;\n    using kilogram = UnitType&lt;0, 1, 0, 0, 0, 0, 0&gt;;\n    using second   = UnitType&lt;0, 0, 1, 0, 0, 0, 0&gt;;\n    using ampere   = UnitType&lt;0, 0, 0, 1, 0, 0, 0&gt;;\n    using kelvin   = UnitType&lt;0, 0, 0, 0, 1, 0, 0&gt;;\n    using mole     = UnitType&lt;0, 0, 0, 0, 0, 1, 0&gt;;\n    using candela  = UnitType&lt;0, 0, 0, 0, 0, 0, 1&gt;;\n\n    using namespace unit_dim_assem;\n    // \u7d44\u7acb\u5358\u4f4d\n    using area          = udim_pow&lt;metere, 2&gt;::unit;\n    using volume        = udim_pow&lt;metere, 3&gt;::unit;\n    using velocity      = udim_div&lt;metere, second&gt;::unit;\n    using acceleration  = udim_div&lt;velocity, second&gt;::unit;\n    using dencity       = udim_div&lt;kilogram, volume&gt;::unit;\n    using angle         = udim_div&lt;metere, metere&gt;::unit;\n    using hertz         = udim_inv&lt;second&gt;::unit;\n    using newton        = udim_div&lt;udim_mul&lt;metere, kilogram&gt;::unit, udim_pow&lt;second, 2&gt;::unit&gt;::unit;\n    using pascal        = udim_div&lt;newton, area&gt;::unit;\n    using viscosity     = udim_mul&lt;pascal, second&gt;::unit;\n    using joule         = udim_mul&lt;newton, metere&gt;::unit;\n    using watt          = udim_div&lt;joule, second&gt;::unit;\n    using volt          = udim_div&lt;watt, ampere&gt;::unit;\n    using coulomb       = udim_mul&lt;second, ampere&gt;::unit;\n    using farad         = udim_div&lt;coulomb, volt&gt;::unit;\n    using ohm           = udim_div&lt;volt, ampere&gt;::unit;\n    using weber         = udim_mul&lt;volt, second&gt;::unit;\n    using henry         = udim_div&lt;weber, ampere&gt;::unit;\n    using torque        = udim_mul&lt;newton, metere&gt;::unit;\n    using inertia       = udim_mul&lt;kilogram, area&gt;::unit;\n    using angular_velocity = udim_div&lt;angle, second&gt;::unit;\n    using angular_acceleration = udim_div&lt;angular_velocity, second&gt;::unit;\n\n}\n\nusing Second = Unit&lt;double, unit_dimention::second, prefix::none&gt;;\nusing MilliSecond = Unit&lt;double, unit_dimention::second, prefix::milli&gt;;\nusing MicroSecond = Unit&lt;double, unit_dimention::second, prefix::micro&gt;;\nusing Meter = Unit&lt;double, unit_dimention::metere, prefix::none&gt;;\nusing MilliMeter = Unit&lt;double, unit_dimention::metere, prefix::milli&gt;;\nusing MicroMeter = Unit&lt;double, unit_dimention::metere, prefix::micro&gt;;\nusing CentiMeter = Unit&lt;double, unit_dimention::metere, prefix::centi&gt;;\nusing KiloGram = Unit&lt;double, unit_dimention::kilogram, prefix::none&gt;;\nusing Gram = Unit&lt;double, unit_dimention::kilogram, prefix::milli&gt;;\n\nusing Watt = Unit&lt;double, unit_dimention::watt, prefix::none&gt;;\nusing KiloWatt = Unit&lt;double, unit_dimention::watt, prefix::kilo&gt;;\nusing Newton = Unit&lt;double, unit_dimention::newton, prefix::none&gt;;\nusing KiloNewton = Unit&lt;double, unit_dimention::newton, prefix::kilo&gt;;\nusing Pascal = Unit&lt;double, unit_dimention::pascal, prefix::none&gt;;\nusing KiloPascal = Unit&lt;double, unit_dimention::pascal, prefix::kilo&gt;;\nusing Hertz = Unit&lt;double, unit_dimention::hertz, prefix::none&gt;;\n\n// \nusing Area = Unit&lt;double, unit_dimention::area, prefix::none&gt;;\nusing Volume = Unit&lt;double, unit_dimention::volume, prefix::none&gt;;\nusing Velocity = Unit&lt;double, unit_dimention::velocity, prefix::none&gt;;\nusing Acceleration = Unit&lt;double, unit_dimention::acceleration, prefix::none&gt;;\nusing Dencity = Unit&lt;double, unit_dimention::dencity, prefix::none&gt;;\nusing Torque = Unit&lt;double, unit_dimention::torque, prefix::none&gt;;\nusing Inertia = Unit&lt;double, unit_dimention::inertia, prefix::none&gt;;\n\n// \u96fb\u6c17\u7cfb\nusing Ampere = Unit&lt;double, unit_dimention::ampere, prefix::none&gt;;\nusing MilliAmpere = Unit&lt;double, unit_dimention::ampere, prefix::milli&gt;;\nusing Volt = Unit&lt;double, unit_dimention::volt, prefix::none&gt;;\nusing MilliVolt = Unit&lt;double, unit_dimention::volt, prefix::milli&gt;;\nusing Ohm = Unit&lt;double, unit_dimention::ohm, prefix::none&gt;;\nusing MilliOhm = Unit&lt;double, unit_dimention::ohm, prefix::milli&gt;;\nusing Henry = Unit&lt;double, unit_dimention::henry, prefix::none&gt;;\nusing MilliHenry = Unit&lt;double, unit_dimention::henry, prefix::milli&gt;;\nusing Farad = Unit&lt;double, unit_dimention::farad, prefix::none&gt;;\nusing MilliFarad = Unit&lt;double, unit_dimention::farad, prefix::milli&gt;;\nusing MicroFarad = Unit&lt;double, unit_dimention::farad, prefix::micro&gt;;\nusing NanoFarad = Unit&lt;double, unit_dimention::farad, prefix::nano&gt;;\n\n// \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6\nusing Radian = Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::radian&gt;;\nusing Degree = Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::degree&gt;;\nusing AngularVelocity = Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec&gt;;\nusing Rps = Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps&gt;;\nusing Rpm = Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm&gt;;\n\nusing AngularAcceleration = Unit&lt;double, unit_dimention::angular_acceleration, prefix::none&gt;;\n\nGENERATE_CONV_FACTOR(unit_dimention::angle, tag::angle::radian, tag::angle::degree, 180.0f/M_PI)\nGENERATE_CONV_FACTOR(unit_dimention::angle, tag::angle::degree, tag::angle::radian, M_PI/180.0f)\n\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rad_per_sec, tag::angular_vel::rps, 1.0f/(2*M_PI))\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rad_per_sec, tag::angular_vel::rpm, 30.0f/M_PI)\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rps, tag::angular_vel::rad_per_sec, (2*M_PI))\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rps, tag::angular_vel::rpm, 60.0f)\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rpm, tag::angular_vel::rps, 1/60.0f)\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rpm, tag::angular_vel::rad_per_sec, M_PI/30.0f)\n}\n}\n\n// suffix\n\nGENERATE_UNIT_SUFFIX(cpp_robotics::Second, s)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliSecond, ms)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MicroSecond, us)\nGENERATE_UNIT_PFX_SUFFIX(cpp_robotics::Meter, prefix::kilo, km)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Meter, m)\nGENERATE_UNIT_SUFFIX(cpp_robotics::CentiMeter, cm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliMeter, mm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloGram, kg)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Gram, g)\n\n//\nGENERATE_UNIT_SUFFIX(cpp_robotics::Watt, W)\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloWatt, kW)\n\n#ifdef UNIT_NEWTON_ENABLE \n// \"_N\"\u3063\u3066\u540d\u524d\u306e\u30de\u30af\u30ed\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u308b\u306e\u3067\u305d\u306e\u307e\u307e\u3060\u3068\u4f7f\u3048\u306a\u3044\n#undef _N\nGENERATE_UNIT_SUFFIX(cpp_robotics::Newton, N) \n#endif // UNIT_NEWTON_ENABLE\n\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloNewton, kN)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Pascal, Pa)\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloPascal, kPa)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Torque, Nm)\nGENERATE_UNIT_PFX_SUFFIX(cpp_robotics::Torque, prefix::milli, mmNm)\n\n// \u56de\u8def\nGENERATE_UNIT_SUFFIX(cpp_robotics::Ampere, A)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliAmpere, mA)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Volt, V)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliVolt, mV)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Ohm, ohm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliOhm, mohm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Henry, H)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliHenry, mH)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Farad, F)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliFarad, mF)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MicroFarad, uF)\nGENERATE_UNIT_SUFFIX(cpp_robotics::NanoFarad, nF)\n\n// \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6\nGENERATE_UNIT_SUFFIX(cpp_robotics::Radian, rad)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Degree, deg)\nGENERATE_UNIT_SUFFIX(cpp_robotics::AngularVelocity, rad_per_sec)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Rpm, rpm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Rps, rps)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/singleton_8hpp/","title":"include/cpp_robotics/utility/singleton.hpp","text":""},{"location":"doxybook/Files/singleton_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/singleton_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b"},{"location":"doxybook/Files/singleton_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;memory&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class T&gt;\nclass Singleton\n{\nprivate:\n    Singleton() = default;\n\npublic:\n    using class_t = T;\n    using shared_t = std::shared_ptr&lt;class_t&gt;;\n\n    static shared_t get_shared_instance()\n    {\n        static shared_t instance = std::make_shared&lt;class_t&gt;();\n        return instance;\n    }\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/siso__system_8hpp/","title":"include/cpp_robotics/system/siso_system.hpp","text":""},{"location":"doxybook/Files/siso__system_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/siso__system_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 struct cpp_robotics::SisoFeedbackSystem::func_list_t"},{"location":"doxybook/Files/siso__system_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;any&gt;\n#include \"../controller/pid.hpp\"\n#include \"../controller/nctf.hpp\"\n#include \"./transfer_function.hpp\"\n\n/*\n\nx_r  +                        x\n-----&gt;*--&gt;| C |--&gt;| G |---*---&gt;\n     -|                   |\n      ---------&lt;-----------\n\nx_r: \u76ee\u6a19\u5024\nx: \u72b6\u614b\nC: \u5236\u5fa1\u5668\nG: \u30d7\u30e9\u30f3\u30c8\n\n*/\n\nnamespace cpp_robotics\n{\n\nclass SisoFeedbackSystem\n{\npublic:\n    struct func_list_t\n    {\n        // C\n        std::function&lt;void(void)&gt; controller_reset;\n        std::function&lt;double(double)&gt; controller;\n        // std::any controller_obj;\n\n        // G\n        std::function&lt;void(void)&gt; system_reset;\n        std::function&lt;double(double)&gt; system;\n        // std::any system_obj;\n    };\n\n    SisoFeedbackSystem() = default;\n    SisoFeedbackSystem(func_list_t fn, double dt): func_list_(fn), dt_(dt) {}\n\n    void reset()\n    {\n        u_ = 0;\n        y_ = 0;\n        func_list_.controller_reset();\n        func_list_.system_reset();\n    }\n\n    double responce(double target)\n    {\n        u_ = func_list_.controller(target - y_);\n        y_ = func_list_.system(u_);\n        return y_;\n    }\n\n    std::tuple&lt;double, double&gt; responce_uy(double target)\n    {\n        u_ = func_list_.controller(target - y_);\n        y_ = func_list_.system(u_);\n        return {u_, y_};\n    }\n\n    double Ts() const { return dt_; }\n\n    double u() const { return u_; }\n    double y() const { return y_; }\n\n    std::function&lt;double(double)&gt; make_control_function()\n    {\n        return [this](double target){ return responce(target); };\n    }\n\n    operator std::function&lt;double(double)&gt;()\n    {\n        return make_control_function();\n    }\n\nprivate:\n    double u_ = 0;\n    double y_ = 0;\n\n    func_list_t func_list_;\n    const double dt_;\n};\n\ntemplate&lt;class CONTROLLER_T, class SYSTEM_T&gt;\nstatic SisoFeedbackSystem make_feedback_system(CONTROLLER_T &amp;controller, SYSTEM_T &amp;system)\n{\n    SisoFeedbackSystem::func_list_t fn;\n    set_controller(fn, controller);\n    set_system(fn, system);\n\n    return SisoFeedbackSystem(fn, system.Ts());\n}\n\nstatic void set_controller(SisoFeedbackSystem::func_list_t &amp;fn, PID &amp;controller)\n{\n    // fn.controller_obj = controller;\n    fn.controller_reset = [&amp;](){ controller.reset(); };\n    fn.controller = [&amp;](double e){ return controller.calculate(e); };\n}\n\nstatic void set_controller(SisoFeedbackSystem::func_list_t &amp;fn, NctfController &amp;controller)\n{\n    // fn.controller_obj = controller;\n    fn.controller_reset = [&amp;](){ controller.reset(); };\n    fn.controller = [&amp;](double e){ return controller.control(e); };\n}\n\nstatic void set_system(SisoFeedbackSystem::func_list_t &amp;fn, TransferFunction &amp;system)\n{\n    // fn.system_obj = system;\n    fn.system_reset = [&amp;](){ return system.reset(); };\n    fn.system = [&amp;](double u){ return system.responce(u); };\n}\n\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/space_8hpp/","title":"include/cpp_robotics/utility/space.hpp","text":""},{"location":"doxybook/Files/space_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/space_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class DataType = std::vector&lt;double&gt;&gt;\nstatic DataType arrange(double start, double end, double step = 1.0)\n{\n    DataType vec((int)(std::floor( (end-start) / step )));\n    for(decltype(vec.size()) i = 0; i &lt; vec.size(); i++)\n    {\n        vec[i] = start + step * i;\n    }\n    return vec;\n}\n\ntemplate&lt;class DataType = std::vector&lt;double&gt;&gt;\nstatic DataType linspace(double start, double end, size_t n = 100)\n{\n    DataType vec(n);\n    for(size_t i = 0; i &lt; n; i++)\n    {\n        vec[i] = lerp(start, end, static_cast&lt;double&gt;(i) / (n-1));\n    }\n    return vec;\n}\n\ntemplate&lt;class DataType = std::vector&lt;double&gt;&gt;\nstatic DataType implusespace(double time, double dt = 1.0)\n{\n    DataType vec((int)(std::floor( time / dt )));\n    for(decltype(vec.size()) i = 0; i &lt; vec.size(); i++)\n    {\n        vec[i] = (i == 0) ? 1.0/dt : 0.0;\n    }\n    return vec;\n}\n\ntemplate&lt;class DataType = std::vector&lt;double&gt;&gt;\nstatic DataType stepspace(double time, double dt = 1.0)\n{\n    DataType vec((int)(std::floor( time / dt )));\n    for(decltype(vec.size()) i = 0; i &lt; vec.size(); i++)\n    {\n        vec[i] = 1.0;\n    }\n    return vec;\n}\n\ntemplate&lt;class DataType = std::vector&lt;double&gt;&gt;\nstatic DataType logspace(double start, double end, size_t n = 100)\n{\n    DataType vec(n);\n    for(size_t i = 0; i &lt; n; i++)\n    {\n        vec[i] = std::pow(10.0, lerp(start, end, static_cast&lt;double&gt;(i) / (n-1)));\n    }\n    return vec;\n}\n\nstatic std::vector&lt;double&gt; funcspace(std::function&lt;double(size_t, size_t)&gt; f, size_t n = 100)\n{\n    std::vector&lt;double&gt; vec(n);\n    for(size_t i = 0; i &lt; n; i++)\n    {\n        vec[i] = f(i, n);\n    }\n    return vec;\n}\n\n// \u4ed5\u69d8\u304c\u66d6\u6627\u3059\u304e\u308b\nstatic std::vector&lt;double&gt; sinspace(double a, double b, size_t n = 100)\n{\n    return funcspace([a, b](size_t i, size_t n_){ (void) n_; return a * std::sin(b * i); }, n );\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/spline_8hpp/","title":"include/cpp_robotics/path_planning/spline.hpp","text":""},{"location":"doxybook/Files/spline_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1"},{"location":"doxybook/Files/spline_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::spline::spline_c class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda"},{"location":"doxybook/Files/spline_8hpp/#source-code","title":"Source code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n\n#include \"../utility/math_utils.hpp\"\n#include \"../vector/vector2.hpp\"\n#include \"../vector/vector4.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace spline\n{\n    struct spline_c\n    {\n        Vector4d xb, yb;\n    };\n\n    spline_c bezier_spline(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2, const Vector2d &amp;p3)\n    {\n        return {\n            Vector4d{p0.x, p1.x, p2.x, p3.x},\n            Vector4d{p0.y, p1.y, p2.y, p3.y}};\n    }\n\n    spline_c hermite_spline(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;v0, const Vector2d &amp;v1)\n    {\n        Vector2d bp1 = p0 + (1.0 / 3.0) * v0;\n        Vector2d bp2 = p1 - (1.0 / 3.0) * v1;\n\n        return bezier_spline(p0, bp1, bp2, p1);\n    }\n\n    spline_c catumull_spline(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2, const Vector2d &amp;p3)\n    {\n        Vector2d bp1 = p1 + (1.0 / 6.0) * (p2 - p0);\n        Vector2d bp2 = p2 - (1.0 / 6.0) * (p3 - p1);\n\n        return bezier_spline(p1, bp1, bp2, p2);\n    }\n\n    // f(t) = a t^3 + b t^2 + c t + d -&gt; bezier\n    spline_c cubic_function_to_bezier(const Vector2d &amp;a, const Vector2d &amp;b, const Vector2d &amp;c, const Vector2d &amp;d)\n    {\n        Vector2d bp1 = d + (1.0 / 3.0) * c;\n        Vector2d bp2 = (1.0 / 3.0) * b + (2.0 / 3.0) * c + d;\n        Vector2d bp3 = a + b + c + d;\n\n        return bezier_spline(d, bp1, bp2, bp3);\n    }\n\n    Vector4d bezier_weight(const double t)\n    {\n        double s = 1.0 - t;\n\n        double t2 = t * t;\n        double t3 = t2 * t;\n\n        double s2 = s * s;\n        double s3 = s2 * s;\n\n        return Vector4d(s3, 3.0 * s2 * t, 3.0 * s * t2, t3);\n    }\n\n    Vector4d bezier_weight(const Vector4d t)\n    {\n        return Vector4d(\n            t.x - 3.0 * t.y + 3.0 * t.z - t.w,\n            3.0 * t.y - 6.0 * t.z + 3.0 * t.w,\n            3.0 * t.z - 3.0 * t.w,\n            t.w);\n    }\n\n    inline Vector2d evaluate(const spline_c &amp;spline, const Vector4d &amp;w)\n    {\n        return {\n            Vector4d::dot(spline.xb, w),\n            Vector4d::dot(spline.yb, w)};\n    }\n\n    Vector2d position(const spline_c &amp;spline, double t)\n    {\n        return evaluate(spline, bezier_weight(t));\n    }\n\n    Vector2d velocity(const spline_c &amp;spline, double t)\n    {\n        Vector4d dt(0.0, 1.0, 2.0 * t, 3.0 * t * t);\n        return evaluate(spline, bezier_weight(dt));\n    }\n\n    Vector2d acceleration(const spline_c &amp;spline, double t)\n    {\n        Vector4d dt(0.0, 0.0, 2.0, 6.0 * t);\n        return evaluate(spline, bezier_weight(t));\n    }\n\n    inline void split(const Vector4d &amp;spline, Vector4d &amp;spline0, Vector4d &amp;spline1, double t)\n    {\n        // assumption: seg = (P0, P1, P2, P3)\n        double q0 = lerp(spline.x, spline.y, t);\n        double q1 = lerp(spline.y, spline.z, t);\n        double q2 = lerp(spline.z, spline.w, t);\n\n        double r0 = lerp(q0, q1, t);\n        double r1 = lerp(q1, q2, t);\n\n        double s0 = lerp(r0, r1, t);\n\n        double sx = spline.x; // support aliasing\n        double sw = spline.w;\n\n        spline0 = Vector4d(sx, q0, r0, s0);\n        spline1 = Vector4d(s0, r1, q2, sw);\n    }\n\n    // Optimised for t=0.5\n    inline void split(const Vector4d &amp;spline, Vector4d &amp;spline0, Vector4d &amp;spline1)\n    {\n        double q0 = (spline.x + spline.y) * 0.5; // x + y / 2\n        double q1 = (spline.y + spline.z) * 0.5; // y + z / 2\n        double q2 = (spline.z + spline.w) * 0.5; // z + w / 2\n\n        double r0 = (q0 + q1) * 0.5; // x + 2y + z / 4\n        double r1 = (q1 + q2) * 0.5; // y + 2z + w / 4\n\n        double s0 = (r0 + r1) * 0.5; // q0 + 2q1 + q2 / 4 = x+y + 2(y+z) + z+w / 8 = x + 3y + 3z + w\n\n        double sx = spline.x; // support aliasing\n        double sw = spline.w;\n\n        spline0 = Vector4d(sx, q0, r0, s0);\n        spline1 = Vector4d(s0, r1, q2, sw);\n    }\n\n    void split(const spline_c&amp; spline, spline_c&amp; spline0, spline_c&amp; spline1)\n    {\n        split(spline.xb, spline0.xb, spline1.xb);\n        split(spline.yb, spline0.yb, spline1.yb);\n    }\n\n    void split(const spline_c&amp; spline, spline_c&amp; spline0, spline_c&amp; spline1, double t)\n    {\n        split(spline.xb, spline0.xb, spline1.xb, t);\n        split(spline.yb, spline0.yb, spline1.yb, t);\n    }\n\n    double length_estimate(const spline_c &amp;s, double *error)\n    {\n        // Our convex hull is p0, p1, p2, p3, so p0_p3 is our minimum possible length, and p0_p1 + p1_p2 + p2_p3 our maximum.\n        double d03 = square(s.xb.x - s.xb.w) + square(s.yb.x - s.yb.w);\n\n        double d01 = square(s.xb.x - s.xb.y) + square(s.yb.x - s.yb.y);\n        double d12 = square(s.xb.y - s.xb.z) + square(s.yb.y - s.yb.z);\n        double d23 = square(s.xb.z - s.xb.w) + square(s.yb.z - s.yb.w);\n\n        double minLength = std::sqrt(d03);\n        double maxLength = std::sqrt(d01) + std::sqrt(d12) + std::sqrt(d23);\n\n        minLength *= 0.5;\n        maxLength *= 0.5;\n\n        *error = maxLength - minLength;\n        return minLength + maxLength;\n    }\n\n    double length(const spline_c &amp;s, double maxError)\n    {\n        double error;\n        double len = length_estimate(s, &amp;error);\n\n        if (error &gt; maxError)\n        {\n            spline_c s0;\n            spline_c s1;\n\n            split(s, s0, s1);\n\n            return length(s0, maxError) + length(s1, maxError);\n        }\n\n        return len;\n    }\n\n    double length(const spline_c &amp;s, double t0, double t1, double maxError)\n    {\n        assert(t0 &gt;= 0.0 &amp;&amp; t0 &lt; 1.0);\n        assert(t1 &gt;= 0.0 &amp;&amp; t1 &lt;= 1.0);\n        assert(t0 &lt;= t1);\n\n        spline_c s0, s1;\n\n        if (t0 == 0.0)\n        {\n            if (t1 == 1.0)\n                return length(s, maxError);\n\n            split(s, s0, s1, t1);\n            return length(s0, maxError);\n        }\n        else\n        {\n            split(s, s0, s1, t0);\n\n            if (t1 == 1.0)\n                return length(s1, maxError);\n\n            split(s1, s0, s1, (t1 - t0) / (1.0 - t0));\n            return length(s0, maxError);\n        }\n    }\n\n    double curvature(const spline_c &amp;spline, double t)\n    {\n        Vector2d v = velocity(spline, t);\n        Vector2d a = acceleration(spline, t);\n\n        double avCrossLen = std::abs(v.x * a.y - v.y * a.x);\n        double vLen = v.norm();\n\n        if (vLen == 0.0)\n            return 1e10;\n\n        return avCrossLen / (vLen * vLen * vLen);\n    }\n} // namespace spline\n\nclass Spline2D\n{\npublic:\n    Spline2D() = default;\n\n    bool is_empty()\n    {\n        return _is_empty;\n    }\n\n    size_t size()\n    {\n        return _size;\n    }\n\n    size_t point_num()\n    {\n        return size()+1;\n    }\n\n    double length()\n    {\n        return _all_length;\n    }\n\n    double length(size_t i)\n    {\n        if(i &gt;= size())\n            return 0;\n\n        return _spline[i].length;\n    }\n\n    Vector2d position(double length)\n    {\n        assert(_is_empty == false);\n        assert(length &gt;= 0);\n        assert(length &lt;= _all_length);\n\n        segment_info_t segment = get_segmet_idx_length(length);\n        return spline::position(_spline[segment.i].coeff, segment.t);\n    }\n\n    Vector2d spline_position(double t)\n    {\n        assert(_is_empty == false);\n        assert(t &gt;= 0);\n        assert(t &lt;= static_cast&lt;double&gt;(size()));\n\n        segment_info_t segment = get_segmet_idx(t);\n        return spline::position(_spline[segment.i].coeff, segment.t);\n    }\n\n    Vector2d spline_velocity(double t)\n    {\n        assert(_is_empty == false);\n        assert(t &gt;= 0);\n        assert(t &lt;= static_cast&lt;double&gt;(size()));\n\n        size_t i = std::floor(t);\n        t -= static_cast&lt;double&gt;(i);\n        return spline::velocity(_spline[i].coeff, t);\n    }\n\n    Vector2d spline_acceleration(double t)\n    {\n        assert(_is_empty == false);\n        assert(t &gt;= 0);\n        assert(t &lt;= static_cast&lt;double&gt;(size()));\n\n        size_t i = std::floor(t);\n        t -= static_cast&lt;double&gt;(i);\n        return spline::acceleration(_spline[i].coeff, t);\n    }\n\nprotected:\n    struct segment_t\n    {\n        spline::spline_c coeff;\n        double length;\n        std::vector&lt;double&gt; split_lengths;\n    };\n\n    struct segment_info_t\n    {\n        size_t i;\n        double t;\n    };\n\n    segment_info_t get_segmet_idx(const double t)\n    {\n        segment_info_t result;\n        result.i = std::min(static_cast&lt;size_t&gt;(std::floor(t)), size()-1);\n        result.t = t - static_cast&lt;double&gt;(result.i);\n        return result;\n    }\n\n    segment_info_t get_segmet_idx_length(double length)\n    {\n        segment_info_t result;\n        result.i = 0;\n        result.t = 1.0;\n        while (length &gt; _spline[result.i].length)\n        {\n            length -= _spline[result.i].length;\n            result.i++;\n        }\n\n        double dt = 1.0 / _spline[result.i].split_lengths.size();\n        for(size_t i = 1; i &lt; _spline[result.i].split_lengths.size(); i++)\n        {\n            if(length &lt; _spline[result.i].split_lengths[i])\n            {\n                double diff = length - _spline[result.i].split_lengths[i-1];\n                double seg_diff = _spline[result.i].split_lengths[i] - _spline[result.i].split_lengths[i-1];\n                result.t = static_cast&lt;double&gt;(i) * dt + (diff/seg_diff) * dt;\n                return result;\n            }\n        }\n\n        return result;\n    }\n\n    std::vector&lt;segment_t&gt; _spline;\n    bool _is_empty;\n    size_t _size;\n    double _all_length;\n};\n\nclass CatumullRom2D : public Spline2D\n{\npublic:\n    CatumullRom2D(std::vector&lt;Vector2d&gt;&amp; points, bool trajectory_loop = false, const double error = 0.01)\n    {\n        const size_t p_size = points.size();\n\n        _is_empty = false;\n        switch (p_size)\n        {\n            case 0:\n                _is_empty = true;\n                return;\n            case 1:\n                {\n                    Vector2d&amp; p0 = points[0];\n                    _spline.push_back({spline::catumull_spline(p0, p0, p0, p0), 0, {}});\n                    return;\n                }\n            case 2:\n                _size = 1;\n                _spline.resize(_size);\n                calcu_segment(_spline[0], points, error, 0, 0, 0, 1, 1);\n                _all_length = _spline[0].length;\n                return;\n        }\n\n        _size = p_size - 1;\n        _spline.resize(_size);\n\n        if(trajectory_loop)\n            calcu_segment(_spline[0], points, error, 0, p_size-2, 0, 1, 2);\n        else\n            calcu_segment(_spline[0], points, error, 0, 0, 0, 1, 2);\n        for (size_t i = 0; i &lt; p_size - 3; i++)\n        {\n            calcu_segment(_spline[i+1], points, error, i, 0, 1, 2, 3);\n        }\n        if(trajectory_loop)\n            calcu_segment(_spline[_size-1], points, error, 0, p_size-3, p_size-2, p_size-1, 1);\n        else\n            calcu_segment(_spline[_size-1], points, error, p_size-3, 0, 1, 2, 2);\n\n        _all_length = 0;\n        for(auto&amp; seg : _spline)\n        {\n            _all_length += seg.length;\n        }\n    }\n\nprivate:\n    void calcu_segment(segment_t&amp; seg, std::vector&lt;Vector2d&gt;&amp; points, const double error, const size_t start, const size_t i0 = 0, const size_t i1 = 1, const size_t i2 = 2, const size_t i3 = 3)\n    {\n        Vector2d &amp;p0 = points[start + i0];\n        Vector2d &amp;p1 = points[start + i1];\n        Vector2d &amp;p2 = points[start + i2];\n        Vector2d &amp;p3 = points[start + i3];\n\n        seg.coeff = spline::catumull_spline(p0, p1, p2, p3);\n        seg.length = spline::length(seg.coeff, error);\n        seg.split_lengths.resize(100);\n        for(size_t i = 0; i &lt; 100; i++)\n        {\n            seg.split_lengths[i] = spline::length(seg.coeff, 0.0, static_cast&lt;double&gt;(i) / 100.0, error);\n        }\n    }\n};\n\nclass CubicSpline : public Spline2D\n{\npublic:\n    CubicSpline(std::vector&lt;Vector2d&gt;&amp; points, const double error = 0.01)\n    {\n        const size_t p_size = points.size();\n        std::vector&lt;double&gt; w;\n\n        _is_empty = false;\n        if(p_size &lt; 2)\n        {\n            _is_empty = true;\n            return;\n        }\n\n        _size = p_size - 1;\n        _spline.resize(p_size);\n        w.resize(p_size);\n\n        for(size_t xy = 0; xy &lt; 2; xy++)\n        {            \n            // 0\u6b21\u306e\u4fc2\u6570\n            for(size_t i = 0; i &lt;= _size; i++)\n            {\n                spline(i, xy).x = p(points, i, xy);\n            }\n\n            // 2\u6b21\u306e\u4fc2\u6570\n            spline(0, xy).z = spline(_size, xy).z = 0.0;\n            for(size_t i = 1; i &lt; _size; i++)\n            {\n                spline(i, xy).z = 3.0 * (spline(i-1, xy).x - 2.0 * spline(i, xy).x + spline(i+1, xy).x);\n            }\n            // \u5de6\u4e0b\u6d88\u53bb\n            w[0] = 0.0;\n            for(size_t i = 1; i &lt; _size; i++)\n            {\n                double temp = 4.0 - w[i-1];\n                spline(i, xy).z = (spline(i, xy).z - spline(i-1, xy).z)/temp;\n                w[i] = 1.0 / temp;\n            }\n\n            // \u53f3\u4e0b\u6d88\u53bb\n            for(size_t i = _size-1; i &gt; 0; i--) {\n                spline(i, xy).z = spline(i, xy).z - spline(i+1, xy).z * w[i];\n            }\n\n            // 1\u6b21\u30683\u6b21\u306e\u4fc2\u6570\n            spline(_size, xy).y = spline(_size, xy).w = 0.0;\n            for(size_t i = 0; i &lt; _size; i++)\n            {\n                spline(i, xy).w = ( spline(i+1, xy).z - spline(i, xy).z) / 3.0;\n                spline(i, xy).y = spline(i+1, xy).x - spline(i, xy).x - spline(i, xy).z - spline(i, xy).w;\n            }\n        }\n        // \u6700\u5f8c\u306e\u30bb\u30b0\u30e1\u30f3\u30c8\u306f\u6700\u5f8c\u306e\u5236\u5fa1\u70b9\u4e00\u70b9\u3088\u3046\u306a\u306e\u3067\u6d88\u3057\u3066\u304a\u304f\n        _spline.erase(_spline.begin()+_spline.size()-1);\n\n        _all_length = 0;\n        for(auto&amp; seg : _spline)\n        {\n            auto c = seg.coeff;\n            seg.coeff = spline::cubic_function_to_bezier(\n                Vector2d(c.xb.w, c.yb.w),\n                Vector2d(c.xb.z, c.yb.z),\n                Vector2d(c.xb.y, c.yb.y),\n                Vector2d(c.xb.x, c.yb.x)\n            );\n            seg.length = spline::length(seg.coeff, error);\n            seg.split_lengths.resize(100);\n            for(size_t i = 0; i &lt; 100; i++)\n            {\n                seg.split_lengths[i] = spline::length(seg.coeff, 0.0, static_cast&lt;double&gt;(i) / 100.0, error);\n            }\n            _all_length += seg.length;\n        }\n    }\n\nprivate:\n    Vector4d&amp; spline(size_t i, size_t xy)\n    {\n        if (xy == 0)\n            return _spline[i].coeff.xb;\n        else\n            return _spline[i].coeff.yb;\n    }\n\n    double&amp; p(std::vector&lt;Vector2d&gt;&amp; points, size_t i, size_t xy)\n    {\n        if (xy == 0)\n            return points[i].x;\n        else\n            return points[i].y;\n    }\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/sqp_8hpp/","title":"include/cpp_robotics/optimize/sqp.hpp","text":""},{"location":"doxybook/Files/sqp_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/sqp_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SQP SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) struct cpp_robotics::SQP::Problem struct cpp_robotics::SQP::Result"},{"location":"doxybook/Files/sqp_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"./constraint.hpp\"\n#include \"./bracketing_serach.hpp\"\n#include \"./bfgs.hpp\"\n#include \"./quasi_newton_method.hpp\"\n// #include \"./quadprog.hpp\"\n#include &lt;cpp_robotics/optimize/quadprog.hpp&gt;\n#include \"./lsei_transition.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass SQP\n{\npublic:\n    using func_type = std::function&lt;double(Eigen::VectorXd)&gt;;\n    using grad_func_type = std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\n\n    struct Problem\n    {\n        func_type func;\n        std::optional&lt;grad_func_type&gt; grad;\n        ConstraintArray con;\n\n        bool use_slsqp = false;\n        double tol_step = 1e-6;\n        double tol_con = 1e-6;\n        size_t max_iter = 100;\n        bool print_variable = false;\n    };\n\n    struct Result\n    {\n        bool is_solved = false;\n        Eigen::VectorXd x;\n        // Eigen::VectorXd lambda_opt;\n        size_t iter_cnt = 0;\n    };\n\n    Result solve(Problem prob, const Eigen::VectorXd &amp;x0, std::optional&lt;std::function&lt;void(Eigen::VectorXd)&gt;&gt; callback = std::nullopt)\n    {\n        Result result;\n\n        grad_func_type grad_f = prob.grad.value_or([&amp;](const Eigen::VectorXd &amp;x){ return derivative(prob.func, x); });\n\n        // \u5236\u7d04\u304c\u306a\u3044\u6642, \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f\n        if(prob.con.size() == 0)\n        {\n            std::tie(result.is_solved, result.x, result.iter_cnt) = \n                quasi_newton_method(prob.func, grad_f, x0, 1e-6, prob.max_iter);\n            return result;\n        }\n\n        Eigen::VectorXd x = x0;\n        Eigen::VectorXd grad_f0 = grad_f(x0);\n        Eigen::MatrixXd B = Eigen::MatrixXd::Identity(x.rows(), x.rows());\n        Eigen::VectorXd grad_fx = grad_f0;\n        Eigen::VectorXd step = grad_f0;\n        Eigen::VectorXd dgg = Eigen::VectorXd::Zero(x.size());\n\n        // Todo: x0\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u306a\u5834\u5408\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u307e\u3067\u79fb\u52d5\u3055\u305b\u308b\n\n        // \u5236\u7d04\n        auto eq_con = prob.con.gen_eq_constraint_list();\n        auto ineq_con = prob.con.gen_ineq_constraint_list();\n\n        // \u30b5\u30d6\u554f\u984c\u306e2\u6b21\u8a08\u753b\u554f\u984c\u306e\u30bd\u30eb\u30d0\u30fc\n        QuadProg qp_solver;\n        qp_solver.param.tol_con = 1e-3;\n        qp_solver.param.tol_step = 1e-3;\n        qp_solver.set_problem_size(x.size(), ineq_con.size(), eq_con.size());\n\n        // \u76f4\u7dda\u63a2\u7d22\u7528\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5236\u7d04\u91cd\u307f\n        const double df0_norm = grad_f(x).norm();\n        Eigen::VectorXd eq_mw   = df0_norm * Eigen::VectorXd::Ones(eq_con.size());\n        Eigen::VectorXd ineq_mw = df0_norm * Eigen::VectorXd::Ones(ineq_con.size());\n        for(size_t i = 0; i &lt; eq_con.size(); i++)\n        {\n            eq_mw(i) /= std::max(eq_con[i].grad(x).norm(), 1.0);\n        }\n        for(size_t i = 0; i &lt; ineq_con.size(); i++)\n        {\n            ineq_mw(i) /= std::max(ineq_con[i].grad(x).norm(), 1.0);\n        }\n\n        // \u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\n        for(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n        {\n            qp_solver.Aeq.row(con_i) = eq_con[con_i].grad(x).transpose();\n            qp_solver.beq(con_i) = -eq_con[con_i].eval(x);\n        }\n\n        // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\n        for(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n        {\n            qp_solver.A.row(con_i) = ineq_con[con_i].grad(x).transpose();\n            qp_solver.b(con_i) = -ineq_con[con_i].eval(x);\n        }\n\n        Eigen::MatrixXd new_Aeq(qp_solver.Aeq.rows(), qp_solver.Aeq.cols());\n        Eigen::VectorXd new_beq(qp_solver.beq.size());\n        Eigen::MatrixXd new_A(qp_solver.A.rows(), qp_solver.A.cols());\n        Eigen::VectorXd new_b(qp_solver.b.size());\n\n        // Todo: \u3053\u306e\u524d\u51e6\u7406\u304c\u6709\u52b9\u306b\u306a\u3063\u305f\u6642\u306bdelta_grad_L\uff1f\u304c\u304a\u304b\u3057\u304f\u306a\u3063\u3066\u30d8\u30c3\u30b7\u30a2\u30f3\u304c\u767a\u6563\u3059\u308b\uff1f\n        auto preprossesing = [&amp;](Eigen::MatrixXd &amp;Aeq, Eigen::VectorXd &amp;beq, Eigen::MatrixXd &amp;A, Eigen::VectorXd &amp;b)\n        {\n            for(int i = 0; i &lt; Aeq.rows(); i++)\n            {\n                if(not Aeq.row(i).allFinite() || not std::isfinite(beq(i)))\n                {\n                    Aeq.row(i).setZero();\n                    beq(i) = 0;\n                }\n            }\n            for(int i = 0; i &lt; A.rows(); i++)\n            {\n                if(not A.row(i).allFinite() || not std::isfinite(b(i)))\n                {       \n                    A.row(i).setZero();\n                    b(i) = 0;\n                }\n            }\n        };\n        preprossesing(qp_solver.Aeq, qp_solver.beq, qp_solver.A, qp_solver.b);\n\n        for(size_t i = 1; i &lt; prob.max_iter+1; i++)\n        {\n            if(prob.print_variable)\n            {\n                std::cout &lt;&lt; \"\\n////////////////////////////////\" &lt;&lt; std::endl;\n            }\n\n            // \u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\n            // \u30b5\u30d6\u306e\u554f\u984c\u8a2d\u5b9a\n            if (prob.use_slsqp)\n            {\n                auto ldlt_obj = B.ldlt();\n                Eigen::MatrixXd L = ldlt_obj.transpositionsP().transpose()*(Eigen::MatrixXd)ldlt_obj.matrixL();\n                Eigen::MatrixXd LT = L.transpose();\n                Eigen::MatrixXd Linv = L.inverse();\n                Eigen::VectorXd D = ldlt_obj.vectorD();\n                Eigen::VectorXd Dsq = D.array().sqrt();\n                Eigen::VectorXd Dinvsq = (D.array()).inverse();\n\n                // std::cout &lt;&lt; \"D\" &lt;&lt; std::endl;\n                // std::cout &lt;&lt; D &lt;&lt; std::endl;\n                // std::cout &lt;&lt; \"Dsq\" &lt;&lt; std::endl;\n                // std::cout &lt;&lt; Dsq &lt;&lt; std::endl;\n                // std::cout &lt;&lt; \"Dinvsq\" &lt;&lt; std::endl;\n                // std::cout &lt;&lt; Dinvsq &lt;&lt; std::endl;\n\n\n                Eigen::MatrixXd C = Dsq.asDiagonal()*LT;\n                Eigen::VectorXd d = Dinvsq.asDiagonal()*Linv*grad_f(x);\n                std::tie(qp_solver.Q, qp_solver.c) = lsi2qp(C, d);\n\n                // std::cout &lt;&lt; \"qp_solver.Q\" &lt;&lt; std::endl;\n                // std::cout &lt;&lt; qp_solver.Q &lt;&lt; std::endl;\n                // std::cout &lt;&lt; \"qp_solver.c\" &lt;&lt; std::endl;\n                // std::cout &lt;&lt; qp_solver.c &lt;&lt; std::endl;\n            }\n            else\n            {\n                qp_solver.Q = B;\n                qp_solver.c = grad_f(x).transpose();\n            }\n\n            // Todo QP\u306e\u5236\u7d04\u3067\u77db\u76fe\u3057\u305f\u3082\u306e\u3001\u6e80\u305f\u305b\u306a\u3044\u3082\u306e\u3092\u53d6\u308a\u9664\u304f\n\n            // \u30b5\u30d6\u306e2\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\n            auto sub_result = qp_solver.solve(Eigen::VectorXd::Zero(x.size()));\n            if(not sub_result.is_solved)\n            {\n                result.is_solved = false;\n                result.iter_cnt = i;\n                result.x = x;\n                // result.lambda_opt = sub_result.lambda_opt;\n                std::cout &lt;&lt; \"cant solve sub qp: \" &lt;&lt; sub_result.iter_cnt &lt;&lt; std::endl;\n                qp_solver.debug_prog();\n                return result;\n            }\n            auto d = sub_result.x;\n\n            // \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u6c7a\u5b9a\n            // \u76f4\u7dda\u63a2\u7d22\n            auto merit_func = [&amp;](const Eigen::VectorXd &amp;x)\n            {\n                double val = prob.func(x);\n\n                // \u7b49\u5f0f\u5236\u7d04\n                for(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n                {\n                    const double eval = eq_con[con_i].eval(x);\n                    if(std::isfinite(eval))\n                        val += eq_mw(con_i) * std::abs(eval);\n                }\n\n                // \u4e0d\u7b49\u5f0f\u5236\u7d04\n                for(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n                {\n                    const double eval = ineq_con[con_i].eval(x);\n                    if(std::isfinite(eval))\n                    val += ineq_mw(con_i) * std::max(eval, 0.0);\n                }\n\n                return val;\n            };\n            double alpha = bracketing_serach(merit_func, [&amp;](const Eigen::VectorXd &amp;x){ return derivative(merit_func, x); }, x, d);\n\n            if(prob.print_variable)\n            {\n                std::cout &lt;&lt; \"d\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; d &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"alpha\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; alpha &lt;&lt; std::endl;\n            }\n\n            if(callback)\n                callback.value()(x);\n            step = alpha * d;\n            x += step;\n\n            // \u53ce\u675f\u5224\u5b9a\n            // Todo: KKT\u6761\u4ef6\u306e1\u6b21\u306e\u6700\u9069\u6027\u30c1\u30a7\u30c3\u30af\u5165\u308c\u308b\n            if(step.norm() &lt; prob.tol_step*(1.0+x.norm())) // &amp;&amp; prob.con.all_satisfy(x, prob.tol_con))\n            {\n                result.is_solved = true;\n                result.iter_cnt = i;\n                result.x = x;\n                return result;\n            }\n\n            // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u91cd\u307f\u66f4\u65b0\n            for(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n            {\n                eq_mw(con_i) = std::max(eq_mw(con_i), 0.5*(eq_mw(con_i) + sub_result.lambda_eq(con_i)));\n            }\n            for(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n            {\n                ineq_mw(con_i) = std::max(ineq_mw(con_i), 0.5*(ineq_mw(con_i) + sub_result.lambda_ineq(con_i)));\n            }\n\n            // \u89e3\u306e\u4fdd\u5b58\n            result.x = x;\n            result.iter_cnt = i;\n\n            // \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u95a2\u6570\u306e\u52fe\u914d\u306e\u5909\u5316\u91cf\n            /*\n            B\u306e\u5024\u304ce10\u4ee5\u4e0a\u306e\u30aa\u30fc\u30c0\u30fc\u3067\u5927\u304d\u304f\u306a\u308b\n            \u5236\u7d04\u306b\u639b\u304b\u308bgrad_L\u306e\u5024\u304c\u6b63\u3057\u3044\u306e\u304b\u78ba\u8a8d\u3059\u308b\n            */\n            // https://jp.mathworks.com/help/optim/ug/constrained-nonlinear-optimization-algorithms.html#bsgppl4\n            Eigen::VectorXd delta_grad_L = -grad_fx;\n            grad_fx = grad_f(x);\n            delta_grad_L += grad_fx;\n            // \u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\n            for(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n            {\n                new_Aeq.row(con_i) = eq_con[con_i].grad(x).transpose();\n                new_beq(con_i) = -eq_con[con_i].eval(x);\n            }\n\n            // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\n            for(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n            {\n                new_A.row(con_i) = ineq_con[con_i].grad(x).transpose();\n                new_b(con_i) = -ineq_con[con_i].eval(x);\n            }\n\n            preprossesing(new_Aeq, new_beq, new_A, new_b);\n\n            delta_grad_L += (new_Aeq - qp_solver.Aeq).transpose() * sub_result.lambda_eq;\n            delta_grad_L += (new_A   - qp_solver.A  ).transpose() * sub_result.lambda_ineq;\n\n            qp_solver.Aeq = new_Aeq;\n            qp_solver.beq = new_beq;\n            qp_solver.A = new_A;\n            qp_solver.b = new_b;\n\n            // \\grad_g(x) * g(x) = [n]*[1]\n            Eigen::VectorXd new_dgg = -new_Aeq.transpose()*new_beq -new_A.transpose()*new_b - x;\n\n            // \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u95a2\u6570\u306e\u7591\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u66f4\u65b0\n            powells_modified_bfgs_step(B, step, delta_grad_L, new_dgg - dgg);\n            dgg = new_dgg;\n\n            if(prob.print_variable)\n            {\n                std::cout &lt;&lt; \"B=\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; B &lt;&lt; std::endl;\n                std::cout &lt;&lt; \"x=\" &lt;&lt; std::endl;\n                std::cout &lt;&lt; x &lt;&lt; std::endl;\n            }\n\n            if(B.array().isNaN().any())\n            {\n                std::cout &lt;&lt; \"NaN\u304c\u5b58\u5728\u3057\u307e\u3059\" &lt;&lt; std::endl;\n                break;\n            }\n        }\n\n        return result;\n    }\n\nprivate:\n    template &lt;typename Mat&gt;\n    bool is_posdef(Mat H)\n    {\n        Eigen::EigenSolver&lt;Mat&gt; eigensolver(H);\n        for (int i = 0; i &lt; eigensolver.eigenvalues().rows(); i++) {\n            double v = eigensolver.eigenvalues()(i).real();\n            if (v &lt;= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/state__space__system_8hpp/","title":"include/cpp_robotics/system/state_space_system.hpp","text":""},{"location":"doxybook/Files/state__space__system_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/state__space__system_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb"},{"location":"doxybook/Files/state__space__system_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/../unsupported/Eigen/MatrixFunctions&gt;\n#include &lt;optional&gt;\n#include \"discret.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass StateSpaceSystem\n{\npublic:\n    StateSpaceSystem() = default;\n\n    template&lt;typename DerivedA, typename DerivedB, typename DerivedC&gt;\n    StateSpaceSystem(const Eigen::MatrixBase&lt;DerivedA&gt; &amp;A, const Eigen::MatrixBase&lt;DerivedB&gt; &amp;B, const Eigen::MatrixBase&lt;DerivedC&gt; &amp;C, const double Ts)\n    {\n        set_continuous(A, B, C, Ts);\n    }\n\n    template&lt;typename DerivedA, typename DerivedB, typename DerivedC&gt;\n    void set_continuous(const Eigen::MatrixBase&lt;DerivedA&gt; &amp;A, const Eigen::MatrixBase&lt;DerivedB&gt; &amp;B, const Eigen::MatrixBase&lt;DerivedC&gt; &amp;C, const double Ts, const bool skip_state_reset = false)\n    {\n        assert(A.rows() == A.cols());\n        assert(A.rows() == B.rows());\n        assert(A.cols() == C.cols());\n\n        state_size_ = A.rows();\n        input_size_ = B.cols();\n        output_size_ = C.rows();\n\n        A_ = A;\n        B_ = B;\n        Ts_ = Ts;\n        std::tie(Ad_, Bd_) = Discret::discritize(A, B, Ts);\n        Cd_ = C;\n\n        if(not skip_state_reset)\n            set_state_zero();\n    }\n\n    template&lt;typename DerivedA, typename DerivedB, typename DerivedC&gt;\n    void set_discrite(const Eigen::MatrixBase&lt;DerivedA&gt; &amp;Ad, const Eigen::MatrixBase&lt;DerivedB&gt; &amp;Bd, const Eigen::MatrixBase&lt;DerivedC&gt; &amp;Cd, const double Ts, const bool skip_state_reset = false)\n    {\n        assert(Ad.rows() == Ad.cols());\n        assert(Ad.rows() == Bd.rows());\n        assert(Ad.cols() == Cd.cols());\n\n        state_size_ = Ad.rows();\n        input_size_ = Bd.cols();\n        output_size_ = Cd.rows();\n\n        A_ = std::nullopt;\n        B_ = std::nullopt;\n        Ts_ = Ts;\n\n        Ad_ = Ad;\n        Bd_ = Bd;\n        Cd_ = Cd;\n\n        if(not skip_state_reset)\n            set_state_zero();\n    }\n\n    size_t state_size() const { return state_size_; }\n    size_t input_size() const { return input_size_; }\n    size_t output_size() const { return output_size_; }\n\n    bool is_siso_model() const { return (input_size() == 1 &amp;&amp; output_size() == 1); }\n\n    inline void set_state_zero()\n    {\n        set_state(Eigen::VectorXd::Zero(state_size()));\n    }\n\n    void set_state(const Eigen::VectorXd &amp;x)\n    {\n        x_ = x;\n    }\n\n    void set_state(const double &amp;x)\n    {\n        assert(input_size() == 1 &amp;&amp; output_size() == 1);\n        Eigen::VectorXd x_vec(1);\n        x_vec(0) = x;\n        set_state(x_vec);\n    }\n\n    auto responce(const Eigen::VectorXd &amp;u)\n    {\n        x_ = Ad_*x_ + Bd_*u;\n        return Cd_*x_;\n    }\n\n    double responce(double u)\n    {\n        assert(input_size() == 1 &amp;&amp; output_size() == 1);\n        Eigen::VectorXd u_vec(1);\n        u_vec(0) = u;\n        return responce(u_vec)(0);\n    }\n\n    std::optional&lt;Eigen::MatrixXd&gt; A() const { return A_; }\n    std::optional&lt;Eigen::MatrixXd&gt; B() const { return B_; }\n    double Ts() const { return Ts_; }\n\n    Eigen::MatrixXd Ad() const { return Ad_; }\n    Eigen::MatrixXd Bd() const { return Bd_; }\n\n    Eigen::MatrixXd C()  const { return Cd_; }\n    Eigen::MatrixXd Cd() const { return Cd_; }\n\n    Eigen::VectorXd x() const { return x_; }\n    Eigen::VectorXd y() const { return Cd_*x_; }\n\nprivate:\n    Eigen::MatrixXd Ad_;\n    Eigen::MatrixXd Bd_;\n    Eigen::MatrixXd Cd_;\n\n    std::optional&lt;Eigen::MatrixXd&gt; A_;\n    std::optional&lt;Eigen::MatrixXd&gt; B_;\n    double Ts_;\n\n    size_t state_size_;\n    size_t input_size_;\n    size_t output_size_;\n\n    Eigen::VectorXd x_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/steepest__descent__method_8hpp/","title":"include/cpp_robotics/optimize/steepest_descent_method.hpp","text":""},{"location":"doxybook/Files/steepest__descent__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/steepest__descent__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; steepest_descent_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000)\n{\n    Eigen::VectorXd x = x_init;\n    Eigen::VectorXd s;\n\n    for(size_t i = 0; i &lt; max_iter; i++)\n    {\n        s = -grad(x);\n\n        if(s.norm() &lt; tol)\n        {\n            return {true, x, i};\n        }\n\n        // \u76f4\u7dda\u63a2\u7d22\n        double a = bracketing_serach(f, grad, x, s);\n        x += a*s;\n    }\n\n    return {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/swerve__ik_8hpp/","title":"include/cpp_robotics/chassis/swerve_ik.hpp","text":""},{"location":"doxybook/Files/swerve__ik_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/swerve__ik_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb"},{"location":"doxybook/Files/swerve__ik_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/vector/transform.hpp\"\n#include \"cpp_robotics/vector/vector2.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass SwerveIk\n{\npublic:\n    using VecArray = std::array&lt;Vector2d, 4&gt;;\n\n    SwerveIk(const double width, const double length)\n    {\n        const double hw = width/2;\n        const double hl = length/2;\n        wheel_place_ =\n        {\n            Vector2d{ hw,  hl},\n            Vector2d{-hw,  hl},\n            Vector2d{-hw, -hl},\n            Vector2d{ hw, -hl}\n        };\n    }\n\n    SwerveIk(VecArray wheel_place):\n        wheel_place_(wheel_place)\n    {\n\n    }\n\n    VecArray calculate(Transformd velocity)\n    {\n        VecArray wv;\n        for(size_t i = 0; i &lt; 4; i++)\n        {\n            const double wangle = wheel_place_[i].angle();\n            const double wpnorm = wheel_place_[i].norm();\n            wv[i].x = velocity.x - wpnorm * velocity.theta * std::sin(wangle);\n            wv[i].y = velocity.y + wpnorm * velocity.theta * std::cos(wangle);\n        }\n        return wv;\n    }\n\n    VecArray wheel_place() const { return wheel_place_; }\n\nprivate:\n    VecArray wheel_place_;\n};\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/system_8hpp/","title":"include/cpp_robotics/system.hpp","text":""},{"location":"doxybook/Files/system_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"system/discret.hpp\"\n#include \"system/state_space_system.hpp\"\n#include \"system/transfer_function.hpp\"\n#include \"system/polynomial.hpp\"\n#include \"system/bode.hpp\"\n#include \"system/nyquist.hpp\"\n#include \"system/time_responce.hpp\"\n#include \"system/siso_system.hpp\"\n// #include \"system/dynamics_integrate.hpp\"\n// #include \"system/system_transformation.hpp\" // +4.0s\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/system__transformation_8hpp/","title":"include/cpp_robotics/system/system_transformation.hpp","text":""},{"location":"doxybook/Files/system__transformation_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/system__transformation_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n#include &lt;cpp_robotics/system/state_space_system.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nStateSpaceSystem tf2ss(const TransferFunction &amp;tf)\n{\n    // \u4f1d\u9054\u95a2\u6570\u3092\u53ef\u5236\u5fa1\u6b63\u6e96\u7cfb\u306b\u5909\u63db\u3057\u3066\u4fdd\u5b58\n    auto num_array = tf.num_array();\n    auto den_array = tf.den_array();\n    const size_t num_size = num_array.size();\n    const size_t den_size = den_array.size();\n    const size_t state_size = tf.den_deg();\n\n    Eigen::MatrixXd A = Eigen::MatrixXd::Zero(state_size, state_size);\n    // \u5bfe\u89d2\u8981\u7d20\u306e1\u500b\u53f3\u96a3\u30921\u57cb\u3081\n    for(size_t i = 0; i &lt; state_size-1; i++)\n    {\n        A(i, i+1) = 1;\n    }\n    // \u4e00\u756a\u4e0b\u306e\u884c\u3092\u4f1d\u9054\u95a2\u6570\u306e\u8981\u7d20\u3067\u57cb\u3081\n    for(size_t i = 0; i &lt; state_size; i++)\n    {\n        A(state_size-1, i) = -den_array[state_size - i] / den_array[0];\n    }\n\n    Eigen::MatrixXd B = Eigen::VectorXd::Zero(state_size);\n    B(state_size-1) = 1;\n\n    Eigen::MatrixXd C = Eigen::RowVectorXd::Zero(state_size);\n    for(size_t i = 0; i &lt;= num_size; i++)\n    {\n        C(i) = num_array[i] / den_array[0];\n    }\n\n    return StateSpaceSystem(A, B, C, tf.Ts());\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/time__responce_8hpp/","title":"include/cpp_robotics/system/time_responce.hpp","text":""},{"location":"doxybook/Files/time__responce_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/time__responce_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include \"../utility/space.hpp\"\n#include \"./transfer_function.hpp\"\n#include \"./siso_system.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace internal\n{\ntemplate &lt;class T&gt;\nclass is_system_class\n{\n    template &lt;class U&gt;\n    static auto check(U&amp;&amp; x)-&gt;decltype(x.Ts(), x.responce(0.0), std::true_type{});\n\n    template &lt;class U&gt;\n    static auto check(...)-&gt;std::false_type;\n\npublic:\n    static constexpr bool value = decltype(check&lt;T&gt;(std::declval&lt;T&gt;()))::value;\n};\n\ntemplate &lt;class T&gt;\nclass is_filter_class\n{\n    template &lt;class U&gt;\n    static auto check(U&amp;&amp; x)-&gt;decltype(x.Ts(), x.filtering(0.0), std::true_type{});\n\n    template &lt;class U&gt;\n    static auto check(...)-&gt;std::false_type;\n\npublic:\n    static constexpr bool value = decltype(check&lt;T&gt;(std::declval&lt;T&gt;()))::value;\n};\n\ntemplate &lt;class T&gt;\nstruct is_pure_filter_class\n{\n    static constexpr bool value = not is_system_class&lt;T&gt;::value &amp;&amp; is_filter_class&lt;T&gt;::value;\n};\n\n}\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; impulse(const std::function&lt;double(double)&gt; &amp;sys, double dt, double time)\n{\n    std::vector&lt;double&gt; t = arrange(0, time, dt);\n    std::vector&lt;double&gt; res(t.size());\n    for(size_t i = 0; i &lt; res.size(); i++)\n    {\n        res[i] = sys( i == 0 ? 1.0/dt : 0.0);\n    }\n    return {t, res};\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_system_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; impulse(SysType &amp;sys, double time)\n{\n    return impulse([&amp;](double u){ return sys.responce(u); }, sys.Ts(), time);\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_pure_filter_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; impulse(SysType &amp;sys, double time)\n{\n    return impulse([&amp;](double u){ return sys.filtering(u); }, sys.Ts(), time);\n}\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step(const std::function&lt;double(double)&gt; &amp;sys, double dt, double time, const double gain = 1.0)\n{\n    std::vector&lt;double&gt; t = arrange(0, time, dt);\n    std::vector&lt;double&gt; res(t.size());\n\n    for(size_t i = 0; i &lt; res.size(); i++)\n    {\n        res[i] = sys(gain);\n    }\n\n    return {t, res};\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_system_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step(SysType &amp;sys, double time, const double gain = 1.0)\n{\n    return step([&amp;](double u){ return sys.responce(u); }, sys.Ts(), time, gain);\n}\n\ntemplate&lt;class FilterType, typename std::enable_if&lt;internal::is_pure_filter_class&lt;FilterType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step(FilterType &amp;filter, double time, const double gain = 1.0)\n{\n    return step([&amp;](double u){ return filter.filtering(u); }, filter.Ts(), time, gain);\n}\n\ntemplate&lt;class DataIterativeType&gt;\nstatic std::tuple&lt;DataIterativeType, DataIterativeType&gt; lsim(const std::function&lt;double(double)&gt; &amp;sys, double dt, const DataIterativeType &amp;input)\n{\n    DataIterativeType t = linspace&lt;DataIterativeType&gt;(0, dt*input.size(), input.size());\n    DataIterativeType res(t.size());\n    for(decltype(res.size()) i = 0; i &lt; res.size(); i++)\n    {\n        res[i] = sys(input[i]);\n    }\n    return {t, res};\n}\n\ntemplate&lt;class DataIterativeType, class SysType, typename std::enable_if&lt;internal::is_system_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;DataIterativeType, DataIterativeType&gt; lsim(SysType sys, const DataIterativeType &amp;input, bool skip_reset = false)\n{\n    if(not skip_reset)\n        sys.reset();\n    return lsim([&amp;](double u){ return sys.responce(u); }, sys.Ts(), input);\n}\n\ntemplate&lt;class DataIterativeType, class SysType, typename std::enable_if&lt;internal::is_pure_filter_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;DataIterativeType, DataIterativeType&gt; lsim(SysType sys, const DataIterativeType &amp;input, bool skip_reset = false)\n{\n    if(not skip_reset)\n        sys.reset();\n    return lsim([&amp;](double u){ return sys.filtering(u); }, sys.Ts(), input);\n}\n\ntemplate&lt;class DataIterativeType&gt;\nstatic std::tuple&lt;DataIterativeType, DataIterativeType&gt; lsim(TransferFunction::tf_t sys_config, const DataIterativeType &amp;input)\n{\n    TransferFunction sys(sys_config);\n    return lsim([&amp;](double u){ return sys.responce(u); }, sys.Ts(), input);\n}\n\ntemplate&lt;class DataIterativeType&gt;\nstatic std::tuple&lt;DataIterativeType, DataIterativeType, DataIterativeType&gt; lsim(SisoFeedbackSystem sys, const DataIterativeType &amp;input, bool skip_reset = false)\n{\n    if(not skip_reset)\n        sys.reset();\n    DataIterativeType t = linspace&lt;DataIterativeType&gt;(0, sys.Ts()*input.size(), input.size());\n    DataIterativeType u(t.size());\n    DataIterativeType res(t.size());\n    for(decltype(res.size()) i = 0; i &lt; res.size(); i++)\n    {\n        std::tie(u[i], res[i]) = sys.responce_uy(input[i]);\n    }\n    return {t, u, res};\n}\n\ntemplate&lt;class DataIterativeType&gt;\nstatic DataIterativeType lsim_y(const std::function&lt;double(double)&gt; &amp;sys, double dt, const DataIterativeType &amp;input)\n{\n    auto [t, res] = lsim(sys, dt, input);\n    return res;\n}\n\ntemplate&lt;class DataIterativeType, class SysType, typename std::enable_if&lt;internal::is_system_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic DataIterativeType lsim_y(SysType sys, const DataIterativeType &amp;input, bool skip_reset = false)\n{\n    if(not skip_reset)\n        sys.reset();\n    return lsim_y([&amp;](double u){ return sys.responce(u); }, sys.Ts(), input);\n}\n\ntemplate&lt;class DataIterativeType, class SysType, typename std::enable_if&lt;internal::is_pure_filter_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic DataIterativeType lsim_y(SysType sys, const DataIterativeType &amp;input, bool skip_reset = false)\n{\n    if(not skip_reset)\n        sys.reset();\n    return lsim_y([&amp;](double u){ return sys.filtering(u); }, sys.Ts(), input);\n}\n\ntemplate&lt;class DataIterativeType&gt;\nstatic DataIterativeType lsim_y(TransferFunction::tf_t sys_config, const DataIterativeType &amp;input)\n{\n    TransferFunction sys(sys_config);\n    return lsim_y([&amp;](double u){ return sys.responce(u); }, sys.Ts(), input);\n}\n\ntemplate&lt;class DataIterativeType&gt;\nstatic std::tuple&lt;DataIterativeType, DataIterativeType&gt; lsim_uy(SisoFeedbackSystem sys, const DataIterativeType &amp;input, bool skip_reset = false)\n{\n    auto [t, u, res] = lsim(sys, input, skip_reset);\n    return {u, res};\n}\n\ntemplate&lt;class DataIterativeType&gt;\nstatic DataIterativeType lsim_y(SisoFeedbackSystem sys, const DataIterativeType &amp;input, bool skip_reset = false)\n{\n    auto [t, u, res] = lsim(sys, input, skip_reset);\n    return res;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/timer_8hpp/","title":"include/cpp_robotics/utility/timer.hpp","text":""},{"location":"doxybook/Files/timer_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/timer_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Timer"},{"location":"doxybook/Files/timer_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;chrono&gt;\n\nnamespace cpp_robotics\n{\n\nclass Timer\n{\npublic:\n    void start()\n    {\n        start_ = std::chrono::system_clock::now();\n    }\n\n    void stop()\n    {\n        end_ = std::chrono::system_clock::now();\n    }\n\n    double second()\n    {\n        return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_-start_).count() * 1e-3;\n    }\n\n    double millisecond()\n    {\n        return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_-start_).count();\n    }\n\nprivate:\n    std::chrono::system_clock::time_point start_, end_; \n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/transfer__function_8hpp/","title":"include/cpp_robotics/system/transfer_function.hpp","text":""},{"location":"doxybook/Files/transfer__function_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/transfer__function_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb struct cpp_robotics::TransferFunction::tf_t"},{"location":"doxybook/Files/transfer__function_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/discret.hpp&gt;\n#include &lt;cpp_robotics/system/polynomial.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass TransferFunction\n{\npublic:\n    struct tf_t\n    {\n        std::vector&lt;double&gt; num;\n        std::vector&lt;double&gt; den;\n        double Ts;\n\n        tf_t inv() const\n        {\n            return {\n                den,\n                num,\n                Ts\n            };\n        }\n\n        tf_t operator+(double val) const\n        {\n            return {\n                (Polynomial(num) + Polynomial(den)*val).coeff(),\n                den,\n                Ts\n            };\n        }\n\n        tf_t operator-(double val) const\n        {\n            return {\n                (Polynomial(num) - Polynomial(den)*val).coeff(),\n                den,\n                Ts\n            };\n        }\n\n        tf_t operator*(double val) const\n        {\n            return {\n                (Polynomial(num)*val).coeff(),\n                den,\n                Ts\n            };\n        }\n\n        tf_t operator/(double val) const\n        {\n            return {\n                (Polynomial(num)/val).coeff(),\n                den,\n                Ts\n            };\n        }\n\n        tf_t operator+(const tf_t &amp;tf) const\n        {\n            return {\n                (Polynomial(num)*Polynomial(tf.den) + Polynomial(tf.num)*Polynomial(den)).coeff(),\n                (Polynomial(den)*Polynomial(tf.den)).coeff(),\n                Ts\n            };\n        }\n\n        tf_t operator-(const tf_t &amp;tf) const\n        {\n            return {\n                (Polynomial(num)*Polynomial(tf.den) - Polynomial(tf.num)*Polynomial(den)).coeff(),\n                (Polynomial(den)*Polynomial(tf.den)).coeff(),\n                Ts\n            };\n        }\n\n        tf_t operator*(const tf_t &amp;tf) const\n        {\n            return {\n                (Polynomial(num)*Polynomial(tf.num)).coeff(),\n                (Polynomial(den)*Polynomial(tf.den)).coeff(),\n                Ts\n            };\n        }\n\n        tf_t operator/(const tf_t &amp;tf) const\n        {\n            return {\n                (Polynomial(num)*Polynomial(tf.den)).coeff(),\n                (Polynomial(den)*Polynomial(tf.num)).coeff(),\n                Ts\n            };\n        }\n\n        friend tf_t operator+(double val, const tf_t &amp;tf)\n        {\n            return tf + val;\n        }\n\n        friend tf_t operator-(double val, const tf_t &amp;tf)\n        {\n            return tf - val;\n        }\n\n        friend tf_t operator*(double val, const tf_t &amp;tf)\n        {\n            return val*tf;\n        }\n\n        friend tf_t operator/(double val, const tf_t &amp;tf)\n        {\n            return val*tf.inv();\n        }\n\n        TransferFunction simulatable()\n        {\n            return TransferFunction(num, den, Ts);\n        }\n\n#ifndef CR_NO_USE_COUT\n        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const tf_t&amp; tf)\n        {\n            std::stringstream ssnum, ssden;\n\n            for(size_t i = 0; i &lt; tf.num.size(); i++)\n            {\n                if(tf.num[i] &gt; 0 &amp;&amp; i != 0)\n                    ssnum &lt;&lt; \"+\";\n                ssnum &lt;&lt; tf.num[i];\n                if(auto deg = tf.num.size()-1-i; deg != 0)\n                {\n                    if(deg == 1)\n                        ssnum &lt;&lt; \"s\";\n                    else\n                        ssnum &lt;&lt; \"s^\" &lt;&lt; deg;\n                }\n                if(i != tf.num.size()-1)\n                    ssnum &lt;&lt; \" \";\n            }\n\n            for(size_t i = 0; i &lt; tf.den.size(); i++)\n            {\n                if(tf.den[i] &gt; 0 &amp;&amp; i != 0)\n                    ssden &lt;&lt; \"+\";\n                ssden &lt;&lt; tf.den[i];\n                if(auto deg = tf.den.size()-1-i; deg != 0)\n                {\n                    if(deg == 1)\n                        ssden &lt;&lt; \"s\";\n                    else\n                        ssden &lt;&lt; \"s^\" &lt;&lt; deg;\n                }\n                if(i != tf.den.size()-1)\n                    ssden &lt;&lt; \" \";\n            }\n\n            size_t len = std::max(ssnum.str().length(), ssden.str().length());\n            std::string bar(len, '-');\n\n            stream &lt;&lt; std::string((len-ssnum.str().length())/2, ' ') + ssnum.str() + \"\\n\"\n                        + bar + \"\\n\" \n                        + std::string((len-ssden.str().length())/2, ' ') + ssden.str();\n\n            return stream;\n        };\n#endif\n    };\n\n    static TransferFunction make_first_order_system(const double T, const double Ts)\n    {\n        return TransferFunction({1}, {T, 1}, Ts);\n    }\n\n    static TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts)\n    {\n        return TransferFunction({omega*omega}, {1.0, 2.0*zeta*omega, omega*omega}, Ts);\n    }\n\n    TransferFunction() = default;\n\n    TransferFunction(std::vector&lt;double&gt; num, std::vector&lt;double&gt; den, const double Ts):\n        num_array_(num), den_array_(den)\n    {\n        set_continuous(num_array_, den_array_, Ts);\n    }\n\n    TransferFunction(const tf_t &amp;tf_config):\n        num_array_(tf_config.num), den_array_(tf_config.den)\n    {\n        set_continuous(num_array_, den_array_, tf_config.Ts);\n    }\n\n    void set_continuous(std::vector&lt;double&gt; num, std::vector&lt;double&gt; den, const double dt)\n    {\n        if(num.size() == 1 &amp;&amp; den.size() == 1)\n        {\n            num_ = num;\n            den_ = den;\n            dt_ = dt;\n            u_.resize(1);\n            y_.resize(1);\n            return;\n        }\n        auto [num_disc, den_disc] = DiscretTransferFunction::discritize(num, den, dt);\n        set_discrite(num_disc, den_disc, dt);\n    }\n\n    // z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306e\u5206\u5b50\u3068\u5206\u6bcd\u3092\u964d\u3079\u304d\u306e\u6e96\u306b\u4e0e\u3048\u308b\n    void set_discrite(std::vector&lt;double&gt; num_disc, std::vector&lt;double&gt; den_disc, const double dt)\n    {\n        assert(num_disc.size() &gt; 0);\n        assert(den_disc.size() &gt; 0);\n\n        num_ = num_disc;\n        den_ = den_disc;\n\n        u_.resize(num_.size());\n        y_.resize(den_.size()-1);\n\n        dt_ = dt;\n\n        reset();\n    }\n\n    double Ts() const { return dt_; }\n\n    virtual void reset(double state = 0)\n    {\n        for(auto &amp;u : u_)\n            u = 0;\n        for(auto &amp;y : y_)\n            y = state;\n        u_.reset_position();\n        y_.reset_position();\n    }\n\n    double responce(double u)\n    {\n        double y = 0;\n        u_.insert_front(u);\n\n        for(size_t i = 0; i &lt; num_.size(); i++)\n        {\n            y += num_[i]*u_.at_circular(i);\n        }\n\n        if(den_.size() != 1)\n        {\n            for(size_t i = 0; i &lt; den_.size()-1; i++)\n            {\n                y -= den_[i+1]*y_.at_circular(i);\n            }\n        }\n        y /= den_[0];\n\n        y_.insert_front(y);\n        return y;\n    }\n\n    size_t num_deg(size_t num_idx = 0) const\n    {\n        return num_array_.size()-1 - num_idx;\n    }\n\n    size_t den_deg(size_t num_idx = 0) const\n    {\n        return den_array_.size()-1 - num_idx;\n    }\n\n    std::vector&lt;double&gt; num_array() const { return num_array_; }\n    std::vector&lt;double&gt; den_array() const { return den_array_; }\n\n    operator tf_t() const\n    {\n        return{\n            num_array_,\n            den_array_,\n            dt_\n        };\n    } \n\n    tf_t inv() const\n    {\n        return {\n            den_array_,\n            num_array_,\n            dt_\n        };\n    }\n\n    tf_t operator+(double val) const\n    {\n        return {\n            (Polynomial(num_array_) + Polynomial(den_array_)*val).coeff(),\n            den_array_,\n            dt_\n        };\n    }\n\n    tf_t operator-(double val) const\n    {\n        return {\n            (Polynomial(num_array_) - Polynomial(den_array_)*val).coeff(),\n            den_array_,\n            dt_\n        };\n    }\n\n    tf_t operator*(double val) const\n    {\n        return {\n            (Polynomial(num_array_)*val).coeff(),\n            den_array_,\n            dt_\n        };\n    }\n\n    tf_t operator/(double val) const\n    {\n        return {\n            (Polynomial(num_array_)/val).coeff(),\n            den_array_,\n            dt_\n        };\n    }\n\n    friend tf_t operator+(double val, const TransferFunction &amp;tf)\n    {\n        return tf + val;\n    }\n\n    friend tf_t operator-(double val, const TransferFunction &amp;tf)\n    {\n        return tf - val;\n    }\n\n    friend tf_t operator*(double val, const TransferFunction &amp;tf)\n    {\n        return tf*val;\n    }\n\n    friend tf_t operator/(double val, const TransferFunction &amp;tf)\n    {\n        return val*tf.inv();\n    }\n\n    friend tf_t operator+(const tf_t &amp;a, const TransferFunction &amp;b)\n    {\n        return a + (tf_t)(b);\n    }\n\n    friend tf_t operator-(const tf_t &amp;a, const TransferFunction &amp;b)\n    {\n        return a - (tf_t)(b);\n    }\n\n    friend tf_t operator*(const tf_t &amp;a, const TransferFunction &amp;b)\n    {\n        return a * (tf_t)(b);\n    }\n\n    friend tf_t operator/(const tf_t &amp;a, const TransferFunction &amp;b)\n    {\n        return a / (tf_t)(b);\n    }\n\n    friend tf_t operator+(const TransferFunction &amp;a, const tf_t &amp;b)\n    {\n        return (tf_t)(a) + b;\n    }\n\n    friend tf_t operator-(const TransferFunction &amp;a, const tf_t &amp;b)\n    {\n        return (tf_t)(a) - b;\n    }\n\n    friend tf_t operator*(const TransferFunction &amp;a, const tf_t &amp;b)\n    {\n        return (tf_t)(a) * b;\n    }\n\n    friend tf_t operator/(const TransferFunction &amp;a, const tf_t &amp;b)\n    {\n        return (tf_t)(a) / b;\n    }\n\n    friend tf_t operator+(const TransferFunction &amp;a, const TransferFunction &amp;b)\n    {\n        return (tf_t)(a) + (tf_t)(b);\n    }\n\n    friend tf_t operator-(const TransferFunction &amp;a, const TransferFunction &amp;b)\n    {\n        return (tf_t)(a) - (tf_t)(b);\n    }\n\n    friend tf_t operator*(const TransferFunction &amp;a, const TransferFunction &amp;b)\n    {\n        return (tf_t)(a) * (tf_t)(b);\n    }\n\n    friend tf_t operator/(const TransferFunction &amp;a, const TransferFunction &amp;b)\n    {\n        return (tf_t)(a) / (tf_t)(b);\n    }\n\n#ifndef CR_NO_USE_COUT\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const TransferFunction&amp; tf)\n    {\n        std::stringstream ssnum, ssden;\n\n        for(size_t i = 0; i &lt; tf.num_array_.size(); i++)\n        {\n            if(tf.num_array_[i] &gt; 0 &amp;&amp; i != 0)\n                ssnum &lt;&lt; \"+\";\n            ssnum &lt;&lt; tf.num_array_[i];\n            if(auto deg = tf.num_deg(i); deg != 0)\n            {\n                if(deg == 1)\n                    ssnum &lt;&lt; \"s\";\n                else\n                    ssnum &lt;&lt; \"s^\" &lt;&lt; deg;\n            }\n            if(i != tf.num_array_.size()-1)\n                ssnum &lt;&lt; \" \";\n        }\n\n        for(size_t i = 0; i &lt; tf.den_array_.size(); i++)\n        {\n            if(tf.den_array_[i] &gt; 0 &amp;&amp; i != 0)\n                ssden &lt;&lt; \"+\";\n            ssden &lt;&lt; tf.den_array_[i];\n            if(auto deg = tf.den_deg(i); deg != 0)\n            {\n                if(deg == 1)\n                    ssden &lt;&lt; \"s\";\n                else\n                    ssden &lt;&lt; \"s^\" &lt;&lt; deg;\n            }\n            if(i != tf.den_array_.size()-1)\n                ssden &lt;&lt; \" \";\n        }\n\n        size_t len = std::max(ssnum.str().length(), ssden.str().length());\n        std::string bar(len, '-');\n\n        stream &lt;&lt; std::string((len-ssnum.str().length())/2, ' ') + ssnum.str() + \"\\n\"\n                    + bar + \"\\n\" \n                    + std::string((len-ssden.str().length())/2, ' ') + ssden.str();\n\n        return stream;\n    };\n#endif\n\nprotected:\n    std::vector&lt;double&gt; num_array_;\n    std::vector&lt;double&gt; den_array_;\n\n    template&lt;typename T&gt;\n    class CircularBuffer : public std::vector&lt;T&gt;\n    {\n    public:\n        void reset_position()\n        {\n            i = 0;\n        }\n\n        T&amp; at_circular(size_t idx)\n        {\n            idx += i;\n            if(this-&gt;size() &lt;= idx)\n                idx-=this-&gt;size();\n            return this-&gt;at(idx);\n        }\n\n        void insert_front(T val)\n        {\n            i += this-&gt;size()-1;\n            if(this-&gt;size() &lt;= i)\n                i-=this-&gt;size();\n            this-&gt;at(i) = val;\n        }\n\n    private:\n        size_t i = 0;\n    };\n    std::vector&lt;double&gt; num_;\n    std::vector&lt;double&gt; den_;\n    CircularBuffer&lt;double&gt; u_;\n    CircularBuffer&lt;double&gt; y_;\n    double dt_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/transform_8hpp/","title":"include/cpp_robotics/vector/transform.hpp","text":"<p>More...</p>"},{"location":"doxybook/Files/transform_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/transform_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9"},{"location":"doxybook/Files/transform_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author: Takumi Odashima (Kotakkucu@gmail.com) </p> <p>Date: 2021-01-25</p> <p>Copyright: Copyright (c) 2021 </p>"},{"location":"doxybook/Files/transform_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./vector2.hpp\"\n\nnamespace cpp_robotics\n{\n    template&lt;typename FLOATING_TYPE&gt;\n    struct Transform;\n    using Transformf = Transform&lt;float&gt;;\n    using Transformd = Transform&lt;double&gt;;\n\n    template&lt;typename FLOATING_TYPE&gt;\n    struct Transform //\n    {\n        using value_type = FLOATING_TYPE;\n        using vector_type = Vector2&lt;value_type&gt;;\n        value_type x, y, theta;\n\n        // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n        Transform() = default;\n\n        constexpr Transform(const value_type _x, const value_type _y, const value_type _theta) : x(_x), y(_y), theta(_theta) {}\n\n        constexpr Transform(const vector_type&amp; _xy, const value_type _theta) : x(_xy.x), y(_xy.y), theta(_theta) {}\n\n        constexpr Transform(const Transform &amp;) = default;\n\n        constexpr vector_type make_vector2() const\n        {\n            return vector_type(x, y);\n        }\n\n        constexpr void set(value_type vx, value_type vy, value_type vtheta) \n        {\n            x = vx;\n            y = vy;\n            theta = vtheta;\n        }\n\n        // origin-xy\u8ddd\u96e2\n        value_type distance() const\n        {\n            return vector_type(x, y).norm();\n        }\n\n        // \u56de\u8ee2\n        void rotate(const value_type theta)\n        {\n            rotate(vector_type::zero(), theta);\n        }\n\n        void rotate(const value_type rotX, const value_type rotY, const value_type theta)\n        {\n            rotate(vector_type(rotX, rotY), theta); \n        }\n\n        void rotate(vector_type rotPos, const value_type theta) \n        { \n            vector_type p = make_vector2() - rotPos;\n            p.rotate(theta);\n            x = p.x + rotPos.x;\n            y = p.y + rotPos.y;\n        }\n\n        // \u6975\u5ea7\u6a19\u6307\u5b9a\n        void set_polar(const value_type radius, const value_type angle, const value_type robotTheta)\n        {\n            x = radius * std::cos(angle);\n            y = radius * std::sin(angle);\n            theta = robotTheta;\n        }\n\n        bool is_zero() const\n        {\n            return approx_zero(x) &amp;&amp; approx_zero(y) &amp;&amp; approx_zero(theta);\n        }\n\n        bool is_zero_pos() const\n        {\n            return x == 0.0 &amp;&amp; y == 0.0;\n        }\n\n        bool is_zero_angle() const\n        {\n            return theta == 0.0;\n        }\n\n        bool has_nan() const\n        {\n            return std::isnan(x) || std::isnan(y) || std::isnan(theta);\n        }\n\n        static constexpr value_type get_angle(Transform &amp;a, Transform &amp;b) { return b.theta - a.theta; };\n\n        static value_type get_distance(Transform &amp;a, Transform &amp;b)\n        {\n            return (b-a).distance();\n        }\n\n        static Transform get_lerp(Transform &amp;a, Transform &amp;b, const value_type t)\n        {\n            return {lerp(a.x, b.x, t), lerp(a.y, b.y, t), lerp(a.theta, b.theta, t)};\n        }\n\n        // constatnt vector\n        static constexpr Transform origin() \n        {\n            return {0.0, 0.0, 0.0};\n        }\n\n        constexpr bool operator == (const Transform v) const\n        {\n            return (x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (theta == v.theta);\n        }\n\n        constexpr bool operator != (const Transform&amp; v) const\n        {\n            return !((x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (theta == v.theta));\n        }\n\n        constexpr Transform operator + (const Transform&amp; v) const \n        {\n            return {x + v.x, y + v.y, theta + v.theta};\n        }\n\n        constexpr Transform operator - (const Transform&amp; v) const\n        {\n            return {x - v.x, y - v.y, theta - v.theta};\n        }\n\n        constexpr Transform&amp; operator += (const Transform&amp; v)\n        {\n            x += v.x;\n            y += v.y;\n            theta += v.theta;\n\n            return *this;\n        }\n\n        constexpr Transform&amp; operator -= (const Transform&amp; v)\n        {\n            x -= v.x;\n            y -= v.y;\n            theta -= v.theta;\n\n            return *this;\n        }\n\n        // xy\n        constexpr Transform operator + (const vector_type&amp; v) const\n        {\n            return {x + v.x, y + v.y, theta};\n        }\n\n        constexpr Transform operator - (const vector_type&amp; v) const\n        {\n            return {x - v.x, y - v.y, theta};\n        }\n\n        // theta\n\n        constexpr Transform operator + (const value_type angle) const\n        {\n            return {x, y, theta + angle};\n        }\n\n        constexpr Transform operator - (const value_type angle) const\n        {\n            return {x, y, theta - angle};\n        }\n\n        // xy\n        constexpr Transform&amp; operator += (const vector_type&amp; v)\n        {\n            x += v.x;\n            y += v.y;\n\n            return *this;\n        }\n\n        constexpr Transform&amp; operator -= (const vector_type&amp; v)\n        {\n            x -= v.x;\n            y -= v.y;\n\n            return *this;\n        }\n\n        // theta\n        constexpr Transform&amp; operator += (const value_type angle)\n        {\n            theta += angle;\n\n            return *this;\n        }\n\n        constexpr Transform&amp; operator -= (const value_type angle)\n        {\n            theta -= angle;\n\n            return *this;\n        }\n\n        constexpr Transform operator * (const value_type value) const\n        {\n            return {x * value, y * value, theta * value};\n        }\n\n        constexpr Transform operator / (const value_type value) const\n        {\n            return {x / value, y / value, theta / value};\n        }\n\n        constexpr Transform&amp; operator *= (const value_type value)\n        {\n            x *= value;\n            y *= value;\n            theta *= value;\n\n            return *this;\n        }\n\n        constexpr Transform&amp; operator /= (const value_type value)\n        {\n            x /= value;\n            y /= value;\n            theta /= value;\n\n            return *this;\n        }\n\n        // index\n        value_type &amp;operator [] (const int index)\n        {\n            assert(0 &lt;= index &amp;&amp; index &lt; 3);\n            if (index == 0) return x;\n            if (index == 1) return y;\n            return theta;\n        }\n\n        constexpr value_type operator [] (const int index) const\n        {\n            assert(0 &lt;= index &amp;&amp; index &lt; 3);\n            if (index == 0) return x;\n            if (index == 1) return y;\n            return theta;\n        }\n    };\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/transformation_8hpp/","title":"include/cpp_robotics/algorithm/transformation.hpp","text":""},{"location":"doxybook/Files/transformation_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/transformation_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic Eigen::MatrixXd homogeneous(const Eigen::MatrixXd &amp;R, const Eigen::VectorXd &amp;T)\n{\n    assert(R.rows() == R.cols());\n    assert(R.cols() == T.rows());\n    const int dim = T.rows();\n    Eigen::MatrixXd H(dim+1, dim+1);\n    H.block(0,0, dim, dim) = R;\n    H.block(0, dim, dim, 1) = T;\n    H(dim, dim) = 1;\n    return H;\n}\n\nstatic Eigen::VectorXd transform_by_homogeneous(const Eigen::MatrixXd &amp;H, const Eigen::VectorXd &amp;x)\n{\n    assert(H.rows() == H.cols());\n    assert(H.cols() == x.rows()+1);\n    const int dim = x.rows();\n\n    Eigen::VectorXd xt = H.block(0,0, dim, dim)*x + H.block(0, dim, dim, 1);\n    return xt;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/unit_8hpp/","title":"include/cpp_robotics/unit.hpp","text":""},{"location":"doxybook/Files/unit_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"unit/unit_core.hpp\"\n#include \"unit/si_unit.hpp\"\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/unit__core_8hpp/","title":"include/cpp_robotics/unit/unit_core.hpp","text":""},{"location":"doxybook/Files/unit__core_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::prefix cpp_robotics::unit::tag"},{"location":"doxybook/Files/unit__core_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 struct cpp_robotics::unit::prefix::pfx_mul struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag&lt;-1 &gt; struct cpp_robotics::unit::tag::is_normal_tag&lt; 0 &gt; class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9"},{"location":"doxybook/Files/unit__core_8hpp/#defines","title":"Defines","text":"Name GENERATE_CONV_FACTOR(unit_dim, from_tag, to_tag, factor) GENERATE_UNIT_SUFFIX(unit, suffix) GENERATE_UNIT_PFX_SUFFIX(unit_type, prefix, suffix)"},{"location":"doxybook/Files/unit__core_8hpp/#macros-documentation","title":"Macros Documentation","text":""},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_conv_factor","title":"define GENERATE_CONV_FACTOR","text":"<pre><code>#define GENERATE_CONV_FACTOR(\n    unit_dim,\n    from_tag,\n    to_tag,\n    factor\n)\ntemplate&lt;&gt;\\\nconstexpr double conv_factor&lt;unit_dim, from_tag, to_tag&gt;()\\\n{\\\n    return (factor);\\\n}\n</code></pre>"},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_unit_suffix","title":"define GENERATE_UNIT_SUFFIX","text":"<pre><code>#define GENERATE_UNIT_SUFFIX(\n    unit,\n    suffix\n)\nconstexpr unit operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr unit operator\"\" _## suffix(long double val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\n</code></pre>"},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_unit_pfx_suffix","title":"define GENERATE_UNIT_PFX_SUFFIX","text":"<pre><code>#define GENERATE_UNIT_PFX_SUFFIX(\n    unit_type,\n    prefix,\n    suffix\n)\nconstexpr auto operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr auto operator\"\" _## suffix(long double val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\n</code></pre>"},{"location":"doxybook/Files/unit__core_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;cstdlib&gt;\n#include &lt;type_traits&gt;\n#include &lt;numeric&gt;\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics\n{\n\ninline namespace unit\n{\nenum UnitIndex\n{\n    MetereIdx,\n    KiloGramIdx,\n    SecondIdx,\n    AmpereIdx,\n    KelvinIdx,\n    MoleIdx,\n    CandelaIdx\n};\n\ntemplate&lt;int DIM1, int DIM2, int DIM3, int DIM4, int DIM5, int DIM6, int DIM7&gt;\nstruct UnitType{\n    static constexpr int dim1 = DIM1;\n\n    static constexpr int dim2 = DIM2;\n\n    static constexpr int dim3 = DIM3;\n\n    static constexpr int dim4 = DIM4;\n\n    static constexpr int dim5 = DIM5;\n\n    static constexpr int dim6 = DIM6;\n\n    static constexpr int dim7 = DIM7;\n};\n\nnamespace unit_dim_assem\n{\n    template&lt;class U1, class U2&gt;\n    struct udim_mul\n    {\n        using unit = UnitType&lt;\n            U1::dim1 + U2::dim1,\n            U1::dim2 + U2::dim2,\n            U1::dim3 + U2::dim3,\n            U1::dim4 + U2::dim4,\n            U1::dim5 + U2::dim5,\n            U1::dim6 + U2::dim6,\n            U1::dim7 + U2::dim7&gt;;\n    };\n\n    template&lt;class U1, class U2&gt;\n    struct udim_div\n    {\n        using unit = UnitType&lt;\n            U1::dim1 - U2::dim1,\n            U1::dim2 - U2::dim2,\n            U1::dim3 - U2::dim3,\n            U1::dim4 - U2::dim4,\n            U1::dim5 - U2::dim5,\n            U1::dim6 - U2::dim6,\n            U1::dim7 - U2::dim7&gt;;\n    };\n\n    template&lt;class U1, int N&gt;\n    struct udim_pow\n    {\n        using unit = UnitType&lt;\n            U1::dim1 * N,\n            U1::dim2 * N,\n            U1::dim3 * N,\n            U1::dim4 * N,\n            U1::dim5 * N,\n            U1::dim6 * N,\n            U1::dim7 * N&gt;;\n    };\n\n    template&lt;class U1&gt;\n    struct udim_inv\n    {\n        using unit = UnitType&lt;\n            -U1::dim1,\n            -U1::dim2,\n            -U1::dim3,\n            -U1::dim4,\n            -U1::dim5,\n            -U1::dim6,\n            -U1::dim7&gt;;\n    };\n}\n\nstruct PrefixBase \n{\n    PrefixBase() = delete;\n};\n\ntemplate&lt;uint32_t N, uint32_t D&gt;\nstruct Prefix : public PrefixBase\n{\n    using type = Prefix&lt;N, D&gt;;\n    static constexpr uint32_t num = N / std::gcd(N, D);\n    static constexpr uint32_t den = D / std::gcd(N, D);\n};\n\nnamespace prefix\n{\n    using nano  = Prefix&lt;1, 1000000000&gt;;\n    using micro = Prefix&lt;1,    1000000&gt;;\n    using milli = Prefix&lt;1,       1000&gt;;\n    using centi = Prefix&lt;1,        100&gt;;\n    using deci  = Prefix&lt;1,         10&gt;;\n    using none  = Prefix&lt;1,          1&gt;;\n    using deca  = Prefix&lt;        10, 1&gt;;\n    using hecto = Prefix&lt;       100, 1&gt;;\n    using kilo  = Prefix&lt;      1000, 1&gt;;\n    using mega  = Prefix&lt;   1000000, 1&gt;;\n    using giga  = Prefix&lt;1000000000, 1&gt;;\n\n    template&lt;class P1, class P2&gt;\n    struct pfx_mul\n    {\n        static constexpr uint32_t raw_num = P2::num * P1::num;\n        static constexpr uint32_t raw_den = P2::den * P1::den;\n        using prefix = Prefix&lt;raw_num, raw_den&gt;;\n    };\n\n    template&lt;class P1, class P2&gt;\n    struct pfx_div\n    {\n        static constexpr uint32_t raw_num = P1::num * P2::den;\n        static constexpr uint32_t raw_den = P1::den * P2::num;\n        using prefix = Prefix&lt;raw_num, raw_den&gt;;\n    };\n\n    template&lt;class P&gt;\n    struct pfx_inv\n    {\n        using prefix = Prefix&lt;P::den, P::num&gt;;\n    };\n\n    template&lt;class P1, class P2&gt;\n    struct pfx_min\n    {\n        static constexpr uint32_t raw_num = std::min(P1::num * P2::den, P2::num * P1::den);\n        static constexpr uint32_t raw_den = P1::den * P2::den;\n        using prefix = Prefix&lt;raw_num, raw_den&gt;;\n    };\n}\n\nnamespace tag\n{\n    enum angle\n    {\n        radian = 0,\n        degree\n    };\n\n    enum angular_vel\n    {\n        rad_per_sec = 0,\n        rps,\n        rpm\n    };\n\n    template &lt;int Tag&gt;\n    struct is_normal_tag : std::false_type{};\n\n    template&lt;&gt;\n    struct is_normal_tag&lt;-1&gt; : std::true_type{};\n    template&lt;&gt;\n    struct is_normal_tag&lt;0&gt; : std::true_type{};\n}\n\ntemplate&lt;class UnitDimType, int FromTag, int ToTag, bool IsNormalTag = tag::is_normal_tag&lt;FromTag&gt;::value &amp;&amp; tag::is_normal_tag&lt;ToTag&gt;::value&gt;\nconstexpr double conv_factor()\n{\n    static_assert(IsNormalTag == true, \"conv_factor is not defined\");\n    return 1;\n}\n\ntemplate&lt;class T, class UnitDimType, class P, int Tag = -1&gt;\nclass Unit\n{\n    static_assert(std::is_arithmetic_v&lt;T&gt;, \"T is not arithmetic.\");\n    static_assert(std::is_base_of_v&lt;PrefixBase, P&gt; &amp;&amp; !std::is_same_v&lt;PrefixBase, P&gt;, \"\");\n\npublic:\n    using value_type = T;\n    using unit_dimention_type = UnitDimType;\n    using prefix_type = P;\n    using unit_type = Unit&lt;T, UnitDimType, P&gt;;\n    static constexpr int tag = Tag;\n\n    Unit() = default;\n    constexpr Unit(T val): val_(val){}\n    constexpr T value() const { return val_; }\n    constexpr T raw_value() const { return val_ * P::num / P::den; }\n\n    constexpr unit_type operator +() const\n    {\n        return val_;\n    }\n\n    constexpr unit_type operator -() const\n    {\n        return -val_;\n    }\n\n    constexpr unit_type operator +(const unit_type&amp; rhl) const\n    {\n        return {val_ + rhl.value()};\n    }\n\n    constexpr unit_type operator -(const unit_type&amp; rhl) const\n    {\n        return {val_ - rhl.value()};\n    }\n\n    constexpr auto operator *(const unit_type&amp; rhl) const\n    {\n        using ret_dim_type = typename unit_dim_assem::udim_mul&lt;unit_dimention_type, unit_dimention_type&gt;::unit;\n        using ret_type = Unit&lt;value_type, ret_dim_type, prefix::none&gt;;\n\n        return ret_type{raw_value() * rhl.raw_value()};\n    }\n\n    constexpr unit_type&amp; operator +=(const unit_type&amp; rhl)\n    {\n        val_ += rhl.value();\n        return *this;\n    }\n\n    constexpr unit_type&amp; operator -=(const unit_type&amp; rhl)\n    {\n        val_ -= rhl.value();\n        return *this;\n    }\n\n    // \u30bf\u30b0\u306e\u5909\u63db\n    template&lt;int R_Tag&gt;\n    constexpr operator Unit&lt;value_type, unit_dimention_type, prefix_type, R_Tag&gt;() const\n    {\n\n        using ret_type = Unit&lt;T, UnitDimType, prefix_type, R_Tag&gt;;\n        if constexpr (tag == -1 &amp;&amp; R_Tag == 0)\n        {\n            ret_type{value()};\n        }\n        return ret_type{value() * conv_factor&lt;unit_dimention_type, tag, R_Tag&gt;()};\n    }\n\n    // \u63a5\u982d\u8a9e\u306e\u5909\u63db\n    template&lt;class R_P&gt;\n    constexpr operator Unit&lt;value_type, unit_dimention_type, R_P, tag&gt;() const\n    {\n        using ret_type = Unit&lt;T, UnitDimType, R_P&gt;;\n        using scale_prefix = typename prefix::pfx_div&lt;R_P, prefix_type&gt;::prefix;\n        return ret_type{value() * scale_prefix::den / scale_prefix::num};\n    }\n\n    // \u6570\u5024\u578b\u306b\u5909\u63db\n    constexpr operator value_type() const\n    {\n        return static_cast&lt;value_type&gt;(val_);\n    }\n\n    constexpr bool operator ==(const unit_type &amp;r_value)\n    {\n        return val_ == r_value.value();\n    }\n\n    constexpr bool operator !=(const unit_type &amp;r_value)\n    {\n        return !(val_ == r_value);\n    }\n\nprivate:\n    T val_;\n};\n\nnamespace unit_assem\n{\n    template&lt;class Unit1, class Unit2&gt;\n    struct unit_mul\n    {\n        static_assert(std::is_same_v&lt;typename Unit1::value_type, typename Unit2::value_type&gt;, \"\");\n        // static_assert(Unit1::tag == 0 &amp;&amp; Unit2::tag == 0, \"\");\n        using dim = typename unit_dim_assem::udim_mul&lt;typename Unit1::unit_dimention_type, typename Unit2::unit_dimention_type&gt;::unit;\n        using pfx = typename prefix::pfx_mul&lt;typename Unit1::prefix_type, typename Unit2::prefix_type&gt;::prefix;\n        using unit = Unit&lt;typename Unit1::value_type, dim, pfx&gt;;\n    };\n\n    template&lt;class Unit1, class Unit2&gt;\n    struct unit_div\n    {\n        static_assert(std::is_same_v&lt;typename Unit1::value_type, typename Unit2::value_type&gt;, \"\");\n        // static_assert(Unit1::tag == 0 &amp;&amp; Unit2::tag == 0, \"\");\n        using dim = typename unit_dim_assem::udim_div&lt;typename Unit1::unit_dimention_type, typename Unit2::unit_dimention_type&gt;::unit;\n        using pfx = typename prefix::pfx_div&lt;typename Unit1::prefix_type, typename Unit2::prefix_type&gt;::prefix;\n        using unit = Unit&lt;typename Unit1::value_type, dim, pfx&gt;;\n    };\n\n    template&lt;class UnitType&gt;\n    struct unit_inv\n    {\n        using dim = typename unit_dim_assem::udim_inv&lt;typename UnitType::unit_dimention_type&gt;::unit;\n        using pfx = typename prefix::pfx_inv&lt;typename UnitType::prefix_type&gt;::prefix;\n        using unit = Unit&lt;typename UnitType::value_type, dim, pfx, 0&gt;;\n    };\n\n    template&lt;class UnitType, class PrefixType&gt;\n    struct unit_pfx_scaled\n    {\n        using unit = Unit&lt;typename UnitType::value_type, \n            typename UnitType::unit_dimention_type, \n            typename prefix::pfx_mul&lt;typename UnitType::prefix_type, PrefixType&gt;::prefix,\n            UnitType::tag&gt;;\n    };\n}\n\n// template &lt;class UnitType, typename T&gt;\n// constexpr auto operator &lt;=&gt;(const UnitType &amp;l_value, const T &amp;r_value)\n// {\n//     return static_cast&lt;typename UnitType::value_type&gt;(l_value) &lt;=&gt; r_value;\n// }\n\n// \u5358\u4f4d*\u6570\u5024\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator *(const Unit&lt;T1, UnitDim, Prefix, Tag&gt; &amp;l_value, const T2 &amp;r_value)\n{\n    static_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\n    using unit_type = Unit&lt;T1, UnitDim, Prefix, Tag&gt;;\n    return unit_type(static_cast&lt;T1&gt;(l_value) * r_value);\n}\n\n// \u6570\u5024*\u5358\u4f4d\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator *(const T1 &amp;l_value, const Unit&lt;T2, UnitDim, Prefix, Tag&gt; &amp;r_value)\n{\n    static_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\n    using unit_type = Unit&lt;T2, UnitDim, Prefix, Tag&gt;;\n    return unit_type(l_value * static_cast&lt;T1&gt;(r_value));\n}\n\n// \u6570\u5024/\u5358\u4f4d\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator /(const T1 &amp;l_value, const Unit&lt;T2, UnitDim, Prefix, Tag&gt; &amp;r_value)\n{\n    static_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\n    using unit_type = Unit&lt;T2, UnitDim, Prefix, Tag&gt;;\n    return typename unit_assem::unit_inv&lt;unit_type&gt;::unit(l_value / static_cast&lt;T2&gt;(r_value));\n}\n\n// \u5358\u4f4d/\u6570\u5024\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator /(const Unit&lt;T1, UnitDim, Prefix, Tag&gt; &amp;l_value, const T2 &amp;r_value)\n{\n    static_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\n    using unit_type = Unit&lt;T1, UnitDim, Prefix, Tag&gt;;\n    return unit_type(static_cast&lt;T1&gt;(l_value) / r_value);\n}\n\n// \u5358\u4f4d*\u5358\u4f4d\ntemplate&lt;typename T1, class UnitDim1, class Prefix1, int Tag1, typename T2, class UnitDim2, class Prefix2, int Tag2&gt;\nconstexpr auto operator *(const Unit&lt;T1, UnitDim1, Prefix1, Tag1&gt;&amp; lhl, const Unit&lt;T2, UnitDim2, Prefix2, Tag2&gt; &amp;rhl)\n{\n    // static_assert(std::is_base_of_v&lt;Unit, R_UnitDimType&gt; &amp;&amp; std::is_base_of_v&lt;Unit, L_UnityDimType&gt;, \"test\");\n    static_assert(tag::is_normal_tag&lt;Tag1&gt;::value &amp;&amp; tag::is_normal_tag&lt;Tag2&gt;::value, \"Type has not normal tag\");\n    // static_assert(R_UnitDimType)\n    // static_assert(R_P)\n    using ret_dim_type = typename unit_dim_assem::udim_mul&lt;UnitDim1, UnitDim2&gt;::unit;\n    using ret_type = Unit&lt;T1, ret_dim_type, prefix::none&gt;;\n    return ret_type{lhl.raw_value() * rhl.raw_value()};\n}\n\n// \u5358\u4f4d/\u5358\u4f4d\ntemplate&lt;typename T1, class UnitDim1, class Prefix1, int Tag1, typename T2, class UnitDim2, class Prefix2, int Tag2&gt;\nconstexpr auto operator /(const Unit&lt;T1, UnitDim1, Prefix1, Tag1&gt;&amp; lhl, const Unit&lt;T2, UnitDim2, Prefix2, Tag2&gt; &amp;rhl)\n{\n    static_assert(tag::is_normal_tag&lt;Tag1&gt;::value &amp;&amp; tag::is_normal_tag&lt;Tag2&gt;::value, \"Type has not normal tag\");\n    // static_assert(R_UnitDimType)\n    // static_assert(R_P)\n    static_assert(tag::is_normal_tag&lt;Tag2&gt;::value, \"R_Tag is imcorrect\");\n    using ret_dim_type = typename unit_dim_assem::udim_div&lt;UnitDim1, UnitDim2&gt;::unit;\n    using ret_type = Unit&lt;T1, ret_dim_type, prefix::none&gt;;\n    return ret_type{lhl.raw_value() / rhl.raw_value()};\n}\n\n// \u5358\u4f4d+\u5358\u4f4d(prefix\u9055\u3044)\n// prefix\u304c\u5c0f\u3055\u3044\u65b9\u3067\u8fd4\u3059\ntemplate&lt;typename T, class UnitDim, class Prefix1, class Prefix2, int Tag&gt;\nconstexpr auto operator +(const Unit&lt;T, UnitDim, Prefix1, Tag&gt;&amp; lhl, const Unit&lt;T, UnitDim, Prefix2, Tag&gt; &amp;rhl)\n{\n    using min_prefix = typename prefix::pfx_min&lt;Prefix1, Prefix2&gt;::prefix;\n\n\n    using lpfx = typename prefix::pfx_div&lt;Prefix1, min_prefix&gt;::prefix;\n    T lhl_scaled_val = lhl.value() * lpfx::num / lpfx::den;\n\n    using rpfx = typename prefix::pfx_div&lt;Prefix2, min_prefix&gt;::prefix;\n    T rhl_scaled_val = rhl.value() * rpfx::num / rpfx::den;\n\n    using ret_type = Unit&lt;T, UnitDim, min_prefix, Tag&gt;;\n    return ret_type{lhl_scaled_val + rhl_scaled_val};\n}\n\ntemplate&lt;typename T, class UnitDim, class Prefix1, class Prefix2, int Tag&gt;\nconstexpr auto operator -(const Unit&lt;T, UnitDim, Prefix1, Tag&gt;&amp; lhl, const Unit&lt;T, UnitDim, Prefix2, Tag&gt; &amp;rhl)\n{\n    using min_prefix = typename prefix::pfx_min&lt;Prefix1, Prefix2&gt;::prefix;\n\n    using lpfx = typename prefix::pfx_div&lt;Prefix1, min_prefix&gt;::prefix;\n    T lhl_scaled_val = lhl.value() * lpfx::num / lpfx::den;\n\n    using rpfx = typename prefix::pfx_div&lt;Prefix2, min_prefix&gt;::prefix;\n    T rhl_scaled_val = rhl.value() * rpfx::num / rpfx::den;\n\n    using ret_type = Unit&lt;T, UnitDim, min_prefix, Tag&gt;;\n    return ret_type{lhl_scaled_val - rhl_scaled_val};\n}\n\n#define GENERATE_CONV_FACTOR(unit_dim, from_tag, to_tag, factor)\\\ntemplate&lt;&gt;\\\nconstexpr double conv_factor&lt;unit_dim, from_tag, to_tag&gt;()\\\n{\\\n    return (factor);\\\n}\n\n#define GENERATE_UNIT_SUFFIX(unit, suffix)\\\nconstexpr unit operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr unit operator\"\" _## suffix(long double val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\n\n#define GENERATE_UNIT_PFX_SUFFIX(unit_type, prefix, suffix)\\\nconstexpr auto operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr auto operator\"\" _## suffix(long double val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\n\n}\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/utility_8hpp/","title":"include/cpp_robotics/utility.hpp","text":""},{"location":"doxybook/Files/utility_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"utility/cpp_support.hpp\"\n#include \"utility/math_utils.hpp\"\n#include \"utility/angle_range.hpp\"\n#include \"utility/space.hpp\"\n#include \"utility/singleton.hpp\"\n#include \"utility/random.hpp\"\n\n#ifdef CR_USE_MATPLOTLIB\n#include \"third_party/matplotlib-cpp/matplotlibcpp.h\"\n#endif\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/vector2_8hpp/","title":"include/cpp_robotics/vector/vector2.hpp","text":"<p>More...</p>"},{"location":"doxybook/Files/vector2_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/vector2_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb"},{"location":"doxybook/Files/vector2_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author: Takumi Odashima (Kotakkucu@gmail.com) </p> <p>Date: 2021-01-25</p> <p>Copyright: Copyright (c) 2021 </p>"},{"location":"doxybook/Files/vector2_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{\n    template&lt;typename FLOATING_TYPE&gt;\n    struct Vector2;\n    using Vector2f = Vector2&lt;float&gt;;\n    using Vector2d = Vector2&lt;double&gt;;\n\n    template&lt;typename FLOATING_TYPE&gt;\n    struct Vector2\n    {\n        using value_type = FLOATING_TYPE;\n        value_type x, y;\n\n        Vector2() = default;\n\n        constexpr Vector2(value_type vx, value_type vy) : x(vx), y(vy) {}\n\n        constexpr Vector2(const Vector2&amp;) = default;\n\n        constexpr void set(const value_type vx, const value_type vy)\n        {\n            x = vx;\n            y = vy;\n        }\n\n        void set_polar(const value_type radius, const value_type theta)\n        {\n            x = radius * std::cos(theta);\n            y = radius * std::sin(theta);\n        }\n\n        constexpr value_type dot(const Vector2 &amp;v) const\n        {\n            return (x * v.x + y * v.y);\n        }\n\n        constexpr value_type cross(const Vector2 &amp;v) const\n        {\n            return (x * v.y - y * v.x);\n        }\n\n        constexpr value_type norm_sq() const\n        {\n            return dot(*this);\n        }\n\n        constexpr value_type norm() const { return std::sqrt(norm_sq()); }\n\n        void normalize() { *this /= norm(); }\n\n\n\n        constexpr value_type angle() const { return std::atan2(y, x); }\n\n        constexpr Vector2 get_normalized()\n        {\n            Vector2 v = *this;\n            v /= v.norm();\n            return v;\n        }\n\n        void rotate(const value_type theta)\n        {\n            Vector2 v = *this;\n            x = v.x * std::cos(theta) - v.y * std::sin(theta);\n            y = v.x * std::sin(theta) + v.y * std::cos(theta);\n        }\n\n        constexpr Vector2 get_rotated(const value_type theta) const\n        {\n            Vector2 v = {\n                x * std::cos(theta) - y * std::sin(theta),\n                x * std::sin(theta) + y * std::cos(theta)\n            };\n\n            return v;\n        }\n\n        constexpr bool is_zero() const\n        {\n            return approx_zero(x) &amp;&amp; approx_zero(y);\n        }\n\n        constexpr bool has_nan() const\n        {\n            return std::isnan(x) || std::isnan(y);\n        }\n\n        constexpr Vector2 yx() const\n        {\n            return {y, x};\n        }\n\n        constexpr Vector2 nyx() const\n        {\n            return {-y, x};\n        }\n\n        constexpr Vector2 ynx() const\n        {\n            return {y, -x};\n        }\n\n        constexpr Vector2 nxy() const\n        {\n            return {-x, y};\n        }\n\n        constexpr Vector2 xny() const\n        {\n            return {x, -y};\n        }\n\n        static constexpr value_type dot(const Vector2 &amp;a, const Vector2 &amp;b)\n        {\n            return a.dot(b);\n        }\n\n        static constexpr value_type angle(const Vector2 &amp;a, const Vector2 &amp;b)\n        {\n            value_type value = a.dot(b) / (a.norm() * b.norm());\n            return std::acos(value);\n        }\n\n        static constexpr value_type distance(const Vector2 &amp;a, const Vector2 &amp;b)\n        {\n            return (b-a).norm();\n        }\n\n        static constexpr Vector2 lerp(const Vector2 &amp;a, const Vector2 &amp;b, const value_type t)\n        {\n            return {cpp_robotics::lerp(a.x, b.x, t),\n                    cpp_robotics::lerp(a.y, b.y, t)};\n        }\n\n        constexpr Vector2 lerp(const Vector2 &amp;b, const value_type t) const\n        {\n            return lerp(*this, b, t);\n        }\n\n        // constatnt vector\n        static constexpr Vector2 zero()\n        {\n            return {0, 0};\n        }\n\n        static constexpr Vector2 up()\n        {\n            return {0, 1};\n        }\n\n        static constexpr Vector2 down()\n        {\n            return {0, -1};\n        }\n\n        static constexpr Vector2 right()\n        {\n            return {1, 0};\n        }\n\n        static constexpr Vector2 left()\n        {\n            return {-1, 0};\n        }\n\n        constexpr Vector2 operator + () const\n        {\n            return *this;\n        }\n\n        constexpr Vector2 operator - () const\n        {\n            return {-x, -y};\n        }\n\n        constexpr bool operator == (const Vector2&amp; v) const\n        {\n            return (x == v.x) &amp;&amp; (y == v.y);\n        }\n\n        constexpr bool operator != (const Vector2&amp; v) const\n        {\n            return !((x == v.x) &amp;&amp; (y == v.y));\n        }\n\n        constexpr Vector2 operator + (const Vector2&amp; v) const\n        {\n            return {x + v.x, y + v.y};\n        }\n\n        constexpr Vector2 operator - (const Vector2&amp; v) const\n        {\n            return {x - v.x, y - v.y};\n        }\n\n        friend constexpr Vector2 operator / (const Vector2&amp; v, const value_type value)\n        {\n            return {v.x / value, v.y / value};\n        }\n\n        constexpr Vector2&amp; operator += (const Vector2&amp; v)\n        {\n            x += v.x;\n            y += v.y;\n\n            return *this;\n        }\n\n        constexpr Vector2&amp; operator -= (const Vector2&amp; v)\n        {\n            x -= v.x;\n            y -= v.y;\n\n            return *this;\n        }\n\n        constexpr Vector2&amp; operator *= (const value_type value)\n        {\n            x *= value;\n            y *= value;\n\n            return *this;\n        }\n\n        constexpr Vector2&amp; operator /= (const value_type value)\n        {\n            x /= value;\n            y /= value;\n\n            return *this;\n        }\n\n        value_type &amp;operator [] (const size_t index)\n        {\n            assert(index &lt; 2);\n            if(index == 0) \n                return x;\n            return y;\n        }\n\n        constexpr value_type operator [] (const size_t index) const\n        {\n            assert(index &lt; 2);\n            if(index == 0) \n                return x;\n            return y;\n        }\n\n        template&lt;typename Scaler&gt;\n        friend constexpr Vector2 operator *(const Vector2&amp; v, const Scaler s) noexcept\n        {\n            return {v.x * static_cast&lt;value_type&gt;(s), \n                    v.y * static_cast&lt;value_type&gt;(s)};\n        }\n\n        template&lt;typename Scaler&gt;\n        friend constexpr Vector2 operator *(const Scaler s, const Vector2&amp; v) noexcept\n        {\n            return (v * static_cast&lt;value_type&gt;(s));\n        }\n    };\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/vector3_8hpp/","title":"include/cpp_robotics/vector/vector3.hpp","text":""},{"location":"doxybook/Files/vector3_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/vector3_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb"},{"location":"doxybook/Files/vector3_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{   \n    template&lt;typename FLOATING_TYPE&gt;\n    struct Vector3;\n    using Vector3f = Vector3&lt;float&gt;;\n    using Vector3d = Vector3&lt;double&gt;;\n\n    template&lt;typename FLOATING_TYPE&gt;\n    struct Vector3\n    {\n        using value_type = FLOATING_TYPE;\n        value_type x, y, z;\n\n        Vector3() = default;\n\n        constexpr Vector3(value_type vx, value_type vy, value_type vz) : x(vx), y(vy), z(vz) {}\n\n        Vector3(const Vector3 &amp;v) = default;\n\n        // function\n        void set(value_type vx, value_type vy, value_type vz)\n        {\n            x = vx;\n            y = vy;\n            z = vz;\n        }\n\n        constexpr value_type dot(const Vector3 &amp;v) const\n        {\n            return (x * v.x + y * v.y + z * v.z);\n        }\n\n        constexpr Vector3 cross(const Vector3 &amp;v) const\n        {\n            return {(y * v.z) - (z * v.y), z * v.x - x * v.z, x * v.y - y * v.x};\n        }\n\n        constexpr value_type norm_sq() const\n        {\n            return dot(*this);\n        }\n\n        value_type norm() { return std::sqrt(norm_sq()); }\n\n        void normalize() { *this /= norm(); }\n\n        Vector3 get_normalized()\n        {\n            Vector3 v = *this;\n            v /= v.norm();\n            return v;\n        }\n\n        constexpr bool is_zero() const\n        {\n            return approx_zero(x) &amp;&amp; approx_zero(y) &amp;&amp; approx_zero(z);\n        }\n\n        constexpr bool has_nan() const\n        {\n            return std::isnan(x) || std::isnan(y) || std::isnan(z);\n        }\n\n        static constexpr value_type dot(const Vector3 &amp;a, const Vector3 &amp;b)\n        {\n            return a.dot(b);\n        }\n\n        static value_type distance(const Vector3 &amp;a, const Vector3 &amp;b)\n        {\n            return (b-a).norm();\n        }\n\n        static constexpr Vector3 lerp(const Vector3 &amp;a, const Vector3 &amp;b, const value_type t)\n        {\n            return {cpp_robotics::lerp(a.x, b.x, t), \n                    cpp_robotics::lerp(a.y, b.y, t),\n                    cpp_robotics::lerp(a.z, b.z, t)};\n        }\n\n        constexpr Vector3 lerp(const Vector3 &amp;b, const value_type t) const\n        {\n            return lerp(*this, b, t);\n        }\n\n        // constant vector\n        static constexpr Vector3 zero()\n        {\n            return {0, 0, 0};\n        }\n\n        static constexpr Vector3 forward()\n        {\n            return {0, 0, 1};\n        }\n\n        static constexpr Vector3 back()\n        {\n            return {0, 0, -1};\n        }\n\n        static constexpr Vector3 up()\n        {\n            return {0, 1, 0};\n        }\n\n        static constexpr Vector3 down()\n        {\n            return {0, -1, 0};\n        }\n\n        static constexpr Vector3 right()\n        {\n            return {1, 0, 0};\n        }\n\n        static constexpr Vector3 left()\n        {\n            return {-1, 0, 0};\n        }\n\n        constexpr Vector3 operator + () const\n        {\n            return *this;\n        }\n\n        constexpr Vector3 operator - () const\n        {\n            return {-x, -y, -z};\n        }\n\n        bool operator == (const Vector3&amp; v) const\n        {\n            return (x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z);\n        }\n\n        bool operator != (const Vector3&amp; v) const\n        {\n            return !((x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z));\n        }\n\n        constexpr Vector3 operator + (const Vector3&amp; v) const\n        {\n            return {x + v.x, y + v.y, z + v.z};\n        }\n\n        constexpr Vector3 operator - (const Vector3&amp; v) const\n        {\n            return {x - v.x, y - v.y, z - v.z};\n        }\n\n        friend constexpr Vector3 operator / (const Vector3&amp; v, const value_type value)\n        {\n            return {v.x / value, v.y / value, v.z / value};\n        }\n\n        constexpr Vector3&amp; operator += (const Vector3&amp; v)\n        {\n            x += v.x;\n            y += v.y;\n            z += v.z;\n\n            return *this;\n        }\n\n        constexpr Vector3&amp; operator -= (const Vector3&amp; v)\n        {\n            x -= v.x;\n            y -= v.y;\n            z -= v.z;\n\n            return *this;\n        }\n\n        constexpr Vector3&amp; operator *= (const value_type value)\n        {\n            x *= value;\n            y *= value;\n            z *= value;\n\n            return *this;\n        }\n\n        constexpr Vector3&amp; operator /= (const value_type value)\n        {\n            x /= value;\n            y /= value;\n            z /= value;\n\n            return *this;\n        }\n\n        value_type &amp;operator [](const int index)\n        {\n            assert(0 &lt;= index &amp;&amp; index &lt; 3);\n            if (index == 0) return x;\n            if (index == 1) return y;\n            return z;\n        }\n\n        constexpr value_type operator [](const int index) const\n        {\n            assert(0 &lt;= index &amp;&amp; index &lt; 3);\n            if (index == 0) return x;\n            if (index == 1) return y;\n            return z;\n        }\n\n        template&lt;typename Scaler&gt;\n        friend constexpr Vector3 operator *(const Vector3&amp; v, const Scaler s) noexcept\n        {\n            return {v.x * static_cast&lt;value_type&gt;(s), \n                    v.y * static_cast&lt;value_type&gt;(s),\n                    v.z * static_cast&lt;value_type&gt;(s)};\n        }\n\n        template&lt;typename Scaler&gt;\n        friend constexpr Vector3 operator *(const Scaler s, const Vector3&amp; v) noexcept\n        {\n            return (v * static_cast&lt;value_type&gt;(s));\n        }\n    };\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/vector4_8hpp/","title":"include/cpp_robotics/vector/vector4.hpp","text":""},{"location":"doxybook/Files/vector4_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/vector4_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb"},{"location":"doxybook/Files/vector4_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{   \n    template&lt;typename FLOATING_TYPE&gt;\n    struct Vector4;\n    using Vector4f = Vector4&lt;float&gt;;\n    using Vector4d = Vector4&lt;double&gt;;\n\n    template&lt;typename FLOATING_TYPE&gt;\n    struct Vector4\n    {\n        using value_type = FLOATING_TYPE;\n        value_type x, y, z, w;\n\n        Vector4() = default;\n\n        constexpr Vector4(value_type vx, value_type vy, value_type vz, value_type vw) : x(vx), y(vy), z(vz), w(vw) {}\n\n        Vector4(const Vector4 &amp;v) = default;\n\n        // function\n        void set(value_type vx, value_type vy, value_type vz, value_type vw)\n        {\n            x = vx;\n            y = vy;\n            z = vz;\n            w = vw;\n        }\n\n        constexpr value_type dot(const Vector4 &amp;v) const\n        {\n            return (x * v.x + y * v.y + z * v.z + w * v.w);\n        }\n\n        constexpr value_type norm_sq() const\n        {\n            return dot(*this);\n        }\n\n        value_type norm() { return std::sqrt(norm_sq()); }\n\n        void normalize() { *this /= norm(); }\n\n        Vector4 get_normalized()\n        {\n            Vector4 v = *this;\n            v /= v.norm();\n            return v;\n        }\n\n        constexpr bool is_zero() const\n        {\n            return approx_zero(x) &amp;&amp; approx_zero(y) &amp;&amp; approx_zero(z) &amp;&amp; approx_zero(w);\n        }\n\n        constexpr bool has_nan() const\n        {\n            return std::isnan(x) || std::isnan(y) || std::isnan(z) || std::isnan(w);\n        }\n\n        static constexpr value_type dot(const Vector4 &amp;a, const Vector4 &amp;b)\n        {\n            return a.dot(b);\n        }\n\n        static value_type distance(const Vector4 &amp;a, const Vector4 &amp;b)\n        {\n            return (b-a).norm();\n        }\n\n        static constexpr Vector4 lerp(const Vector4 &amp;a, const Vector4 &amp;b, const value_type t)\n        {\n            return {cpp_robotics::lerp(a.x, b.x, t), \n                    cpp_robotics::lerp(a.y, b.y, t),\n                    cpp_robotics::lerp(a.z, b.z, t),\n                    cpp_robotics::lerp(a.w, b.w, t)};\n        }\n\n        constexpr Vector4 lerp(const Vector4 &amp;b, const value_type t) const\n        {\n            return lerp(*this, b, t);\n        }\n\n        // constant vector\n\n        static constexpr Vector4 zero()\n        {\n            return {0, 0, 0, 0};\n        }\n\n        constexpr Vector4 operator + () const\n        {\n            return *this;\n        }\n\n        constexpr Vector4 operator - () const\n        {\n            return {-x, -y, -z, -w};\n        }\n\n        bool operator == (const Vector4&amp; v) const\n        {\n            return (x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z) &amp;&amp; (w == v.w);\n        }\n\n        bool operator != (const Vector4&amp; v) const\n        {\n            return !((x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z) &amp;&amp; (w == v.w));\n        }\n\n        constexpr Vector4 operator + (const Vector4&amp; v) const\n        {\n            return {x + v.x, y + v.y, z + v.z, w + v.w};\n        }\n\n        constexpr Vector4 operator - (const Vector4&amp; v) const\n        {\n            return {x - v.x, y - v.y, z - v.z, w - v.w};\n        }\n\n        constexpr Vector4 operator * (const value_type value) const\n        {\n            return {x * value, y * value, z * value, w * value};\n        }\n\n        constexpr Vector4 operator / (const value_type value) const\n        {\n            return {x / value, y / value, z / value, w / value};\n        }\n\n        constexpr Vector4&amp; operator += (const Vector4&amp; v)\n        {\n            x += v.x;\n            y += v.y;\n            z += v.z;\n            w += v.w;\n\n            return *this;\n        }\n\n        constexpr Vector4&amp; operator -= (const Vector4&amp; v)\n        {\n            x -= v.x;\n            y -= v.y;\n            z -= v.z;\n            w -= v.w;\n\n            return *this;\n        }\n\n        constexpr Vector4&amp; operator *= (const value_type value)\n        {\n            x *= value;\n            y *= value;\n            z *= value;\n            w *= value;\n\n            return *this;\n        }\n\n        constexpr Vector4&amp; operator /= (const value_type value)\n        {\n            x /= value;\n            y /= value;\n            z /= value;\n            w /= value;\n\n            return *this;\n        }\n\n        value_type &amp;operator [](const int index)\n        {\n            assert(0 &lt;= index &amp;&amp; index &lt; 4);\n            if (index == 0) return x;\n            if (index == 1) return y;\n            if (index == 2) return z;\n            return w;\n        }\n\n        constexpr value_type operator [](const int index) const\n        {\n            assert(0 &lt;= index &amp;&amp; index &lt; 4);\n            if (index == 0) return x;\n            if (index == 1) return y;\n            if (index == 2) return z;\n            return w;\n        }\n\n        template&lt;typename Scaler&gt;\n        friend constexpr Vector4 operator *(Scaler s, Vector4 v) noexcept\n        {\n            return (v * static_cast&lt;value_type&gt;(s));\n        }\n    };\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/vector_8hpp/","title":"include/cpp_robotics/vector.hpp","text":""},{"location":"doxybook/Files/vector_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"vector/vector2.hpp\"\n#include \"vector/vector3.hpp\"\n#include \"vector/vector4.hpp\"\n#include \"vector/transform.hpp\"\n#include \"vector/quaternion.hpp\"\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/","title":"include/cpp_robotics/filter/velocity_limit_filter.hpp","text":""},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n#include \"integrator.hpp\"\n\nnamespace cpp_robotics\n{\n\n// \u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f\nclass VelocityLimitFilter\n{\npublic:\n    VelocityLimitFilter(double v_max, double dt):\n        VelocityLimitFilter(v_max, dt, 0.5/dt, 0.5/dt){}\n\n    VelocityLimitFilter(double v_max, double dt, std::pair&lt;double, double&gt; limit):\n        VelocityLimitFilter(v_max, dt, 0.5/dt, 0.5/dt, limit){}\n\n    VelocityLimitFilter(double v_max, double dt, double gpd, double fb_gain, std::optional&lt;std::pair&lt;double, double&gt;&gt; limit = std::nullopt): \n        Ts_(dt), v_max_(v_max), gpd_(gpd), cfb_(fb_gain), dp_(gpd, dt), intr_(dt), limit_(limit)\n    {\n        reset();\n    }\n\n    virtual void reset() \n    {\n        reset(0);\n    }\n    void reset(double u)\n    {\n        u1_ = u;\n        y1_ = u;\n        dp_.reset(u);\n        intr_.reset(u);\n    }\n\n    virtual double filtering(double u) \n    {\n        if(limit_)\n        {\n            u = std::clamp(u, limit_.value().first, limit_.value().second);\n        }\n        auto[diff, pass] = dp_.filtering(u);\n        double v = diff - (cfb_*(y1_-pass));\n        v = std::clamp(v, -v_max_, v_max_);\n        double y = intr_.filtering(v);\n        if(limit_)\n        {\n            y = std::clamp(y, limit_.value().first, limit_.value().second);\n        }\n\n        u1_ = u;\n        y1_ = y;\n        return y;\n    }\n\n    double Ts() const { return Ts_; }\n\nprivate:\n    // diff = s / (gpd*s + 1)\n    // pass = 1 / (gpd*s + 1)\n    class DiffPair\n    {\n    public:\n        DiffPair(double gpd, double Ts): Ts_(Ts), gpd_(gpd) {}\n\n        void reset()\n        {\n            reset(0.0);\n        }\n\n        void reset(double u)\n        {\n            u1_ = u;\n            y1diff_ = 0;\n            y1pass_ = 0;\n        }\n\n        std::tuple&lt;double, double&gt; filtering(double u)\n        {\n            double diff = ( 2.0*gpd_*(u-u1_) + (2.0-Ts_*gpd_)*y1diff_ )/(2.0+Ts_*gpd_);\n            double pass = ( gpd_*Ts_*(u+u1_) + (2.0-gpd_*Ts_)*y1pass_ )/(2.0+Ts_*gpd_);\n\n            u1_ = u;\n            y1diff_ = diff;\n            y1pass_ = pass;\n\n            return {diff, pass};\n        }\n\n    private:    \n        double Ts_, gpd_;\n        double u1_ = 0, y1diff_ = 0, y1pass_ = 0;\n    };\n\n    double Ts_, v_max_, gpd_, cfb_;\n    DiffPair dp_;\n    Integrator intr_;\n    double u1_ = 0, y1_ = 0;\n\n    std::optional&lt;std::pair&lt;double, double&gt;&gt; limit_;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/vrft_8hpp/","title":"include/cpp_robotics/controller/vrft.hpp","text":""},{"location":"doxybook/Files/vrft_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/vrft_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system.hpp&gt;\n#include &lt;cpp_robotics/optimize/least_squares_method.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nEigen::VectorXd vrft_leastsq(const Eigen::VectorXd &amp;u, const Eigen::VectorXd &amp;y, const double Ts, TransferFunction ref_model, std::vector&lt;TransferFunction&gt; &amp;control_base, std::optional&lt;TransferFunction&gt; prefilter)\n{\n    (void) Ts;\n\n    Eigen::VectorXd uf, ef;\n    if(prefilter)\n    {\n        uf = lsim_y(prefilter.value(), u);\n        ef = lsim_y(prefilter.value()*(ref_model.inv()-1.0), y);\n    }\n    else\n    {\n        uf = u;\n        ef = lsim_y((ref_model.inv()-1.0), y);\n    }\n\n    Eigen::MatrixXd phi(ef.size(), control_base.size());\n    for(size_t i = 0; i &lt; control_base.size(); ++i)\n    {\n        phi.col(i) = lsim_y(control_base[i], ef);\n    }\n\n    return leastsq(phi, uf);\n}\n\nEigen::VectorXd vrft_pid(const Eigen::VectorXd &amp;u, const Eigen::VectorXd &amp;y, const double Ts, TransferFunction ref_model, std::optional&lt;TransferFunction&gt; prefilter, double Td = 0.01)\n{\n    std::vector&lt;TransferFunction&gt; control_base = {\n        TransferFunction({1.0}, {1.0}, Ts),         // P\n        TransferFunction({1.0}, {1.0, 0.0}, Ts),    // I\n        TransferFunction({1.0, 0.0}, {Td, 1.0}, Ts) // D\n    };\n\n    return vrft_leastsq(u, y, Ts, ref_model, control_base, prefilter);\n}\n\nEigen::VectorXd vrft_p(const Eigen::VectorXd &amp;u, const Eigen::VectorXd &amp;y, const double Ts, TransferFunction ref_model, std::optional&lt;TransferFunction&gt; prefilter)\n{\n    std::vector&lt;TransferFunction&gt; control_base = {\n        TransferFunction({1.0}, {1.0}, Ts)\n    };\n\n    return vrft_leastsq(u, y, Ts, ref_model, control_base, prefilter);\n}\n\nEigen::VectorXd vrft_pi(const Eigen::VectorXd &amp;u, const Eigen::VectorXd &amp;y, const double Ts, TransferFunction ref_model, std::optional&lt;TransferFunction&gt; prefilter)\n{\n    std::vector&lt;TransferFunction&gt; control_base = {\n        TransferFunction({1.0}, {1.0}, Ts),\n        TransferFunction({1.0}, {1.0, 0.0}, Ts)\n    };\n\n    return vrft_leastsq(u, y, Ts, ref_model, control_base, prefilter);\n}\n\nEigen::VectorXd vrft_pd(const Eigen::VectorXd &amp;u, const Eigen::VectorXd &amp;y, const double Ts, TransferFunction ref_model, std::optional&lt;TransferFunction&gt; prefilter, double Td = 0.01)\n{\n    std::vector&lt;TransferFunction&gt; control_base = {\n        TransferFunction({1.0}, {1.0}, Ts),\n        TransferFunction({1.0, 0.0}, {Td, 1.0}, Ts)\n    };\n\n    return vrft_leastsq(u, y, Ts, ref_model, control_base, prefilter);\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/wave__propagation_8hpp/","title":"include/cpp_robotics/path_planning/wave_propagation.hpp","text":""},{"location":"doxybook/Files/wave__propagation_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/wave__propagation_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"grid_path_planning_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\nstd::vector&lt;Eigen::Vector2i&gt; wave_propagation(const Eigen::Vector2i&amp; start, const Eigen::Vector2i&amp; end, const Eigen::MatrixXi&amp; map)\n{\n    using namespace grid_path_planning_utils;\n\n    if(not contain_in_map(map, start) || not contain_in_map(map, end))\n        return {start};\n\n    if(start == end)\n        return {start};\n    if(!is_correct_step(start, map) || !is_correct_step(end, map))\n        return {}; // not exist path\n\n    const static std::array&lt;Eigen::Vector2i,8&gt; nb = {Eigen::Vector2i{1,0}, {0,1}, {-1,0}, {0,-1},\n                            {1,1}, {-1,1}, {-1,-1}, {1,-1}};\n\n    std::vector&lt;std::vector&lt;int&gt;&gt; costs_mat;\n    costs_mat.resize(map.rows());\n    for(auto &amp;r : costs_mat)\n    {\n        r.resize(map.cols());\n    }\n\n    auto costs = [&amp;](int x, int y) -&gt; int&amp;\n    {\n        return costs_mat.at(y).at(x);\n    };\n\n    std::list&lt;GridNode&gt; nodes = {}, new_nodes = {};\n\n    GridNode enode;\n    enode.pos = end;\n    enode.cost = 1;\n    nodes.push_back(enode);\n    costs(end(0), end(1)) = enode.cost;\n\n    // propagate a wave\n    auto exist_wp = [&amp;costs](const Eigen::Vector2i&amp; p) { return costs(p(0), p(1)) != 0; };\n    while(not nodes.empty())\n    {\n\n        for(auto &amp;n : nodes)\n        {\n            for(size_t i = 0; i &lt; 4; i++)\n            {\n                auto pos = n.pos + nb[i];\n                if(is_correct_step(pos, map)) // \u30b3\u30b9\u30c8\u304c0\u306e\u3068\u304d\n                {\n                    if(!exist_wp(pos))\n                    {\n                        int new_cost = n.cost + 1;\n                        costs(pos(0), pos(1)) = new_cost;\n                        GridNode nnode;\n                        nnode.pos = pos;\n                        nnode.cost = new_cost;\n                        new_nodes.push_back(nnode);\n                    }\n                }\n            }\n        }\n        nodes.clear();\n        nodes.insert(nodes.begin(), new_nodes.begin(), new_nodes.end());\n        new_nodes.clear();            \n    }\n\n    // create path\n    std::vector&lt;Eigen::Vector2i&gt; path;\n    Eigen::Vector2i look = start;\n    path.push_back(start);\n    std::array&lt;int, 8&gt; nb_costs;\n\n    // \u58c1\u306e\u90e8\u5206\u306f\u30b3\u30b9\u30c80&amp;nb_costs\u306e\u66f8\u304d\u63db\u3048\u3092\u884c\u308f\u306a\u3044\u305f\u3081\u58c1\u5074\u306b\u9032\u3080\u306e\u3092\u9632\u3050\n    for(auto &amp;c : nb_costs)\n        c = costs(look(0), look(1));\n\n    while(look != end)\n    {\n        size_t correct_step_count = 0;\n        for(size_t i = 0; i &lt; 8; i++)\n        {\n            auto neighbor = look + nb[i];\n            if(is_correct_step(neighbor, map))\n            {\n                int cost = costs(neighbor(0), neighbor(1));\n                if(cost != 0)\n                {\n                    correct_step_count++;\n                    nb_costs[i] = cost;\n                }\n            }\n        }\n        if(correct_step_count == 0)\n        {\n            // no exist path\n            // std::cout &lt;&lt; \"------------------- no exist path\" &lt;&lt; std::endl;\n            return {};\n        }\n\n        auto min_it = std::min_element(nb_costs.begin(), nb_costs.end());\n        look += nb[std::distance(nb_costs.begin(), min_it)];\n        // std::cout &lt;&lt; \"------------------- push\" &lt;&lt; look(0) &lt;&lt; \", \" &lt;&lt; look(1) &lt;&lt; std::endl;\n        path.push_back(look);\n    }\n\n    return path;\n}\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Files/xy__2link__robot_8hpp/","title":"include/cpp_robotics/arm_kinematics/xy_2link_robot.hpp","text":""},{"location":"doxybook/Files/xy__2link__robot_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/xy__2link__robot_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::XY2LinkRobot"},{"location":"doxybook/Files/xy__2link__robot_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cpp_robotics/arm_kinematics/arm_kinematics.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass XY2LinkRobot : public ArmForwardKinematics&lt;XY2LinkRobot&gt;\n{\npublic:\n    XY2LinkRobot(double l1, double l2):\n        ArmForwardKinematics&lt;XY2LinkRobot&gt;(2, 2), l1(l1), l2(l2) {}\n\n    template&lt;typename Vector&gt;\n    void forward_kinematics(const Vector&amp; q, Vector&amp; x)\n    {\n        x[0] = l1*cos(q[0]) + l2*cos(q[0]+q[1]);\n        x[1] = l1*sin(q[0]) + l2*sin(q[0]+q[1]);\n    } \n\nprivate:\n    const double l1;\n    const double l2;\n};\n\n}\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespaceEigen/","title":"Eigen","text":"<p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/","title":"cpp_robotics","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#namespaces","title":"Namespaces","text":"Name cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 cpp_robotics::internal cpp_robotics::unit::prefix cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 cpp_robotics::unit::tag cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit_dimention"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#classes","title":"Classes","text":"Name class cpp_robotics::ADVector class cpp_robotics::KMeansMethod K-means\u6cd5 class cpp_robotics::KDTree k-d\u6728 class cpp_robotics::ArmKinematics class cpp_robotics::ArmForwardKinematics class cpp_robotics::ArmInverseKinematics class cpp_robotics::XY2LinkRobot class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::ALConfig class cpp_robotics::ALiLQR struct cpp_robotics::iLQRConfig class cpp_robotics::iLQR class cpp_robotics::LinearMPC \u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9 class cpp_robotics::LinearRegulatorMPC class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668 class cpp_robotics::OCPConstraint class cpp_robotics::OCPConstraintArray class cpp_robotics::OCPFunctionalConstraint class cpp_robotics::OCPInputIndexedBoundConstraint class cpp_robotics::OCPStateIndexedBoundConstraint class cpp_robotics::OCPCost class cpp_robotics::OCPCostQuadratic class cpp_robotics::OCPCostServoQuadratic class cpp_robotics::OCPDynamics class cpp_robotics::OCPDiscreteLinearDynamics class cpp_robotics::OCPContinuousLinearDynamics class cpp_robotics::OCPDiscreteNonlinearDynamics class cpp_robotics::OCPContinuousNonlinearDynamics class cpp_robotics::OCPContinuousNonlinearDynamicsAD class cpp_robotics::OptimalControlProblem class cpp_robotics::SISOPFC class cpp_robotics::PID PID\u5236\u5fa1\u5668 class cpp_robotics::PID2 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 class cpp_robotics::PSMC class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668 class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::ButterworthFilter \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668 class cpp_robotics::ExtendedKalmanFilter class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Integrator \u7a4d\u5206\u5668 class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9 struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 class cpp_robotics::SQP SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) class cpp_robotics::DubinsPath Dubins\u30d1\u30b9 class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class cpp_robotics::DiscretTransferFunction struct cpp_robotics::Polynomial \u591a\u9805\u5f0f class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b class cpp_robotics::Timer class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#types","title":"Types","text":"Name enum class CanonicalizeMode enum uint8_t OCPConstraintType enum class OCPIntegrationMethod enum UnitIndex template &lt;class DerType  =Eigen::VectorXd&gt; using Eigen::AutoDiffScalar&lt; DerType &gt; ADScalar using ADVector&lt; Eigen::VectorXd, Eigen::Dynamic &gt; ADVectorXd using unit_assem::unit_div&lt; Torque, Ampere &gt;::unit TorqueConstant using unit_assem::unit_div&lt; Volt, AngularVelocity &gt;::unit BackEmfConstant using unit_assem::unit_mul&lt; Torque, Second &gt;::unit FrictionConstant using Unit&lt; double, unit_dimention::second, prefix::none &gt; Second using Unit&lt; double, unit_dimention::second, prefix::milli &gt; MilliSecond using Unit&lt; double, unit_dimention::second, prefix::micro &gt; MicroSecond using Unit&lt; double, unit_dimention::metere, prefix::none &gt; Meter using Unit&lt; double, unit_dimention::metere, prefix::milli &gt; MilliMeter using Unit&lt; double, unit_dimention::metere, prefix::micro &gt; MicroMeter using Unit&lt; double, unit_dimention::metere, prefix::centi &gt; CentiMeter using Unit&lt; double, unit_dimention::kilogram, prefix::none &gt; KiloGram using Unit&lt; double, unit_dimention::kilogram, prefix::milli &gt; Gram using Unit&lt; double, unit_dimention::watt, prefix::none &gt; Watt using Unit&lt; double, unit_dimention::watt, prefix::kilo &gt; KiloWatt using Unit&lt; double, unit_dimention::newton, prefix::none &gt; Newton using Unit&lt; double, unit_dimention::newton, prefix::kilo &gt; KiloNewton using Unit&lt; double, unit_dimention::pascal, prefix::none &gt; Pascal using Unit&lt; double, unit_dimention::pascal, prefix::kilo &gt; KiloPascal using Unit&lt; double, unit_dimention::hertz, prefix::none &gt; Hertz using Unit&lt; double, unit_dimention::area, prefix::none &gt; Area using Unit&lt; double, unit_dimention::volume, prefix::none &gt; Volume using Unit&lt; double, unit_dimention::velocity, prefix::none &gt; Velocity using Unit&lt; double, unit_dimention::acceleration, prefix::none &gt; Acceleration using Unit&lt; double, unit_dimention::dencity, prefix::none &gt; Dencity using Unit&lt; double, unit_dimention::torque, prefix::none &gt; Torque using Unit&lt; double, unit_dimention::inertia, prefix::none &gt; Inertia using Unit&lt; double, unit_dimention::ampere, prefix::none &gt; Ampere using Unit&lt; double, unit_dimention::ampere, prefix::milli &gt; MilliAmpere using Unit&lt; double, unit_dimention::volt, prefix::none &gt; Volt using Unit&lt; double, unit_dimention::volt, prefix::milli &gt; MilliVolt using Unit&lt; double, unit_dimention::ohm, prefix::none &gt; Ohm using Unit&lt; double, unit_dimention::ohm, prefix::milli &gt; MilliOhm using Unit&lt; double, unit_dimention::henry, prefix::none &gt; Henry using Unit&lt; double, unit_dimention::henry, prefix::milli &gt; MilliHenry using Unit&lt; double, unit_dimention::farad, prefix::none &gt; Farad using Unit&lt; double, unit_dimention::farad, prefix::milli &gt; MilliFarad using Unit&lt; double, unit_dimention::farad, prefix::micro &gt; MicroFarad using Unit&lt; double, unit_dimention::farad, prefix::nano &gt; NanoFarad using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::radian &gt; Radian using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::degree &gt; Degree using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec &gt; AngularVelocity using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps &gt; Rps using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm &gt; Rpm using Unit&lt; double, unit_dimention::angular_acceleration, prefix::none &gt; AngularAcceleration using RandomGenerator&lt; std::uniform_int_distribution&lt;&gt; &gt; UniformIntRandomEngine \u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::uniform_real_distribution&lt;&gt; &gt; UniformRealRandomEngine \u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::bernoulli_distribution &gt; BernoulliRandomEngine \u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::binomial_distribution&lt;&gt; &gt; BinomialRandomEngine \u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::geometric_distribution&lt;&gt; &gt; GeometricRandomEngine \u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::negative_binomial_distribution&lt;&gt; &gt; NegativeBinomialRandomEngine \u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::poisson_distribution&lt;&gt; &gt; PoissonRandomEngine \u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::exponential_distribution&lt;&gt; &gt; ExponentialRandomEngine \u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::gamma_distribution&lt;&gt; &gt; GammaRandomEngine \u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::weibull_distribution&lt;&gt; &gt; WeibullRandomEngine \u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::extreme_value_distribution&lt;&gt; &gt; ExtremeValueRandomEngine \u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::normal_distribution&lt;&gt; &gt; NormalRandomEngine \u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::lognormal_distribution&lt;&gt; &gt; LognormalRandomEngine \u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::chi_squared_distribution&lt;&gt; &gt; ChiSquaredRandomEngine \u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::cauchy_distribution&lt;&gt; &gt; CauchyRandomEngine \u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::fisher_f_distribution&lt;&gt; &gt; FisherFRandomEngine \u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::student_t_distribution&lt;&gt; &gt; StudentTRandomEngine \u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::discrete_distribution&lt;&gt; &gt; DiscreteRandomEngine \u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::piecewise_constant_distribution&lt;&gt; &gt; PiecewiseConstantRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::piecewise_linear_distribution&lt;&gt; &gt; PiecewiseLinearRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using Quaternion&lt; float &gt; Quaternionf using Quaternion&lt; double &gt; Quaterniond using Transform&lt; float &gt; Transformf using Transform&lt; double &gt; Transformd using Vector2&lt; float &gt; Vector2f using Vector2&lt; double &gt; Vector2d using Vector3&lt; float &gt; Vector3f using Vector3&lt; double &gt; Vector3d using Vector4&lt; float &gt; Vector4f using Vector4&lt; double &gt; Vector4d"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#functions","title":"Functions","text":"Name template &lt;int DIM&gt; std::pair&lt; Eigen::Matrix&lt; double, DIM, DIM &gt;, Eigen::Matrix&lt; double, DIM, 1 &gt; &gt; calcu_transformatoin(std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest, std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; fixed) template &lt;int DIM&gt; std::tuple&lt; std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt; &gt;, Eigen::MatrixXd, size_t &gt; icp(std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest, const std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; &amp; fixed, double eps =1e-4, size_t max_iter =100) double mahalanobis(const Eigen::VectorXd &amp; a, const Eigen::VectorXd &amp; b, const Eigen::MatrixXd cov_inv)\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 Polynomial poly_regression(const std::vector&lt; double &gt; &amp; x, const std::vector&lt; double &gt; &amp; y, const size_t degree)\u56de\u5e30\u66f2\u7dda Eigen::MatrixXd homogeneous(const Eigen::MatrixXd &amp; R, const Eigen::VectorXd &amp; T) Eigen::VectorXd transform_by_homogeneous(const Eigen::MatrixXd &amp; H, const Eigen::VectorXd &amp; x) std::optional&lt; Eigen::MatrixXd &gt; solve_riccati_arimoto_potter(const Eigen::MatrixXd &amp; A, const Eigen::MatrixXd &amp; B, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R)\u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 Eigen::MatrixXd lqr(const Eigen::MatrixXd &amp; A, const Eigen::MatrixXd &amp; B, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R) Eigen::MatrixXd controllability_matrix(const Eigen::MatrixXd &amp; A, const Eigen::VectorXd &amp; B)\u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 bool is_controllable(const Eigen::MatrixXd &amp; A, const Eigen::VectorXd &amp; B)\u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 bool is_controllable(const StateSpaceSystem &amp; sys) Eigen::MatrixXd observability_matrix(const Eigen::MatrixXd &amp; A, const Eigen::RowVectorXd &amp; C)\u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b bool is_observable(const Eigen::MatrixXd &amp; A, const Eigen::RowVectorXd &amp; C)\u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 bool is_observable(const StateSpaceSystem &amp; sys) std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(const Eigen::MatrixXd &amp; A, const Eigen::MatrixXd &amp; B, const Eigen::MatrixXd &amp; C, CanonicalizeMode mode =CanonicalizeMode::COMPANION)\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(const StateSpaceSystem &amp; sys, CanonicalizeMode mode =CanonicalizeMode::COMPANION)\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Eigen::VectorXd place(const StateSpaceSystem &amp; sys, std::vector&lt; double &gt; poles)\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e OCPConstraintArray OCPInputBoundConstraints(const Eigen::VectorXd &amp; lb, const Eigen::VectorXd &amp; ub, double slope =10.0) OCPConstraintArray OCPStateBoundConstrants(const Eigen::VectorXd &amp; lb, const Eigen::VectorXd &amp; ub, double slope =10.0) Eigen::VectorXd vrft_leastsq(const Eigen::VectorXd &amp; u, const Eigen::VectorXd &amp; y, const double Ts, TransferFunction ref_model, std::vector&lt; TransferFunction &gt; &amp; control_base, std::optional&lt; TransferFunction &gt; prefilter) Eigen::VectorXd vrft_pid(const Eigen::VectorXd &amp; u, const Eigen::VectorXd &amp; y, const double Ts, TransferFunction ref_model, std::optional&lt; TransferFunction &gt; prefilter, double Td =0.01) Eigen::VectorXd vrft_p(const Eigen::VectorXd &amp; u, const Eigen::VectorXd &amp; y, const double Ts, TransferFunction ref_model, std::optional&lt; TransferFunction &gt; prefilter) Eigen::VectorXd vrft_pi(const Eigen::VectorXd &amp; u, const Eigen::VectorXd &amp; y, const double Ts, TransferFunction ref_model, std::optional&lt; TransferFunction &gt; prefilter) Eigen::VectorXd vrft_pd(const Eigen::VectorXd &amp; u, const Eigen::VectorXd &amp; y, const double Ts, TransferFunction ref_model, std::optional&lt; TransferFunction &gt; prefilter, double Td =0.01) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector2d &amp; v) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector3d &amp; v) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector4d &amp; v) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Transformd &amp; v) bool intersect(const Vector2d &amp; a, const Vector2d &amp; b) bool intersect(const Vector2d &amp; a, const Line &amp; b) bool intersect(const Vector2d &amp; a, const Rect &amp; b) bool intersect(const Vector2d &amp; a, const Circle &amp; b) bool intersect(const Line &amp; a, const Vector2d &amp; b) bool intersect(const Line &amp; a, const Circle &amp; b) bool intersect(const Rect &amp; a, const Vector2d &amp; b) bool intersect(const Circle &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Line &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Rect &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Circle &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Line &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Line &amp; a, const Line &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Rect &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Circle &amp; a, const Vector2d &amp; b) constexpr DCMotorParam generate_mabuchi_motor_param(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Torque stall_torque, Ampere stall_current, Henry inductance, Inertia rotor_inertia) constexpr DCMotorParam generate_maxon_brush_motor_param(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm resistance, Henry inductance, TorqueConstant Kt, Inertia rotor_inertia) TransferFunction make_motor_vel_tf(const DCMotorParam &amp; motor, const double dt)DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_motor_pos_tf(const DCMotorParam &amp; motor, const double dt)DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_vel_tf(const DCGearedMotorParam &amp; geared_motor, const double dt)\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_pos_tf(const DCGearedMotorParam &amp; geared_motor, const double dt)\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; barrier_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =10.0, const double tol =1e-3, const size_t max_iter =1000)\u30d0\u30ea\u30a2\u6cd5 void bfgs_step(Eigen::MatrixXd &amp; hess, Eigen::VectorXd s, Eigen::VectorXd y)BFGS\u6cd5 void powells_modified_bfgs_step(Eigen::MatrixXd &amp; hess, Eigen::VectorXd s, Eigen::VectorXd y, Eigen::VectorXd dgg, double gamma =0.2)\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 void powells_modified_bfgs_step(Eigen::MatrixXd &amp; hess, Eigen::VectorXd s, Eigen::VectorXd y, double gamma =0.2) double bracketing_serach(std::function&lt; double(Eigen::VectorXd)&gt; func, std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad, const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; d, double gamma =0.3, double tau =0.9, const size_t max_iter =1000)\u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 double bracketing_serach(std::function&lt; double(double)&gt; func, const double init =1.0, const double beta =0.9, const size_t max_iter =1000)\u56f2\u3044\u8fbc\u307f\u6cd5 double derivative(std::function&lt; double(double)&gt; f, double x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R -&gt; R\u306e\u6570\u5024\u5fae\u5206 Eigen::VectorXd derivative(std::function&lt; double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R^n -&gt; R\u306e\u6570\u5024\u5fae\u5206 Eigen::MatrixXd derivative(std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R^n -&gt; R^m\u306e\u6570\u5024\u5fae\u5206 double second_derivative(std::function&lt; double(double)&gt; f, double x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R -&gt; R\u306e2\u56de\u6570\u5024\u5fae\u5206 Eigen::MatrixXd second_derivative(std::function&lt; double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R^n -&gt; R\u306e2\u56de\u6570\u5024\u5fae\u5206 Eigen::MatrixXd mixed_derivative(std::function&lt; double(Eigen::VectorXd, Eigen::VectorXd)&gt; f, Eigen::VectorXd x, Eigen::VectorXd y, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R^(n, m) -&gt; R\u306en,m\u3067\u306e\u504f\u5fae\u5206 Eigen::MatrixXd approx_hessian(std::function&lt; double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)) double golden_search(std::function&lt; double(double)&gt; f, double low, double high, const double tol =1e-6, const size_t max_iter =100)\u9ec4\u91d1\u63a2\u7d22 Eigen::VectorXd leastsq(const Eigen::MatrixXd &amp; A, const Eigen::VectorXd &amp; b) std::tuple&lt; Eigen::MatrixXd, Eigen::VectorXd &gt; lsi2qp(const Eigen::MatrixXd &amp; C, const Eigen::VectorXd &amp; d) std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; newton_method(std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, std::function&lt; Eigen::MatrixXd(const Eigen::VectorXd &amp;)&gt; hesse, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000)\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; penalty_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =1.0, const double tol =1e-3, const size_t max_iter =1000)\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; quasi_newton_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000)\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; steepest_descent_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000)\u6700\u6025\u964d\u4e0b\u6cd5 std::vector&lt; Eigen::Vector2i &gt; a_star(const Eigen::Vector2i &amp; start, const Eigen::Vector2i &amp; end, const Eigen::MatrixXi &amp; map)A*\u6cd5 double normalized_mjm_position(double t) double normalized_mjm_velocity(double t) double normalized_mjm_acceleration(double t) double normalized_mjm_jerk(double t) std::vector&lt; Eigen::Vector2i &gt; wave_propagation(const Eigen::Vector2i &amp; start, const Eigen::Vector2i &amp; end, const Eigen::MatrixXi &amp; map)Wave propagation\u6cd5 std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; bode(TransferFunction &amp; tf, const std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500), bool gain_db_mode =true, bool phase_deg_mode =true)\u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b template &lt;class T &gt; T integrate_forward_euler(double dt, const T &amp; x, const T &amp; u, std::function&lt; T(const T &amp;, const T &amp;)&gt; dynamics) template &lt;class T &gt; T integrate_modified_euler(double dt, const T &amp; x, const T &amp; u, std::function&lt; T(const T &amp;, const T &amp;)&gt; dynamics) template &lt;class T &gt; T integrate_rk4(double dt, const T &amp; x, const T &amp; u, std::function&lt; T(const T &amp;, const T &amp;)&gt; dynamics) std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; nyquist(TransferFunction &amp; tf, const std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500))\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Polynomial &amp; v) template &lt;class CONTROLLER_T ,class SYSTEM_T &gt; SisoFeedbackSystem make_feedback_system(CONTROLLER_T &amp; controller, SYSTEM_T &amp; system) void set_controller(SisoFeedbackSystem::func_list_t &amp; fn, PID &amp; controller) void set_controller(SisoFeedbackSystem::func_list_t &amp; fn, NctfController &amp; controller) void set_system(SisoFeedbackSystem::func_list_t &amp; fn, TransferFunction &amp; system) StateSpaceSystem tf2ss(const TransferFunction &amp; tf) std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(const std::function&lt; double(double)&gt; &amp; sys, double dt, double time)\u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b template &lt;class SysType ,typename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(SysType &amp; sys, double time) std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(const std::function&lt; double(double)&gt; &amp; sys, double dt, double time, const double gain =1.0)\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b template &lt;class SysType ,typename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(SysType &amp; sys, double time, const double gain =1.0) template &lt;class FilterType ,typename std::enable_if&lt; internal::is_pure_filter_class&lt; FilterType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(FilterType &amp; filter, double time, const double gain =1.0) template &lt;class DataIterativeType &gt; std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim(const std::function&lt; double(double)&gt; &amp; sys, double dt, const DataIterativeType &amp; input)\u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b template &lt;class DataIterativeType ,class SysType ,typename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim(SysType sys, const DataIterativeType &amp; input, bool skip_reset =false) template &lt;class DataIterativeType &gt; std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim(TransferFunction::tf_t sys_config, const DataIterativeType &amp; input) template &lt;class DataIterativeType &gt; std::tuple&lt; DataIterativeType, DataIterativeType, DataIterativeType &gt; lsim(SisoFeedbackSystem sys, const DataIterativeType &amp; input, bool skip_reset =false) template &lt;class DataIterativeType &gt; DataIterativeType lsim_y(const std::function&lt; double(double)&gt; &amp; sys, double dt, const DataIterativeType &amp; input) template &lt;class DataIterativeType ,class SysType ,typename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt; DataIterativeType lsim_y(SysType sys, const DataIterativeType &amp; input, bool skip_reset =false) template &lt;class DataIterativeType &gt; DataIterativeType lsim_y(TransferFunction::tf_t sys_config, const DataIterativeType &amp; input) template &lt;class DataIterativeType &gt; std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim_uy(SisoFeedbackSystem sys, const DataIterativeType &amp; input, bool skip_reset =false) template &lt;class DataIterativeType &gt; DataIterativeType lsim_y(SisoFeedbackSystem sys, const DataIterativeType &amp; input, bool skip_reset =false) template &lt;class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag::value &amp;&amp; tag::is_normal_tag::value&gt; constexpr double conv_factor() template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator+(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator-(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl) template &lt;class ForwardIterator &gt; constexpr ForwardIterator shift_left(ForwardIterator first, ForwardIterator last, typename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n)Substitute shift_left function in C++20 alogorithm. template &lt;class ForwardIterator &gt; constexpr ForwardIterator shift_right(ForwardIterator first, ForwardIterator last, typename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n)Substitute shift_right function in C++20 alogorithm. template &lt;typename... Args&gt; std::string c_format(const std::string &amp; format, Args const &amp;... args)printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b template &lt;typename MatrixType &gt; bool isPositiveDefinite(const MatrixType &amp; matrix) template &lt;typename MatrixType &gt; MatrixType pseudo_inverse(const MatrixType &amp; a, double epsilon =std::numeric_limits&lt; double &gt;::epsilon()) template &lt;typename MatrixType &gt; MatrixType sr_inverse(const MatrixType &amp; a, double w0 =1e-2, Eigen::MatrixXd W =Eigen::MatrixXd()) template &lt;typename T &gt; constexpr bool in_range_open(T x, T min, T max) template &lt;typename T &gt; constexpr bool in_range(T x, T min, T max) template &lt;typename T &gt; constexpr int sgn(T x) template &lt;typename T &gt; constexpr double radians(T deg) template &lt;typename T &gt; constexpr double degrees(T rad) double normalize_angle_positive(double angle) double normalize_angle(double angle) double shortest_angular_distance(double from, double to) double nearest_angle(double from, double to) constexpr double square(const double x) constexpr double cubic(const double x) constexpr double lerp(const double a, const double b, const double t) constexpr double approx_eq(const double a, const double b) constexpr double approx_zero(const double a) template &lt;typename Real  =double&gt; Real gererate_random()0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b template &lt;class DataType  =std::vector&gt; DataType arrange(double start, double end, double step =1.0)start\u304b\u3089end\u307e\u3067step\u305a\u3064\u5897\u3048\u308b\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 template &lt;class DataType  =std::vector&gt; DataType linspace(double start, double end, size_t n =100)start\u304b\u3089end\u307e\u3067\u3092n\u5206\u5272\u3057\u305f\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 template &lt;class DataType  =std::vector&gt; DataType implusespace(double time, double dt =1.0) template &lt;class DataType  =std::vector&gt; DataType stepspace(double time, double dt =1.0) template &lt;class DataType  =std::vector&gt; DataType logspace(double start, double end, size_t n =100)10^start\u304b\u308910^end\u307e\u3067\u5bfe\u6570\u7684\u306b\u7b49\u9593\u9694\u306an\u500b\u306e\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 std::vector&lt; double &gt; funcspace(std::function&lt; double(size_t, size_t)&gt; f, size_t n =100) std::vector&lt; double &gt; sinspace(double a, double b, size_t n =100)"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#attributes","title":"Attributes","text":"Name constexpr DCMotorParam RZ_735VA_9517 constexpr DCMotorParam RS_775_8513 constexpr DCMotorParam RS_555VC_5524 constexpr DCMotorParam RS_380PH_4045 constexpr DCMotorParam RS_385PH_2465 constexpr DCMotorParam RE_65_250_18 constexpr GearHeadParam IG42C_4 constexpr GearHeadParam IG42C_14 constexpr GearHeadParam IG42C_17 constexpr GearHeadParam IG32_27 constexpr GearHeadParam IG32_71 constexpr GearHeadParam IG32_100 constexpr double PI \u5186\u5468\u7387 constexpr double HALF_PI \u5186\u5468\u7387 / 2 constexpr double TWO_PI \u5186\u5468\u7387 * 2 constexpr double DEG_TO_RAD degree -&gt; radians constexpr double RAD_TO_DEG radian -&gt; degree constexpr double EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr double GRAVITY \u91cd\u529b constexpr double Nm2gfm constexpr double gfm2Nm constexpr double mNm2gfcm constexpr double gfcm2mNm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-canonicalizemode","title":"enum CanonicalizeMode","text":"Enumerator Value Description COMPANION OBSERBAVLE CONTROLLABLE"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-ocpconstrainttype","title":"enum OCPConstraintType","text":"Enumerator Value Description Eq Ineq"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-ocpintegrationmethod","title":"enum OCPIntegrationMethod","text":"Enumerator Value Description ForwardEuler ModifiedEuler RK4"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-unitindex","title":"enum UnitIndex","text":"Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-adscalar","title":"using ADScalar","text":"<pre><code>template &lt;class DerType  =Eigen::VectorXd&gt;\nusing cpp_robotics::ADScalar = typedef Eigen::AutoDiffScalar&lt;DerType&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-advectorxd","title":"using ADVectorXd","text":"<pre><code>using cpp_robotics::ADVectorXd = typedef ADVector&lt;Eigen::VectorXd, Eigen::Dynamic&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-torqueconstant","title":"using TorqueConstant","text":"<pre><code>using cpp_robotics::unit::TorqueConstant = typedef unit_assem::unit_div&lt;Torque, Ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-backemfconstant","title":"using BackEmfConstant","text":"<pre><code>using cpp_robotics::unit::BackEmfConstant = typedef unit_assem::unit_div&lt;Volt, AngularVelocity&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-frictionconstant","title":"using FrictionConstant","text":"<pre><code>using cpp_robotics::unit::FrictionConstant = typedef unit_assem::unit_mul&lt;Torque, Second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-second","title":"using Second","text":"<pre><code>using cpp_robotics::unit::Second = typedef Unit&lt;double, unit_dimention::second, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millisecond","title":"using MilliSecond","text":"<pre><code>using cpp_robotics::unit::MilliSecond = typedef Unit&lt;double, unit_dimention::second, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-microsecond","title":"using MicroSecond","text":"<pre><code>using cpp_robotics::unit::MicroSecond = typedef Unit&lt;double, unit_dimention::second, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-meter","title":"using Meter","text":"<pre><code>using cpp_robotics::unit::Meter = typedef Unit&lt;double, unit_dimention::metere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millimeter","title":"using MilliMeter","text":"<pre><code>using cpp_robotics::unit::MilliMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-micrometer","title":"using MicroMeter","text":"<pre><code>using cpp_robotics::unit::MicroMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-centimeter","title":"using CentiMeter","text":"<pre><code>using cpp_robotics::unit::CentiMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::centi&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilogram","title":"using KiloGram","text":"<pre><code>using cpp_robotics::unit::KiloGram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-gram","title":"using Gram","text":"<pre><code>using cpp_robotics::unit::Gram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-watt","title":"using Watt","text":"<pre><code>using cpp_robotics::unit::Watt = typedef Unit&lt;double, unit_dimention::watt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilowatt","title":"using KiloWatt","text":"<pre><code>using cpp_robotics::unit::KiloWatt = typedef Unit&lt;double, unit_dimention::watt, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-newton","title":"using Newton","text":"<pre><code>using cpp_robotics::unit::Newton = typedef Unit&lt;double, unit_dimention::newton, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilonewton","title":"using KiloNewton","text":"<pre><code>using cpp_robotics::unit::KiloNewton = typedef Unit&lt;double, unit_dimention::newton, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-pascal","title":"using Pascal","text":"<pre><code>using cpp_robotics::unit::Pascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilopascal","title":"using KiloPascal","text":"<pre><code>using cpp_robotics::unit::KiloPascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-hertz","title":"using Hertz","text":"<pre><code>using cpp_robotics::unit::Hertz = typedef Unit&lt;double, unit_dimention::hertz, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-area","title":"using Area","text":"<pre><code>using cpp_robotics::unit::Area = typedef Unit&lt;double, unit_dimention::area, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-volume","title":"using Volume","text":"<pre><code>using cpp_robotics::unit::Volume = typedef Unit&lt;double, unit_dimention::volume, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-velocity","title":"using Velocity","text":"<pre><code>using cpp_robotics::unit::Velocity = typedef Unit&lt;double, unit_dimention::velocity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-acceleration","title":"using Acceleration","text":"<pre><code>using cpp_robotics::unit::Acceleration = typedef Unit&lt;double, unit_dimention::acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-dencity","title":"using Dencity","text":"<pre><code>using cpp_robotics::unit::Dencity = typedef Unit&lt;double, unit_dimention::dencity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-torque","title":"using Torque","text":"<pre><code>using cpp_robotics::unit::Torque = typedef Unit&lt;double, unit_dimention::torque, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-inertia","title":"using Inertia","text":"<pre><code>using cpp_robotics::unit::Inertia = typedef Unit&lt;double, unit_dimention::inertia, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-ampere","title":"using Ampere","text":"<pre><code>using cpp_robotics::unit::Ampere = typedef Unit&lt;double, unit_dimention::ampere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-milliampere","title":"using MilliAmpere","text":"<pre><code>using cpp_robotics::unit::MilliAmpere = typedef Unit&lt;double, unit_dimention::ampere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-volt","title":"using Volt","text":"<pre><code>using cpp_robotics::unit::Volt = typedef Unit&lt;double, unit_dimention::volt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millivolt","title":"using MilliVolt","text":"<pre><code>using cpp_robotics::unit::MilliVolt = typedef Unit&lt;double, unit_dimention::volt, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-ohm","title":"using Ohm","text":"<pre><code>using cpp_robotics::unit::Ohm = typedef Unit&lt;double, unit_dimention::ohm, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-milliohm","title":"using MilliOhm","text":"<pre><code>using cpp_robotics::unit::MilliOhm = typedef Unit&lt;double, unit_dimention::ohm, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-henry","title":"using Henry","text":"<pre><code>using cpp_robotics::unit::Henry = typedef Unit&lt;double, unit_dimention::henry, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millihenry","title":"using MilliHenry","text":"<pre><code>using cpp_robotics::unit::MilliHenry = typedef Unit&lt;double, unit_dimention::henry, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-farad","title":"using Farad","text":"<pre><code>using cpp_robotics::unit::Farad = typedef Unit&lt;double, unit_dimention::farad, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millifarad","title":"using MilliFarad","text":"<pre><code>using cpp_robotics::unit::MilliFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-microfarad","title":"using MicroFarad","text":"<pre><code>using cpp_robotics::unit::MicroFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-nanofarad","title":"using NanoFarad","text":"<pre><code>using cpp_robotics::unit::NanoFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::nano&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-radian","title":"using Radian","text":"<pre><code>using cpp_robotics::unit::Radian = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::radian&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-degree","title":"using Degree","text":"<pre><code>using cpp_robotics::unit::Degree = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::degree&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-angularvelocity","title":"using AngularVelocity","text":"<pre><code>using cpp_robotics::unit::AngularVelocity = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-rps","title":"using Rps","text":"<pre><code>using cpp_robotics::unit::Rps = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-rpm","title":"using Rpm","text":"<pre><code>using cpp_robotics::unit::Rpm = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-angularacceleration","title":"using AngularAcceleration","text":"<pre><code>using cpp_robotics::unit::AngularAcceleration = typedef Unit&lt;double, unit_dimention::angular_acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-uniformintrandomengine","title":"using UniformIntRandomEngine","text":"<pre><code>using cpp_robotics::UniformIntRandomEngine = typedef RandomGenerator&lt;std::uniform_int_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-uniformrealrandomengine","title":"using UniformRealRandomEngine","text":"<pre><code>using cpp_robotics::UniformRealRandomEngine = typedef RandomGenerator&lt;std::uniform_real_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-bernoullirandomengine","title":"using BernoulliRandomEngine","text":"<pre><code>using cpp_robotics::BernoulliRandomEngine = typedef RandomGenerator&lt;std::bernoulli_distribution&gt;;\n</code></pre> <p>\u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-binomialrandomengine","title":"using BinomialRandomEngine","text":"<pre><code>using cpp_robotics::BinomialRandomEngine = typedef RandomGenerator&lt;std::binomial_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-geometricrandomengine","title":"using GeometricRandomEngine","text":"<pre><code>using cpp_robotics::GeometricRandomEngine = typedef RandomGenerator&lt;std::geometric_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-negativebinomialrandomengine","title":"using NegativeBinomialRandomEngine","text":"<pre><code>using cpp_robotics::NegativeBinomialRandomEngine = typedef RandomGenerator&lt;std::negative_binomial_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-poissonrandomengine","title":"using PoissonRandomEngine","text":"<pre><code>using cpp_robotics::PoissonRandomEngine = typedef RandomGenerator&lt;std::poisson_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-exponentialrandomengine","title":"using ExponentialRandomEngine","text":"<pre><code>using cpp_robotics::ExponentialRandomEngine = typedef RandomGenerator&lt;std::exponential_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-gammarandomengine","title":"using GammaRandomEngine","text":"<pre><code>using cpp_robotics::GammaRandomEngine = typedef RandomGenerator&lt;std::gamma_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-weibullrandomengine","title":"using WeibullRandomEngine","text":"<pre><code>using cpp_robotics::WeibullRandomEngine = typedef RandomGenerator&lt;std::weibull_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-extremevaluerandomengine","title":"using ExtremeValueRandomEngine","text":"<pre><code>using cpp_robotics::ExtremeValueRandomEngine = typedef RandomGenerator&lt;std::extreme_value_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-normalrandomengine","title":"using NormalRandomEngine","text":"<pre><code>using cpp_robotics::NormalRandomEngine = typedef RandomGenerator&lt;std::normal_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-lognormalrandomengine","title":"using LognormalRandomEngine","text":"<pre><code>using cpp_robotics::LognormalRandomEngine = typedef RandomGenerator&lt;std::lognormal_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-chisquaredrandomengine","title":"using ChiSquaredRandomEngine","text":"<pre><code>using cpp_robotics::ChiSquaredRandomEngine = typedef RandomGenerator&lt;std::chi_squared_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-cauchyrandomengine","title":"using CauchyRandomEngine","text":"<pre><code>using cpp_robotics::CauchyRandomEngine = typedef RandomGenerator&lt;std::cauchy_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-fisherfrandomengine","title":"using FisherFRandomEngine","text":"<pre><code>using cpp_robotics::FisherFRandomEngine = typedef RandomGenerator&lt;std::fisher_f_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-studenttrandomengine","title":"using StudentTRandomEngine","text":"<pre><code>using cpp_robotics::StudentTRandomEngine = typedef RandomGenerator&lt;std::student_t_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-discreterandomengine","title":"using DiscreteRandomEngine","text":"<pre><code>using cpp_robotics::DiscreteRandomEngine = typedef RandomGenerator&lt;std::discrete_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-piecewiseconstantrandomengine","title":"using PiecewiseConstantRandomEngine","text":"<pre><code>using cpp_robotics::PiecewiseConstantRandomEngine = typedef RandomGenerator&lt;std::piecewise_constant_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-piecewiselinearrandomengine","title":"using PiecewiseLinearRandomEngine","text":"<pre><code>using cpp_robotics::PiecewiseLinearRandomEngine = typedef RandomGenerator&lt;std::piecewise_linear_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-quaternionf","title":"using Quaternionf","text":"<pre><code>using cpp_robotics::Quaternionf = typedef Quaternion&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-quaterniond","title":"using Quaterniond","text":"<pre><code>using cpp_robotics::Quaterniond = typedef Quaternion&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-transformf","title":"using Transformf","text":"<pre><code>using cpp_robotics::Transformf = typedef Transform&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-transformd","title":"using Transformd","text":"<pre><code>using cpp_robotics::Transformd = typedef Transform&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector2f","title":"using Vector2f","text":"<pre><code>using cpp_robotics::Vector2f = typedef Vector2&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector2d","title":"using Vector2d","text":"<pre><code>using cpp_robotics::Vector2d = typedef Vector2&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector3f","title":"using Vector3f","text":"<pre><code>using cpp_robotics::Vector3f = typedef Vector3&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector3d","title":"using Vector3d","text":"<pre><code>using cpp_robotics::Vector3d = typedef Vector3&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector4f","title":"using Vector4f","text":"<pre><code>using cpp_robotics::Vector4f = typedef Vector4&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector4d","title":"using Vector4d","text":"<pre><code>using cpp_robotics::Vector4d = typedef Vector4&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-calcu_transformatoin","title":"function calcu_transformatoin","text":"<pre><code>template &lt;int DIM&gt;\nstatic std::pair&lt; Eigen::Matrix&lt; double, DIM, DIM &gt;, Eigen::Matrix&lt; double, DIM, 1 &gt; &gt; calcu_transformatoin(\n    std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest,\n    std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; fixed\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-icp","title":"function icp","text":"<pre><code>template &lt;int DIM&gt;\nstatic std::tuple&lt; std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt; &gt;, Eigen::MatrixXd, size_t &gt; icp(\n    std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest,\n    const std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; &amp; fixed,\n    double eps =1e-4,\n    size_t max_iter =100\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-mahalanobis","title":"function mahalanobis","text":"<pre><code>double mahalanobis(\n    const Eigen::VectorXd &amp; a,\n    const Eigen::VectorXd &amp; b,\n    const Eigen::MatrixXd cov_inv\n)\n</code></pre> <p>\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>cov_inv \u5206\u6563\u306e\u9006\u884c\u5217 </li> </ul> <p>Return: double \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-poly_regression","title":"function poly_regression","text":"<pre><code>Polynomial poly_regression(\n    const std::vector&lt; double &gt; &amp; x,\n    const std::vector&lt; double &gt; &amp; y,\n    const size_t degree\n)\n</code></pre> <p>\u56de\u5e30\u66f2\u7dda </p> <p>Parameters: </p> <ul> <li>x </li> <li>y </li> <li>degree \u56de\u5e30\u66f2\u7dda\u306e\u6b21\u5143 </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-homogeneous","title":"function homogeneous","text":"<pre><code>static Eigen::MatrixXd homogeneous(\n    const Eigen::MatrixXd &amp; R,\n    const Eigen::VectorXd &amp; T\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-transform_by_homogeneous","title":"function transform_by_homogeneous","text":"<pre><code>static Eigen::VectorXd transform_by_homogeneous(\n    const Eigen::MatrixXd &amp; H,\n    const Eigen::VectorXd &amp; x\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-solve_riccati_arimoto_potter","title":"function solve_riccati_arimoto_potter","text":"<pre><code>static std::optional&lt; Eigen::MatrixXd &gt; solve_riccati_arimoto_potter(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::MatrixXd &amp; B,\n    const Eigen::MatrixXd &amp; Q,\n    const Eigen::MatrixXd &amp; R\n)\n</code></pre> <p>\u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> <li>Q </li> <li>R </li> </ul> <p>Return: std::optional"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lqr","title":"function lqr","text":"<pre><code>static Eigen::MatrixXd lqr(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::MatrixXd &amp; B,\n    const Eigen::MatrixXd &amp; Q,\n    const Eigen::MatrixXd &amp; R\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-controllability_matrix","title":"function controllability_matrix","text":"<pre><code>static Eigen::MatrixXd controllability_matrix(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::VectorXd &amp; B\n)\n</code></pre> <p>\u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_controllable","title":"function is_controllable","text":"<pre><code>static bool is_controllable(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::VectorXd &amp; B\n)\n</code></pre> <p>\u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> </ul> <p>Return: </p> <ul> <li>true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u3042\u308b </li> <li>false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u306a\u3044 </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_controllable_1","title":"function is_controllable","text":"<pre><code>static bool is_controllable(\n    const StateSpaceSystem &amp; sys\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-observability_matrix","title":"function observability_matrix","text":"<pre><code>static Eigen::MatrixXd observability_matrix(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::RowVectorXd &amp; C\n)\n</code></pre> <p>\u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>A </li> <li>C </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_observable","title":"function is_observable","text":"<pre><code>static bool is_observable(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::RowVectorXd &amp; C\n)\n</code></pre> <p>\u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 </p> <p>Parameters: </p> <ul> <li>A </li> <li>C </li> </ul> <p>Return: </p> <ul> <li>true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b </li> <li>false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044 </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_observable_1","title":"function is_observable","text":"<pre><code>static bool is_observable(\n    const StateSpaceSystem &amp; sys\n)\n</code></pre> <p>Parameters: </p> <ul> <li>sys \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 </li> </ul> <p>Return: </p> <ul> <li>true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b </li> <li>false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044 </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-canonicalize_system","title":"function canonicalize_system","text":"<pre><code>static std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::MatrixXd &amp; B,\n    const Eigen::MatrixXd &amp; C,\n    CanonicalizeMode mode =CanonicalizeMode::COMPANION\n)\n</code></pre> <p>\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> <li>C </li> <li>mode </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-canonicalize_system_1","title":"function canonicalize_system","text":"<pre><code>static std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(\n    const StateSpaceSystem &amp; sys,\n    CanonicalizeMode mode =CanonicalizeMode::COMPANION\n)\n</code></pre> <p>\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db </p> <p>Parameters: </p> <ul> <li>sys </li> <li>mode </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-place","title":"function place","text":"<pre><code>static Eigen::VectorXd place(\n    const StateSpaceSystem &amp; sys,\n    std::vector&lt; double &gt; poles\n)\n</code></pre> <p>\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e </p> <p>Parameters: </p> <ul> <li>sys </li> <li>poles </li> </ul> <p>Return: Eigen::VectorXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-ocpinputboundconstraints","title":"function OCPInputBoundConstraints","text":"<pre><code>static OCPConstraintArray OCPInputBoundConstraints(\n    const Eigen::VectorXd &amp; lb,\n    const Eigen::VectorXd &amp; ub,\n    double slope =10.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-ocpstateboundconstrants","title":"function OCPStateBoundConstrants","text":"<pre><code>static OCPConstraintArray OCPStateBoundConstrants(\n    const Eigen::VectorXd &amp; lb,\n    const Eigen::VectorXd &amp; ub,\n    double slope =10.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-vrft_leastsq","title":"function vrft_leastsq","text":"<pre><code>Eigen::VectorXd vrft_leastsq(\n    const Eigen::VectorXd &amp; u,\n    const Eigen::VectorXd &amp; y,\n    const double Ts,\n    TransferFunction ref_model,\n    std::vector&lt; TransferFunction &gt; &amp; control_base,\n    std::optional&lt; TransferFunction &gt; prefilter\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-vrft_pid","title":"function vrft_pid","text":"<pre><code>Eigen::VectorXd vrft_pid(\n    const Eigen::VectorXd &amp; u,\n    const Eigen::VectorXd &amp; y,\n    const double Ts,\n    TransferFunction ref_model,\n    std::optional&lt; TransferFunction &gt; prefilter,\n    double Td =0.01\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-vrft_p","title":"function vrft_p","text":"<pre><code>Eigen::VectorXd vrft_p(\n    const Eigen::VectorXd &amp; u,\n    const Eigen::VectorXd &amp; y,\n    const double Ts,\n    TransferFunction ref_model,\n    std::optional&lt; TransferFunction &gt; prefilter\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-vrft_pi","title":"function vrft_pi","text":"<pre><code>Eigen::VectorXd vrft_pi(\n    const Eigen::VectorXd &amp; u,\n    const Eigen::VectorXd &amp; y,\n    const double Ts,\n    TransferFunction ref_model,\n    std::optional&lt; TransferFunction &gt; prefilter\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-vrft_pd","title":"function vrft_pd","text":"<pre><code>Eigen::VectorXd vrft_pd(\n    const Eigen::VectorXd &amp; u,\n    const Eigen::VectorXd &amp; y,\n    const double Ts,\n    TransferFunction ref_model,\n    std::optional&lt; TransferFunction &gt; prefilter,\n    double Td =0.01\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const Vector2d &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const Vector3d &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const Vector4d &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const Transformd &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect","title":"function intersect","text":"<pre><code>bool intersect(\n    const Vector2d &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_1","title":"function intersect","text":"<pre><code>bool intersect(\n    const Vector2d &amp; a,\n    const Line &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_2","title":"function intersect","text":"<pre><code>bool intersect(\n    const Vector2d &amp; a,\n    const Rect &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_3","title":"function intersect","text":"<pre><code>bool intersect(\n    const Vector2d &amp; a,\n    const Circle &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_4","title":"function intersect","text":"<pre><code>bool intersect(\n    const Line &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_5","title":"function intersect","text":"<pre><code>bool intersect(\n    const Line &amp; a,\n    const Circle &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_6","title":"function intersect","text":"<pre><code>bool intersect(\n    const Rect &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_7","title":"function intersect","text":"<pre><code>bool intersect(\n    const Circle &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Vector2d &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_1","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Vector2d &amp; a,\n    const Line &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_2","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Vector2d &amp; a,\n    const Rect &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_3","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Vector2d &amp; a,\n    const Circle &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_4","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Line &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_5","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Line &amp; a,\n    const Line &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_6","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Rect &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_7","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\n    const Circle &amp; a,\n    const Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-generate_mabuchi_motor_param","title":"function generate_mabuchi_motor_param","text":"<pre><code>inline constexpr DCMotorParam generate_mabuchi_motor_param(\n    Volt nominal_voltage,\n    Rpm free_speed,\n    Ampere free_current,\n    Torque stall_torque,\n    Ampere stall_current,\n    Henry inductance,\n    Inertia rotor_inertia\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-generate_maxon_brush_motor_param","title":"function generate_maxon_brush_motor_param","text":"<pre><code>inline constexpr DCMotorParam generate_maxon_brush_motor_param(\n    Volt nominal_voltage,\n    Rpm free_speed,\n    Ampere free_current,\n    Ohm resistance,\n    Henry inductance,\n    TorqueConstant Kt,\n    Inertia rotor_inertia\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_motor_vel_tf","title":"function make_motor_vel_tf","text":"<pre><code>static TransferFunction make_motor_vel_tf(\n    const DCMotorParam &amp; motor,\n    const double dt\n)\n</code></pre> <p>DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_motor_pos_tf","title":"function make_motor_pos_tf","text":"<pre><code>static TransferFunction make_motor_pos_tf(\n    const DCMotorParam &amp; motor,\n    const double dt\n)\n</code></pre> <p>DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_geared_motor_vel_tf","title":"function make_geared_motor_vel_tf","text":"<pre><code>static TransferFunction make_geared_motor_vel_tf(\n    const DCGearedMotorParam &amp; geared_motor,\n    const double dt\n)\n</code></pre> <p>\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>geared_motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_geared_motor_pos_tf","title":"function make_geared_motor_pos_tf","text":"<pre><code>static TransferFunction make_geared_motor_pos_tf(\n    const DCGearedMotorParam &amp; geared_motor,\n    const double dt\n)\n</code></pre> <p>\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>geared_motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-barrier_method","title":"function barrier_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; barrier_method(\n    std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\n    ConstraintArray constraint,\n    Eigen::VectorXd x_init,\n    const double r_init =10.0,\n    const double tol =1e-3,\n    const size_t max_iter =1000\n)\n</code></pre> <p>\u30d0\u30ea\u30a2\u6cd5 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bfgs_step","title":"function bfgs_step","text":"<pre><code>static void bfgs_step(\n    Eigen::MatrixXd &amp; hess,\n    Eigen::VectorXd s,\n    Eigen::VectorXd y\n)\n</code></pre> <p>BFGS\u6cd5 </p> <p>Parameters: </p> <ul> <li>hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 </li> <li>s x_k+1 - x_k </li> <li>y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k) </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-powells_modified_bfgs_step","title":"function powells_modified_bfgs_step","text":"<pre><code>static void powells_modified_bfgs_step(\n    Eigen::MatrixXd &amp; hess,\n    Eigen::VectorXd s,\n    Eigen::VectorXd y,\n    Eigen::VectorXd dgg,\n    double gamma =0.2\n)\n</code></pre> <p>\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 </p> <p>Parameters: </p> <ul> <li>hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 </li> <li>s x_k+1 - x_k </li> <li>y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k) </li> <li>w \\grad g(x+1)g(x+1) - \\grad g(x)g(x) </li> <li>gamma </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-powells_modified_bfgs_step_1","title":"function powells_modified_bfgs_step","text":"<pre><code>static void powells_modified_bfgs_step(\n    Eigen::MatrixXd &amp; hess,\n    Eigen::VectorXd s,\n    Eigen::VectorXd y,\n    double gamma =0.2\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bracketing_serach","title":"function bracketing_serach","text":"<pre><code>static double bracketing_serach(\n    std::function&lt; double(Eigen::VectorXd)&gt; func,\n    std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad,\n    const Eigen::VectorXd &amp; x,\n    const Eigen::VectorXd &amp; d,\n    double gamma =0.3,\n    double tau =0.9,\n    const size_t max_iter =1000\n)\n</code></pre> <p>\u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 </p> <p>Parameters: </p> <ul> <li>func </li> <li>grad </li> <li>x </li> <li>d </li> <li>gamma </li> <li>tau </li> <li>max_iter </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bracketing_serach_1","title":"function bracketing_serach","text":"<pre><code>static double bracketing_serach(\n    std::function&lt; double(double)&gt; func,\n    const double init =1.0,\n    const double beta =0.9,\n    const size_t max_iter =1000\n)\n</code></pre> <p>\u56f2\u3044\u8fbc\u307f\u6cd5 </p> <p>Parameters: </p> <ul> <li>func </li> <li>init </li> <li>beta </li> <li>max_iter </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative","title":"function derivative","text":"<pre><code>static double derivative(\n    std::function&lt; double(double)&gt; f,\n    double x,\n    double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R -&gt; R\u306e\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative_1","title":"function derivative","text":"<pre><code>static Eigen::VectorXd derivative(\n    std::function&lt; double(Eigen::VectorXd)&gt; f,\n    Eigen::VectorXd x,\n    double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R^n -&gt; R\u306e\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::VectorXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative_2","title":"function derivative","text":"<pre><code>static Eigen::MatrixXd derivative(\n    std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; f,\n    Eigen::VectorXd x,\n    double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R^n -&gt; R^m\u306e\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-second_derivative","title":"function second_derivative","text":"<pre><code>static double second_derivative(\n    std::function&lt; double(double)&gt; f,\n    double x,\n    double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R -&gt; R\u306e2\u56de\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-second_derivative_1","title":"function second_derivative","text":"<pre><code>static Eigen::MatrixXd second_derivative(\n    std::function&lt; double(Eigen::VectorXd)&gt; f,\n    Eigen::VectorXd x,\n    double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R^n -&gt; R\u306e2\u56de\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-mixed_derivative","title":"function mixed_derivative","text":"<pre><code>static Eigen::MatrixXd mixed_derivative(\n    std::function&lt; double(Eigen::VectorXd, Eigen::VectorXd)&gt; f,\n    Eigen::VectorXd x,\n    Eigen::VectorXd y,\n    double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R^(n, m) -&gt; R\u306en,m\u3067\u306e\u504f\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_hessian","title":"function approx_hessian","text":"<pre><code>static Eigen::MatrixXd approx_hessian(\n    std::function&lt; double(Eigen::VectorXd)&gt; f,\n    Eigen::VectorXd x,\n    double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-golden_search","title":"function golden_search","text":"<pre><code>static double golden_search(\n    std::function&lt; double(double)&gt; f,\n    double low,\n    double high,\n    const double tol =1e-6,\n    const size_t max_iter =100\n)\n</code></pre> <p>\u9ec4\u91d1\u63a2\u7d22 </p> <p>Parameters: </p> <ul> <li>f </li> <li>low </li> <li>high </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-leastsq","title":"function leastsq","text":"<pre><code>Eigen::VectorXd leastsq(\n    const Eigen::MatrixXd &amp; A,\n    const Eigen::VectorXd &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsi2qp","title":"function lsi2qp","text":"<pre><code>std::tuple&lt; Eigen::MatrixXd, Eigen::VectorXd &gt; lsi2qp(\n    const Eigen::MatrixXd &amp; C,\n    const Eigen::VectorXd &amp; d\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-newton_method","title":"function newton_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; newton_method(\n    std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad,\n    std::function&lt; Eigen::MatrixXd(const Eigen::VectorXd &amp;)&gt; hesse,\n    Eigen::VectorXd x_init,\n    const double tol =1e-6,\n    const size_t max_iter =1000\n)\n</code></pre> <p>\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 </p> <p>Parameters: </p> <ul> <li>grad </li> <li>hesse </li> <li>x_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-penalty_method","title":"function penalty_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; penalty_method(\n    std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\n    ConstraintArray constraint,\n    Eigen::VectorXd x_init,\n    const double r_init =1.0,\n    const double tol =1e-3,\n    const size_t max_iter =1000\n)\n</code></pre> <p>\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 </p> <p>Parameters: </p> <ul> <li>f </li> <li>constraint </li> <li>x_init </li> <li>r_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-quasi_newton_method","title":"function quasi_newton_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; quasi_newton_method(\n    std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\n    std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad,\n    Eigen::VectorXd x_init,\n    const double tol =1e-6,\n    const size_t max_iter =1000\n)\n</code></pre> <p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 </p> <p>Parameters: </p> <ul> <li>f </li> <li>grad </li> <li>x_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-steepest_descent_method","title":"function steepest_descent_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; steepest_descent_method(\n    std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\n    std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad,\n    Eigen::VectorXd x_init,\n    const double tol =1e-6,\n    const size_t max_iter =1000\n)\n</code></pre> <p>\u6700\u6025\u964d\u4e0b\u6cd5 </p> <p>Parameters: </p> <ul> <li>f </li> <li>grad </li> <li>x_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-a_star","title":"function a_star","text":"<pre><code>static std::vector&lt; Eigen::Vector2i &gt; a_star(\n    const Eigen::Vector2i &amp; start,\n    const Eigen::Vector2i &amp; end,\n    const Eigen::MatrixXi &amp; map\n)\n</code></pre> <p>A*\u6cd5 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>map </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_position","title":"function normalized_mjm_position","text":"<pre><code>static double normalized_mjm_position(\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_velocity","title":"function normalized_mjm_velocity","text":"<pre><code>static double normalized_mjm_velocity(\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_acceleration","title":"function normalized_mjm_acceleration","text":"<pre><code>static double normalized_mjm_acceleration(\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_jerk","title":"function normalized_mjm_jerk","text":"<pre><code>static double normalized_mjm_jerk(\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-wave_propagation","title":"function wave_propagation","text":"<pre><code>std::vector&lt; Eigen::Vector2i &gt; wave_propagation(\n    const Eigen::Vector2i &amp; start,\n    const Eigen::Vector2i &amp; end,\n    const Eigen::MatrixXi &amp; map\n)\n</code></pre> <p>Wave propagation\u6cd5 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>map </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bode","title":"function bode","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; bode(\n    TransferFunction &amp; tf,\n    const std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500),\n    bool gain_db_mode =true,\n    bool phase_deg_mode =true\n)\n</code></pre> <p>\u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>tf </li> <li>omegas </li> <li>gain_db_mode </li> <li>phase_deg_mode </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-integrate_forward_euler","title":"function integrate_forward_euler","text":"<pre><code>template &lt;class T &gt;\nstatic T integrate_forward_euler(\n    double dt,\n    const T &amp; x,\n    const T &amp; u,\n    std::function&lt; T(const T &amp;, const T &amp;)&gt; dynamics\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-integrate_modified_euler","title":"function integrate_modified_euler","text":"<pre><code>template &lt;class T &gt;\nstatic T integrate_modified_euler(\n    double dt,\n    const T &amp; x,\n    const T &amp; u,\n    std::function&lt; T(const T &amp;, const T &amp;)&gt; dynamics\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-integrate_rk4","title":"function integrate_rk4","text":"<pre><code>template &lt;class T &gt;\nstatic T integrate_rk4(\n    double dt,\n    const T &amp; x,\n    const T &amp; u,\n    std::function&lt; T(const T &amp;, const T &amp;)&gt; dynamics\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-nyquist","title":"function nyquist","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; nyquist(\n    TransferFunction &amp; tf,\n    const std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500)\n)\n</code></pre> <p>\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>tf </li> <li>omegas </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\n    std::ostream &amp; os,\n    const Polynomial &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_feedback_system","title":"function make_feedback_system","text":"<pre><code>template &lt;class CONTROLLER_T ,\nclass SYSTEM_T &gt;\nstatic SisoFeedbackSystem make_feedback_system(\n    CONTROLLER_T &amp; controller,\n    SYSTEM_T &amp; system\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_controller","title":"function set_controller","text":"<pre><code>static void set_controller(\n    SisoFeedbackSystem::func_list_t &amp; fn,\n    PID &amp; controller\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_controller_1","title":"function set_controller","text":"<pre><code>static void set_controller(\n    SisoFeedbackSystem::func_list_t &amp; fn,\n    NctfController &amp; controller\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_system","title":"function set_system","text":"<pre><code>static void set_system(\n    SisoFeedbackSystem::func_list_t &amp; fn,\n    TransferFunction &amp; system\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-tf2ss","title":"function tf2ss","text":"<pre><code>StateSpaceSystem tf2ss(\n    const TransferFunction &amp; tf\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-impulse","title":"function impulse","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(\n    const std::function&lt; double(double)&gt; &amp; sys,\n    double dt,\n    double time\n)\n</code></pre> <p>\u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b </p> <p>Parameters: </p> <ul> <li>sys </li> <li>dt </li> <li>time </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-impulse_1","title":"function impulse","text":"<pre><code>template &lt;class SysType ,\ntypename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(\n    SysType &amp; sys,\n    double time\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step","title":"function step","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(\n    const std::function&lt; double(double)&gt; &amp; sys,\n    double dt,\n    double time,\n    const double gain =1.0\n)\n</code></pre> <p>\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b </p> <p>Parameters: </p> <ul> <li>sys </li> <li>dt </li> <li>time </li> <li>gain </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step_1","title":"function step","text":"<pre><code>template &lt;class SysType ,\ntypename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(\n    SysType &amp; sys,\n    double time,\n    const double gain =1.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step_2","title":"function step","text":"<pre><code>template &lt;class FilterType ,\ntypename std::enable_if&lt; internal::is_pure_filter_class&lt; FilterType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(\n    FilterType &amp; filter,\n    double time,\n    const double gain =1.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim","title":"function lsim","text":"<pre><code>template &lt;class DataIterativeType &gt;\nstatic std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim(\n    const std::function&lt; double(double)&gt; &amp; sys,\n    double dt,\n    const DataIterativeType &amp; input\n)\n</code></pre> <p>\u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b </p> <p>Parameters: </p> <ul> <li>sys </li> <li>dt </li> <li>input </li> </ul> <p>Template Parameters: </p> <ul> <li>DataIterativeType </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_1","title":"function lsim","text":"<pre><code>template &lt;class DataIterativeType ,\nclass SysType ,\ntypename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim(\n    SysType sys,\n    const DataIterativeType &amp; input,\n    bool skip_reset =false\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_2","title":"function lsim","text":"<pre><code>template &lt;class DataIterativeType &gt;\nstatic std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim(\n    TransferFunction::tf_t sys_config,\n    const DataIterativeType &amp; input\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_3","title":"function lsim","text":"<pre><code>template &lt;class DataIterativeType &gt;\nstatic std::tuple&lt; DataIterativeType, DataIterativeType, DataIterativeType &gt; lsim(\n    SisoFeedbackSystem sys,\n    const DataIterativeType &amp; input,\n    bool skip_reset =false\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_y","title":"function lsim_y","text":"<pre><code>template &lt;class DataIterativeType &gt;\nstatic DataIterativeType lsim_y(\n    const std::function&lt; double(double)&gt; &amp; sys,\n    double dt,\n    const DataIterativeType &amp; input\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_y_1","title":"function lsim_y","text":"<pre><code>template &lt;class DataIterativeType ,\nclass SysType ,\ntypename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt;\nstatic DataIterativeType lsim_y(\n    SysType sys,\n    const DataIterativeType &amp; input,\n    bool skip_reset =false\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_y_2","title":"function lsim_y","text":"<pre><code>template &lt;class DataIterativeType &gt;\nstatic DataIterativeType lsim_y(\n    TransferFunction::tf_t sys_config,\n    const DataIterativeType &amp; input\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_uy","title":"function lsim_uy","text":"<pre><code>template &lt;class DataIterativeType &gt;\nstatic std::tuple&lt; DataIterativeType, DataIterativeType &gt; lsim_uy(\n    SisoFeedbackSystem sys,\n    const DataIterativeType &amp; input,\n    bool skip_reset =false\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_y_3","title":"function lsim_y","text":"<pre><code>template &lt;class DataIterativeType &gt;\nstatic DataIterativeType lsim_y(\n    SisoFeedbackSystem sys,\n    const DataIterativeType &amp; input,\n    bool skip_reset =false\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-conv_factor","title":"function conv_factor","text":"<pre><code>template &lt;class UnitDimType ,\nint FromTag,\nint ToTag,\nbool IsNormalTag =tag::is_normal_tag&lt;FromTag&gt;::value &amp;&amp; tag::is_normal_tag&lt;ToTag&gt;::value&gt;\nconstexpr double conv_factor()\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_5","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\n    const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\n    const T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_6","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\n    const T1 &amp; l_value,\n    const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_7","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\n    const T1 &amp; l_value,\n    const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_8","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\n    const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\n    const T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_9","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator*(\n    const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\n    const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_10","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator/(\n    const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\n    const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_11","title":"function operator+","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator+(\n    const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\n    const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator-","title":"function operator-","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator-(\n    const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\n    const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shift_left","title":"function shift_left","text":"<pre><code>template &lt;class ForwardIterator &gt;\nconstexpr ForwardIterator shift_left(\n    ForwardIterator first,\n    ForwardIterator last,\n    typename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n\n)\n</code></pre> <p>Substitute shift_left function in C++20 alogorithm. </p> <p>Parameters: </p> <ul> <li>first </li> <li>last </li> <li>n </li> </ul> <p>Template Parameters: </p> <ul> <li>ForwardIterator </li> </ul> <p>Return: constexpr ForwardIterator </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shift_right","title":"function shift_right","text":"<pre><code>template &lt;class ForwardIterator &gt;\nconstexpr ForwardIterator shift_right(\n    ForwardIterator first,\n    ForwardIterator last,\n    typename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n\n)\n</code></pre> <p>Substitute shift_right function in C++20 alogorithm. </p> <p>Parameters: </p> <ul> <li>first </li> <li>last </li> <li>n </li> </ul> <p>Template Parameters: </p> <ul> <li>ForwardIterator </li> </ul> <p>Return: constexpr ForwardIterator </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-c_format","title":"function c_format","text":"<pre><code>template &lt;typename... Args&gt;\nstd::string c_format(\n    const std::string &amp; format,\n    Args const &amp;... args\n)\n</code></pre> <p>printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b </p> <p>Parameters: </p> <ul> <li>format </li> <li>args </li> </ul> <p>Template Parameters: </p> <ul> <li>Args </li> </ul> <p>Return: std::string </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-ispositivedefinite","title":"function isPositiveDefinite","text":"<pre><code>template &lt;typename MatrixType &gt;\nbool isPositiveDefinite(\n    const MatrixType &amp; matrix\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-pseudo_inverse","title":"function pseudo_inverse","text":"<pre><code>template &lt;typename MatrixType &gt;\nMatrixType pseudo_inverse(\n    const MatrixType &amp; a,\n    double epsilon =std::numeric_limits&lt; double &gt;::epsilon()\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sr_inverse","title":"function sr_inverse","text":"<pre><code>template &lt;typename MatrixType &gt;\nMatrixType sr_inverse(\n    const MatrixType &amp; a,\n    double w0 =1e-2,\n    Eigen::MatrixXd W =Eigen::MatrixXd()\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-in_range_open","title":"function in_range_open","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr bool in_range_open(\n    T x,\n    T min,\n    T max\n)\n</code></pre> <p>Parameters: </p> <ul> <li>x </li> <li>min </li> <li>max </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-in_range","title":"function in_range","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr bool in_range(\n    T x,\n    T min,\n    T max\n)\n</code></pre> <p>Parameters: </p> <ul> <li>x </li> <li>min </li> <li>max </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sgn","title":"function sgn","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr int sgn(\n    T x\n)\n</code></pre> <p>Parameters: </p> <ul> <li>x </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: constexpr int </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-radians","title":"function radians","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr double radians(\n    T deg\n)\n</code></pre> <p>Parameters: </p> <ul> <li>deg </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: constexpr double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-degrees","title":"function degrees","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr double degrees(\n    T rad\n)\n</code></pre> <p>Parameters: </p> <ul> <li>rad </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: constexpr double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalize_angle_positive","title":"function normalize_angle_positive","text":"<pre><code>static inline double normalize_angle_positive(\n    double angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalize_angle","title":"function normalize_angle","text":"<pre><code>static inline double normalize_angle(\n    double angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shortest_angular_distance","title":"function shortest_angular_distance","text":"<pre><code>static inline double shortest_angular_distance(\n    double from,\n    double to\n)\n</code></pre> <p>Parameters: </p> <ul> <li>from </li> <li>to </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-nearest_angle","title":"function nearest_angle","text":"<pre><code>static inline double nearest_angle(\n    double from,\n    double to\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-square","title":"function square","text":"<pre><code>inline constexpr double square(\n    const double x\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-cubic","title":"function cubic","text":"<pre><code>inline constexpr double cubic(\n    const double x\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr double lerp(\n    const double a,\n    const double b,\n    const double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_eq","title":"function approx_eq","text":"<pre><code>inline constexpr double approx_eq(\n    const double a,\n    const double b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_zero","title":"function approx_zero","text":"<pre><code>inline constexpr double approx_zero(\n    const double a\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-gererate_random","title":"function gererate_random","text":"<pre><code>template &lt;typename Real  =double&gt;\nstatic Real gererate_random()\n</code></pre> <p>0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Template Parameters: </p> <ul> <li>Real \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b </li> </ul> <p>Return: Real \u4e71\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-arrange","title":"function arrange","text":"<pre><code>template &lt;class DataType  =std::vector&lt;double&gt;&gt;\nstatic DataType arrange(\n    double start,\n    double end,\n    double step =1.0\n)\n</code></pre> <p>start\u304b\u3089end\u307e\u3067step\u305a\u3064\u5897\u3048\u308b\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>step </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-linspace","title":"function linspace","text":"<pre><code>template &lt;class DataType  =std::vector&lt;double&gt;&gt;\nstatic DataType linspace(\n    double start,\n    double end,\n    size_t n =100\n)\n</code></pre> <p>start\u304b\u3089end\u307e\u3067\u3092n\u5206\u5272\u3057\u305f\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>n </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-implusespace","title":"function implusespace","text":"<pre><code>template &lt;class DataType  =std::vector&lt;double&gt;&gt;\nstatic DataType implusespace(\n    double time,\n    double dt =1.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-stepspace","title":"function stepspace","text":"<pre><code>template &lt;class DataType  =std::vector&lt;double&gt;&gt;\nstatic DataType stepspace(\n    double time,\n    double dt =1.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-logspace","title":"function logspace","text":"<pre><code>template &lt;class DataType  =std::vector&lt;double&gt;&gt;\nstatic DataType logspace(\n    double start,\n    double end,\n    size_t n =100\n)\n</code></pre> <p>10^start\u304b\u308910^end\u307e\u3067\u5bfe\u6570\u7684\u306b\u7b49\u9593\u9694\u306an\u500b\u306e\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>n </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-funcspace","title":"function funcspace","text":"<pre><code>static std::vector&lt; double &gt; funcspace(\n    std::function&lt; double(size_t, size_t)&gt; f,\n    size_t n =100\n)\n</code></pre> <p>Parameters: </p> <ul> <li>f </li> <li>n </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sinspace","title":"function sinspace","text":"<pre><code>static std::vector&lt; double &gt; sinspace(\n    double a,\n    double b,\n    size_t n =100\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rz_735va_9517","title":"variable RZ_735VA_9517","text":"<pre><code>constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param(\n    18_V,\n    20400_rpm,\n    2.8_A,\n    1265_mmNm,\n    156_A,\n    7.088e-5_H,\n    2.46e-5 \n);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_775_8513","title":"variable RS_775_8513","text":"<pre><code>constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param(\n    18_V,\n    18400_rpm,\n    2.7_A,\n    1216_mmNm, \n    130_A,\n    5.872e-5_H,\n    2.46e-5 \n);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_555vc_5524","title":"variable RS_555VC_5524","text":"<pre><code>constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param(\n    12_V,\n    9100_rpm,\n    0.8_A,\n    450_mmNm, \n    36_A,\n    1.820e-4_H,\n    2.46e-5 \n);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_380ph_4045","title":"variable RS_380PH_4045","text":"<pre><code>constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param(\n    6_V,\n    12500_rpm,\n    0.56_A,\n    77.5_mmNm, \n    18_A,\n    1.521e-4_H,\n    2.46e-5 \n);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_385ph_2465","title":"variable RS_385PH_2465","text":"<pre><code>constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param(\n    18_V,\n    17500_rpm,\n    0.23_A,\n    76.9_mmNm, \n    7.91_A,\n    1.521e-4_H,\n    2.46e-5 \n);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-re_65_250_18","title":"variable RE_65_250_18","text":"<pre><code>constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param(\n    18_V,\n    3520_rpm,\n    755_mA,\n    0.0609_ohm,\n    0.0226_mH,\n    46e-3_Nm_per_A,\n    1.38\n);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_4","title":"variable IG42C_4","text":"<pre><code>constexpr GearHeadParam IG42C_4 = { 1/4.0f, 0.8f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_14","title":"variable IG42C_14","text":"<pre><code>constexpr GearHeadParam IG42C_14 = { 1/14.0f, 0.7f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_17","title":"variable IG42C_17","text":"<pre><code>constexpr GearHeadParam IG42C_17 = { 1/17.0f, 0.7f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_27","title":"variable IG32_27","text":"<pre><code>constexpr GearHeadParam IG32_27 = { 1/27.0f, 0.7f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_71","title":"variable IG32_71","text":"<pre><code>constexpr GearHeadParam IG32_71 = { 1/71.0f, 0.6f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_100","title":"variable IG32_100","text":"<pre><code>constexpr GearHeadParam IG32_100 = { 1/100.0f, 0.6f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-pi","title":"variable PI","text":"<pre><code>constexpr double PI = 3.1415926535897932384626433832795;\n</code></pre> <p>\u5186\u5468\u7387 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-half_pi","title":"variable HALF_PI","text":"<pre><code>constexpr double HALF_PI = PI / 2.0;\n</code></pre> <p>\u5186\u5468\u7387 / 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-two_pi","title":"variable TWO_PI","text":"<pre><code>constexpr double TWO_PI = PI * 2.0;\n</code></pre> <p>\u5186\u5468\u7387 * 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-deg_to_rad","title":"variable DEG_TO_RAD","text":"<pre><code>constexpr double DEG_TO_RAD = PI / 180.0;\n</code></pre> <p>degree -&gt; radians </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rad_to_deg","title":"variable RAD_TO_DEG","text":"<pre><code>constexpr double RAD_TO_DEG = 180.0 / PI;\n</code></pre> <p>radian -&gt; degree </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-euler","title":"variable EULER","text":"<pre><code>constexpr double EULER = 2.718281828459045235360287471352;\n</code></pre> <p>\u30cd\u30a4\u30d4\u30a2\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gravity","title":"variable GRAVITY","text":"<pre><code>constexpr double GRAVITY = 9.807;\n</code></pre> <p>\u91cd\u529b </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-nm2gfm","title":"variable Nm2gfm","text":"<pre><code>constexpr double Nm2gfm = (1/GRAVITY);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gfm2nm","title":"variable gfm2Nm","text":"<pre><code>constexpr double gfm2Nm = GRAVITY;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-mnm2gfcm","title":"variable mNm2gfcm","text":"<pre><code>constexpr double mNm2gfcm = (Nm2gfm * 100);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gfcm2mnm","title":"variable gfcm2mNm","text":"<pre><code>constexpr double gfcm2mNm = (gfm2Nm / 100);\n</code></pre> <p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/","title":"cpp_robotics::constants","text":"<p>\u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#attributes","title":"Attributes","text":"Name constexpr double PI \u5186\u5468\u7387 constexpr double HALF_PI \u5186\u5468\u7387 / 2 constexpr double TWO_PI \u5186\u5468\u7387 * 2 constexpr double DEG_TO_RAD degree -&gt; radians constexpr double RAD_TO_DEG radian -&gt; degree constexpr double EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr double GRAVITY \u91cd\u529b constexpr double Nm2gfm constexpr double gfm2Nm constexpr double mNm2gfcm constexpr double gfcm2mNm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-pi","title":"variable PI","text":"<pre><code>constexpr double PI = 3.1415926535897932384626433832795;\n</code></pre> <p>\u5186\u5468\u7387 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-half_pi","title":"variable HALF_PI","text":"<pre><code>constexpr double HALF_PI = PI / 2.0;\n</code></pre> <p>\u5186\u5468\u7387 / 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-two_pi","title":"variable TWO_PI","text":"<pre><code>constexpr double TWO_PI = PI * 2.0;\n</code></pre> <p>\u5186\u5468\u7387 * 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-deg_to_rad","title":"variable DEG_TO_RAD","text":"<pre><code>constexpr double DEG_TO_RAD = PI / 180.0;\n</code></pre> <p>degree -&gt; radians </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-rad_to_deg","title":"variable RAD_TO_DEG","text":"<pre><code>constexpr double RAD_TO_DEG = 180.0 / PI;\n</code></pre> <p>radian -&gt; degree </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-euler","title":"variable EULER","text":"<pre><code>constexpr double EULER = 2.718281828459045235360287471352;\n</code></pre> <p>\u30cd\u30a4\u30d4\u30a2\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gravity","title":"variable GRAVITY","text":"<pre><code>constexpr double GRAVITY = 9.807;\n</code></pre> <p>\u91cd\u529b </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-nm2gfm","title":"variable Nm2gfm","text":"<pre><code>constexpr double Nm2gfm = (1/GRAVITY);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gfm2nm","title":"variable gfm2Nm","text":"<pre><code>constexpr double gfm2Nm = GRAVITY;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-mnm2gfcm","title":"variable mNm2gfcm","text":"<pre><code>constexpr double mNm2gfcm = (Nm2gfm * 100);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gfcm2mnm","title":"variable gfcm2mNm","text":"<pre><code>constexpr double gfcm2mNm = (gfm2Nm / 100);\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/","title":"cpp_robotics::grid_path_planning_utils","text":"<p>\u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#classes","title":"Classes","text":"Name struct cpp_robotics::grid_path_planning_utils::GridNode"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#functions","title":"Functions","text":"Name bool contain_in_map(const Eigen::MatrixXi &amp; map, const Eigen::Vector2i &amp; p) int dist(const Eigen::Vector2i &amp; pos, const Eigen::Vector2i &amp; end) template &lt;typename T &gt; bool in_range_open(T x, T min, T max) bool is_valid(const Eigen::Vector2i &amp; pos, size_t row, size_t col) bool is_wall(const Eigen::Vector2i &amp; pos, size_t row, size_t col) bool is_correct_step(const Eigen::Vector2i &amp; pos, const Eigen::MatrixXi &amp; map) bool exist(std::list&lt; GridNode &gt; &amp; open, std::list&lt; GridNode &gt; &amp; closed, const Eigen::Vector2i &amp; p, int cost)"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-contain_in_map","title":"function contain_in_map","text":"<pre><code>static bool contain_in_map(\n    const Eigen::MatrixXi &amp; map,\n    const Eigen::Vector2i &amp; p\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-dist","title":"function dist","text":"<pre><code>static int dist(\n    const Eigen::Vector2i &amp; pos,\n    const Eigen::Vector2i &amp; end\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-in_range_open","title":"function in_range_open","text":"<pre><code>template &lt;typename T &gt;\nbool in_range_open(\n    T x,\n    T min,\n    T max\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_valid","title":"function is_valid","text":"<pre><code>bool is_valid(\n    const Eigen::Vector2i &amp; pos,\n    size_t row,\n    size_t col\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_wall","title":"function is_wall","text":"<pre><code>bool is_wall(\n    const Eigen::Vector2i &amp; pos,\n    size_t row,\n    size_t col\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_correct_step","title":"function is_correct_step","text":"<pre><code>bool is_correct_step(\n    const Eigen::Vector2i &amp; pos,\n    const Eigen::MatrixXi &amp; map\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-exist","title":"function exist","text":"<pre><code>bool exist(\n    std::list&lt; GridNode &gt; &amp; open,\n    std::list&lt; GridNode &gt; &amp; closed,\n    const Eigen::Vector2i &amp; p,\n    int cost\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1internal/","title":"cpp_robotics::internal","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1internal/#classes","title":"Classes","text":"Name struct cpp_robotics::internal::has_forward_kinematics struct cpp_robotics::internal::has_inverse_kinematics struct cpp_robotics::internal::has_forward_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().forward_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt; struct cpp_robotics::internal::has_inverse_kinematics&lt; T, std::void_t&lt; decltype(std::declval&lt; T &gt;().inverse_kinematics(std::declval&lt; Eigen::VectorXd &gt;(), std::declval&lt; Eigen::VectorXd &amp; &gt;()))&gt; &gt; struct cpp_robotics::internal::has_ad_dynamics struct cpp_robotics::internal::has_ad_dynamics&lt; DerClass, Scalar, std::void_t&lt; decltype(std::declval&lt; const DerClass &gt;().dynamics(std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;(), std::declval&lt; Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp; &gt;()))&gt;&gt; <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/","title":"cpp_robotics::spline","text":"<p>\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#classes","title":"Classes","text":"Name struct cpp_robotics::spline::spline_c"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#functions","title":"Functions","text":"Name spline_c bezier_spline(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2, const Vector2d &amp; p3) spline_c hermite_spline(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; v0, const Vector2d &amp; v1) spline_c catumull_spline(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2, const Vector2d &amp; p3) spline_c cubic_function_to_bezier(const Vector2d &amp; a, const Vector2d &amp; b, const Vector2d &amp; c, const Vector2d &amp; d) Vector4d bezier_weight(const double t) Vector4d bezier_weight(const Vector4d t) Vector2d evaluate(const spline_c &amp; spline, const Vector4d &amp; w) Vector2d position(const spline_c &amp; spline, double t) Vector2d velocity(const spline_c &amp; spline, double t) Vector2d acceleration(const spline_c &amp; spline, double t) void split(const Vector4d &amp; spline, Vector4d &amp; spline0, Vector4d &amp; spline1, double t) void split(const Vector4d &amp; spline, Vector4d &amp; spline0, Vector4d &amp; spline1) void split(const spline_c &amp; spline, spline_c &amp; spline0, spline_c &amp; spline1) void split(const spline_c &amp; spline, spline_c &amp; spline0, spline_c &amp; spline1, double t) double length_estimate(const spline_c &amp; s, double * error) double length(const spline_c &amp; s, double maxError) double length(const spline_c &amp; s, double t0, double t1, double maxError) double curvature(const spline_c &amp; spline, double t)"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_spline","title":"function bezier_spline","text":"<pre><code>spline_c bezier_spline(\n    const Vector2d &amp; p0,\n    const Vector2d &amp; p1,\n    const Vector2d &amp; p2,\n    const Vector2d &amp; p3\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-hermite_spline","title":"function hermite_spline","text":"<pre><code>spline_c hermite_spline(\n    const Vector2d &amp; p0,\n    const Vector2d &amp; p1,\n    const Vector2d &amp; v0,\n    const Vector2d &amp; v1\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-catumull_spline","title":"function catumull_spline","text":"<pre><code>spline_c catumull_spline(\n    const Vector2d &amp; p0,\n    const Vector2d &amp; p1,\n    const Vector2d &amp; p2,\n    const Vector2d &amp; p3\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-cubic_function_to_bezier","title":"function cubic_function_to_bezier","text":"<pre><code>spline_c cubic_function_to_bezier(\n    const Vector2d &amp; a,\n    const Vector2d &amp; b,\n    const Vector2d &amp; c,\n    const Vector2d &amp; d\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_weight","title":"function bezier_weight","text":"<pre><code>Vector4d bezier_weight(\n    const double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_weight_1","title":"function bezier_weight","text":"<pre><code>Vector4d bezier_weight(\n    const Vector4d t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-evaluate","title":"function evaluate","text":"<pre><code>inline Vector2d evaluate(\n    const spline_c &amp; spline,\n    const Vector4d &amp; w\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-position","title":"function position","text":"<pre><code>Vector2d position(\n    const spline_c &amp; spline,\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-velocity","title":"function velocity","text":"<pre><code>Vector2d velocity(\n    const spline_c &amp; spline,\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-acceleration","title":"function acceleration","text":"<pre><code>Vector2d acceleration(\n    const spline_c &amp; spline,\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split","title":"function split","text":"<pre><code>inline void split(\n    const Vector4d &amp; spline,\n    Vector4d &amp; spline0,\n    Vector4d &amp; spline1,\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_1","title":"function split","text":"<pre><code>inline void split(\n    const Vector4d &amp; spline,\n    Vector4d &amp; spline0,\n    Vector4d &amp; spline1\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_2","title":"function split","text":"<pre><code>void split(\n    const spline_c &amp; spline,\n    spline_c &amp; spline0,\n    spline_c &amp; spline1\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_3","title":"function split","text":"<pre><code>void split(\n    const spline_c &amp; spline,\n    spline_c &amp; spline0,\n    spline_c &amp; spline1,\n    double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length_estimate","title":"function length_estimate","text":"<pre><code>double length_estimate(\n    const spline_c &amp; s,\n    double * error\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length","title":"function length","text":"<pre><code>double length(\n    const spline_c &amp; s,\n    double maxError\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length_1","title":"function length","text":"<pre><code>double length(\n    const spline_c &amp; s,\n    double t0,\n    double t1,\n    double maxError\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-curvature","title":"function curvature","text":"<pre><code>double curvature(\n    const spline_c &amp; spline,\n    double t\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/","title":"cpp_robotics::unit","text":"<p>\u5358\u4f4d\u7cfb </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#namespaces","title":"Namespaces","text":"Name cpp_robotics::unit::prefix cpp_robotics::unit::tag cpp_robotics::unit_dimention"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#classes","title":"Classes","text":"Name struct cpp_robotics::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#types","title":"Types","text":"Name enum UnitIndex using unit_assem::unit_div&lt; Torque, Ampere &gt;::unit TorqueConstant using unit_assem::unit_div&lt; Volt, AngularVelocity &gt;::unit BackEmfConstant using unit_assem::unit_mul&lt; Torque, Second &gt;::unit FrictionConstant using Unit&lt; double, unit_dimention::second, prefix::none &gt; Second using Unit&lt; double, unit_dimention::second, prefix::milli &gt; MilliSecond using Unit&lt; double, unit_dimention::second, prefix::micro &gt; MicroSecond using Unit&lt; double, unit_dimention::metere, prefix::none &gt; Meter using Unit&lt; double, unit_dimention::metere, prefix::milli &gt; MilliMeter using Unit&lt; double, unit_dimention::metere, prefix::micro &gt; MicroMeter using Unit&lt; double, unit_dimention::metere, prefix::centi &gt; CentiMeter using Unit&lt; double, unit_dimention::kilogram, prefix::none &gt; KiloGram using Unit&lt; double, unit_dimention::kilogram, prefix::milli &gt; Gram using Unit&lt; double, unit_dimention::watt, prefix::none &gt; Watt using Unit&lt; double, unit_dimention::watt, prefix::kilo &gt; KiloWatt using Unit&lt; double, unit_dimention::newton, prefix::none &gt; Newton using Unit&lt; double, unit_dimention::newton, prefix::kilo &gt; KiloNewton using Unit&lt; double, unit_dimention::pascal, prefix::none &gt; Pascal using Unit&lt; double, unit_dimention::pascal, prefix::kilo &gt; KiloPascal using Unit&lt; double, unit_dimention::hertz, prefix::none &gt; Hertz using Unit&lt; double, unit_dimention::area, prefix::none &gt; Area using Unit&lt; double, unit_dimention::volume, prefix::none &gt; Volume using Unit&lt; double, unit_dimention::velocity, prefix::none &gt; Velocity using Unit&lt; double, unit_dimention::acceleration, prefix::none &gt; Acceleration using Unit&lt; double, unit_dimention::dencity, prefix::none &gt; Dencity using Unit&lt; double, unit_dimention::torque, prefix::none &gt; Torque using Unit&lt; double, unit_dimention::inertia, prefix::none &gt; Inertia using Unit&lt; double, unit_dimention::ampere, prefix::none &gt; Ampere using Unit&lt; double, unit_dimention::ampere, prefix::milli &gt; MilliAmpere using Unit&lt; double, unit_dimention::volt, prefix::none &gt; Volt using Unit&lt; double, unit_dimention::volt, prefix::milli &gt; MilliVolt using Unit&lt; double, unit_dimention::ohm, prefix::none &gt; Ohm using Unit&lt; double, unit_dimention::ohm, prefix::milli &gt; MilliOhm using Unit&lt; double, unit_dimention::henry, prefix::none &gt; Henry using Unit&lt; double, unit_dimention::henry, prefix::milli &gt; MilliHenry using Unit&lt; double, unit_dimention::farad, prefix::none &gt; Farad using Unit&lt; double, unit_dimention::farad, prefix::milli &gt; MilliFarad using Unit&lt; double, unit_dimention::farad, prefix::micro &gt; MicroFarad using Unit&lt; double, unit_dimention::farad, prefix::nano &gt; NanoFarad using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::radian &gt; Radian using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::degree &gt; Degree using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec &gt; AngularVelocity using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps &gt; Rps using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm &gt; Rpm using Unit&lt; double, unit_dimention::angular_acceleration, prefix::none &gt; AngularAcceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#functions","title":"Functions","text":"Name template &lt;class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag::value &amp;&amp; tag::is_normal_tag::value&gt; constexpr double conv_factor() template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator+(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator-(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl)"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#enum-unitindex","title":"enum UnitIndex","text":"Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-torqueconstant","title":"using TorqueConstant","text":"<pre><code>using cpp_robotics::unit::TorqueConstant = typedef unit_assem::unit_div&lt;Torque, Ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-backemfconstant","title":"using BackEmfConstant","text":"<pre><code>using cpp_robotics::unit::BackEmfConstant = typedef unit_assem::unit_div&lt;Volt, AngularVelocity&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-frictionconstant","title":"using FrictionConstant","text":"<pre><code>using cpp_robotics::unit::FrictionConstant = typedef unit_assem::unit_mul&lt;Torque, Second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-second","title":"using Second","text":"<pre><code>using cpp_robotics::unit::Second = typedef Unit&lt;double, unit_dimention::second, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millisecond","title":"using MilliSecond","text":"<pre><code>using cpp_robotics::unit::MilliSecond = typedef Unit&lt;double, unit_dimention::second, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-microsecond","title":"using MicroSecond","text":"<pre><code>using cpp_robotics::unit::MicroSecond = typedef Unit&lt;double, unit_dimention::second, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-meter","title":"using Meter","text":"<pre><code>using cpp_robotics::unit::Meter = typedef Unit&lt;double, unit_dimention::metere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millimeter","title":"using MilliMeter","text":"<pre><code>using cpp_robotics::unit::MilliMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-micrometer","title":"using MicroMeter","text":"<pre><code>using cpp_robotics::unit::MicroMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-centimeter","title":"using CentiMeter","text":"<pre><code>using cpp_robotics::unit::CentiMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::centi&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilogram","title":"using KiloGram","text":"<pre><code>using cpp_robotics::unit::KiloGram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-gram","title":"using Gram","text":"<pre><code>using cpp_robotics::unit::Gram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-watt","title":"using Watt","text":"<pre><code>using cpp_robotics::unit::Watt = typedef Unit&lt;double, unit_dimention::watt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilowatt","title":"using KiloWatt","text":"<pre><code>using cpp_robotics::unit::KiloWatt = typedef Unit&lt;double, unit_dimention::watt, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-newton","title":"using Newton","text":"<pre><code>using cpp_robotics::unit::Newton = typedef Unit&lt;double, unit_dimention::newton, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilonewton","title":"using KiloNewton","text":"<pre><code>using cpp_robotics::unit::KiloNewton = typedef Unit&lt;double, unit_dimention::newton, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-pascal","title":"using Pascal","text":"<pre><code>using cpp_robotics::unit::Pascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilopascal","title":"using KiloPascal","text":"<pre><code>using cpp_robotics::unit::KiloPascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-hertz","title":"using Hertz","text":"<pre><code>using cpp_robotics::unit::Hertz = typedef Unit&lt;double, unit_dimention::hertz, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-area","title":"using Area","text":"<pre><code>using cpp_robotics::unit::Area = typedef Unit&lt;double, unit_dimention::area, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-volume","title":"using Volume","text":"<pre><code>using cpp_robotics::unit::Volume = typedef Unit&lt;double, unit_dimention::volume, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-velocity","title":"using Velocity","text":"<pre><code>using cpp_robotics::unit::Velocity = typedef Unit&lt;double, unit_dimention::velocity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-acceleration","title":"using Acceleration","text":"<pre><code>using cpp_robotics::unit::Acceleration = typedef Unit&lt;double, unit_dimention::acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-dencity","title":"using Dencity","text":"<pre><code>using cpp_robotics::unit::Dencity = typedef Unit&lt;double, unit_dimention::dencity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-torque","title":"using Torque","text":"<pre><code>using cpp_robotics::unit::Torque = typedef Unit&lt;double, unit_dimention::torque, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-inertia","title":"using Inertia","text":"<pre><code>using cpp_robotics::unit::Inertia = typedef Unit&lt;double, unit_dimention::inertia, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-ampere","title":"using Ampere","text":"<pre><code>using cpp_robotics::unit::Ampere = typedef Unit&lt;double, unit_dimention::ampere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-milliampere","title":"using MilliAmpere","text":"<pre><code>using cpp_robotics::unit::MilliAmpere = typedef Unit&lt;double, unit_dimention::ampere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-volt","title":"using Volt","text":"<pre><code>using cpp_robotics::unit::Volt = typedef Unit&lt;double, unit_dimention::volt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millivolt","title":"using MilliVolt","text":"<pre><code>using cpp_robotics::unit::MilliVolt = typedef Unit&lt;double, unit_dimention::volt, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-ohm","title":"using Ohm","text":"<pre><code>using cpp_robotics::unit::Ohm = typedef Unit&lt;double, unit_dimention::ohm, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-milliohm","title":"using MilliOhm","text":"<pre><code>using cpp_robotics::unit::MilliOhm = typedef Unit&lt;double, unit_dimention::ohm, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-henry","title":"using Henry","text":"<pre><code>using cpp_robotics::unit::Henry = typedef Unit&lt;double, unit_dimention::henry, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millihenry","title":"using MilliHenry","text":"<pre><code>using cpp_robotics::unit::MilliHenry = typedef Unit&lt;double, unit_dimention::henry, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-farad","title":"using Farad","text":"<pre><code>using cpp_robotics::unit::Farad = typedef Unit&lt;double, unit_dimention::farad, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millifarad","title":"using MilliFarad","text":"<pre><code>using cpp_robotics::unit::MilliFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-microfarad","title":"using MicroFarad","text":"<pre><code>using cpp_robotics::unit::MicroFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-nanofarad","title":"using NanoFarad","text":"<pre><code>using cpp_robotics::unit::NanoFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::nano&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-radian","title":"using Radian","text":"<pre><code>using cpp_robotics::unit::Radian = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::radian&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-degree","title":"using Degree","text":"<pre><code>using cpp_robotics::unit::Degree = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::degree&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-angularvelocity","title":"using AngularVelocity","text":"<pre><code>using cpp_robotics::unit::AngularVelocity = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-rps","title":"using Rps","text":"<pre><code>using cpp_robotics::unit::Rps = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-rpm","title":"using Rpm","text":"<pre><code>using cpp_robotics::unit::Rpm = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-angularacceleration","title":"using AngularAcceleration","text":"<pre><code>using cpp_robotics::unit::AngularAcceleration = typedef Unit&lt;double, unit_dimention::angular_acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-conv_factor","title":"function conv_factor","text":"<pre><code>template &lt;class UnitDimType ,\nint FromTag,\nint ToTag,\nbool IsNormalTag =tag::is_normal_tag&lt;FromTag&gt;::value &amp;&amp; tag::is_normal_tag&lt;ToTag&gt;::value&gt;\nconstexpr double conv_factor()\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\n    const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\n    const T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_1","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\n    const T1 &amp; l_value,\n    const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_2","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\n    const T1 &amp; l_value,\n    const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_3","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\n    const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\n    const T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_4","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator*(\n    const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\n    const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_5","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator/(\n    const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\n    const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_6","title":"function operator+","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator+(\n    const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\n    const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator-","title":"function operator-","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator-(\n    const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\n    const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/","title":"cpp_robotics::unit::prefix","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#classes","title":"Classes","text":"Name struct cpp_robotics::unit::prefix::pfx_mul struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#types","title":"Types","text":"Name using Prefix&lt; 1, 1000000000 &gt; nano using Prefix&lt; 1, 1000000 &gt; micro using Prefix&lt; 1, 1000 &gt; milli using Prefix&lt; 1, 100 &gt; centi using Prefix&lt; 1, 10 &gt; deci using Prefix&lt; 1, 1 &gt; none using Prefix&lt; 10, 1 &gt; deca using Prefix&lt; 100, 1 &gt; hecto using Prefix&lt; 1000, 1 &gt; kilo using Prefix&lt; 1000000, 1 &gt; mega using Prefix&lt; 1000000000, 1 &gt; giga"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-nano","title":"using nano","text":"<pre><code>using cpp_robotics::unit::prefix::nano = typedef Prefix&lt;1, 1000000000&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-micro","title":"using micro","text":"<pre><code>using cpp_robotics::unit::prefix::micro = typedef Prefix&lt;1, 1000000&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-milli","title":"using milli","text":"<pre><code>using cpp_robotics::unit::prefix::milli = typedef Prefix&lt;1, 1000&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-centi","title":"using centi","text":"<pre><code>using cpp_robotics::unit::prefix::centi = typedef Prefix&lt;1, 100&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-deci","title":"using deci","text":"<pre><code>using cpp_robotics::unit::prefix::deci = typedef Prefix&lt;1, 10&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-none","title":"using none","text":"<pre><code>using cpp_robotics::unit::prefix::none = typedef Prefix&lt;1, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-deca","title":"using deca","text":"<pre><code>using cpp_robotics::unit::prefix::deca = typedef Prefix&lt; 10, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-hecto","title":"using hecto","text":"<pre><code>using cpp_robotics::unit::prefix::hecto = typedef Prefix&lt; 100, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-kilo","title":"using kilo","text":"<pre><code>using cpp_robotics::unit::prefix::kilo = typedef Prefix&lt; 1000, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-mega","title":"using mega","text":"<pre><code>using cpp_robotics::unit::prefix::mega = typedef Prefix&lt; 1000000, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-giga","title":"using giga","text":"<pre><code>using cpp_robotics::unit::prefix::giga = typedef Prefix&lt;1000000000, 1&gt;;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/","title":"cpp_robotics::unit::tag","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#classes","title":"Classes","text":"Name struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag&lt;-1 &gt; struct cpp_robotics::unit::tag::is_normal_tag&lt; 0 &gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#types","title":"Types","text":"Name enum angle enum angular_vel"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#enum-angle","title":"enum angle","text":"Enumerator Value Description radian 0 degree"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#enum-angular_vel","title":"enum angular_vel","text":"Enumerator Value Description rad_per_sec 0 rps rpm <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/","title":"cpp_robotics::unit_dimention","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#types","title":"Types","text":"Name using UnitType&lt; 0, 0, 0, 0, 0, 0, 0 &gt; no_dimention using UnitType&lt; 1, 0, 0, 0, 0, 0, 0 &gt; metere using UnitType&lt; 0, 1, 0, 0, 0, 0, 0 &gt; kilogram using UnitType&lt; 0, 0, 1, 0, 0, 0, 0 &gt; second using UnitType&lt; 0, 0, 0, 1, 0, 0, 0 &gt; ampere using UnitType&lt; 0, 0, 0, 0, 1, 0, 0 &gt; kelvin using UnitType&lt; 0, 0, 0, 0, 0, 1, 0 &gt; mole using UnitType&lt; 0, 0, 0, 0, 0, 0, 1 &gt; candela using udim_pow&lt; metere, 2 &gt;::unit area using udim_pow&lt; metere, 3 &gt;::unit volume using udim_div&lt; metere, second &gt;::unit velocity using udim_div&lt; velocity, second &gt;::unit acceleration using udim_div&lt; kilogram, volume &gt;::unit dencity using udim_div&lt; metere, metere &gt;::unit angle using udim_inv&lt; second &gt;::unit hertz using udim_div&lt; udim_mul&lt; metere, kilogram &gt;::unit, udim_pow&lt; second, 2 &gt;::unit &gt;::unit newton using udim_div&lt; newton, area &gt;::unit pascal using udim_mul&lt; pascal, second &gt;::unit viscosity using udim_mul&lt; newton, metere &gt;::unit joule using udim_div&lt; joule, second &gt;::unit watt using udim_div&lt; watt, ampere &gt;::unit volt using udim_mul&lt; second, ampere &gt;::unit coulomb using udim_div&lt; coulomb, volt &gt;::unit farad using udim_div&lt; volt, ampere &gt;::unit ohm using udim_mul&lt; volt, second &gt;::unit weber using udim_div&lt; weber, ampere &gt;::unit henry using udim_mul&lt; newton, metere &gt;::unit torque using udim_mul&lt; kilogram, area &gt;::unit inertia using udim_div&lt; angle, second &gt;::unit angular_velocity using udim_div&lt; angular_velocity, second &gt;::unit angular_acceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-no_dimention","title":"using no_dimention","text":"<pre><code>using cpp_robotics::unit::unit_dimention::no_dimention = typedef UnitType&lt;0, 0, 0, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-metere","title":"using metere","text":"<pre><code>using cpp_robotics::unit::unit_dimention::metere = typedef UnitType&lt;1, 0, 0, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-kilogram","title":"using kilogram","text":"<pre><code>using cpp_robotics::unit::unit_dimention::kilogram = typedef UnitType&lt;0, 1, 0, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-second","title":"using second","text":"<pre><code>using cpp_robotics::unit::unit_dimention::second = typedef UnitType&lt;0, 0, 1, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-ampere","title":"using ampere","text":"<pre><code>using cpp_robotics::unit::unit_dimention::ampere = typedef UnitType&lt;0, 0, 0, 1, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-kelvin","title":"using kelvin","text":"<pre><code>using cpp_robotics::unit::unit_dimention::kelvin = typedef UnitType&lt;0, 0, 0, 0, 1, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-mole","title":"using mole","text":"<pre><code>using cpp_robotics::unit::unit_dimention::mole = typedef UnitType&lt;0, 0, 0, 0, 0, 1, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-candela","title":"using candela","text":"<pre><code>using cpp_robotics::unit::unit_dimention::candela = typedef UnitType&lt;0, 0, 0, 0, 0, 0, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-area","title":"using area","text":"<pre><code>using cpp_robotics::unit::unit_dimention::area = typedef udim_pow&lt;metere, 2&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-volume","title":"using volume","text":"<pre><code>using cpp_robotics::unit::unit_dimention::volume = typedef udim_pow&lt;metere, 3&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-velocity","title":"using velocity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::velocity = typedef udim_div&lt;metere, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-acceleration","title":"using acceleration","text":"<pre><code>using cpp_robotics::unit::unit_dimention::acceleration = typedef udim_div&lt;velocity, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-dencity","title":"using dencity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::dencity = typedef udim_div&lt;kilogram, volume&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angle","title":"using angle","text":"<pre><code>using cpp_robotics::unit::unit_dimention::angle = typedef udim_div&lt;metere, metere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-hertz","title":"using hertz","text":"<pre><code>using cpp_robotics::unit::unit_dimention::hertz = typedef udim_inv&lt;second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-newton","title":"using newton","text":"<pre><code>using cpp_robotics::unit::unit_dimention::newton = typedef udim_div&lt;udim_mul&lt;metere, kilogram&gt;::unit, udim_pow&lt;second, 2&gt;::unit&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-pascal","title":"using pascal","text":"<pre><code>using cpp_robotics::unit::unit_dimention::pascal = typedef udim_div&lt;newton, area&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-viscosity","title":"using viscosity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::viscosity = typedef udim_mul&lt;pascal, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-joule","title":"using joule","text":"<pre><code>using cpp_robotics::unit::unit_dimention::joule = typedef udim_mul&lt;newton, metere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-watt","title":"using watt","text":"<pre><code>using cpp_robotics::unit::unit_dimention::watt = typedef udim_div&lt;joule, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-volt","title":"using volt","text":"<pre><code>using cpp_robotics::unit::unit_dimention::volt = typedef udim_div&lt;watt, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-coulomb","title":"using coulomb","text":"<pre><code>using cpp_robotics::unit::unit_dimention::coulomb = typedef udim_mul&lt;second, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-farad","title":"using farad","text":"<pre><code>using cpp_robotics::unit::unit_dimention::farad = typedef udim_div&lt;coulomb, volt&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-ohm","title":"using ohm","text":"<pre><code>using cpp_robotics::unit::unit_dimention::ohm = typedef udim_div&lt;volt, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-weber","title":"using weber","text":"<pre><code>using cpp_robotics::unit::unit_dimention::weber = typedef udim_mul&lt;volt, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-henry","title":"using henry","text":"<pre><code>using cpp_robotics::unit::unit_dimention::henry = typedef udim_div&lt;weber, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-torque","title":"using torque","text":"<pre><code>using cpp_robotics::unit::unit_dimention::torque = typedef udim_mul&lt;newton, metere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-inertia","title":"using inertia","text":"<pre><code>using cpp_robotics::unit::unit_dimention::inertia = typedef udim_mul&lt;kilogram, area&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angular_velocity","title":"using angular_velocity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::angular_velocity = typedef udim_div&lt;angle, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angular_acceleration","title":"using angular_acceleration","text":"<pre><code>using cpp_robotics::unit::unit_dimention::angular_acceleration = typedef udim_div&lt;angular_velocity, second&gt;::unit;\n</code></pre> <p>Updated on 2024-01-06 at 13:57:27 +0000</p>"},{"location":"doxybook/Namespaces/namespacestd/","title":"std","text":"<p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"doxybook/Namespaces/namespaceunit__dim__assem/","title":"unit_dim_assem","text":"<p>Updated on 2024-01-06 at 13:57:26 +0000</p>"},{"location":"example/hello_world/","title":"Hello World","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/hello_world.cpp</p> <p>cpp_robotics\u306e\u6a5f\u80fd\u306e\u4e00\u4f8b\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u6a5f\u80fd\u3092\u4f7f\u3063\u3066\u3044\u307e\u3059  </p> <ul> <li>Vector : Eigen\u306eVector2d, Vector3d etc\u3068\u9055\u3063\u3066constexpr\u306b\u3067\u304d\u3001\u6570\u5b66\u95a2\u6570\u3082\u3044\u304f\u3064\u304b\u30e1\u30f3\u30d0\u95a2\u6570\u3068\u3057\u3066\u5b9f\u88c5\u3057\u3066\u3044\u307e\u3059</li> <li>LQR : \u72b6\u614b\u65b9\u7a0b\u5f0f\u304b\u3089LQR\u3067\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u6c42\u3081\u307e\u3059</li> <li>Polynomal : \u591a\u9805\u5f0f\u306e\u8a55\u4fa1\u3084\u5408\u6210\u3092\u884c\u3044\u307e\u3059</li> <li>TransferFunction : \u4f1d\u9054\u95a2\u6570\u306e\u5408\u6210\u3084\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u884c\u3044\u307e\u3059</li> <li>bode/nyquist : \u30dc\u30fc\u30c9\u7dda\u56f3\u3084\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u8868\u793a\u3057\u307e\u3059</li> </ul> <p>\u51fa\u529b</p> <pre><code>constexpr 2D vector: (3,4), norm = 5\n\nLQR feedback vector\n10  8\n\npolynomial\n( 1x^2 + 3 )\n(x-2)*(x+2) = ( 1x^2 - 4 )\n\nG(s) = \n  1\n-----\n1s +1\n\nC(s) = \n 1s +1\n--------\n0.01s +1\n\nC(s)*G(s) = \n      1s +1\n-----------------\n0.01s^2 +1.01s +1\n\ntransfer function step responce\ntransfer function bode fig plot\ntransfer function nyquist fig plot\n</code></pre> <p>\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54</p> <p></p> <p>\u30dc\u30fc\u30c9\u7dda\u56f3</p> <p></p> <p>\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3</p> <p></p>"},{"location":"example/template/","title":"title","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/xxx/xxx.cpp</p> <p>fig </p>"},{"location":"example/algorithm/icp_sample/","title":"ICP","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm.hpp&gt;\n#include &lt;cpp_robotics/vector/vector2.hpp&gt;\n#include &lt;cpp_robotics/third_party/matplotlib-cpp/matplotlibcpp.h&gt;\n\nint main()\n{\n    namespace cr = cpp_robotics;\n\n    {\n        std::vector&lt;Eigen::Vector2d&gt; fixed = {\n            {0,9},\n            {0,7},\n            {0,5},\n            {0,3},\n            {2,1},\n            {4,1},\n            {6,1},\n            {8,3},\n            {8,5},\n            {8,9},\n        };\n\n        std::vector&lt;Eigen::Vector2d&gt; p2 = fixed;\n        for(size_t i = 0; i &lt; fixed.size(); i++)\n        {\n            // p2[i][0] = fixed[i][1] + 1;\n            // p2[i][1] = -fixed[i][0];\n            p2[i][0] += 3.0; //fixed[i][0];\n            p2[i][1] += 1.0; //fixed[i][1];\n        }\n        auto [R, T] = cr::calcu_transformatoin&lt;2&gt;(p2, fixed);\n\n        std::cout &lt;&lt; \"R = \" &lt;&lt; std::endl;\n        std::cout &lt;&lt; R &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"T = \" &lt;&lt; std::endl;\n        std::cout &lt;&lt; T &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"///// check /////\" &lt;&lt; std::endl;\n\n        for(size_t i = 0; i &lt; p2.size(); i++)\n        {\n            auto moved_p = R*p2[i] + T;\n\n            std::cout &lt;&lt; moved_p.transpose() &lt;&lt; \", err = \" &lt;&lt; (moved_p-fixed[i]).transpose() &lt;&lt; std::endl;\n        }\n    }\n\n    {\n        std::vector&lt;Eigen::Vector2d&gt; p1 = {\n            {0,8},\n            {0,7},\n            {0,5},\n            {0,3},\n            {2,1},\n            {4,1},\n            {6,1},\n            {8,3},\n            {8,5},\n            {8,9},\n        };\n\n        std::vector&lt;Eigen::Vector2d&gt; p2 = p1;\n        for(auto &amp;v : p2)\n            v += Eigen::Vector2d(3, 0);\n\n        auto [points, cnt] = cr::icp&lt;2&gt;(p2, p1, 50);\n\n        auto gen = [](std::vector&lt;Eigen::Vector2d&gt; ps)\n        {\n            std::vector&lt;double&gt; x_(ps.size()), y_(ps.size());\n\n            for(size_t i = 0; i &lt; (ps.size()); i++)\n            {\n                x_[i] = ps[i][0];\n                y_[i] = ps[i][1];\n            }\n\n            return std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;(x_, y_);\n        };\n\n        auto [x, y] = gen(p1);\n        matplotlibcpp::plot(x, y);\n        auto [x2, y2] = gen(points);\n        matplotlibcpp::plot(x2, y2);\n        matplotlibcpp::show();\n\n    }\n}\n</code></pre>"},{"location":"example/algorithm/kdtree_sample/","title":"KDTree","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm/kdtree.hpp&gt;\n#include &lt;cpp_robotics/vector/vector2.hpp&gt;\n#include &lt;Eigen/Dense&gt;\n\nint main()\n{\n    namespace cr = cpp_robotics;\n\n    // for cpp_rototics::VectorXx\n    std::cout &lt;&lt; \"for cpp_rototics::VectorXx\" &lt;&lt; std::endl;\n    {\n        cr::KDTree&lt;cr::Vector2d, 2&gt; kdtree;\n\n        std::vector&lt;cr::Vector2d&gt; points = {\n            {0,1},\n            {2,3},\n            {3,4},\n            {4,5},\n            {5,6},\n        };\n\n        kdtree.build(points);\n        // kdtree.debug_node();\n\n        auto ret = kdtree.knn_search_points(cr::Vector2d(0,1), 1);\n\n        printf(\"size %ld\\n\", ret.size());\n        std::for_each(ret.begin(), ret.end(), [&amp;](cr::Vector2d p)\n        {\n            printf(\"%6.2f, %6.2f\\n\", p.x, p.y);\n        });\n    }\n\n    // for Eigen::VectorXx\n    std::cout &lt;&lt; \"for Eigen::VectorXx\" &lt;&lt; std::endl;\n    {\n        cr::KDTree&lt;Eigen::Vector2d, 2&gt; kdtree;\n\n        std::vector&lt;Eigen::Vector2d&gt; points = {\n            {0,1},\n            {2,3},\n            {3,4},\n            {4,5},\n            {5,6},\n        };\n\n        kdtree.build(points);\n        // kdtree.debug_node();\n\n        auto ret = kdtree.knn_search_points(Eigen::Vector2d(0,1), 1);\n\n        printf(\"size %ld\\n\", ret.size());\n        std::for_each(ret.begin(), ret.end(), [&amp;](Eigen::Vector2d p)\n        {\n            printf(\"%6.2f, %6.2f\\n\", p[0], p[1]);\n        });\n    }\n\n}\n</code></pre>"},{"location":"example/control/alilqr/","title":"AL-iLQR","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/controller/alilqr_diffbot_example.cpp example/controller/alilqr_cartpole_example.cpp</p> <p>AL-iLQR\u3092\u7528\u3044\u3066\u975e\u7dda\u5f62\u30e2\u30c7\u30eb\u306e\u6700\u9069\u5236\u5fa1\u3092\u884c\u3044\u307e\u3059\u3002 \u5236\u7d04\u3068\u3057\u3066\u5165\u529b\u91cf\u306ebox\u5236\u7d04\u3092\u6307\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002</p>"},{"location":"example/control/alilqr/#_1","title":"\u5dee\u52d5\u4e8c\u8f2a","text":""},{"location":"example/control/alilqr/#cartpole","title":"Cartpole","text":""},{"location":"example/control/canonicalize/","title":"\u6b63\u6e96\u5f62","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/controller/canonicalize.cpp</p> <p>\u30b7\u30b9\u30c6\u30e0\u306e\u53ef\u5236\u5fa1\u6b63\u6e96\u7cfb\u3092\u6c42\u3081\u308b\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0\u3067\u3059</p>"},{"location":"example/control/ilqr/","title":"iLQR","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/controller/ilqr_linear_example.cpp example/controller/ilqr_diffbot_example.cpp</p> <p>iLQR\u3092\u7528\u3044\u3066\u7dda\u5f62/\u975e\u7dda\u5f62\u30e2\u30c7\u30eb\u306e\u6700\u9069\u5236\u5fa1\u3092\u884c\u3044\u307e\u3059\u3002  </p> <p>Warning</p> <p>cpp_robotics\u306b\u5b9f\u88c5\u3057\u3066\u3044\u308biLQR\u3067\u306f\u5236\u7d04\u304c\u6271\u3048\u307e\u305b\u3093</p>"},{"location":"example/control/ilqr/#double-integrator","title":"double-integrator","text":""},{"location":"example/control/ilqr/#_1","title":"\u5dee\u52d5\u4e8c\u8f2a","text":""},{"location":"example/control/lqr/","title":"LQR","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/controller/lqr.cpp</p> <p>\u4ee5\u4e0b\u306e\u30b7\u30b9\u30c6\u30e0\u3092LQR\u3067\u5236\u5fa1\u3057\u307e\u3059</p> \\[ \\frac{d}{dt} \\left [\\begin{array}{c} x_1 \\\\ x_2 \\end{array} \\right ] = \\left [\\begin{array}{c} 0 &amp; 1 \\\\ -10 &amp; -1 \\end{array} \\right ] \\left [\\begin{array}{c} x_1 \\\\ x_2 \\end{array} \\right ] + \\left [\\begin{array}{c} 0 \\\\ 1 \\end{array} \\right ] u \\] <p>\u91cd\u307f\u884c\u5217\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u3057\u307e\u3059</p> \\[ Q= \\left [\\begin{array}{c} 100 &amp; 0 \\\\ 0 &amp; 1 \\end{array} \\right ] , \\space R=0.001 \\] <p>\u51fa\u529b <pre><code>feedback gain\n306.386 39.1718\n</code></pre></p> <p></p>"},{"location":"example/control/pid_vs_nctf/","title":"PID vs NCTF","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/core.hpp&gt;\n#include &lt;cpp_robotics/motor/dc_motor_list.hpp&gt;\n#include &lt;cpp_robotics/motor/motor_tf.hpp&gt;\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step_test(cpp_robotics::SisoFeedbackSystem &amp;sys, double time, double dt)\n{\n    std::vector&lt;double&gt; t = cpp_robotics::arrange(0, time, dt);\n    std::vector&lt;double&gt; target(t.size());\n    std::vector&lt;double&gt; res(t.size());\n    std::vector&lt;double&gt; dres(t.size());\n    std::vector&lt;double&gt; input(t.size());\n\n    cpp_robotics::Differentiator diff_(1/dt, dt);\n\n\n    for(size_t i = 0; i &lt; res.size(); i++)\n    {\n        target[i] = (res.size()/2 &lt; i ) ? ( (res.size()*3/4 &lt; i ) ? 0: 20 ) : 20*std::cos(i*0.03); // : 1.0;\n        res[i] = sys.control(target[i]);\n        dres[i] = diff_.filtering(res[i]);\n        input[i] = sys.u();\n    }\n\n    return {t, target, input, res, dres};\n}\n\nvoid make_nct_test(std::function&lt;double(double)&gt; f)\n{\n    std::vector&lt;double&gt; e = cpp_robotics::arrange(-10, 10, 0.05);\n    std::vector&lt;double&gt; e_dot(e.size());\n\n    for(size_t i = 0; i &lt; e.size(); i++)\n    {\n        e_dot[i] = f(e[i]);\n    }\n\n    namespace plt = matplotlibcpp;\n    plt::plot(e, e_dot);\n    plt::ylim(-10, 10);\n    plt::show();\n}\n\nint main()\n{\n    using namespace cpp_robotics;\n\n    const double dt = 0.01;\n    const double max_output = 24;\n\n    //////////////////// PID ////////////////////\n    PIDController::pid_param_t pid_param = \n    {\n        .Ts = dt,\n        .gpd = 100,\n        .Kp = 10.0,\n        .Ki = 0.0,\n        .Kd = 0.09,\n        .output_limit = std::pair(-max_output, max_output)\n    };\n    PIDController pid(pid_param);\n\n    //////////////////// NCTF ////////////////////\n    PIDController::pid_param_t nctf_pid_param = \n    {\n        .Ts = dt,\n        .gpd = 500,\n        .Kp = 0.8,\n        .Ki = 0.0,\n        .Kd = 0.005,\n        .output_limit = std::pair(-max_output, max_output)\n    };\n\n    const double nct_max_velocity = 300.0;\n    const double nct_slope = 10;\n    NctfController nctf(nct_max_velocity, nct_slope, nctf_pid_param, dt);\n\n    //////////////////// Plant ////////////////////\n    auto motor = DCGearedMotorParam(24_V, RZ_735VA_9517, IG42C_17);\n    auto plant = make_geared_motor_pos_tf(motor, dt); // [rad]\n\n    // make_nct_test(nctf.nct());\n    // {\n    //     auto vel_plant = make_geared_motor_vel_tf(motor, dt); // [rad]\n    //     namespace plt = matplotlibcpp;\n    //     auto [t, res] = step(vel_plant, 3.0, max_output);\n    //     plt::named_plot(\"responce\", t, res);\n    //     plt::legend();\n    //     plt::show();\n    // }\n\n    {\n        namespace plt = matplotlibcpp;\n        {\n            SisoFeedbackSystem siso_sys = cpp_robotics::make_feedback_system(pid, plant);\n            siso_sys.reset();\n            auto [t, target, input, ret, dres] = step_test(siso_sys, 5.0, dt);\n\n            plt::named_plot(\"target\", t, target);\n            plt::named_plot(\"PID responce\", t, ret);\n        }\n\n        {\n            SisoFeedbackSystem siso_sys = cpp_robotics::make_feedback_system(nctf, plant);\n            auto [t, target, input, ret, dres] = step_test(siso_sys, 5.0, dt);\n            plant.set_state_zero();\n            siso_sys.reset();\n            // plt::named_plot(\"target\", t, target);\n            plt::named_plot(\"NCTF responce\", t, ret);\n            // plt::named_plot(\"input\", t, input);\n        }\n\n        // plt::named_plot(\"input\", t, input);\n        // plt::named_plot(\"d responce / dt\", t, dres);\n\n        plt::ylim(-30.0, 30.0);\n        plt::legend();\n        plt::show();\n\n        // // show NCT\n        // plt::named_plot(\"actual NCT\", nctf.e_, nctf.e_dot_);\n        // plt::named_plot(\"target NCT\", nctf.e_, nctf.target_e_dot_);\n        // plt::show();\n    }\n\n}\n</code></pre>"},{"location":"example/control/place/","title":"\u6975\u914d\u7f6e","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/controller/place.cpp</p> <p>\u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3067\u4e0e\u3048\u3089\u308c\u308b\u30e2\u30c7\u30eb\u306b\u5bfe\u3057\u3066\u6975\u914d\u7f6e\u3092\u884c\u3044\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u6c42\u3081\u307e\u3059</p>"},{"location":"example/control/pure_pursuit/","title":"Pure pursuit","text":""},{"location":"example/control/vrft_pid/","title":"VRFT\u306b\u3088\u308bPID\u30b2\u30a4\u30f3\u306e\u81ea\u52d5\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/controller/vrft_pid.cpp</p> <p>\u89d2\u5468\u6ce2\u657010[rad/s]\u3001\u6e1b\u8870\u4fc2\u65700.3\u306e\u30b7\u30b9\u30c6\u30e0\u3092\u4f8b\u306b\u8003\u3048\u308b</p> \\[ G(s) = \\frac{10^2}{s^2 + 2 \\cdot 0.3 \\cdot 10 s + 10^2} \\]"},{"location":"example/control/vrft_pid/#_1","title":"\u958b\u30eb\u30fc\u30d7\u3067\u306e\u5b9f\u9a13\u7d50\u679c\u304b\u3089\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0","text":"<p>\u5de6\u306e\u56f3\u306f\u30b2\u30a4\u30f31\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u306e\u6e2c\u5b9a\u7d50\u679c\u3067\u3001\u3053\u306e\u7d50\u679c\u3092\u3082\u3068\u306b\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3092\u884c\u3044\u3001VRFT\u3067\u6c42\u3081\u305fPID\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u305f\u7d50\u679c\u304c\u53f3\u306e\u56f3\u3067\u3042\u308b</p> <p></p>"},{"location":"example/control/vrft_pid/#_2","title":"\u9589\u30eb\u30fc\u30d7\u3067\u306e\u5b9f\u9a13\u7d50\u679c\u304b\u3089\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0","text":"<p>\u9069\u5f53\u306aPID\u30d1\u30e9\u30e1\u30fc\u30bf(\u3053\u3053\u3067\u306f\\(Kp=1.0, Ki=0, Kd=0.1\\))\u3092\u7528\u3044\u3066\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6e2c\u5b9a\u3057\u305f\u7d50\u679c\u3092\u7528\u3044\u3066\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3092\u884c\u3044\u3001VRFT\u3067\u6c42\u3081\u305fPID\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u4f7f\u3063\u3066\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u305f\u7d50\u679c\u304c\u53f3\u306e\u56f3\u3067\u3042\u308b</p> <p></p>"},{"location":"example/filter/limit_filter/","title":"VelocityLimitFilter &amp; AccelerationLimitFilter","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/filter/vel_limit_filter.cpp</p>"},{"location":"example/filter/limit_filter/#velocitylimitfilter","title":"\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(VelocityLimitFilter)","text":"<p>\u5165\u529b\u306e1\u56de\u5fae\u5206\u3092\u5236\u9650\u3057\u307e\u3059</p> <p></p>"},{"location":"example/filter/limit_filter/#accelerationlimitfilter","title":"\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(AccelerationLimitFilter)","text":"<p>\u5165\u529b\u306e2\u56de\u5fae\u5206\u3092\u5236\u9650\u3057\u307e\u3059</p> <p></p>"},{"location":"example/filter/lpf_hpf/","title":"LPF, HPF","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/filter/lpf_step.cpp example/filter/hpf_step.cpp</p> <p>LPF\u3068HPF\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u8abf\u3079\u307e\u3059</p>"},{"location":"example/filter/lpf_hpf/#lpf","title":"LPF\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54","text":""},{"location":"example/filter/lpf_hpf/#hpf","title":"HPF\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54","text":""},{"location":"example/optimize/active_set_method_example/","title":"\u6709\u52b9\u5236\u7d04\u6cd5","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm.hpp&gt;\n#include &lt;cpp_robotics/optimize/active_set_method.hpp&gt;\n\nint main()\n{\n    namespace cr = cpp_robotics;\n\n    cr::ActiveSetMethod solver;\n\n    cr::ActiveSetMethod::Problem prob(2);\n\n    std::cout &lt;&lt; \"prob setup\" &lt;&lt; std::endl;\n    prob.Q &lt;&lt; 1,0,0,1;\n    prob.c &lt;&lt; -6,-2;\n\n    Eigen::VectorXd A(2);\n    A &lt;&lt; 0,0;\n    Eigen::VectorXd b(1);\n    b &lt;&lt; 1;\n\n    // prob.add_inequality_constraint(A.transpose(), b); // x2 = 1\u306e\u5236\u7d04\n    // A &lt;&lt; -1, 0;\n    // prob.add_equality_constraint(A.transpose(), b); // x1 = 1\u306e\u5236\u7d04\n\n    Eigen::Vector2d x0;\n    x0 &lt;&lt; 3,2;\n\n    std::cout &lt;&lt; \"prob setup end\" &lt;&lt; std::endl;\n\n    auto result = solver.solve(prob, x0);\n\n    if(result.is_solved)\n    {\n        std::cout &lt;&lt; \"\u89e3\u3051\u305f\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; \"\u89e3\u7121\u3057\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; result.x_opt.transpose() &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"iter: \" &lt;&lt; result.iter_cnt &lt;&lt; std::endl;\n\n}\n</code></pre>"},{"location":"example/optimize/optimize_rosenbrock/","title":"Rosenbrock\u95a2\u6570\u306e\u6700\u9069\u5316","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/optimize/optimize_rosenbrock.cpp</p> <p>\u9023\u7d9a\u95a2\u6570\u306e\u6700\u9069\u5316\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u3067\u3088\u304f\u767b\u5834\u3059\u308bRosenbrock\u95a2\u6570\u3092\u4f7f\u3063\u3066\u6700\u9069\u5316\u3092\u884c\u3044\u307e\u3059\u3002 \u89e3\u306e\u521d\u671f\u5024x= (0,0)\u304b\u3089\u6700\u9069\u89e3\u306fx = (1, 1)\u3092\u898b\u3064\u3051\u308b\u3053\u3068\u304c\u3067\u304d\u3066\u3044\u307e\u3059\u3002</p> <p>\u51fa\u529b <pre><code>optimize Rosenbrock function with quasi newton method\nans: 1 1\nitr: 20\n</code></pre></p>"},{"location":"example/optimize/optimize_scalar/","title":"\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u306e\u6700\u9069\u5316","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/optimize/optmize_scalar.cpp</p> <p>\u30b9\u30ab\u30e9\u30fc\u5024\u95a2\u6570\u306e\u6700\u9069\u5316\u306b\u4f7f\u3048\u308b\u95a2\u6570\u306e\u4f8b\u3092\u793a\u3057\u307e\u3059\u3002 \u9ec4\u91d1\u63a2\u7d22\u306f\u9023\u7d9a\u306a\u4e0b\u306b\u51f8\u306e\u95a2\u6570\u306e\u52b9\u7387\u7684\u306a\u6700\u5c0f\u5316\u304c\u3067\u304d\u307e\u3059 2\u3064\u76ee\u306e\u51fa\u529b\u3067\u306fsin\u95a2\u6570\u306ex=0\u5468\u308a\u3067\u306e\u6570\u5024\u5fae\u5206\u3092\u6c42\u3081\u3066\u3044\u307e\u3059\u3002</p> <p>\u51fa\u529b <pre><code>optimize_scalar\nmin x =&gt; (x+1)^2 = -1\nsin'(0) = cos(0) = 1\n</code></pre></p>"},{"location":"example/optimize/optimize_without_constraint/","title":"\u7121\u5236\u7d04\u6700\u9069\u5316","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/optimize/optimize_without_constraint.cpp</p> <p>\u7c21\u5358\u306a2\u5024\u95a2\u6570\u306e\u6700\u9069\u5316\u3092\u884c\u3044\u307e\u3059\u3002 \u6700\u6025\u964d\u4e0b\u6cd5\u3068\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u540c\u3058\u554f\u984c\u3092\u89e3\u3044\u3066\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u306f\u53cd\u5fa9\u56de\u6570\u304c\u5c11\u306a\u3044\u3053\u3068\u304c\u78ba\u8a8d\u3067\u304d\u307e\u3059\u3002</p> <p>\u51fa\u529b <pre><code>steepest_descent_method\n(2 3), itr: 14\nquasi_newton_method\n(2 3), itr: 2\n</code></pre></p>"},{"location":"example/optimize/sqp_example/","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm.hpp&gt;\n#include &lt;cpp_robotics/optimize/sqp.hpp&gt;\n\nusing namespace cpp_robotics;\n\nint main()\n{\n    SQP solver;\n    SQP::Problem prob;\n\n    //////////////////// \u554f\u984c\u8a2d\u5b9a ////////////////////\n    prob.func = [](Eigen::VectorXd x)\n    {\n        return std::pow(x(0)-3, 2) + std::pow(x(1)-3,2);\n    };\n\n    prob.con.push_back({\n        Constraint::Ineq,\n        [](Eigen::VectorXd x)\n        {\n            return (x.squaredNorm() - 1);\n        },\n    });\n    // prob.con.push_back({\n    //     Constraint::Ineq,\n    //     [](Eigen::VectorXd x)\n    //     {\n    //         x(0) -= 1.5;\n    //         return x.squaredNorm() - 1;\n    //     },\n    // });\n\n    prob.max_iter = 3;\n\n    Eigen::VectorXd x0(2);\n    x0 &lt;&lt; 1.0, 0;\n\n    //////////////////// \u89e3\u304f ////////////////////\n    auto result = solver.solve(prob, x0);\n\n    std::cout &lt;&lt; \"min (x(0)-3)^2 + x(1)^2\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"s.t. x(0)^2 + x(1)^2 &lt;= 1\" &lt;&lt; std::endl;\n\n    if(result.is_solved)\n    {\n        std::cout &lt;&lt; \"\u89e3\u3051\u305f\" &lt;&lt; std::endl;\n    }\n    else\n    {\n        std::cout &lt;&lt; \"\u89e3\u3051\u306a\u304b\u3063\u305f\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"x_opt =\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; result.x_opt &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"lambda_opt =\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; result.lambda_opt &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"iter: \" &lt;&lt; result.iter_cnt &lt;&lt; std::endl;\n\n}\n</code></pre>"},{"location":"example/path_planning/dubins_path/","title":"Dubins\u66f2\u7dda","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/path_planning/dubins_path.cpp</p> <p>(4, 3)\u5730\u70b9-45\u5ea6\u306e\u65b9\u5411\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u3057\u3066(1,1)\u306b45\u5ea6\u306e\u65b9\u5411\u306b\u5230\u9054\u3059\u308b\u7d4c\u8def\u3092\u751f\u6210\u3057\u307e\u3059\u3002 \u66f2\u7dda\u306e\u7b87\u6240\u306f\u66f2\u7387\u304c1\u306b\u306a\u308b\u3088\u3046\u306b\u8a2d\u5b9a\u3057\u307e\u3059\u3002</p> <p>\u51fa\u529b <pre><code>RSR\n1.45579\n2.55239\n3.2566\n</code></pre></p> <p></p>"},{"location":"example/system/bode_nyquist/","title":"\u30dc\u30fc\u30c9\u7dda\u56f3\u30fb\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/system/bode_nyquist.cpp</p> <p>\u4ee5\u4e0b\u306e\u4f1d\u9054\u95a2\u6570\u306e\u30dc\u30fc\u30c9\u7dda\u56f3\u3068\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u8868\u793a\u3057\u307e\u3059</p> \\[ G(s) = \\frac{4^2}{s^2 + 2 \\cdot 0.5 \\cdot 4 \\cdot s + 4^2} \\] <p> </p>"},{"location":"example/system/state_space_system/","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/system/state_space_system.cpp</p> <p>\u4ee5\u4e0b\u306e\u30b7\u30b9\u30c6\u30e0\u3092\u8868\u3059\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3057\u307e\u3059\u3002\u307e\u305f\u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u30fb\u53ef\u89b3\u6e2c\u3067\u3042\u308b\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059</p> \\[ \\begin{align} \\frac{d}{dt} \\left [\\begin{array}{c} x_1 \\\\ x_2 \\end{array} \\right ] &amp;= \\left [\\begin{array}{c} 0 &amp; 1 \\\\ 1 &amp; 0.5 \\end{array} \\right ] \\left [\\begin{array}{c} x_1 \\\\ x_2 \\end{array} \\right ] + \\left [\\begin{array}{c} 0 \\\\ 0.5 \\end{array} \\right ] u\\\\ y &amp;= \\left [\\begin{array}{c} 1 &amp; 0 \\end{array} \\right ] \\left [\\begin{array}{c} x_1 \\\\ x_2 \\end{array} \\right ] \\end{align} \\] <p>\u51fa\u529b</p> <pre><code>Controllable\nObservable\n</code></pre>"},{"location":"example/system/step_responce/","title":"\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54","text":"<p>\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9</p> <p>example/system/step_responce.cpp</p> \\[ G(s) = \\frac{4^2}{s^2 + 2 \\cdot 0.5 \\cdot 4 \\cdot s + 4^2} \\] <p></p>"},{"location":"example/units/units/","title":"\u5358\u4f4d\u7cfb","text":"<pre><code>#include &lt;iostream&gt;\n// #include &lt;cpp_robotics/core.hpp&gt;\n\n#include \"cpp_robotics/utility.hpp\"\n#include \"cpp_robotics/vector.hpp\"\n#include \"cpp_robotics/unit.hpp\"\n\nint main()\n{\n    using namespace cpp_robotics;\n\n    constexpr Meter width = 1.5_m;\n    constexpr Meter height = 3000_mm;\n\n    constexpr Meter perimeter = 2*(width + height); // 8.0\n\n    constexpr Area rectangle_area = width*height; // 4.5\n\n    constexpr Volt voltage = 20_V;\n    constexpr Ohm res = 5_ohm;\n\n    constexpr Ampere current = voltage / res; // 4.0\n}\n</code></pre>"},{"location":"tech_note/algorithm/auto_diff/","title":"\u81ea\u52d5\u5fae\u5206","text":""},{"location":"tech_note/algorithm/auto_diff/#_2","title":"\u30d5\u30a9\u30ef\u30fc\u30c9\u30e2\u30fc\u30c9\u30fb\u30d0\u30c3\u30af\u30ef\u30fc\u30c9\u30e2\u30fc\u30c9","text":""},{"location":"tech_note/algorithm/auto_diff/#_3","title":"\u81ea\u52d5\u5fae\u5206\u30e9\u30a4\u30d6\u30e9\u30ea","text":""},{"location":"tech_note/algorithm/auto_diff/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/algorithm/icp/","title":"ICP (Iterative Closest Point)","text":""},{"location":"tech_note/algorithm/icp/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>ICP\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5229\u7528\u3057\u305fSLAM\u7528Python\u3001MATLAB\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0</li> <li>ICP(Iterative Closest Point)\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/algorithm/jerk_minimum_model/","title":"\u8e8d\u5ea6\u6700\u5c0f\u5316\u30e2\u30c7\u30eb","text":""},{"location":"tech_note/algorithm/jerk_minimum_model/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/algorithm/k_means_method/","title":"K-means\u6cd5","text":""},{"location":"tech_note/algorithm/k_means_method/#k-means_1","title":"K-means++\u6cd5","text":""},{"location":"tech_note/algorithm/k_means_method/#_1","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/algorithm/kdtree/","title":"KDTree","text":""},{"location":"tech_note/algorithm/mahalanobis/","title":"\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2","text":"<p>\u7570\u5e38\u691c\u77e5\u306a\u3069\u306b\u3088\u304f\u4f7f\u308f\u308c\u308b\u591a\u5909\u6570\u306e\u7a7a\u9593\u306b\u5bfe\u3057\u3066\u305d\u308c\u305e\u308c\u306e\u5909\u6570\u306e\u5171\u5206\u6563\u884c\u5217\u3092\u4f7f\u3063\u3066\u8868\u73fe\u3055\u308c\u308b\u8ddd\u96e2</p> \\[ d = \\sqrt{(x-\\mu)^T\\Sigma^{-1}(x-\\mu)} \\]"},{"location":"tech_note/algorithm/mahalanobis/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2</li> </ul>"},{"location":"tech_note/algorithm/ndt/","title":"NDT scan matching","text":""},{"location":"tech_note/algorithm/ndt/#ndt","title":"NDT\u30de\u30c3\u30c1\u30f3\u30b0\u5927\u307e\u304b\u306a\u6d41\u308c","text":"<ul> <li>\u30de\u30c3\u30d7\u3092NDT\u5316\u3059\u308b</li> <li>\u30ec\u30fc\u30b6\u30fc\u306e\u89b3\u6e2c\u30c7\u30fc\u30bf\u3092\u3053\u308c\u307e\u3067\u306e\u81ea\u5df1\u4f4d\u7f6e\u3092\u30d9\u30fc\u30b9\u306b\u3057\u3066NDT\u5316\u3059\u308b?</li> <li></li> <li>\u30ec\u30fc\u30b6\u30fc\u3067\u306e</li> </ul>"},{"location":"tech_note/algorithm/ndt/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>NDT\u52c9\u5f37\u4f1a</li> <li>\u3010ROS\u3011\u30b9\u30ad\u30e3\u30f3\u30de\u30c3\u30c1\u30f3\u30b0SLAM\u306e\u5b9f\u88c5\uff08NDT\u5b9f\u88c5\u7de8\uff09</li> <li>Scan Matching \u81ea\u5df1\u4f4d\u7f6e\u63a8\u5b9a\u624b\u6cd5</li> <li>pcl_apps ROS2\u3067pcl\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8</li> </ul>"},{"location":"tech_note/algorithm/poly/","title":"\u591a\u9805\u5f0f","text":""},{"location":"tech_note/algorithm/poly/#_2","title":"\u52a0\u6e1b\u4e57\u9664","text":""},{"location":"tech_note/algorithm/poly/#_3","title":"\u5c55\u958b","text":""},{"location":"tech_note/algorithm/poly/#_4","title":"\u56e0\u6570\u5206\u89e3","text":""},{"location":"tech_note/algorithm/poly/#_5","title":"\u5fae\u5206\u30fb\u7a4d\u5206","text":""},{"location":"tech_note/algorithm/poly_lerp/","title":"\u591a\u9805\u5f0f\u88dc\u9593","text":"<p>\u30ed\u30dc\u30c3\u30c8\u30a2\u30fc\u30e0\u306a\u3069\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3057\u305f\u3044\u6642\u306b\u76ee\u6a19\u5024\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3059\u3053\u3068\u3067\u5b9f\u73fe\u3057\u3088\u3046\u3068\u3057\u305f\u6642\u306b\u306a\u308b\u3079\u304f\u7c21\u5358\u306b\u53c2\u7167\u8ecc\u9053\u3092\u4f5c\u308a\u305f\u3044\u3053\u3068\u304c\u3042\u308b\u3002\u7c21\u5358\u306b\u5b9f\u88c5\u3059\u308b\u306a\u3089\u591a\u9805\u5f0f\u3067\u8ecc\u9053\u3092\u4f5c\u308b\u306e\u304c\u7c21\u5358\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/algorithm/poly_lerp/#1","title":"1\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65702</p> <p>\u59cb\u70b9\u4f4d\u7f6e\\(P_0\\), \u7d42\u70b9\u4f4d\u7f6e\\(P_1\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; \\dfrac{P_1 - P_0}{T} \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#2","title":"2\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65703</p> <p>\u59cb\u70b9\\((P_0, v_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{T^2}\\left\\{ (P_1 - P_0) - v_0T \\right\\}\\\\ \\end{array} \\] <p>\u59cb\u70b9\\((P_0, v_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((v_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{2T}(v_1 - v_0)\\\\ \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#3","title":"3\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65704</p> <p>\u59cb\u70b9\\((P_0, v_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, v_1)\\), \u9593\u9694\\(T`x\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{T^2}\\left\\{ 3(P_1 - P_0) - (v_1 + 2v_0)T \\right\\}\\\\ a_3 &amp;=&amp; \\dfrac{1}{T^3}\\left\\{ -2(P_1 - P_0) - (v_1 + v_0)T \\right\\} \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#4","title":"4\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65705</p> <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((v_1, acc_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{2} acc_0\\\\ a_3 &amp;=&amp; \\dfrac{1}{3T^2}\\left\\{ 3(v_1 - v_0) - (acc_1 + 2acc_0)T \\right\\}\\\\ a_4 &amp;=&amp; \\dfrac{1}{4T^3}\\left\\{ -2(v_1 - v_0) + (acc_1 + acc_0)T \\right\\}\\\\ \\end{array} \\] <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, v_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, acc_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p>"},{"location":"tech_note/algorithm/poly_lerp/#5","title":"5\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65706</p> <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, v_1, acc_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{2} acc_0\\\\ a_3 &amp;=&amp; \\dfrac{1}{2T^3}\\left\\{ 20(P_1 - P_0) - (8v_1 + 12v_0)T + (acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_4 &amp;=&amp; \\dfrac{1}{2T^4}\\left\\{ -30(P_1 - P_0) + (14v_1 + 16v_0)T -    (2acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_5 &amp;=&amp; \\dfrac{1}{2T^5}\\left\\{ 12(P_1 - P_0) - 6(v_1 + v_0)T +    (acc_1 - acc_0)T^2 \\right\\} \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30c3\u30c8\u5de5\u5b66\u306e\u57fa\u790e\uff08\u7b2c2\u7248\uff09</li> </ul>"},{"location":"tech_note/algorithm/poly_regression/","title":"\u56de\u5e30\u66f2\u7dda","text":""},{"location":"tech_note/algorithm/poly_regression/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/control/frit_vrft_turning/","title":"\u30c7\u30fc\u30bf\u99c6\u52d5\u5f62\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0","text":"<p>PID\u5236\u5fa1\u306a\u3069\u3067\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3092\u3059\u308b\u969b\u306b\u9650\u754c\u611f\u5ea6\u6cd5\u3084\u30b8\u30fc\u30b0\u30e9\u30fb\u30cb\u30b3\u30eb\u30b9\u6cd5\u306a\u3069\u306b\u3088\u308b\u8abf\u6574\u3084\u8a66\u884c\u932f\u8aa4\u7684\u306b\u8abf\u6574\u3059\u308b\u65b9\u6cd5\u304c\u3088\u304f\u53d6\u3089\u308c\u3066\u3044\u308b\u304c\u3001\u3053\u306e\u30da\u30fc\u30b8\u3067\u306f\u4e00\u56de\u306e\u5b9f\u9a13\u306e\u5165\u529b\u4fe1\u53f7\u3068\u51fa\u529b\u4fe1\u53f7\u3068\u671b\u307e\u308c\u308b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30eb\u30fc\u30d7\u306e\u898f\u7bc4\u30e2\u30c7\u30eb\u3092\u7528\u3044\u3066\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3092\u884c\u3046\u65b9\u6cd5\u3092\u8aac\u660e\u3059\u308b</p>"},{"location":"tech_note/control/frit_vrft_turning/#_2","title":"\u524d\u63d0","text":"<ul> <li>\\(u_0\\) \u5165\u529b\u4fe1\u53f7</li> <li>\\(y_0\\) \u30b7\u30b9\u30c6\u30e0\u306b\\(u_0\\)\u3092\u4e0e\u3048\u305f\u3068\u304d\u306e\u51fa\u529b</li> <li> <p>\\(T_d(s)\\) \u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u3059\u308b\u3068\u304d\u306e\u898f\u7bc4\u30e2\u30c7\u30eb     \u6642\u5b9a\u65700.5\u79d2\u306e1\u6b21\u9045\u308c\u3092\u898f\u7bc4\u30e2\u30c7\u30eb\u306b\u3059\u308b\u5834\u5408</p> \\[ T_d(s) = \\frac{1}{0.5s + 1} \\] </li> <li> <p>\\(C(s, \\rho)\\) \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9 \\(\\rho\\)\u306f\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3067PID\u306e\u5834\u5408\\(\\rho = (Kp, Ki, Kd)\\)</p> </li> </ul>"},{"location":"tech_note/control/frit_vrft_turning/#fritfictitious-reference-iterative-turning","title":"FRIT(Fictitious Reference Iterative Turning)","text":"<p>Memo</p> <p>Fictitious : \u67b6\u7a7a\u306e  </p> <p>\u7591\u4f3c\u53c2\u7167\u4fe1\u53f7\\(\\tilde{r}(s, \\rho)\\)\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3059\u308b</p> \\[ \\begin{array}{lll} \\tilde{r}(s, \\rho) = C^{-1}(s, \\rho)u_0 + u_0 \\\\ J(\\rho) = || y_0 - T_d(s)\\tilde{r}(s, \\rho) ||^2 \\end{array} \\] <p>\u4ee5\u4e0b\u306e\u8a55\u4fa1\u95a2\u6570\u306e\u6700\u5c0f\u5316\u554f\u984c\u306b\u3064\u3044\u3066\u6700\u9069\u5316\u3092\u884c\u3044\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\\(\\rho\\)\u3092\u6c42\u3081\u308b</p> \\[ \\underset{\\rho}{\\text{min}} || y_0 - T_d(s)\\tilde{r}(s, \\rho) ||^2 \\]"},{"location":"tech_note/control/frit_vrft_turning/#vrftvirtual-reference-feedback-turning","title":"VRFT(Virtual Reference Feedback Turning)","text":"<p>\u30d7\u30ec\u30d5\u30a3\u30eb\u30bf\\(L(s)\\)\u3068\u898f\u7bc4\u30e2\u30c7\u30eb\u304b\u3089\u4ee5\u4e0b\u3092\u5b9a\u7fa9</p> \\[ \\begin{array}{lll} u_f = L(s) u_0 \\\\ e_f = L(s) \\left(\\frac{1}{T_d(s)}y_0 - y_0 \\right)  \\end{array} \\] <p>\u4ee5\u4e0b\u306e\u8a55\u4fa1\u95a2\u6570\u306e\u6700\u5c0f\u5316\u554f\u984c\u306b\u3064\u3044\u3066\u6700\u9069\u5316\u3092\u884c\u3044\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\\(\\rho\\)\u3092\u6c42\u3081\u308b</p> \\[ \\underset{\\rho}{\\text{min}} || u_f - C(s, \\rho)e_f ||^2 \\]"},{"location":"tech_note/control/frit_vrft_turning/#_3","title":"\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u306b\u304a\u3051\u308b\u6ce8\u610f\u70b9","text":""},{"location":"tech_note/control/frit_vrft_turning/#_4","title":"\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u306b\u4f7f\u7528\u3059\u308b\u72b6\u614b\u91cf\u306e\u4fe1\u53f7\u3092\u5f97\u308b\u6642\u306f\u958b\u30eb\u30fc\u30d7\u30fb\u9589\u30eb\u30fc\u30d7\u3092\u554f\u308f\u306a\u3044","text":"<p>FRIT, VRFT\u3068\u3082\u306b\\(u_0\\),\\(y_0\\)\u306f\u958b\u30eb\u30fc\u30d7/\u9589\u30eb\u30fc\u30d7\u306e\u3069\u3061\u3089\u3067\u5f97\u3066\u3082\u554f\u984c\u306a\u3044</p>"},{"location":"tech_note/control/frit_vrft_turning/#_5","title":"\u51fa\u529b\u4fe1\u53f7\u304c\u5341\u5206\u306b\u30b7\u30b9\u30c6\u30e0\u306e\u7279\u6027\u3092\u52b1\u8d77\u3057\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b","text":"<p>\\(y0\\)\u306b\u306f\u5341\u5206\u306b\u9ad8\u3044\u5468\u6ce2\u6570\u307e\u3067\u306e\u7279\u6027\u3092\u542b\u3093\u3067\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u4f8b\u3048\u3070\\(y_0\\)\u304csin\u6ce2\u3067\u3042\u308a\u5358\u4e00\u5468\u6ce2\u6570\u306e\u7279\u6027\u3057\u304b\u542b\u307e\u306a\u3044\u3068\u306a\u308b\u3068\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u304c\u6b63\u3057\u304f\u884c\u308f\u308c\u306a\u3044\u53ef\u80fd\u6027\u304c\u9ad8\u3044</p>"},{"location":"tech_note/control/frit_vrft_turning/#_6","title":"\u4f7f\u3048\u308b\u30bd\u30eb\u30d0\u306e\u9055\u3044","text":"<p>PID\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u5834\u5408\u3001\u6700\u9069\u5316\u306e\u969b\u306bFRIT\u3067\u306f\u975e\u7dda\u5f62\u6700\u9069\u5316\u3092\u884c\u3046\u5fc5\u8981\u304c\u3042\u308b\u3002VRFT\u3067\u306f\u6700\u5c0f\u4e8c\u4e57\u6cd5\u3067\u6700\u9069\u5316\u3092\u884c\u3046\u3053\u3068\u304c\u3067\u304d\u308b</p>"},{"location":"tech_note/control/frit_vrft_turning/#vrft","title":"VRFT\u306e\u30d7\u30ec\u30d5\u30a3\u30eb\u30bf","text":"<p>\u30b7\u30f3\u30d7\u30eb\u306b\\(L(s) = T_d(s)\\)\u3068\u3059\u308b\u3053\u3068\u3067\u3082\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u306f\u53ef\u80fd\u3067\u3042\u308b</p>"},{"location":"tech_note/control/frit_vrft_turning/#_7","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u8077\u5834\u3067\u4f7f\u3048\u308b\u30c7\u30fc\u30bf\u99c6\u52d5\u578bPID\u30aa\u30fc\u30c8\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u5165\u9580 : FRIT\u3068VRFT\u7de8 \u5236\u5fa1\u30fbAI\u30fb\u30bb\u30f3\u30b7\u30f3\u30b0\u30b7\u30ea\u30fc\u30ba</li> <li>\u30c7\u30fc\u30bf\u99c6\u52d5\u578b\u5236\u5fa1\u5668\u30c1\u30e5\u30fc\u30cb\u30f3\u30b0\u2015FRIT\u30a2\u30d7\u30ed\u30fc\u30c1\u2015</li> <li>M.C. Campi and A. Lecchini and S.M. Savaresi. (2002). Virtual reference feedback tuning: a direct method for the design of feedback controllers. Automatica, 38(8), 1337-1346</li> </ul>"},{"location":"tech_note/control/ilqr/","title":"iLQR/DDP/AL-iLQR","text":""},{"location":"tech_note/control/ilqr/#ilqr","title":"iLQR","text":""},{"location":"tech_note/control/ilqr/#_1","title":"\u554f\u984c\u8a2d\u5b9a","text":"<p>\u30c0\u30a4\u30ca\u30df\u30af\u30b9 $$ x_{k+1} = f_k(x_k, u_k) $$</p> <p>\u8a55\u4fa1\u95a2\u6570 $$ J = \\phi(x_N) + \\Sigma l_k(x_k, u_k)</p> <p>\\phi(x_N) =  \\Sigma l_k(x_k, u_k) =</p> <p>$$</p> \\[ \\delta Q_k =  \\] <p>Q\u306e1\u6b21\u8fd1\u4f3c $$ Q_{xx} Q_{uu} Q_{ux} Q_u Q_x $$</p> \\[ \\dealta u_k^* \\]"},{"location":"tech_note/control/ilqr/#ddp","title":"DDP","text":"<p>iLQR\u3067\u306fQ\u30921\u6b21\u8fd1\u4f3c\u3057\u305f\u304cDDP\u3067\u306f2\u6b21\u8fd1\u4f3c\u3057\u305f\u3082\u306e\u3092\u4f7f\u3046</p>"},{"location":"tech_note/control/ilqr/#fddp","title":"FDDP","text":""},{"location":"tech_note/control/ilqr/#al-ilqr","title":"AL-iLQR","text":"<p>iLQR/DDP\u304c\u30c0\u30a4\u30ca\u30df\u30af\u30b9\u306e\u307f\u306e\u554f\u984c\u8a2d\u5b9a\u304b\u3089\u51fa\u767a\u3059\u308b\u306e\u306b\u5bfe\u3057\u3066\u3001\u5236\u7d04\u3092\u8003\u3048\u30e9\u30b0\u30e9\u30b8\u30a2\u30f3\u304b\u3089\u51fa\u767a\u3059\u308bmodeified iLQR\u3092\u30d9\u30fc\u30b9\u3068\u3057\u305f\u306e\u304cAL-iLQR\u3067\u3042\u308b AL-iLQR\u3092\u30d9\u30fc\u30b9\u3068\u3057\u305f\u5236\u7d04\u4ed8\u304d\u8d77\u52d5\u6700\u9069\u5316\u30bd\u30eb\u30d0\u3067\u3042\u308bALTRO\u306b\u4f7f\u7528\u3055\u308c\u3066\u3044\u308b</p>"},{"location":"tech_note/control/ilqr/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u5fae\u5206\u52d5\u7684\u8a08\u753b\u6cd5</li> <li>LQR/iLQR\u3092\u7406\u89e3\u3059\u308b</li> <li>Differential Dynamic Programming(DDP)/iterative LQR(iLQR)/Sequential LQR(SLQ)</li> <li>AL-iLQR Tutorial</li> <li>\u5fae\u5206\u52d5\u7684\u8a08\u753b\u6cd5\u306e\u8fd1\u5e74\u306e\u52d5\u5411\uff1a\u5236\u7d04\u4ed8\u304d\u8ecc\u9053\u8a08\u753b\u554f\u984c\u3078\u306e\u30a2\u30d7\u30ed\u30fc\u30c1 </li> </ul>"},{"location":"tech_note/control/lqr/","title":"LQR","text":""},{"location":"tech_note/control/lqr/#_1","title":"\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f","text":""},{"location":"tech_note/control/lqr/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u7dda\u5f62\u4e8c\u6b21\u30ec\u30ae\u30e5\u30ec\u30fc\u30bf(Linear-Quadratic Regulator:LQR)\u306e\u6982\u8981\u3068Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9</li> <li>\u7dda\u5f62\u6700\u9069\u5236\u5fa1\uff08LQR\uff09\u3068Riccati\u30bd\u30eb\u30d0\u30fc\u306b\u3064\u3044\u3066</li> <li>LQR\u5236\u5fa1\u3068\u306f\u30fb\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u304d\u65b9</li> </ul>"},{"location":"tech_note/control/minphase/","title":"\u6700\u5c0f\u4f4d\u76f8\u7cfb\u30fb\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb","text":""},{"location":"tech_note/control/minphase/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3010\u5236\u5fa1\u5de5\u5b66\u3011\u4e0d\u5b89\u5b9a\u96f6\u70b9\u3068\u30a2\u30f3\u30c0\u30fc\u30b7\u30e5\u30fc\u30c8\uff08\u5236\u5fa1\u7406\u8ad6#7\uff09(YouTube)</li> <li>106\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb#\u3064\u3076\u3084\u304d\u5236\u5fa1\u5de5\u5b66 (YouTube)</li> </ul>"},{"location":"tech_note/control/nctf/","title":"NCTF","text":""},{"location":"tech_note/control/pfc/","title":"PFC","text":""},{"location":"tech_note/control/pfc/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>Predictive Functional Control\u306e\u5b9f\u88c5</li> </ul>"},{"location":"tech_note/control/pid/","title":"PID","text":"<p>\u53e4\u5178\u5236\u5fa1\u306e\u4ee3\u8868\u7684\u306a\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u5668\u3002\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3092\u3001\u72b6\u614b\u91cf\u3068\u76ee\u6a19\u5024\u306e\u5dee\u5206\u3001\u305d\u306e\u7a4d\u5206\u5024\u3001\u5fae\u5206\u5024\u306b\u3088\u3063\u3066\u6c7a\u5b9a\u3059\u308b\u30023\u3064\u306e\u5024\u306b\u5bfe\u3057\u3066\u30b2\u30a4\u30f3\u3092\u304b\u3051\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5fdc\u7b54\u3092\u8abf\u6574\u3059\u308b\u3002</p> \\[ u(t) = K_p e + K_i \\int_0^t e dt + K_d \\dot{e} \\] <p>PID\u5236\u5fa1\u5668\u306f\u4e0a\u8a18\u306e\u3088\u3046\u306b\u8868\u3055\u308c\u3001\\(K_p\\), \\(K_i\\), \\(K_d\\)\u3092\u305d\u308c\u305e\u308c\u6bd4\u4f8b\u30b2\u30a4\u30f3\u3001\u7a4d\u5206\u30b2\u30a4\u30f3\u3001\u5fae\u5206\u30b2\u30a4\u30f3\u3068\u547c\u3076\u3002</p> <p>\u7a4d\u5206\u9805\u3001\u5fae\u5206\u9805\u306e\u4fc2\u6570\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u8a18\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002</p> \\[ u(t) = K_p \\left( e + \\frac{1}{T_i} \\int_0^t e dt + T_d \\dot{e} \\right) \\text{ \u305f\u3060\u3057}K_i=K_p/T_i, Kd = K_pT_d \\] <p>\u3053\u3053\u3067\\(T_i\\)\u306f\u7a4d\u5206\u6642\u9593\u3068\u547c\u3070\u308c\\(T_d\\)\u306f\u5fae\u5206\u6642\u9593\u3068\u547c\u3070\u308c\u308b\u3002</p>"},{"location":"tech_note/control/pid/#_1","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u8abf\u6574\u6cd5","text":""},{"location":"tech_note/control/pid/#_2","title":"\u9650\u754c\u611f\u5ea6\u6cd5","text":""},{"location":"tech_note/control/pid/#_3","title":"\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u6cd5","text":""},{"location":"tech_note/control/pid/#chr","title":"CHR\u6cd5","text":""},{"location":"tech_note/control/pid/#_4","title":"\u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7","text":"<p>\u7a4d\u5206\u9805\u304c\u6709\u52b9\u306aPID\u5236\u5fa1\u5668\u306e\u5834\u5408\u3001\u504f\u5dee\u304c\u9577\u3044\u6642\u9593\u306b\u6e21\u3063\u3066\u5b58\u5728\u3059\u308b\u3068\u7a4d\u5206\u5024\u304c\u5927\u304d\u304f\u306a\u308a\u5165\u529b\u91cf\u304c\u98fd\u548c\u3059\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u3053\u308c\u3092\u9632\u3050\u305f\u3081\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b\u3002</p>"},{"location":"tech_note/control/pid/#_5","title":"\u7a4d\u5206\u306e\u505c\u6b62","text":"<p>\u4e00\u756a\u7c21\u5358\u306a\u624b\u6cd5\u3068\u3057\u3066\u7a4d\u5206\u3092\u505c\u6b62\u3055\u305b\u308b\u3053\u3068\u304c\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u308c\u306fPID\u5236\u5fa1\u306e\u51fa\u529b\u304c\u98fd\u548c\u3057\u305f\u3068\u304d\u306b\u306f\u7a4d\u5206\u9805\u3078\u306e\u5165\u529b\u3092\u305d\u308c\u4ee5\u4e0a\u7a4d\u5206\u9805\u304c\u5927\u304d\u304f\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u7c21\u5358\u3067\u3042\u308b\u304c\u4eba\u306b\u3088\u3063\u3066\u5b9f\u88c5\u65b9\u6cd5\u306b\u3086\u3089\u304e\u304c\u51fa\u3084\u3059\u3044</p>"},{"location":"tech_note/control/pid/#_6","title":"\u81ea\u52d5\u6574\u5408","text":"<p>\u81ea\u52d5\u6574\u5408\u3084\u9006\u89e3\u6790\u3068\u547c\u3070\u308c\u308b\u3053\u306e\u624b\u6cd5\u306f\u3001\u7d14\u7c8b\u306aPID\u306e\u51fa\u529b\u3068\u98fd\u548c\u3057\u3066\u5236\u9650\u304c\u304b\u304b\u3063\u305f\u51fa\u529b\u306e\u5dee\u5206\u3092PD\u5236\u5fa1\u5668\u306e\u9006\u30b7\u30b9\u30c6\u30e0\u3092\u901a\u3057\u3066\u7a4d\u5206\u9805\u3078\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b\u5f62\u3092\u53d6\u308b\u3002</p>"},{"location":"tech_note/control/pid/#pid_1","title":"\u901f\u5ea6\u578bPID","text":"<p>\u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3068\u3044\u3046\u308f\u3051\u3067\u306f\u306a\u3044\u304c\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3057\u306a\u3044\u5f62\u306ePID\u5236\u5fa1\u5668\u306e\u5f62\u3068\u3057\u3066\u901f\u5ea6\u578bPID\u304c\u3042\u308b\u3002\u6700\u521d\u306b\u7d39\u4ecb\u3057\u305fPID\u5236\u5fa1\u5668\u306f\u4f4d\u7f6e\u578bPID\u3068\u547c\u3070\u308c\u5bfe\u6bd4\u3055\u308c\u308b\u3002\u901f\u5ea6\u578bPID\u306f\u504f\u5dee\u3092\u4e00\u968e\u5fae\u5206\u3057\u3066PID\u306b\u5165\u529b\u3059\u308b\u3053\u3068\u3067PID\u306e\u4e2d\u304b\u3089\u7a4d\u5206\u8981\u7d20\u3092\u6392\u9664\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u3042\u308b\u3002</p>"},{"location":"tech_note/control/pid/#_7","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>PID\u5236\u5fa1</li> <li>PID\u5236\u5fa1\u3068\u306f\uff1f\u4ed5\u7d44\u307f\u3068\u52d5\u4f5c\u30a4\u30e1\u30fc\u30b8\u3092\u5206\u304b\u308a\u3084\u3059\u304f\u89e3\u8aac\uff01</li> <li>PID\u5236\u5fa1\u5668\u306eAnti-windup</li> </ul>"},{"location":"tech_note/control/pid2/","title":"2\u81ea\u7531\u5ea6PID","text":"<p>2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306bPID\u3092\u4f7f\u7528\u3057\u305f\u3082\u306e\u30922\u81ea\u7531\u5ea6PID\u3068\u547c\u3076\u3002 2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u3068\u306f\u76ee\u6a19\u5024\u3068\u72b6\u614b\u91cf\u306e2\u3064\u306e\u60c5\u5831\u3092\u6271\u3063\u3066\u5236\u5fa1\u3059\u308b\u5236\u5fa1\u7cfb\u3092\u6307\u3059\u3002 \u5358\u7d14\u306aPID\u5236\u5fa1\u7cfb\u306b\u3082\u76ee\u6a19\u5024\u306e\u5165\u529b\u3068\u72b6\u614b\u91cf\u306e\u51fa\u529b\u306f\u5b58\u5728\u3059\u308b\u304cPID\u5236\u5fa1\u5668\u3078\u306e\u5165\u529b\u306f\u305d\u308c\u3089\u306e\u5dee\u5206\u3067\u3042\u308b\u504f\u5dee\u306e\u307f\u3067\u3042\u308b\u305f\u3081\u81ea\u7531\u5ea6\u306f1\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/control/pid2/#2","title":"2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306e\u30d6\u30ed\u30c3\u30af\u56f3","text":"<p>2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306f\u30d6\u30ed\u30c3\u30af\u56f3\u3067\u8003\u3048\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u578b\u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"tech_note/control/pid2/#_1","title":"\u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u578b","text":"<p>\u5165\u529b\u306b\u76ee\u6a19\u5024\u3068\u504f\u5dee\u3092\u53d6\u308b 2\u3064\u306ePID\u306e\u51fa\u529b\u3092\u8db3\u3057\u5408\u308f\u305b\u3066\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3068\u3059\u308b</p> \\[ u_{ff} = K_{pff}r + K_{dff} s r \\\\ u_{fb} = K_{pfb}(r-y) + \\frac{K_i}{s}(r-y) + K_{dfb}s(r-y) \\\\ u = u_{ff} + u_{fb} \\]"},{"location":"tech_note/control/pid2/#_2","title":"\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u578b","text":"<p>\u5165\u529b\u306b\u504f\u5dee\u3068\u72b6\u614b\u91cf\u3092\u53d6\u308b 2\u3064\u306ePID\u306e\u51fa\u529b\u3092\u8db3\u3057\u5408\u308f\u305b\u3066\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3068\u3059\u308b</p>"},{"location":"tech_note/control/pid2/#_3","title":"\u30d5\u30a3\u30eb\u30bf\u30fc\u578b","text":"<p>\u5165\u529b\u306b\u76ee\u6a19\u5024\u3068\u504f\u5dee\u3092\u53d6\u308b \u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u578b\u3068\u9055\u3063\u3066\u76ee\u6a19\u5024\u3092\u5165\u529b\u306b\u53d6\u308b\u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u51fa\u529b\u3068\u72b6\u614b\u91cf\u306e\u5dee\u3092\u504f\u5dee\u3068\u3059\u308b \u504f\u5dee\u3092\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u5165\u529b\u3068\u3057\u3066\u305d\u306e\u51fa\u529b\u3092\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3068\u3059\u308b</p>"},{"location":"tech_note/control/pid2/#_4","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u5171\u901a\u5316","text":"<p>\u4e0a\u8a18\u306e\u3088\u3046\u306b2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u69cb\u9020\u304c\u3042\u308b (\u307e\u3068\u3081\u3066\u6271\u3048\u308b\u3088\u3046\u306b\u304b\u3069\u3046\u304b\u306f\u308f\u304b\u3089\u306a\u3044\u304c)\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u5f62\u306e\u3082\u306e\u304c\u3088\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b</p> \\[ u = K_p(br-y) + \\frac{K_i}{s}(r-y) + K_d s (cr-y) \\]"},{"location":"tech_note/control/pid2/#2pid_1","title":"\u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u578b2\u81ea\u7531\u5ea6PID\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u5171\u901a\u5316","text":"\\[ b = \\frac{K_{pff} + K_{pfb}}{K_{pfb}} \\\\ c = \\frac{K_{dff} + K_{dfb}}{K_{dfb}} \\]"},{"location":"tech_note/control/pid2/#2pid_2","title":"\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u578b2\u81ea\u7531\u5ea6PID\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u5171\u901a\u5316","text":""},{"location":"tech_note/control/pid2/#2pid_3","title":"\u30d5\u30a3\u30eb\u30bf\u30fc2\u81ea\u7531\u5ea6PID\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u5171\u901a\u5316","text":""},{"location":"tech_note/control/pid2/#pidpi-d","title":"\u5fae\u5206\u5148\u884c\u578bPID(PI-D)","text":"<p>\u5fae\u5206\u9805\u3092\u504f\u5dee\u306e\u5fae\u5206\u3067\u306f\u306a\u304f\u72b6\u614b\u91cf\u306e\u5fae\u5206\u306b\u3059\u308b\u3053\u3068\u3067\u76ee\u6a19\u5024\u306e\u6025\u6fc0\u306a\u5909\u5316\u306b\u3088\u308b\u30ad\u30c3\u30af\u306e\u767a\u751f\u3092\u6291\u3048\u308b\u52b9\u679c\u304c\u3042\u308b $$ b = 1 \\ c = 0 $$</p>"},{"location":"tech_note/control/pid2/#pidi-pd","title":"\u6bd4\u4f8b\u5fae\u5206\u5148\u884c\u578bPID(I-PD)","text":"<p>\u6bd4\u4f8b\u9805\u3068\u5fae\u5206\u9805\u3092\u72b6\u614b\u91cf\u304b\u3089\u6c42\u3081\u308b\u3053\u3068\u3067\u30ad\u30c3\u30af\u306e\u767a\u751f\u3092\u6291\u3048\u308b\u52b9\u679c\u304c\u3042\u308b\u3002\u76ee\u6a19\u5024\u306e\u5909\u5316\u306b\u8ffd\u5f93\u3059\u308b\u6210\u5206\u304c\u7a4d\u5206\u9805\u306e\u307f\u306b\u306a\u308b\u305f\u3081\u4fdd\u5b88\u7684\u306a\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u306a\u308b</p> \\[ b = 0 \\\\ c = 0 \\]"},{"location":"tech_note/control/pid2/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>2 \u81ea\u7531\u5ea6 PID \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc</li> <li>2-DOF PID \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc\u306e SISO \u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3078\u306e\u5206\u89e3</li> <li>zpk</li> </ul>"},{"location":"tech_note/control/place/","title":"\u6975\u914d\u7f6e\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af","text":""},{"location":"tech_note/control/place/#_2","title":"\u7c21\u5358\u306a\u30b7\u30b9\u30c6\u30e0\u306e\u624b\u8a08\u7b97\u306b\u3088\u308b\u6975\u914d\u7f6e","text":""},{"location":"tech_note/control/place/#_3","title":"\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308b\u6975\u914d\u7f6e","text":"<p>\u6570\u5024\u8a08\u7b97\u3067\u6975\u914d\u7f6e\u3092\u884c\u3046\u306b\u306fSISO\u30e2\u30c7\u30eb\u306b\u5bfe\u3057\u3066\u306f\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u3068\u3044\u3046\u3082\u306e\u304c\u63d0\u5531\u3055\u308c\u3066\u304d\u305f\u3002</p> <p>\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u65b9\u3067\u306f\u4ee5\u4e0b\u306e\u624b\u9806\u3067\u6975\u914d\u7f6e\u3092\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u6c42\u3081\u308b\u3002</p> <ol> <li>\u914d\u7f6e\u3057\u305f\u3044\u6975\u306e\u5024\u304b\u3089\u7279\u6027\u65b9\u7a0b\u5f0f\u306b\u5c55\u958b\u3059\u308b</li> <li>\u30b7\u30b9\u30c6\u30e0\u306e\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092\u6c42\u3081\u308b</li> <li>\u53ef\u5236\u5fa1\u6027\u884c\u5217\\(U_c\\)\u3068\u30b7\u30b9\u30c6\u30e0\u306e\u9077\u79fb\u884c\u5217\\(A\\)\u3068\u7279\u6027\u65b9\u7a0b\u5f0f\u306e\u4fc2\u6570\\(d_n\\)\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a08\u7b97\u3059\u308b</li> </ol> \\[ \\begin{array}{l} K = [0 &amp; 0 &amp; 0 &amp; \\dots \\ &amp; 1]U_c^{-1}(A^n + d_{n-1}A^{n-1} + \\dots + d_{2}A^{2} + d_{1}A^{1} + d_{0}I) \\end{array} \\] <p>\u3053\u308c\u306b\u3088\u308a\u6c42\u3081\u305f\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\\(K\\)\u3067\\(u = -Kx\\)\u306e\u3088\u3046\u306b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3092\u884c\u3046\u3002</p>"},{"location":"tech_note/control/place/#_4","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6975\u914d\u7f6e\u306e\u5b9f\u88c5\uff1a\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\uff0cEigenvalueStructure\u6cd5\u306eMATLAB\u5b9f\u88c5</li> </ul>"},{"location":"tech_note/control/pole_and_zero/","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975\u30fb\u96f6\u70b9","text":""},{"location":"tech_note/control/pole_and_zero/#_2","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975","text":""},{"location":"tech_note/control/pole_and_zero/#_3","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u96f6\u70b9","text":""},{"location":"tech_note/control/pole_and_zero/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/control/pure_pursuit/","title":"Pure pursuit","text":""},{"location":"tech_note/control/stability/","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027\u3068\u306f</p>"},{"location":"tech_note/control/stability/#_2","title":"\u5b89\u5b9a\u5224\u5225","text":""},{"location":"tech_note/control/stability/#_3","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/filter/extend_kalman_filter/","title":"\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf","text":"<p>\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306f\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u3057\u304b\u6271\u3046\u3053\u3068\u304c\u51fa\u6765\u306a\u304b\u3063\u305f\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306e\u7406\u8ad6\u3092\u975e\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306b\u307e\u3067\u62e1\u5f35\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/filter/extend_kalman_filter/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/filter/kalman_filter/","title":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf","text":"<p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3068\u306f\u7dda\u5f62\u306e\u904b\u52d5\u30e2\u30c7\u30eb\u3068\u89b3\u6e2c\u30e2\u30c7\u30eb\u304b\u3089\u72b6\u614b\u3092\u63a8\u5b9a\u3059\u308b\u30d5\u30a3\u30eb\u30bf\u306e\u4e00\u7a2e\u3067\u3042\u308b</p>"},{"location":"tech_note/filter/kalman_filter/#_2","title":"\u96e2\u6563\u5316\u30e2\u30c7\u30eb","text":"<p>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f\u3067\u96e2\u6563\u5316\u3057\u305f\u7dda\u5f62\u30e2\u30c7\u30eb\u304c\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3068\u3059\u308b\u3002</p> \\[ \\begin{array}{lll} x(t) = Fx(t-1) + Gu(t) + w(t) \\\\ z(t) = Hx(t) + v(t) \\end{array} \\] <p>\u3053\u3053\u3067\u5404\u5909\u6570\u306f\u4ee5\u4e0b\u306e\u901a\u308a \\(x \\in \\mathbb{R}^{n \\times 1}\\) : \u72b6\u614b\u91cf \\(u \\in \\mathbb{R}^{r \\times 1}\\) : \u5236\u5fa1\u91cf \\(z \\in \\mathbb{R}^{p \\times 1}\\) : \u89b3\u6e2c\u91cf \\(F \\in \\mathbb{R}^{n \\times n}\\) : \u72b6\u614b\u9077\u79fb\u884c\u5217 \\(G \\in \\mathbb{R}^{n \\times r}\\) : \u5236\u5fa1\u884c\u5217 \\(H \\in \\mathbb{R}^{p \\times n}\\) : \u89b3\u6e2c\u884c\u5217  </p> <p>\\(Q \\in \\mathbb{R}^{n \\times n}\\) : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 \\(w \\in \\mathbb{R}^{n \\times 1}\\) : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba \\(N[0, Q]\\)\u306b\u5f93\u3046 \\(R \\in \\mathbb{R}^{p \\times p}\\) : \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 \\(v \\in \\mathbb{R}^{p \\times 1}\\) : \u89b3\u6e2c\u30ce\u30a4\u30ba \\(N[0, R]\\)\u306b\u5f93\u3046</p>"},{"location":"tech_note/filter/kalman_filter/#_3","title":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306b\u4e0e\u3048\u305f\u5165\u529b\\(u\\)\u3068\u8aa4\u5dee\u304c\u3042\u308b\u89b3\u6e2c\u91cf\\(z\\)\u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf\\(\\bar{x}\\)\u3092\u63a8\u5b9a\u3059\u308b\u3002</p> <p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306b\u306f\u5927\u304d\u304f\u5206\u3051\u3066\u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7\u3068\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7\u306b\u5206\u3051\u3089\u308c\u308b\u3002</p>"},{"location":"tech_note/filter/kalman_filter/#_4","title":"\u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7","text":""},{"location":"tech_note/filter/kalman_filter/#_5","title":"\u4e8b\u524d\u72b6\u614b\u63a8\u5b9a","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u3092\u4f7f\u3063\u3066\u3001\u524d\u30b9\u30c6\u30c3\u30d7\u306e\u72b6\u614b\u91cf\u3068\u5165\u529b\u91cf\u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf\u304c\u3069\u3046\u306a\u308b\u304b\u3092\u8a08\u7b97\u3059\u308b</p> \\[ \\bar{x} = F\\bar{x} + Gu \\]"},{"location":"tech_note/filter/kalman_filter/#_6","title":"\u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0","text":"<p>\u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\u3067\u72b6\u614b\u3092\u66f4\u65b0\u3057\u305f\u3053\u3068\u306b\u3088\u308b\u72b6\u614b\u306e\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b</p> \\[ P = FPF^T + Q \\]"},{"location":"tech_note/filter/kalman_filter/#_7","title":"\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7","text":""},{"location":"tech_note/filter/kalman_filter/#_8","title":"\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u306e\u8a08\u7b97","text":"<p>\u72b6\u614b\u306e\u4e0d\u78ba\u304b\u3055\u3068\u89b3\u6e2c\u306e\u4e0d\u78ba\u304b\u3055\u304b\u3089\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b</p> \\[ K = PH^T(HPH^T + R)^-1 \\]"},{"location":"tech_note/filter/kalman_filter/#_9","title":"\u72b6\u614b\u63a8\u5b9a","text":"<p>\u8aa4\u5dee\u4ed8\u304d\u306e\u89b3\u6e2c\u91cf\u3068\u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u304b\u3089\u4e88\u6e2c\u3055\u308c\u308b\u89b3\u6e2c\u91cf\u306e\u5dee\u5206\u3092\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3067\u8abf\u6574\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b</p> \\[ \\bar{x} = \\bar{x} + K(z - H\\bar{x}) \\]"},{"location":"tech_note/filter/kalman_filter/#_10","title":"\u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0","text":"<p>\u72b6\u614b\u63a8\u5b9a\u306e\u66f4\u65b0\u306e\u5206\u306e\u72b6\u614b\u91cf\u306e\u4e0d\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b</p> \\[ P = (I -KH)P \\]"},{"location":"tech_note/filter/kalman_filter/#_11","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3063\u3066\u306a\u306b\uff1f</li> <li>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u30fc</li> <li>\u88cf\u53e3\u304b\u3089\u306e\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u5165\u9580 (YouTube)</li> </ul>"},{"location":"tech_note/filter/limitted_filter/","title":"\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u30fb\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf","text":"<p>\u3053\u3053\u3067\u306f\u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u308b\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3068\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u306b\u3064\u3044\u3066\u8aac\u660e\u3092\u3057\u3066\u3044\u304f\u3002</p>"},{"location":"tech_note/filter/limitted_filter/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/filter/tf_filter/","title":"\u4f1d\u9054\u95a2\u6570\u3067\u8868\u73fe\u3055\u308c\u308b\u30d5\u30a3\u30eb\u30bf","text":"\u8aac\u660e \u4f1d\u9054\u95a2\u6570 \u96e2\u6563\u4f1d\u9054\u95a2\u6570(\u53cc\u4e00\u6b21\u5909\u63db) \u7a4d\u5206\u8981\u7d20 \\(\\dfrac{1}{s}\\) \\(\\dfrac{T}{2} \\dfrac{z+1}{z-1}\\) \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{\\omega}{s + \\omega}\\) \\(\\dfrac{T\\omega z + T\\omega}{(T\\omega + 2)z + (T\\omega - 2)}\\) \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{s}{s + \\omega}\\) \\(\\dfrac{2z - 2}{(T\\omega + 2)z + (T\\omega - 2)}\\) \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{2\\zeta\\omega s}{s^2 + 2\\zeta\\omega s + \\omega^2}\\) \\(\\dfrac{(4T\\zeta\\omega)z^2 + (-4T\\zeta\\omega) }{(4+ 4T\\zeta \\omega +T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4-4T\\zeta \\omega + T^2\\omega^2)}\\) \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{s^2 + \\omega^2}{s^2 + 2\\zeta\\omega s + \\omega^2}\\) \\(\\dfrac{(4+T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4+T^2\\omega^2)}{(4+ 4T\\zeta \\omega +T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4-4T\\zeta \\omega + T^2\\omega^2)}\\) \u8aac\u660e \u4f1d\u9054\u95a2\u6570 \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(2\u6b21) \\(\\dfrac{1}{\\tau^2s^2 + \\sqrt{2} \\tau s + 1 }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(3\u6b21) \\(\\dfrac{1}{(\\tau s + 1)(\\tau^2s^2 + \\tau s + 1) }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(4\u6b21) \\(\\dfrac{1}{(\\tau^2s^2 + 0.7654 \\tau s + 1)(\\tau^2s^2 + 1.8478\\tau s + 1) }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(5\u6b21) \\(\\dfrac{1}{(\\tau s + 1)(\\tau^2s^2 + 0.6180\\tau s + 1)(\\tau^2s^2 + 1.6180\\tau s + 1) }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(n\u6b21: n\u304c\u5076\u6570) \\(\\dfrac{1}{ \\prod_{k=1}{\\frac{n}{2}} \\left[ \\tau^2 s^2 -2 \\tau s \\cos \\left( \\dfrac{2k+n-1}{2n}\\pi \\right) + 1 \\right] }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(n\u6b21: n\u304c\u5947\u6570) \\(\\dfrac{1}{ (\\tau s + 1) \\prod_{k=1}{\\frac{n-1}{2}} \\left[ \\tau^2s^2 - 2 \\tau s \\cos \\left( \\dfrac{2k+n-1}{2n}\\pi \\right) + 1 \\right] }\\)"},{"location":"tech_note/filter/tf_filter/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u53cc\u4e00\u6b21\u5909\u63db (Wikipedia)</li> <li>\u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf</li> <li>\u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u578b\u30ed\u30fc\u30d1\u30b9\u30fb\u30d5\u30a3\u30eb\u30bf</li> </ul>"},{"location":"tech_note/geometry/geometry/","title":"\u56f3\u5f62\u306e\u885d\u7a81\u5224\u5b9a","text":""},{"location":"tech_note/kinematics/delta_robot/","title":"\u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8","text":""},{"location":"tech_note/kinematics/delta_robot/#_2","title":"\u9806\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/delta_robot/#_3","title":"\u9006\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/delta_robot/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/kinematics/diff_robot/","title":"\u5dee\u52d5\u4e8c\u8f2a","text":""},{"location":"tech_note/kinematics/diff_robot/#_2","title":"\u9806\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/diff_robot/#_3","title":"\u9006\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/diff_robot/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/kinematics/mecanum/","title":"\u30e1\u30ab\u30ca\u30e0\u79fb\u52d5\u6a5f\u69cb","text":"<p>\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u30e1\u30ab\u30ca\u30e0\u30db\u30a4\u30fc\u30eb\u306e\u6a3d\u306e\u8ef8\u65b9\u5411\u306e\u307f\u306b\u529b\u304c\u4f5c\u7528\u3059\u308b\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\u3068</p> \\[ v_1 \\cos \\frac{\\pi}{4} = - \\dot{x} \\cos \\frac{\\pi}{4} + \\dot{y} \\cos \\frac{\\pi}{4} + l \\dot{\\theta} \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right) \\] <p>\u5f0f\u6574\u7406\u3057\u3066</p> \\[ v_1 = - \\dot{x} + \\dot{y} + (a+b)\\dot{\\theta}  \\] <p>\u3053\u3053\u3067\u53f3\u8fba\u7b2c3\u9805\u306e\\(\\dot{\\theta}\\)\u306b\u3064\u3044\u3066\u306e\u5f0f\u5909\u5f62\u306b\u3064\u3044\u3066\u4e0b\u8a18\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[     \\frac{l \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right)}{\\cos \\frac{\\pi}{4} } \\dot{\\theta}\\\\ \\] <p>\u5206\u5b50\u306b\u52a0\u6cd5\u5b9a\u7406\u3092\u9069\u7528</p> \\[ \\begin{array}{cc}     \\frac{l \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right)}{\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\     \\Leftrightarrow      \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\sin \\frac{\\pi}{4} \\right\\}}     {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\     \\Leftrightarrow      \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\cos \\frac{\\pi}{4} \\right\\}}     {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\     \\Leftrightarrow      l \\left( \\cos \\alpha + \\sin \\alpha \\right) \\dot{\\theta}\\\\     \\Leftrightarrow      l \\left( \\frac{a}{l} + \\frac{b}{l} \\right) \\dot{\\theta}\\\\     \\Leftrightarrow      \\left(a +b \\right) \\dot{\\theta} \\end{array} \\] <p>4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -1 &amp;  1 &amp; (a+b) \\\\ -1 &amp; -1 &amp; (a+b) \\\\  1 &amp; -1 &amp; (a+b) \\\\  1 &amp;  1 &amp; (a+b) \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \\] <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/mecanum/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76     \u53c2\u8003\u6587\u732e\u3068\u306f\u30bf\u30a4\u30e4\u306e\u56de\u8ee2\u65b9\u5411\u306e\u5b9a\u7fa9\u304c\u7570\u306a\u308b\u305f\u3081\u9006\u904b\u52d5\u5b66\u304c\u7570\u306a\u308b\u3053\u3068\u306b\u6ce8\u610f</li> </ul>"},{"location":"tech_note/kinematics/omni/","title":"\u30aa\u30e0\u30cb\u79fb\u52d5\u6a5f\u69cb","text":""},{"location":"tech_note/kinematics/omni/#3","title":"3\u8f2a\u30aa\u30e0\u30cb","text":"<p>\u56f3\u306e\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066</p> \\[ v_1 = - \\dot{x} \\sin \\alpha + \\dot{y} \\cos \\alpha + L \\dot{\\theta} \\] <p>3\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha &amp; \\cos\\alpha &amp; L \\\\ -\\sin \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) &amp; \\cos \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) &amp; L \\\\ -\\sin \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) &amp; \\cos \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) &amp; L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \\] <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/omni/#4","title":"4\u8f2a\u30aa\u30e0\u30cb","text":"<p>\u5404\u8eca\u8f2a\u3054\u3068\u306b\u8003\u3048\u308b\u3053\u3068\u306f3\u8f2a\u30aa\u30e0\u30cb\u3068\u5909\u308f\u3089\u306a\u3044</p> \\[ \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha &amp; \\cos\\alpha &amp; L \\\\ -\\sin \\left( \\alpha + \\dfrac{\\pi}{2} \\right) &amp; \\cos \\left( \\alpha + \\dfrac{\\pi}{2} \\right) &amp; L \\\\ -\\sin \\left( \\alpha + \\pi \\right) &amp; \\cos \\left( \\alpha + \\pi \\right) &amp; L \\\\ -\\sin \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) &amp; \\cos \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) &amp; L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \\] <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/omni/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76</li> </ul>"},{"location":"tech_note/kinematics/swerve/","title":"\u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb","text":"<p>\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u8003\u3048\u308b\u3068</p> \\[ \\vec{v_1} = \\left(      \\dot{x} -r \\dot{\\theta}\\sin{\\theta},      \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right) \\] <p>\u3053\u306e\u6642\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306e\u64cd\u8235\u89d2\u5ea6\u306f</p> \\[ \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}} \\] <p>4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{array}{} \\vec{v_1} = \\left(      \\dot{x} -r \\dot{\\theta}\\sin{\\theta},      \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_2} = \\left(      \\dot{x} -r \\dot{\\theta}\\cos{\\theta},      \\dot{y} -r \\dot{\\theta}\\sin{\\theta} \\right)\\\\ \\vec{v_3} = \\left(      \\dot{x} +r \\dot{\\theta}\\sin{\\theta},      \\dot{y} -r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_4} = \\left(      \\dot{x} +r \\dot{\\theta}\\cos{\\theta},      \\dot{y} +r \\dot{\\theta}\\sin{\\theta} \\right) \\end{array} \\] \\[ \\begin{array}{} \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_2 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} -r \\dot{\\theta}\\cos{\\theta}}\\\\ \\theta_3 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} +r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_4 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} +r \\dot{\\theta}\\cos{\\theta}}\\\\ \\end{array} \\] <p>\u5236\u5fa1\u3059\u308b\u969b\u306b\u306f\u64cd\u8235\u89d2\u306e\u89d2\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b\\(\\theta_j\\)\u3092\u4e0e\u3048\u3001\u30db\u30a4\u30fc\u30eb\u306e\u901f\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b\\(|\\vec{v_j}|\\)\u3092\u4e0e\u3048\u308b\u3002</p> <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/swerve/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76     \u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb\u306e\u9006\u904b\u52d5\u5b66\u306b\u3064\u3044\u3066\u3053\u306e\u30da\u30fc\u30b8\u3068\u53c2\u8003\u6587\u732e\u3067\\(v_1\\)\u306b\u3064\u3044\u3066\u306e\\(\\cos, \\sin\\)\u304c\u7570\u306a\u3063\u3066\u3044\u308b\u7b87\u6240\u304c\u5b58\u5728\u3059\u308b\u304c\u5c0e\u51fa\u3092\u8003\u3048\u308b\u3068\u53c2\u8003\u6587\u732e\u306e\u65b9\u306b\u8aa4\u690d\u304c\u3042\u308b\u3068\u8003\u3048\u3089\u308c\u308b</li> </ul>"},{"location":"tech_note/motor/mabuchi/","title":"\u30de\u30d6\u30c1\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a","text":"<p>\u30de\u30d6\u30c1\u306e\u88fd\u54c1\u30da\u30fc\u30b8\u306b\u306f\u3053\u306e\u3088\u3046\u306b\u6027\u80fd\u8868\u304c\u8f09\u3063\u3066\u3044\u308b\u304c\u3053\u3053\u306e\u60c5\u5831\u304b\u3089\u8a08\u7b97\u3092\u3057\u3066\u9759\u7279\u6027\u3092\u89e3\u6790\u3059\u308b</p> <p></p> <p></p>"},{"location":"tech_note/motor/mabuchi/#_2","title":"\u9759\u7279\u6027","text":"<p>\u9759\u7279\u6027\u306f\u516c\u958b\u3057\u3066\u3042\u308b\u6027\u80fd\u8868\u304b\u3089\u8a08\u7b97\u304c\u51fa\u6765\u308b\u3002\u500b\u4f53\u5024\u3082\u3042\u308b\u306e\u3067\u53c2\u8003\u7a0b\u5ea6</p>"},{"location":"tech_note/motor/mabuchi/#v","title":"\u516c\u79f0\u96fb\u5727[V]","text":"<p>VOLTAGE - NOMINAL</p>"},{"location":"tech_note/motor/mabuchi/#rpm","title":"\u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]","text":"<p>NO LOAD - SPEED</p>"},{"location":"tech_note/motor/mabuchi/#a","title":"\u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]","text":"<p>NO LOAD - CURRENT</p>"},{"location":"tech_note/motor/mabuchi/#a_1","title":"\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41[A]","text":"<p>STALL - CURRENT</p>"},{"location":"tech_note/motor/mabuchi/#_3","title":"\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af","text":"<p>STALL - TORQUE</p>"},{"location":"tech_note/motor/mabuchi/#ohm","title":"\u96fb\u6a5f\u5b50\u62b5\u6297[ohm]","text":"<p>\u516c\u79f0\u96fb\u5727 / \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41</p>"},{"location":"tech_note/motor/mabuchi/#nma","title":"\u30c8\u30eb\u30af\u5b9a\u6570[Nm/A]","text":"<p>\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af / (\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41 - \u7121\u8ca0\u8377\u96fb\u6d41)</p>"},{"location":"tech_note/motor/mabuchi/#vrads","title":"\u9006\u6c17\u96fb\u529b\u5b9a\u6570[V/(rad/s)]","text":"<p>(\u516c\u79f0\u96fb\u5727 - \u96fb\u6a5f\u5b50\u62b5\u6297\u00d7\u7121\u8ca0\u8377\u96fb\u6d41)/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]</p>"},{"location":"tech_note/motor/mabuchi/#nm","title":"\u30c8\u30eb\u30af\u640d\u5931[Nm]","text":"<p>\u7121\u8ca0\u8377\u6642\u96fb\u6d41\u00d7\u30c8\u30eb\u30af\u5b9a\u6570</p>"},{"location":"tech_note/motor/mabuchi/#nms","title":"\u7c98\u6027\u4fc2\u6570[Nms]","text":"<p>\u30c8\u30eb\u30af\u640d\u5931/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]</p>"},{"location":"tech_note/motor/mabuchi/#_4","title":"\u52d5\u7279\u6027","text":"<p>\u52d5\u7279\u6027\u306f\u6027\u80fd\u8868\u304b\u3089\u306f\u308f\u304b\u3089\u306a\u3044\u306e\u3067\u8a08\u6e2c\u3059\u308b</p>"},{"location":"tech_note/motor/mabuchi/#h","title":"\u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H]","text":""},{"location":"tech_note/motor/mabuchi/#s","title":"\u96fb\u6c17\u7684\u6642\u5b9a\u6570[s]","text":"<p>\u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9/\u96fb\u6a5f\u5b50\u62b5\u6297</p>"},{"location":"tech_note/motor/mabuchi/#kgm2","title":"\u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2]","text":"<p>\u52d5\u7279\u6027\u306f\u6027\u80fd\u8868\u304b\u3089\u306f\u308f\u304b\u3089\u306a\u3044\u306e\u3067\u8a08\u6e2c\u3059\u308b</p>"},{"location":"tech_note/motor/mabuchi/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>RS-555VC-3754</li> </ul>"},{"location":"tech_note/motor/motor_model/","title":"\u30e2\u30fc\u30bf\u30fc\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe","text":"\\[ \\begin{array}{l} \\frac{\\rm{d}}{\\rm{dt}} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} = \\begin{bmatrix} -\\frac{R}{L} &amp; -\\frac{K_e}{L} \\\\ \\frac{K_t}{J} &amp; 0 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} +  \\begin{bmatrix} \\frac{1}{L}\\\\ 0 \\end{bmatrix} V(t) \\\\ y(t) = \\begin{bmatrix} 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} \\end{array} \\]"},{"location":"tech_note/motor/motor_model/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u73fe\u4ee3\u5236\u5fa1 2\u6b21\u30b7\u30b9\u30c6\u30e0(RL\u56de\u8def+\u30e2\u30fc\u30bf\u30fc)\u306e\u72b6\u614b\u65b9\u7a0b\u5f0f</li> </ul>"},{"location":"tech_note/optimal_control/linear_mpc/","title":"\u6642\u4e0d\u5909\u7dda\u5f62MPC","text":""},{"location":"tech_note/optimal_control/linear_mpc/#_1","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/optimal_control/mpc/","title":"\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1","text":""},{"location":"tech_note/optimal_control/mpc/#mpc","title":"\u7dda\u5f62\u30e2\u30c7\u30ebMPC","text":""},{"location":"tech_note/optimal_control/mpc/#mpcnmpc","title":"\u975e\u7dda\u5f62\u30e2\u30c7\u30ebMPC(NMPC)","text":""},{"location":"tech_note/optimal_control/mpc/#cgmres","title":"C/GMRES\u6cd5","text":""},{"location":"tech_note/optimal_control/mpc/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580</li> <li>Model Predictive Control:MPC (\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1)\u306e\u6280\u8853\u5206\u985e</li> <li>\u30b7\u30f3\u30d7\u30eb\u306aMPC\u6700\u9069\u5316\u30e2\u30c7\u30ea\u30f3\u30b0\u306e\u6570\u5f0f\u5c0e\u51fa\u3068Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9</li> </ul>"},{"location":"tech_note/optimal_control/optimal_control/","title":"\u6700\u9069\u5236\u5fa1","text":""},{"location":"tech_note/optimal_control/optimal_control/#_2","title":"\u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f","text":"<p>\u30b7\u30b9\u30c6\u30e0\u30fb\u521d\u671f\u72b6\u614b\u30fb\u8a55\u4fa1\u95a2\u6570\u304c\u4e0e\u3048\u3089\u308c\u305f\u6642\u306b\u8a55\u4fa1\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u6700\u9069\u306a\u5236\u5fa1\u5165\u529b\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6\u3002\u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308bKKT\u6761\u4ef6\u3068\u8003\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_3","title":"\u52d5\u7684\u8a08\u753b\u6cd5","text":"<p>\u52d5\u7684\u8a08\u753b\u6cd5\u3067\u306f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5206\u91ce\u3067\u306f\u5bfe\u8c61\u3068\u306a\u308b\u554f\u984c\u3092\u8907\u6570\u306e\u90e8\u5206\u554f\u984c\u306b\u5206\u5272\u3057\u3001\u90e8\u5206\u554f\u984c\u306e\u8a08\u7b97\u7d50\u679c\u3092\u8a18\u9332\u3057\u306a\u304c\u3089\u89e3\u3044\u3066\u3044\u304f\u624b\u6cd5\u306e\u7dcf\u79f0\u3092\u6307\u3059\u3002 \u6700\u9069\u5236\u5fa1\u306b\u304a\u3051\u308b\u52d5\u7684\u8a08\u753b\u6cd5\u3068\u306f\u8a55\u4fa1\u95a2\u6570\u306e\u6700\u5c0f\u5024\u3092\u518d\u5e30\u7684\u306b\u8868\u3059\u624b\u6cd5\u306e\u3053\u3068\u3092\u6307\u3059\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_4","title":"\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f","text":"<p>\u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u3063\u3066\u8868\u3055\u308c\u305f\u5024\u95a2\u6570\u306e\u518d\u5e30\u4e00\u56de\u5206\u3092\u53d6\u308a\u51fa\u3057\u305f\u6642\u523bk\u3068\u6642\u523bk+1\u306e\u5024\u95a2\u6570\u306e\u95a2\u4fc2\u5f0f\u3002\u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f\u306b\u3088\u3063\u3066\u6700\u9069\u5236\u5fa1\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6\u304c\u5c0e\u304b\u308c\u308b\u304c\u3001\u6700\u9069\u5236\u5fa1\u554f\u984c\u304c\u6301\u3064\u6642\u9593\u7684\u306a\u69cb\u9020\u3092\u4f7f\u3046\u3053\u3068\u3067\u5c0e\u304b\u308c\u308b\u5225\u306e\u5f62\u306e\u6700\u9069\u6027\u6761\u4ef6\u304c\u3053\u306e\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u3067\u8868\u3055\u308c\u308b\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_5","title":"\u6700\u9069\u5236\u5fa1\u306e\u5fc5\u8981\u6761\u4ef6","text":"<p>\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u306e\u7d42\u7aef\u6761\u4ef6\u306e\u3082\u3068\u3067\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u304c\u6210\u7acb\u3059\u308b</p>"},{"location":"tech_note/optimal_control/optimal_control/#_6","title":"\u6700\u9069\u5236\u5fa1\u306e\u5341\u5206\u6761\u4ef6","text":""},{"location":"tech_note/optimal_control/optimal_control/#_7","title":"\u5909\u5206\u6cd5","text":"<p>\u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u6700\u9069\u5236\u5fa1\u306b\u304a\u3044\u3066\u57fa\u790e\u3068\u306a\u308b\u3001\u95a2\u6570\u306e\u5fae\u5206\u3092\u6c4e\u95a2\u6570\u306b\u62e1\u5f35\u3057\u305f\u3082\u306e\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_8","title":"\u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5","text":"<p>\u4ee5\u4e0b\u306e\u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5\u306f\u30b7\u30b9\u30c6\u30e0\u304c\u9023\u7d9a\u6642\u9593\u3067\u3082\u96e2\u6563\u6642\u9593\u3067\u3082\u96e2\u6563\u7684\u306b\u6c42\u3081\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u96e2\u6563\u30b7\u30b9\u30c6\u30e0\u306e\u5834\u5408\u306f\u6570\u5024\u7684\u306b\u7a4d\u5206\u64cd\u4f5c\u3092\u884c\u3046\u306a\u3069\u306e\u64cd\u4f5c\u304c\u767a\u751f\u3059\u308b\u3002</p> \u6570\u5024\u89e3\u6cd5 \u9577\u6240 \u77ed\u6240 \u9069\u3059\u308b\u7528\u9014 \u52fe\u914d\u6cd5 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u4e0d\u8981 \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u9045\u3044 \u6700\u9069\u89e3\u306e\u304a\u304a\u3088\u305d\u306e\u69d8\u5b50\u3092\u624b\u8efd\u306b\u77e5\u308a\u305f\u3044\u6642 \u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5 \u672a\u77e5\u91cf\u304c\u6709\u9650\u6b21\u5143 \u8a08\u7b97\u304c\u767a\u6563\u3057\u3084\u3059\u3044 \u826f\u597d\u306a\u521d\u671f\u63a8\u5b9a\u89e3\u3092\u9078\u3079\u308b\u6642 \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(2\u6b21\u306e\u52fe\u914d\u6cd5) \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u901f\u3044 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u5fc5\u8981\u3067\u5404\u53cd\u5fa9\u306b\u304a\u3051\u308b\u8a08\u7b97\u91cf\u304c\u591a\u3044 \u6700\u9069\u89e3\u3092\u7cbe\u5ea6\u826f\u304f\u6c42\u3081\u305f\u3044\u6642 \u52d5\u7684\u8a08\u753b\u6cd5 \u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u304c\u5f97\u3089\u308c\u308b \u72b6\u614b\u306e\u6b21\u5143\u304c\u9ad8\u3044\u3068\u8a18\u61b6\u91cf\u304c\u81a8\u5927 \u72b6\u614b\u306e\u6b21\u5143\u304c\u4f4e\u3044\u304b\u3001\u72ed\u3044\u7bc4\u56f2\u3060\u3051\u8003\u616e\u3059\u308c\u3070\u826f\u3044\u6642"},{"location":"tech_note/optimal_control/optimal_control/#_9","title":"\u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5)","text":"<p>\u30cf\u30df\u30eb\u30c8\u30f3\u95a2\u6570\u306e\u5236\u5fa1\u5165\u529b\u504f\u5fae\u5206\\(\\frac{\\partial H}{\\partial u}\\)\u304c0\u306b\u306a\u308b\u307e\u3067\\(-\\frac{\\partial H}{\\partial u}\\)\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3001\u76f4\u7dda\u7dda\u63a2\u7d22\u3068\u7d44\u307f\u5408\u308f\u305b\u3066\\(u\\)\u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u3002\u968f\u4f34\u5909\u6570\u306f\u968f\u4f34\u65b9\u7a0b\u5f0f\u304b\u3089\\(\\frac{\\partial H}{\\partial x}\\)\u3092\u4f7f\u3063\u3066\u6c42\u3081\u308b\u3002\u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u5236\u5fa1\u91cf\\(u\\)\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_10","title":"\u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5","text":"<p>\u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u521d\u671f\u5024\u304b\u3089\u72b6\u614b\u91cf\u3092\u64cd\u4f5c\u3057\u3001\u7d42\u7aef\u6761\u4ef6\u3092\u5408\u308f\u305b\u306b\u3044\u304f\u69d8\u304c\u5c04\u6483\u306b\u4f3c\u3066\u3044\u308b\u3053\u3068\u304b\u3089\u3053\u306e\u540d\u304c\u3064\u3051\u3089\u308c\u305f\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_11","title":"\u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5","text":"<p>\u958b\u59cb\u6642\u9593\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u306e\u521d\u671f\u5024\u3092\u4e0e\u3048\u3001\u521d\u671f\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6761\u4ef6\u3068\u3057\u3066\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3092\u7d42\u7aef\u6642\u9593\u307e\u3067\u89e3\u304d\u3001\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6c42\u3081\u308b\u3002\u305d\u306e\u5f8c\u65b9\u7a0b\u5f0f\u304b\u3089\u5236\u5fa1\u91cf\u304c\u6c42\u307e\u308b\u3002\u7d42\u7aef\u6642\u523b\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u304c\\(\\frac{\\partial \\phi}{\\partial x}\\)\u306b\u5341\u5206\u306b\u8fd1\u3065\u304f\u307e\u3067\u968f\u4f34\u5909\u6570\u3092\u66f4\u65b0\u3059\u308b\u3002 \u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u968f\u4f34\u5909\u6570\\(\\lambda\\)\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#ddpdifferential-dynamic-programming","title":"DDP(Differential Dynamic Programming)","text":""},{"location":"tech_note/optimal_control/optimal_control/#ilqrinteractive-linear-quadratic-regulator","title":"iLQR(interactive Linear Quadratic Regulator)","text":""},{"location":"tech_note/optimal_control/optimal_control/#slqsequential-linear-quadratic-regulator","title":"SLQ(Sequential Linear Quadratic Regulator)","text":"\u6570\u5024\u89e3\u6cd5 \u53cd\u5fa9\u306b\u304a\u3051\u308b\u64cd\u4f5c\u91cf \u7279\u5fb4 \u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5 \u968f\u4f34\u5909\u6570 iLQR \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c\u30ac\u30a6\u30b9\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 DDP \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c2\u6b21\u8fd1\u4f3c\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 SLQ \u5236\u5fa1\u5165\u529b ???"},{"location":"tech_note/optimal_control/optimal_control/#_12","title":"\u5165\u529b\u91cf\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5)\u306b\u304a\u3044\u3066\u306ft\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\u306b\\(\\frac{\\partial H}{\\partial u}\\)\u3092\u4f7f\u7528\u3057\u305f\u304c\u3053\u308c\u306f\u6700\u9069\u5316\u554f\u984c\u30921\u6b21\u8fd1\u4f3c\u3057\u53cd\u5fa9\u306b\u3088\u3063\u3066\u6700\u9069\u89e3\u3092\u6c42\u3081\u3066\u3044\u308b\u3002\u306a\u3089\u3070\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3066\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u89e3\u304f\u3053\u3068\u3082\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u306e\u65b9\u6cd5\u3067\u306f\u7dda\u5f62\uff12\u70b9\u5883\u754c\u5024\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3067\\(\\delta x\\)\u3001\\(\\delta \\lambda\\)\u304c\u6c42\u3081\u3089\u308c\u305d\u3053\u304b\u3089\\(\\delta u\\)\u304c\u6c42\u3081\u3089\u308c\u308b\u305f\u3081\\(\\delta u\\)\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_13","title":"\u52d5\u7684\u8a08\u753b\u6cd5","text":""},{"location":"tech_note/optimal_control/optimal_control/#_14","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580</li> <li>Differential Dynamic Programming(DDP)/iterative LQR(iLQR)/Sequential LQR(SLQ)</li> </ul>"},{"location":"tech_note/optimize/active_set_method/","title":"\u6709\u52b9\u5236\u7d04\u6cd5","text":"<p>\u6709\u52b9\u5236\u7d04\u6cd5\u3068\u306f\u7dda\u5f62\u5236\u7d04\u3092\u6301\u3064\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b</p>"},{"location":"tech_note/optimize/algo_abst/","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u6982\u8981","text":"<p>\u3053\u3053\u3067\u306f\u5909\u6570\u30fb\u5236\u7d04\u306b\u53d6\u308b\u5024\u304c\u6574\u6570\u306b\u5236\u9650\u3055\u308c\u306a\u3044\u6700\u9069\u5316\u554f\u984c\u306b\u3064\u3044\u3066\u6982\u8981\u3092\u307e\u3068\u3081\u308b</p>"},{"location":"tech_note/optimize/algo_abst/#_2","title":"\u5358\u4f53\u6cd5(\u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5)","text":"<p>\u7dda\u5f62\u8a08\u753b\u554f\u984c\u3067\u4f7f\u7528\u3055\u308c\u308bDantzig\u306b\u3088\u3063\u3066\u63d0\u6848\u3055\u308c\u305f\u624b\u6cd5\u3002\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5883\u754c\u306b\u6cbf\u3063\u3066\u89e3\u3092\u66f4\u65b0\u3059\u308b\u3002\u5f8c\u306b\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u304c\u63d0\u6848\u3057\u305f\u591a\u9805\u5f0f\u6642\u9593\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u6955\u5186\u4f53\u6cd5\u306b\u3088\u3063\u3066\u666e\u53ca\u3057\u305f\u5185\u70b9\u6cd5\u3068\u4e26\u3093\u3067\u5e83\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b\u3002</p> <p>\u5358\u4f53\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u3001Dantzig\u304c\u63d0\u6848\u3057\u305f\u7279\u6b8a\u306a\u56f3\u89e3\u6cd5\u306b\u304a\u3044\u3066\u306f\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u9032\u884c\u306b\u5f93\u3063\u3066\u5358\u4f53\u304c\u4e0b\u306b\u843d\u3061\u3066\u3044\u304f\u3088\u3046\u306b\u898b\u3048\u308b\u3053\u3068\u306b\u7531\u6765\u3059\u308b\u3002</p> \\[ \\begin{array} \\text{max } \\space z = Cx \\\\ \\text{s.t.} \\space Ax &lt; b \\end{array} \\]"},{"location":"tech_note/optimize/algo_abst/#_3","title":"\u6709\u52b9\u5236\u7d04\u6cd5","text":"<p>\u6709\u52b9\u5236\u7d04\u6cd5\u306f\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\u7528\u3044\u3089\u308c\u308b\u3002</p> \\[ \\begin{array} \\text{min } \\space f(x) = \\frac{1}{2}x^TQx + cx \\\\ \\text{s.t.} \\space a_i^T x \\geq b_i \\end{array} \\]"},{"location":"tech_note/optimize/algo_abst/#_4","title":"\u5185\u70b9\u6cd5","text":"<p>\u30d0\u30ea\u30a2\u6cd5\u306e\u3088\u3046\u306a\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5185\u90e8\u3092\u9032\u3080\u3088\u3046\u306b\u89e3\u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u306e\u7dcf\u79f0 \u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u306a\u3044\u5834\u5408\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u89e3\u3092\u79fb\u52d5\u3055\u305b\u308b\u624b\u6bb5\u304c\u5fc5\u8981\u306b\u306a\u308b</p> <p>\u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u65b9\u6cd5\u306b\u3088\u3063\u3066\u3001\u30a2\u30d5\u30a3\u30f3\u5909\u63db\u6cd5\u3001\u30dd\u30c6\u30f3\u30b7\u30e3\u30eb\u6e1b\u5c11\u6cd5\u3001\u30d1\u30b9\u8ffd\u8de1\u6cd5\u306a\u3069\u306b\u5206\u985e\u3055\u308c\u308b</p> <p>\u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u3092\u76f4\u63a5\u6271\u3046\u65b9\u6cd5(\u4e3b\u5185\u70b9\u6cd5)\u3001\u305d\u306e\u53cc\u5bfe\u554f\u984c\u3092\u6271\u3046\u65b9\u6cd5(\u53cc\u5bfe\u5185\u70b9\u6cd5)\u3001\u4e3b\u554f\u984c\u3068\u53cc\u5bfe\u554f\u984c\u3092\u540c\u6642\u306b\u89e3\u304f\u65b9\u6cd5(\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5)\u306b\u5206\u3051\u3089\u308c\u308b</p>"},{"location":"tech_note/optimize/algo_abst/#_5","title":"\u4e3b\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#_6","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#_7","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#_8","title":"\u5916\u70b9\u6cd5","text":"<p>\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u306b\u4ee3\u8868\u3055\u308c\u308b\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u306e\u53cd\u5fa9\u3092\u8a31\u3059\u624b\u6cd5\u306e\u7dcf\u79f0 \u5185\u70b9\u6cd5\u3068\u7570\u306a\u308a\u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u3042\u3063\u3066\u3082\u53cd\u5fa9\u8a08\u7b97\u304c\u53ef\u80fd\u3067\u3042\u308b\u304c\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u306e\u30b9\u30b1\u30fc\u30eb\u8abf\u6574\u306b\u3088\u3063\u3066\u306f\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u53ce\u675f\u3059\u308b\u5834\u5408\u304c\u3042\u308b</p>"},{"location":"tech_note/optimize/algo_abst/#sqp","title":"\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(SQP\u6cd5)","text":"<p>NLP\u554f\u984c\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0</p> <ul> <li>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u89e3\u304f\u624b\u6cd5</li> <li>\u4fe1\u983c\u9818\u57df\u6cd5\u306b\u3088\u308a\u89e3\u304f\u624b\u6cd5</li> <li>\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP)</li> <li>\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP)</li> </ul> <p>\u306a\u3069\u304c\u3042\u308b \u57fa\u672c\u7684\u306b\u9055\u3044\u306f\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3059\u308b\u65b9\u6cd5\u3068\u3001\u8fd1\u4f3c\u3057\u305f\u4e8c\u6b21\u554f\u984c\u304b\u3089\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u5b9a\u3059\u308b\u65b9\u6cd5\u3078\u306e\u9055\u3044</p>"},{"location":"tech_note/optimize/algo_abst/#_9","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u4ee3\u308f\u308a\u306bBFGS\u6cd5\u3067\u8fd1\u4f3c\u3057\u305fB\u884c\u5217\u3092\u4f7f\u7528\u3057\u305fQP\u554f\u984c\u3092\u4f5c\u6210\u3057\u3001\u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f</p>"},{"location":"tech_note/optimize/algo_abst/#_10","title":"\u4fe1\u983c\u9818\u57df\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#slp-sqp-slqp","title":"\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP, SLQP)","text":"<p>\u5236\u7d04\u5145\u8db3\u306e\u305f\u3081\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u76ee\u7684\u95a2\u6570\u5024\u6700\u5c0f\u5316\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u3044\u3046\u4e8c\u3064\u306e\u30d5\u30a7\u30fc\u30ba\u304b\u3089\u69cb\u6210\u3055\u308c\u308b\u4ed6\u306eSQP\u6cd5\u3068\u306f\u6bdb\u8272\u304c\u9055\u3046\u6700\u9069\u5316\u624b\u6cd5</p>"},{"location":"tech_note/optimize/algo_abst/#slsqp","title":"\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP)","text":"<p>\u300c\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5\u300d\u3068\u3044\u3046\u65e5\u672c\u8a9e\u8a33\u306f\u3042\u3063\u3066\u306a\u3044\u304b\u65e5\u672c\u8a9e\u8a33\u304c\u5f53\u3066\u3089\u308c\u3066\u3044\u306a\u3044\u53ef\u80fd\u6027\u304c\u3042\u308b MATLAB\u3084Scipy\u3067\u5c0e\u5165\u3055\u308c\u3066\u3044\u308bSLSQP\u306f1988\u5e74Kraft\u3089\u306e\u767a\u8868\u3057\u305f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u540c\u68b1\u3055\u308c\u8a00\u8a9e\u306fFortran \u8ad6\u6587\u30bf\u30a4\u30c8\u30eb\u306f\u4ee5\u4e0b</p> <p>Kraft, D. A software package for sequential quadratic    programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace    Center -- Institute for Flight Mechanics, Koln, Germany.</p>"},{"location":"tech_note/optimize/algo_abst/#_11","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6700\u9069\u5316\u554f\u984c</li> <li>\u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5</li> <li>B.2 \u5358\u4f53\u6cd5\u30fb\u6709\u52b9\u5236\u7d04\u6cd5</li> <li>\u5185\u70b9\u6cd5<ul> <li>\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> <li>B.1 \u5185\u70b9\u6cd5</li> </ul> </li> <li>B.7 \u5916\u70b9\u6cd5</li> <li>B.3 \u9010\u6b21\u4e8c\u6b21\u8a08\u753b\uff08SQP\uff09\u6cd5<ul> <li>SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066</li> </ul> </li> </ul>"},{"location":"tech_note/optimize/barrier_method/","title":"\u30d0\u30ea\u30a2\u6cd5","text":"<p>\u30d0\u30ea\u30a2\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u76ee\u7684\u95a2\u6570\u306b\u5236\u7d04\u306e\u8a55\u4fa1\u5024\u306b\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5024\u3092\u8db3\u3057\u3066\u5236\u7d04\u306a\u3057\u306e\u6700\u9069\u5316\u554f\u984c\u3068\u3057\u3066\u89e3\u304f\u5185\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b</p>"},{"location":"tech_note/optimize/benchmark_cont/","title":"\u9023\u7d9a\u95a2\u6570\u6700\u9069\u5316\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570","text":"<p>\u6700\u9069\u5316\u624b\u6cd5\u306e\u6bd4\u8f03\u306a\u3069\u306b\u4f7f\u7528\u3055\u308c\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u7528\u306e\u95a2\u6570\u306f\u4ee5\u4e0b\u3092\u8003\u616e\u3057\u3066\u4f5c\u3089\u308c\u305f\u3082\u306e\u304c\u591a\u3044\u3002</p> <ul> <li>\u5909\u6570\u306b\u3088\u3063\u3066\u53d6\u308b\u7bc4\u56f2\u304c\u9055\u3046(\u60aa\u30b9\u30b1\u30fc\u30eb\u6027)</li> <li>\u5909\u6570\u304c\u72ec\u7acb\u3067\u306a\u304f\u5909\u6570\u3054\u3068\u306e\u95a2\u6570\u306e\u548c\u3068\u3057\u3066\u8868\u73fe\u3067\u304d\u306a\u3044(\u5909\u6570\u9593\u4f9d\u5b58\u6027)</li> <li>\u5c40\u6240\u89e3\u304c\u6ca2\u5c71\u5b58\u5728\u3059\u308b\u3082\u306e(\u591a\u5cf0\u6027)</li> </ul> <p>\u4f8b\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u95a2\u6570\u304c\u6319\u3052\u3089\u308c\u308b\u3002</p> <ul> <li>Sphere\u95a2\u6570</li> <li>Ellipsoid\u95a2\u6570</li> <li>k-tablet\u95a2\u6570</li> <li>Rosenbrock\u95a2\u6570(star\u578b/chain\u578b)</li> <li>Bohachevsky\u95a2\u6570</li> <li>Ackley\u95a2\u6570</li> <li>Scaffer\u95a2\u6570</li> <li>Rastrign\u95a2\u6570</li> </ul>"},{"location":"tech_note/optimize/benchmark_cont/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6700\u9069\u5316\u624b\u6cd5\u8a55\u4fa1\u306e\u305f\u3081\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u3010Python\u30d7\u30ed\u30b0\u30e9\u30e0\u4ed8\u3011</li> <li>\u6700\u9069\u5316\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8a55\u4fa1\u3059\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u307e\u3068\u3081</li> </ul>"},{"location":"tech_note/optimize/conj_grad/","title":"\u6700\u6025\u964d\u4e0b\u6cd5","text":"<p>\u6700\u6025\u964d\u4e0b\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u306e\u9006\u65b9\u5411\u306b\u5909\u6570\u306e\u66f4\u65b0\u65b9\u5411\u3092\u53d6\u308a\u3001\u505c\u7559\u70b9\u306b\u53ce\u675f\u3059\u308b\u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u3002\u63a2\u7d22\u65b9\u5411\u306e\u53d6\u308a\u3046\u308b\u4e2d\u3067\u4e00\u756a\u52fe\u914d\u304c\u6025\u306a\u65b9\u5411\u306b\u66f4\u65b0\u3057\u7d9a\u3051\u308b\u305f\u3081\u3053\u306e\u540d\u304c\u3064\u3044\u305f</p> <p>\u6700\u9069\u5316\u306e\u53cd\u5fa9\u6cd5\u306b\u304a\u3051\u308b\u89e3\u306e\u66f4\u65b0\u5247\u306f</p> \\[ \\bf{x}^{(k+1)} = \\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)} \\] <p>\u6700\u6025\u964d\u4e0b\u6cd5\u3067\u306f\u63a2\u7d22\u65b9\u5411\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u53d6\u308b</p> \\[ \\bf{d}^{(k)} = -\\Delta f(\\bf{x}^{(k)}) \\] <p>\u63a2\u7d22\u65b9\u5411\u6c7a\u5b9a\u5f8c\u306f\u30b9\u30c6\u30c3\u30d7\u5e45\u30921\u306b\u56fa\u5b9a\u3059\u308b\u304b\u76f4\u7dda\u63a2\u7d22\u3092\u5225\u9014\u884c\u3044\u89e3\u3092\u66f4\u65b0\u3059\u308b</p>"},{"location":"tech_note/optimize/conj_grad/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/derivative/","title":"\u6570\u5024\u5fae\u5206\u6cd5","text":""},{"location":"tech_note/optimize/derivative/#1","title":"1\u968e\u5dee\u5206\u6cd5","text":"<p>\u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e1\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5</p> <p>\u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u65b9\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044</p> \\[ \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_{i+1} - f_{i-1}}{2\\Delta x}  \\] <p>\u3053\u306e\u4ed6\u7c21\u5358\u306a\u65b9\u6cd5\u3068\u3057\u3066\u306f\u5f8c\u9000\u5dee\u5206\u6cd5\u304c\u3042\u308b</p> \\[ \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_i - f_{i-1}}{\\Delta x}  \\]"},{"location":"tech_note/optimize/derivative/#2","title":"2\u968e\u5dee\u5206\u6cd5","text":"<p>\u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e2\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5</p> <p>\u3053\u308c\u3082\u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u6cd5\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044</p> \\[ \\left(\\frac{\\partial^2 f}{\\partial^2 x}\\right)_i = \\frac{f_{i+1} - 2f_{i} + f_{i-1}}{\\Delta x^2}  \\]"},{"location":"tech_note/optimize/interior_method/","title":"\u5185\u70b9\u6cd5","text":""},{"location":"tech_note/optimize/interior_method/#_2","title":"\u4e3b\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/interior_method/#_3","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/interior_method/#_4","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/interior_method/#hpipmhigh-performance-interior-point-method","title":"HPIPM(High Performance Interior Point Method)","text":""},{"location":"tech_note/optimize/interior_method/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u51f8\u6700\u9069\u5316\u306e\u6982\u8981\u3068\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac</li> <li>\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5</li> <li>\uff12\u6b21\u8a08\u753b\u554f\u984c\u3068\u5185\u70b9\u6cd5</li> <li>\u6570\u7406\u6700\u9069\u5316\u3092\u3057\u3063\u304b\u308a\u5b66\u3076\u305f\u3081\u306b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3068\u305d\u308c\u3092\u4f7f\u3063\u305fSVM\u3092\u5b9f\u88c5</li> </ul>"},{"location":"tech_note/optimize/kkt_condition/","title":"KKT\u6761\u4ef6","text":""},{"location":"tech_note/optimize/kkt_condition/#1","title":"\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027","text":"\\[ \\begin{array}{} \\text{min} \\space  f(x)\\\\ \\text{s.t.} \\space  g_i(x) = 0, \\space i = 0, \\dots , m\\\\ x \\in \\mathbb{R}^n \\end{array} \\] <p>\u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9\\(x^*\\)\u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\\(u^*\\)\u304c\u5b58\u5728\u3059\u308b</p> \\[ \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0 \\] <p>Note</p> <p>\u70b9\\(x\\)\u306b\u304a\u3044\u3066\\(\\nabla g_1(x), \\dots ,\\nabla g_m(x)\\)\u304c\u4e92\u3044\u306b1\u6b21\u72ec\u7acb\u306a\u3089\u3070\u70b9\\(x\\)\u306f\u6b63\u5247\u3067\u3042\u308b\u3068\u3044\u3046</p>"},{"location":"tech_note/optimize/kkt_condition/#1_1","title":"\u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027","text":"\\[ \\begin{array}{} \\text{\\rm min} \\space  f(x)\\\\ \\text{s.t.} \\space  g_i(x) \\leq 0, \\space i = 0, \\dots , m\\\\ x \\in \\mathbb{R}^n \\end{array} \\] <p>\u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9\\(x^*\\)\u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\\(u^*\\)\u304c\u5b58\u5728\u3059\u308b</p> \\[ \\begin{array}{} \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0\\\\ u_i^* g_i(x^*) = 0, \\space i = 0, \\dots , m\\\\ u_i^* \\geq 0, \\space i = 0, \\dots , m \\end{array} \\] <p>2\u5f0f\u76ee\u306f\u76f8\u88dc\u6027\u6761\u4ef6\u3068\u547c\u3070\u308c\u308b\u3002\\(g_i(x^*)\\)\u304c\u6709\u52b9\u306a\u6642\u306f\\(g_i(x^*)=0\\)\u3068\u306a\u308a, \u6709\u52b9\u3067\u306a\u3044\u5834\u5408\u306f\\(u_i^*=0\\)\u3068\u306a\u308b\u3002</p>"},{"location":"tech_note/optimize/kkt_condition/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/least_squares_method/","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5","text":""},{"location":"tech_note/optimize/least_squares_method/#_2","title":"\u5236\u7d04\u306a\u3057\u306e\u5834\u5408\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5","text":"\\[ \\underset{x}{\\text{min}} || Cx -d ||^2 \\] <p>\u306b\u3064\u3044\u3066\u89e3\u306f</p> \\[ x = (C^TC)^{-1}C^Td \\]"},{"location":"tech_note/optimize/least_squares_method/#_3","title":"\u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5","text":""},{"location":"tech_note/optimize/least_squares_method/#_4","title":"\u7dda\u5f62\u7b49\u5f0f\u30fb\u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5","text":""},{"location":"tech_note/optimize/least_squares_method/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b</li> <li>\u5236\u7d04\u4ed8\u304d\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b</li> <li>Conversion from least squares to quadratic programming</li> <li>lsqlin</li> <li>\u6700\u5c0f\u4e8c\u4e57 (\u30e2\u30c7\u30eb\u5f53\u3066\u306f\u3081) \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/optimize/line_search/","title":"\u76f4\u7dda\u63a2\u7d22","text":"<p>\u9023\u7d9a\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b\u9010\u6b21\u6700\u9069\u5316\u306b\u304a\u3044\u3066\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u3081\u305f\u5f8c\u306b\u3069\u308c\u3060\u3051\u305d\u306e\u65b9\u5411\u306b\u9032\u3080\u304b\u306e\u30b9\u30c6\u30c3\u30d7\u30b5\u30a4\u30ba\u3092\u6c7a\u5b9a\u3059\u308b\u624b\u6cd5</p> <p>\u76ee\u7684\u95a2\u6570\\(f\\)\u306b\u5bfe\u3057\u3066\\(g\\)\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3057\u3001\\(\\alpha\\)\u306b\u3064\u3044\u3066\u6700\u5c0f\u5316\u3059\u308b\u3053\u3068\u3092\u76ee\u7684\u3068\u3059\u308b</p> \\[ g(\\alpha) = f(\\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)}) \\]"},{"location":"tech_note/optimize/line_search/#_2","title":"\u56f2\u3044\u8fbc\u307f\u6cd5","text":"<p>\u30b9\u30c6\u30c3\u30d7\u5e45\u30921\u304b\u3089\u958b\u59cb\u3057\u53cd\u5fa9\u3054\u3068\u306b0\u3088\u308a\u5927\u304d\u304f1\u3088\u308a\u5c0f\u3055\u3044\u5b9a\u6570\u3092\u304b\u3051\u3066\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u5c0f\u3055\u304f\u3057\u3066\u3044\u304f\u3002\u95a2\u6570\u306e\u5024\u304c\u5c0f\u3055\u304f\u306a\u308b\u9650\u308a\u3053\u306e\u53cd\u5fa9\u3092\u7d9a\u3051\u308b</p>"},{"location":"tech_note/optimize/line_search/#_3","title":"\u30a2\u30eb\u30df\u30db\u6761\u4ef6","text":"<p>\u3042\u308b\u5b9a\u6570\\(0 &lt; \\tau &lt; 1\\)\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u3088\u3046\u306a\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u63a1\u7528\u3059\u308b</p> \\[ g(\\alpha) \\leq g(0) + \\tau g'(0) \\alpha \\] <p>\u3053\u3053\u3067\\(f\\)\u306f\u5fae\u5206\u53ef\u80fd\u3067\u3042\u308b\u3068\u3057</p> \\[ g'(\\alpha) = \\Delta f(\\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)})^T \\bf{d}^{(k)} \\]"},{"location":"tech_note/optimize/line_search/#_4","title":"\u30a6\u30eb\u30d5\u6761\u4ef6","text":"<p>\u3042\u308b\u5b9a\u6570\\(0 &lt; \\tau_1 &lt; \\tau_2 &lt; 1\\)\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u3088\u3046\u306a\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u63a1\u7528\u3059\u308b</p> \\[ \\begin{array} g(\\alpha) \\leq g(0) + \\tau_1 g'(0) \\alpha  \\\\ g'(\\alpha) \\geq \\tau_2 g'(\\alpha) \\end{array} \\]"},{"location":"tech_note/optimize/line_search/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> <li>\u76f4\u7dda\u63a2\u7d22\u306b\u304a\u3051\u308bArmijo\u6761\u4ef6\u3068Wolfe\u6761\u4ef6\u3092\u56f3\u304b\u3089\u7406\u89e3\u3059\u308b</li> </ul>"},{"location":"tech_note/optimize/newton/","title":"\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u3068\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u3044\u95a2\u6570\u3092\u5909\u6570\u306e\u5468\u308a\u30672\u6b21\u8fd1\u4f3c\u3057\u89e3\u304f\u3053\u3068\u3067\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u5b9a\u3057\u3001\u505c\u7559\u70b9\u306b\u53ce\u675f\u3059\u308b\u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u3002\u6700\u6025\u964d\u4e0b\u6cd5\u304c\u4e00\u6b21\u53ce\u675f\u3067\u3042\u308b\u3053\u3068\u306b\u5bfe\u3057\u3066\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f2\u6b21\u53ce\u675f\u3067\u3042\u308b\u305f\u3081\u505c\u7559\u70b9\u4ed8\u8fd1\u3067\u3082\u53ce\u675f\u304c\u901f\u3044\u304c\u76ee\u7684\u95a2\u6570\u306e2\u89e3\u5fae\u5206\u304c\u5fc5\u8981\u3067\u3042\u308b\u3002</p> <p>\u6700\u9069\u5316\u306e\u53cd\u5fa9\u6cd5\u306b\u304a\u3051\u308b\u89e3\u306e\u66f4\u65b0\u5247\u306f</p> \\[ \\bf{x}^{(k+1)} = \\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)} \\] <p>\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u306f\u63a2\u7d22\u65b9\u5411\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u53d6\u308b\u3002\u884c\u3063\u3066\u3044\u308b\u3053\u3068\u306f\u73fe\u5728\u306e\u89e3\u5468\u308a\u3067\u76ee\u7684\u95a2\u6570\u30922\u6b21\u8fd1\u4f3c\u3057\u3001\u6700\u5c0f\u5024\u3092\u65b9\u7a0b\u5f0f\u304b\u3089\u6c42\u3081\u3066\u3044\u308b\u3002</p> \\[ \\bf{d}^{(k)} = -\\Delta^2 f(\\bf{x}^{(k)})^{-1} \\Delta f(\\bf{x}^{(k)}) \\] <p>\u63a2\u7d22\u65b9\u5411\u6c7a\u5b9a\u5f8c\u306f\u76f4\u7dda\u63a2\u7d22\u3067\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u8a08\u7b97\u3057\u52b9\u7387\u7684\u306b\u89e3\u3092\u66f4\u65b0\u3059\u308b</p>"},{"location":"tech_note/optimize/newton/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/penalty_methond/","title":"\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5","text":"<p>\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u79fb\u52d5\u3057\u305f\u969b\u306b\u5024\u304c\u5897\u52a0\u3059\u308b\u3088\u3046\u306a\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u76ee\u7684\u95a2\u6570\u306b\u4ed8\u52a0\u3057\u305f\u5916\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/","title":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7","text":""},{"location":"tech_note/optimize/prob_and_algo/#_2","title":"\u6570\u7406\u8a08\u753b\u554f\u984c","text":""},{"location":"tech_note/optimize/prob_and_algo/#lp-linear-programming","title":"LP (Linear Programming : \u7dda\u5f62\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u554f\u984c\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u3082\u306e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#milp-mixed-integer-linear-programming","title":"MILP (Mixed Integer Linear Programming : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e   MIP(Mixed Integer Programming)\u3068\u547c\u3070\u308c\u308b\u3053\u3068\u3082\u591a\u3044</p>"},{"location":"tech_note/optimize/prob_and_algo/#miqp-mixed-integer-quadratic-programming","title":"MIQP (Mixed Integer Quadratic Programming : \u6df7\u5408\u6574\u6570\u4e8c\u6b21\u8a08\u753b\u554f\u984c)","text":"<p>\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3001\u76ee\u7684\u95a2\u6570\u304c\u4e8c\u6b21\u95a2\u6570\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e</p>"},{"location":"tech_note/optimize/prob_and_algo/#minlp-mixed-integer-nonlinear-programming","title":"MINLP (Mixed Integer Nonlinear Programming : \u6df7\u5408\u6574\u6570\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c)","text":"<p>\u5236\u7d04\u5f0f\u304a\u3088\u3073\u76ee\u7684\u95a2\u6570\u304c\u975e\u7dda\u5f62\u3067\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#cqp-convex-quadratic-programming","title":"CQP (Convex Quadratic Programming : \u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u304c\u51f8\u306a\u4e8c\u6b21\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u3082\u306e (\u305f\u3060\u3057\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u3082\u306e)  </p>"},{"location":"tech_note/optimize/prob_and_algo/#cp-convex-programming","title":"CP (Convex Programming : \u51f8\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u306a\u3082\u306e\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304c\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u304c\u51f8\u3067\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u554f\u984c\u3053\u3053\u3067\u306f\u6574\u6570\u5909\u6570\u306f\u542b\u307e\u306a\u3044\u3082\u306e\u3092\u6307\u3059  \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3082\u51f8\u8a08\u753b\u554f\u984c\u306e\u4e00\u90e8\u3067\u3059\u304c\u3001\u3053\u3053\u306b\u306f\u542b\u3081\u306a\u3044</p>"},{"location":"tech_note/optimize/prob_and_algo/#nlp-nonlinear-programming","title":"NLP (Nonlinear Programming : \u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c)","text":"<p>\u4e0a\u8a18\u4ee5\u5916\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c  </p>"},{"location":"tech_note/optimize/prob_and_algo/#sdp-semidefinite-programing","title":"SDP (SemiDefinite Programing : \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c)","text":"<p>\u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u3080\u7dda\u5f62\u8a08\u753b\u554f\u984c  </p>"},{"location":"tech_note/optimize/prob_and_algo/#nlsdp-nonlinear-semidefinite-programing","title":"NLSDP (NonLinear SemiDefinite Programing : \u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c)","text":"<p>\u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u307f\u3001\u306a\u304a\u304b\u3064\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u542b\u307e\u308c\u308b\u554f\u984c  </p>"},{"location":"tech_note/optimize/prob_and_algo/#wcsp-weighted-constraint-satisfaction-problem","title":"WCSP (Weighted Constraint Satisfaction Problem : \u91cd\u307f\u4ed8\u304d\u5236\u7d04\u5145\u8db3\u554f\u984c)","text":"<p>\u5404\u3005\u91cd\u307f\u306e\u4ed8\u3044\u305f\u5236\u7d04\u6761\u4ef6\u3092\u306a\u308b\u3079\u304f\u6e80\u8db3\u3059\u308b\u305f\u3081\u306b\u306f\u5024\u3092\u3069\u306e\u3088\u3046\u306b\u5272\u308a\u5f53\u3066\u308b\u3068\u826f\u3044\u304b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0wcsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/#rcpsp-resource-constrained-project-scheduling-problem","title":"RCPSP (Resource Constrained Project Scheduling Problem : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c)","text":"<p>\u4e00\u5b9a\u306e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\u3067\u3001\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u3000\u3000 \u4e00\u822c\u306e\u6574\u6570\u8a08\u753b\u554f\u984c(MILP)\u3068\u3057\u3066\u8a18\u8ff0\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3060\u304c\u3001\u7279\u6b8a\u306a\u8a18\u6cd5\u3092\u884c\u3046\u3068\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0rcpsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/#_3","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7","text":""},{"location":"tech_note/optimize/prob_and_algo/#simplex","title":"simplex : \u5358\u4f53\u6cd5()","text":"<p>\u7dda\u5f62\u8a08\u753b\u6cd5\u306e\u89e3\u6cd5\u3068\u3057\u3066\u53e4\u304f\u304b\u3089\u77e5\u3089\u308c\u3066\u3044\u308b\u65b9\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\u5185\u70b9\u6cd5\u306b\u901f\u5ea6\u7684\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u304c\u6c42\u307e\u308a\u539f\u7406\u7684\u306b\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e \u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u6307\u5b9a\u3059\u308b\u3068\uff0c\u5358\u4f53\u6cd5\u3092\u5206\u679d\u9650\u5b9a\u6cd5(Branch and bound method)\u3068\u3044\u3046\u67a0\u7d44\u306e\u306a\u304b\u3067\u7e70\u308a\u8fd4\u3057\u884c\u3063\u3066\uff0c\u6700\u9069\u6027\u306e\u4fdd\u8a3c\u306e\u3042\u308b\u6574\u6570\u89e3\u3092\u6c42\u3081\u307e\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u306b\u304a\u3044\u3066\u57fa\u5e95\u89e3\u304c\u5fc5\u8981\u306a\u5834\u5408\u306b\u306f\uff0c\"cross:on\"\u3068\u6307\u5b9a\u3057\u3066\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u306e\u304c\u6709\u5229\u3067\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#dual_simplex-dual_simplex","title":"dual_simplex : \u53cc\u5bfe\u5358\u4f53\u6cd5(DUAL_SIMPLEX)","text":"<p>(\u4e3b)\u5358\u4f53\u6cd5\u304c\u4e3b\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304f\u306e\u306b\u5bfe\u3057\uff0c\u53cc\u5bfe\u5358\u4f53\u6cd5\u306f\u53cc\u5bfe\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304d\u307e\u3059\uff0e \u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\uff0c(\u4e3b)\u5358\u4f53\u6cd5\u3068\u6bd4\u8f03\u3057\u3066\u6709\u5229\u3067\u3042\u308b\u3053\u3068\u304c\u3042\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#asqp-active_set_qp","title":"asqp : \u6709\u52b9\u5236\u7d04\u6cd5(ACTIVE_SET_QP)","text":"<p>\u5358\u4f53\u6cd5\u3068\u540c\u69d8\uff0c\u53e4\u5178\u7684\u306a\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u53b3\u5bc6\u89e3\u6cd5\u3067\u3059\uff0e1\u4e07\u5909\u6570\u4ee5\u4e0a\u306e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\uff0c\u4e00\u822c\u306b\u5185\u70b9\u6cd5(\u76f4\u7dda\u63a2\u7d22\u6cd5(Line Search Method))\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c \u5909\u6570\u306b\u6bd4\u3079\u3066\u5236\u7d04\u5f0f\u306e\u6570\u304c\u975e\u5e38\u306b\u5c11\u306a\u3044(1/10\u4ee5\u4e0b)\u5834\u5408 \u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30bb\u884c\u5217\u304c\u5bc6\u884c\u5217\u3067\u3042\u308b\u5834\u5408 \u306b\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u304b\u3064\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e\u307e\u305f\uff0c\u6574\u6570\u8a08\u753b\u6cd5\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u306e\u3067\uff0c\u6574\u6570\u5909\u6570\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\"cross:on\"\u3068\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\uff0c\u5927\u898f\u6a21\u554f\u984c\u306b\u5bfe\u3057\u3066\u9ad8\u7cbe\u5ea6\u306a\u89e3\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#higher-higher_order","title":"higher : \u7dda\u5f62\u8a08\u753b\u554f\u984c\u5c02\u7528\u5185\u70b9\u6cd5(HIGHER_ORDER)","text":"<p>\u7dda\u5f62\u8a08\u753b\u6cd5\u306b\u7279\u5316\u3057\u305f\u5185\u70b9\u6cd5\u3067\uff0c\u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306e\u89e3\u6cd5\u3068\u3057\u3066\u306f\u6700\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5358\u4f53\u6cd5\u3068\u9055\u3044\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u306f\u6c42\u307e\u308a\u307e\u305b\u3093\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lipm-line_search_ipm","title":"lipm : (\u65b0\u7248)\u76f4\u7dda\u63a2\u7d22\u6cd5(LINE_SEARCH_IPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#lepm-line_search_epm","title":"lepm : \u76f4\u7dda\u63a2\u7d22\u5916\u70b9\u6cd5(LINE_SEARCH_EPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#line-line_search","title":"line : (\u65e7\u7248)\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5(LINE_SEARCH)","text":"<p>\u4e00\u822c\u306e\u51f8\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u554f\u984c\u304c\u51f8\u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u5834\u5408\u306b\u306f\u4fe1\u983c\u9818\u57df\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(lipm)\uff0c\u5916\u70b9\u6cd5(lepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(line)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5line\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5lipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059)\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#bfgs-bfgs_line_search","title":"bfgs : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(BFGS_LINE_SEARCH)","text":"<p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u201cbfgs\u201d\u306f\u30d8\u30c3\u30bb\u884c\u5217\u306e\u8fd1\u4f3c\u884c\u5217\u3092\u5bc6\u884c\u5217\u3068\u3057\u3066\u4fdd\u6301\u3057\u307e\u3059\u306e\u3067\uff0c\u5c0f\u898f\u6a21(50\uff5e500\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#tipm-trust_region_ipm","title":"tipm : (\u65b0\u7248)\u4fe1\u983c\u9818\u57df\u5185\u70b9\u6cd5(TRUST_REGION_IPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#tepm-trust_region_epm","title":"tepm : \u4fe1\u983c\u9818\u57df\u5916\u70b9\u6cd5(TRUST_REGION_EPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#trust-trust_region","title":"trust : (\u65e7\u7248)\u4fe1\u983c\u9818\u57df\u6cd5\u5185\u70b9\u6cd5(TRUST_REGION)","text":"<p>\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(tipm)\uff0c\u5916\u70b9\u6cd5(tepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(trust)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5trust\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5tipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3054\u3056\u3044\u307e\u3059)\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lsqp-line_search_sqp","title":"lsqp : \u76f4\u7dda\u63a2\u7d22\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(LINE_SEARCH_SQP)","text":"<p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5c0f\u898f\u6a21(50\uff5e100\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e \u554f\u984c\u306b\u3088\u3063\u3066\u306f\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(lipm/lepm/line)\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#tsqp-trust_region_sqp","title":"tsqp : \u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(TRUST_REGION_SQP)","text":"<p>\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u305d\u306e\u307e\u307e\u7528\u3044\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u65b9\u6cd5\u3067\u3059\uff0e\u4e00\u822c\u306b\u5185\u70b9\u6cd5\u3088\u308a\u3082\u4f4e\u901f\u3067\u3059\u304c\uff0c\u554f\u984c\u306b\u3088\u3063\u3066\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\uff0c\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u5909\u6570\u306e\u6570\u3088\u308a\u3082\u5236\u7d04\u5f0f\u6570\u304c\u591a\u3044\u5834\u5408\u306b\u306f\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3088\u308a\u3082\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#slpsqp-slp-sqp","title":"slpsqp : \u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP)","text":"<p>\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u7528\u3044\u306a\u3044\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u3042\u308b\u7a0b\u5ea6\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u3067\u3059\uff0e\u5927\u57df\u7684\u53ce\u675f\u6027\u3092\u4fdd\u8a3c\u3059\u308b\u539f\u7406\u304c\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3084\u5f93\u6765\u306e\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(lsqp/tsqp)\u306e\u3082\u306e\u3068\u306f\u7570\u306a\u308b\u305f\u3081\uff0c\u4ed6\u306e\u65b9\u6cd5\u3067\u53ce\u675f\u3057\u306a\u3044\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e\u307e\u305f\uff0c\u5236\u7d04\u5f0f\u306e\u52fe\u914d\u304c\u5c0f\u3055\u3044\u53cd\u5fa9\u70b9\u306b\u3044\u308b\u6642\uff0c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u63a5\u8fd1\u3059\u308b\u3068\u3044\u3046\u4ed5\u7d44\u307f\u304c\u7d44\u307f\u8fbc\u307e\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u8907\u96d1\u306a\u5236\u7d04\u306b\u304a\u3044\u3066\u3082\u5b89\u5b9a\u7684\u306a\u52d5\u4f5c\u304c\u671f\u5f85\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lsdp","title":"lsdp : \u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u7dda\u5f62\u306e\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u51fa\u73fe\u3059\u308b\u9805\u306f\u7dda\u5f62\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3044\u307e\u305b\u3093\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#csdp","title":"csdp : \u51f8\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u76ee\u7684\u95a2\u6570\u304c\u51f8\u975e\u7dda\u5f62\u95a2\u6570\u3067\uff0c\u5236\u7d04\u304c\u7dda\u5f62\u306a\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u3053\u306e\u985e\u306e\u554f\u984c\u306f\uff0c\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3067\u8a18\u8ff0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u304c\uff0c\u305d\u306e\u307e\u307e\u6271\u3063\u305f\u65b9\u304c\u9ad8\u901f\u306b\u6c42\u89e3\u3067\u304d\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3046\u70b9\u304clsdp\u3068\u7570\u306a\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#qnsdp","title":"qnsdp : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lmsdp-levenberg-marquardt","title":"lmsdp : Levenberg-Marquardt\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u70ba\u306b\uff0cLevenberg-Marquardt\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u306b\u6bd4\u3079\u3066\uff0c\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e\u5909\u6570\u304c\u5c11\u306a\u304f\uff0c\u884c\u5217\u6b21\u5143\u304c\u5927\u304d\u3044\u554f\u984c\u306e\u5834\u5408\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(trsdp)\u3088\u308a\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e trsdp : \u4fe1\u983c\u9818\u57df\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u3088\u308a\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#wcsp-wcsp","title":"wcsp : \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0(WCSP)","text":"<p>\u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u5236\u7d04\u5145\u8db3\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u5fc5\u305a\u3057\u3082\u53b3\u5bc6\u89e3\u304c\u6c42\u307e\u308b\u308f\u3051\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\uff0c\u5927\u898f\u6a21\u306a\u6574\u6570\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\uff0c\u975e\u5e38\u306b\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3(\u8fd1\u4f3c\u89e3)\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u6574\u6570\u5909\u6570\u306e\u307f\u3092\u542b\u307f\uff0c\u304b\u3064\u3059\u3079\u3066\u306e\u5909\u6570\u306b\u4e0a\u9650\u3068\u4e0b\u9650\u304c\u3042\u308b\u554f\u984c\u306b\u5bfe\u3057\u3066\u306e\u307f\u6709\u52b9\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\uff0c\u5236\u7d04\u5f0f\u306b\u91cd\u307f\u3092\u8a2d\u5b9a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u5236\u7d04\u306e\u91cd\u307f\u306b\u306f\uff0c\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bb\u30df\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bd\u30d5\u30c8\u5236\u7d04\u306e\u4e09\u7a2e\u985e\u304c\u3042\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#wcsplp","title":"wcsplp : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u5c02\u7528\u306e\u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0","text":"<p>\u7dda\u5f62\u306a\u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u3092\u5236\u7d04\u5145\u8db3\u554f\u984c\u306e\u67a0\u7d44\u307f\u3067\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u306f\uff0c\u9023\u7d9a\u5909\u6570\u306f\u9069\u5f53\u306a\u523b\u307f\u5e45\u3092\u3082\u3064DiscreteVariable\u3068\u89e3\u91c8\u3055\u308c\u307e\u3059\uff0ewcsplp\u3067\u306f\u5168\u3066\u306e\u5236\u7d04\u5f0f\u3092\u30cf\u30fc\u30c9\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\uff0c\u76ee\u7684\u95a2\u6570\u3092\u30bd\u30d5\u30c8\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#rcpsp-rcpsp","title":"rcpsp : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0(RCPSP)","text":"<p>\u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\uff0c\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u306e\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u9ad8\u901f\u306b\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0ercpsp\u306e\u8a18\u8ff0\u306b\u3042\u305f\u3063\u3066\u306f\u554f\u984c\u3092SIMPLE\u306e\u7279\u6b8a\u306a\u30af\u30e9\u30b9\u3092\u7528\u3044\u3066\u8a18\u8ff0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5b8c\u4e86\u6642\u523b\u306e\u6700\u5c0f\u5316\u554f\u984c\u3068\uff0c\u7d0d\u671f\u9045\u308c\u6700\u5c0f\u5316\u554f\u984c\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u524d\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30bd\u30d5\u30c8\u5236\u7d04\uff0c\u5f8c\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30cf\u30fc\u30c9\u5236\u7d04\u306e\u307f\u304c\u4f7f\u7528\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#_4","title":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc","text":"LP MILP MIQP MINLP CQP CP NLP SDP NLSDP RCPSP simplex \u25cb \u25cb -- -- -- -- -- -- -- \u25b3 dual_simplex \u25cb -- -- -- -- -- -- -- -- -- asqp \u25cb -- \u25cb -- \u25cb -- -- -- -- -- higher \u25cb -- -- -- -- -- -- -- -- -- lipm/lepm/line \u25b3 -- -- -- \u25cb \u25cb -- -- -- -- bfgs \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- tipm/tepm/trust \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- lsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- tsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- slpsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- lsdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- csdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- qnsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- trsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- lmsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- wcsp -- \u25cb\u203b1 \u25cb\u203b1 \u25cb\u203b1 -- -- -- -- -- -- wcsplp \u25b3 \u25cb\u203b2 -- -- -- -- -- -- -- -- global \u25b3 \u25b3 \u25b3 \u25cb \u25b3 \u25b3 \u25cb \u25cb \u25cb \u25b3 DFO \u25b3 -- -- -- \u25b3 \u25b3 \u25cb -- -- -- rcpsp -- -- -- -- -- -- -- -- -- \u25cb <p>Info</p> <p>\u203b1: 0-1\u6574\u6570\u5909\u6570\u3068\u96e2\u6563\u5909\u6570\u306e\u307f\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u9069\u7528\u3067\u304d\u308b\u3053\u3068\u3092\u610f\u5473\u3059\u308b \u3000\u3000\u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u3042\u308b\u3044\u306f\u4e0a\u9650\u3068\u4e0b\u9650\u3092\u6301\u305f\u306a\u3044\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u306f\u9069\u7528\u3067\u304d\u306a\u3044 \u203b2: \u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u5834\u5408\u3082\u9069\u7528\u304c\u3067\u304d\u308b\u304c\u52b9\u7387\u304c\u843d\u3061\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>14.1 \u6570\u7406\u8a08\u753b\u554f\u984c\u4e00\u89a7</li> <li>14.2 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7</li> <li>14.3 \u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc</li> </ul>"},{"location":"tech_note/optimize/quadprog/","title":"\u4e8c\u6b21\u8a08\u753b\u6cd5","text":"<p>\u4ee5\u4e0b\u306e\u6700\u9069\u5316\u554f\u984c\u3092\u8003\u3048\u308b</p> \\[ \\begin{array} \\text{min} \\space \\dfrac{1}{2}x^TQx + c^T x\\\\ \\text{s.t.} \\space Ax = b, A_{eq}x \\leq b_{eq}, l_x \\leq x \\leq u_x \\\\ x \\in \\mathbb{R}^n \\end{array} \\]"},{"location":"tech_note/optimize/quadprog/#kkt","title":"KKT\u6761\u4ef6","text":"<p>\u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u306b\u5bfe\u3059\u308bKKT\u6761\u4ef6\u306f\u4ee5\u4e0b</p> \\[ \\begin{array}{l} Qx+c + A^T\\lambda + A_{eq}\\lambda_{eq} = \\bf{0} \\\\ \\lambda_i s_i = \\rho\\\\ Ax-b+s = \\bf{0}\\\\ A_{eq}x-b_{eq} = \\bf{0}\\\\ s &gt; \\bf{0}\\\\ \\lambda &gt; \\bf{0}\\\\ \\end{array} \\] <p>KKT\u6761\u4ef6\u306b\u3064\u3044\u3066</p>"},{"location":"tech_note/optimize/quadprog/#_2","title":"\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a","text":"<p>KKT\u6761\u4ef6\u306b\u5bfe\u3057\u3066\u5404\u5909\u6570\u3092\u5fae\u5c0f\u5909\u5316\u3055\u305b\u305f\u5834\u5408\u3092\u8003\u3048\u308b</p> \\[ \\begin{array}{cc} x \\leftarrow x + \\Delta x\\\\ s \\leftarrow s + \\Delta s\\\\ \\lambda \\leftarrow \\lambda + \\Delta \\lambda\\\\ \\lambda_{eq} \\leftarrow \\lambda_{eq} + \\Delta \\lambda_{eq}\\\\ \\end{array} \\] <p>KKT\u6761\u4ef6\u306b\u4ee5\u4e0a\u3092\u4ee3\u5165\u3057\u5fae\u5c0f\u5909\u5316\u91cf\u306b\u5bfe\u3057\u3066\u9023\u7acb\u65b9\u7a0b\u5f0f\u306e\u5f62\u5f0f\u306b\u307e\u3068\u3081\u308b</p> \\[ \\begin{bmatrix} Q    &amp; \\bf{0}    &amp; A^T    &amp; A_{eq}^T \\\\ A    &amp; I         &amp; \\bf{0} &amp; \\bf{0} \\\\ 0    &amp; D_\\lambda &amp; D_s    &amp; \\bf{0} \\\\ A_eq &amp; \\bf{0}    &amp; 0      &amp; \\bf{0} \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta s \\\\ \\Delta \\lambda \\\\ \\Delta \\lambda_{eq} \\\\ \\end{bmatrix} =  \\begin{bmatrix} Qx + c + A^T\\lambda + A_{eq}^T \\lambda_{eq}\\\\ Ax - b + s\\\\ -\\rho I + \\lambda \\bigodot s \\\\ A_{eq} x - b_{eq}\\\\ \\end{bmatrix}\\\\ \\space\\\\ D_\\lambda = \\text{diag}(\\lambda)\\\\ D_s = \\text{diag}(s)\\\\ \\lambda \\bigodot s = \\text{(\u8981\u7d20\u7a4d\u30fb\u30a2\u30c0\u30de\u30fc\u30eb\u7a4d)} \\] <p>\u3053\u306e\u65b9\u7a0b\u5f0f\u3092\u89e3\u3044\u3066\u5404\u5909\u6570\u3092\u66f4\u65b0\u3057\u3066\u3044\u304f</p>"},{"location":"tech_note/optimize/quadprog/#_3","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u4e8c\u6b21\u8a08\u753b\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/optimize/quasi_newton/","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u4f7f\u7528\u3057\u305f\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u7528\u305b\u305a\u8fd1\u4f3c\u3057\u305f\u3082\u306e\u3092\u4f7f\u7528\u3057\u3066\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u3053\u306e\u3068\u304d\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u306f\u6b63\u5247\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067BFGS\u516c\u5f0f\u3092\u4f7f\u7528\u3057\u3066\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u66f4\u65b0\u3059\u308b\u3002</p> <p>\u6700\u9069\u5316\u306e\u53cd\u5fa9\u6cd5\u306b\u304a\u3051\u308b\u89e3\u306e\u66f4\u65b0\u5247\u306f</p> \\[ \\bf{x}^{(k+1)} = \\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)} \\] <p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u306f\u63a2\u7d22\u65b9\u5411\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u53d6\u308b\u3002\u73fe\u5728\u306e\u89e3\u5468\u308a\u3067\u306e\u76ee\u7684\u95a2\u6570\u306e2\u6b21\u8fd1\u4f3c\u3092\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\\(B\\)\u3092\u4f7f\u3063\u3066\u884c\u3063\u3066\u3044\u308b</p> \\[ \\bf{d}^{(k)} = - (\\bf{B}^{(k)})^{-1} \\Delta f(\\bf{x}^{(k)}) \\] <p>\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\\(B\\)\u306f\u521d\u671f\u5316\u306e\u3068\u304d\u306b\u306f\u5358\u4f4d\u884c\u5217\u306a\u3069\u3092\u9078\u3076</p> <p>\u63a2\u7d22\u65b9\u5411\u6c7a\u5b9a\u5f8c\u306f\u76f4\u7dda\u63a2\u7d22\u3067\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u8a08\u7b97\u3057\u3066\u89e3\u3092\u66f4\u65b0\u3059\u308b\u3002\u307e\u305f\u3001\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\\(B\\)\u3092BFGS\u516c\u5f0f\u306b\u3088\u308a\u66f4\u65b0\u3059\u308b</p>"},{"location":"tech_note/optimize/quasi_newton/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/sqp/","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)","text":"<p>NLP\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0 QP\u3078\u306e\u8fd1\u4f3c\u3068\u305d\u306e\u89e3\u6cd5\u306b\u3088\u3063\u3066\u3044\u304f\u3064\u304b\u306e\u7a2e\u985e\u306b\u5206\u304b\u308c\u308b  \u3053\u3053\u3067\u306f\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u3082\u306e\u3068SLSQP\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b  </p>"},{"location":"tech_note/optimize/sqp/#_1","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u307e\u305a\u306f\u7d14\u7c8b\u306aSQP\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b\u3002\u4e0e\u3048\u3089\u308c\u308b\u554f\u984c\u306f\u4ee5\u4e0b\u306e\u5f62\u5f0f\u3067\u3042\u308b</p> \\[ \\begin{array}{} \\underset{x}{\\text{min}} \\space f(x)\\\\ \\text{s.t.} \\space  g_i(x) = 0, \\space i = 0, \\dots , m_e\\\\ \\text{\u3000\u3000\u3000} \\space  g_i(x) \\leq 0, \\space i = m_e+1, \\dots , l\\\\ x \\in \\mathbb{R}^n \\end{array} \\] <p>\u30b5\u30d6\u554f\u984c\u3068\u3057\u3066QP\u306b\u8fd1\u4f3c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u5f62\u3092\u53d6\u308b</p> \\[ f(x) \\approx \\dfrac{1}{2}x^TQx + c^Tx\\\\ \\] <p>\u3053\u3053\u3067\u4efb\u610f\u306e\u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30b7\u30a2\u30f3\\(Q\\)\u306b\u3064\u3044\u3066\u534a\u6b63\u5b9a\u5024\u6027\u304c\u4fdd\u8a3c\u3055\u308c\u306a\u3044\u305f\u3081\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5\u306b\u3088\u308a\u8fd1\u4f3c\u3057\u305f\u884c\u5217\u3092\u4f7f\u7528\u3059\u308b\u3002</p> <p>\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\u306e\u305f\u3081\u306b\u76ee\u7684\u5909\u6570\u3092\u63a2\u7d22\u65b9\u5411\u306b\u53d6\u308aQP\u554f\u984c\u3092\u5b9a\u5f0f\u5316\u3059\u308b\u3002</p> \\[ \\begin{array}{} \\underset{d}{\\text{min}} \\dfrac{1}{2}d^TQd + c^Td\\\\ \\text{s.t.} \\space \\nabla g_i(x)^Td + g_i(x) = 0, \\space i = 0, \\dots , m_e\\\\ \\text{\u3000\u3000\u3000} \\space \\nabla g_i(x)^Td + g_i(x) \\leq 0, \\space i = m_e+1, \\dots , l\\\\ \\end{array} \\] <p>\u63a2\u7d22\u65b9\u5411\u304c\u6c7a\u5b9a\u3057\u305f\u3089\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u76f4\u7dda\u63a2\u7d22\u306b\u3088\u308a\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c7a\u5b9a\u3057\u3001\u5909\u6570\u3092\u66f4\u65b0\u3059\u308b\u3002 \u305d\u306e\u5f8cBFGS\u306b\u3088\u308b\u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u66f4\u65b0\u3092\u884c\u3046\u3002</p> <p>\u4ee5\u4e0a\u306e\u64cd\u4f5c\u3092\u53ce\u675f\u3059\u308b\u307e\u3067\u884c\u3046\u3002</p>"},{"location":"tech_note/optimize/sqp/#slsqp","title":"SLSQP","text":"<p>SLSQP\u3067\u306f\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u8aac\u660e\u3057\u305f\u30b5\u30d6\u554f\u984c\u3067\u3042\u308bQP\u3092\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306b\u5909\u5f62\u3057\u3066\u89e3\u3044\u3066\u3044\u308b\u3002\u3053\u308c\u306b\u3042\u305f\u3063\u3066B\u884c\u5217\u3092\u4fee\u6b63\u30b3\u30ec\u30b9\u30ad\u30fc\u5206\u89e3\u3059\u308b</p> \\[ B = LDL^T \\] <p>\u5206\u89e3\u3057\u305f\u884c\u5217\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u3092\u89e3\u304f</p> \\[ \\begin{array}{} \\underset{d}{\\text{min}} || D^\\frac{1}{2}L^Td + D^{-\\frac{1}{2}}L^{-1}\\nabla f(x) ||\\\\ \\text{s.t.} \\space \\nabla g_i(x)^Td + g_i(x) = 0, \\space i = 0, \\dots , m_e\\\\ \\text{\u3000\u3000\u3000} \\space \\nabla g_i(x)^Td + g_i(x) \\leq 0, \\space i = m_e+1, \\dots , l\\\\ \\end{array} \\]"},{"location":"tech_note/optimize/sqp/#qp","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5\u554f\u984c\u304b\u3089QP\u554f\u984c\u3078\u306e\u5909\u63db","text":"<p>Kraft, D. A software package for sequential quadratic    programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace    Center -- Institute for Flight Mechanics, Koln, Germany.</p>"},{"location":"tech_note/optimize/sqp/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> <li> <p>SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066</p> </li> <li> <p>fmincon SQP \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0     \u57fa\u672c\u7684\u306a\u5b9f\u88c5\u306f\u3053\u306e\u30da\u30fc\u30b8\u306efmincon \u30a2\u30af\u30c6\u30a3\u30d6 \u30bb\u30c3\u30c8 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u53c2\u7167</p> </li> </ul>"},{"location":"tech_note/optimize/tolerances_and_stopping/","title":"\u8a31\u5bb9\u8aa4\u5dee\u30fb\u505c\u6b62\u6761\u4ef6","text":"<p>\u6700\u9069\u5316\u3092\u884c\u3046\u4e0a\u3067\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u505c\u6b62\u6761\u4ef6\u3092\u5224\u65ad\u3059\u308b\u305f\u3081\u306b\u8a31\u5bb9\u8aa4\u5dee\u3092\u8a2d\u5b9a\u3059\u308b\u3002 \u3053\u306e\u8a31\u5bb9\u8aa4\u5dee\u306b\u306f\u6700\u9069\u6027\u30fb\u95a2\u6570\u5024\u30fb\u30b9\u30c6\u30c3\u30d7\u30fb\u5236\u7d04\u306b\u5bfe\u3057\u3066\u76e3\u8996\u3055\u308c\u3001\u307e\u305f\u3001\u305d\u308c\u305e\u308c\u306e\u8a31\u5bb9\u8aa4\u5dee\u306f\u554f\u984c\u8a2d\u5b9a\u306b\u3088\u3063\u3066\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u304b\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u5316\u304c\u7570\u306a\u308b\u3002</p>"},{"location":"tech_note/optimize/tolerances_and_stopping/#_2","title":"\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u3068\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee","text":""},{"location":"tech_note/optimize/tolerances_and_stopping/#_3","title":"\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee","text":"<p>\u5404\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3067\u8a55\u4fa1\u3055\u308c\u305f\u5024\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee  \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408  </p> \\[ (f(x_{i+1}) - f(x_i)) &lt; AbsTolerance  \\] <p>\u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408  </p> \\[ |x_{i+1} - x_{i}| &lt; AbsTolerance \\]"},{"location":"tech_note/optimize/tolerances_and_stopping/#_4","title":"\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee","text":"<p>\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308b\u5024\u306e\u5909\u5316\u91cf\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408</p> \\[ (f(x_{i+1}) - f(x_i)) &lt; RelTolerance \\times (1 + f(x_i)) \\] <p>\u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408  </p> \\[ |x_{i+1} - x_{i}| &lt; RelTolerance \\times (1 + |x_i|) \\] \u554f\u984c \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 \u6700\u9069\u6027\u306e\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u8a31\u5bb9\u8aa4\u5dee \u30b9\u30c6\u30c3\u30d7\u306e\u8a31\u5bb9\u8aa4\u5dee \u5236\u7d04\u306e\u8a31\u5bb9\u8aa4\u5dee \u5099\u8003 \u5236\u7d04\u306a\u3057\u975e\u7dda\u5f62\u6700\u9069\u5316 (fminsearch) - Abs Abs - \u540c\u6642\u306b\u6e80\u305f\u3057\u305f\u6642\u7d42\u4e86\u3068\u3059\u308b \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Rel - Rel - \u5236\u7d04\u4ed8\u304d\u975e\u7dda\u5f62\u6700\u9069\u5316 \u5185\u70b9\u6cd5 Rel - Rel Rel \u6709\u52b9\u5236\u7d04\u6cd5 Abs Abs Abs Abs \u9010\u6b21\u4e8c\u6b21\u6700\u9069\u5316(SQP) Rel - Rel Rel <p>Abs: \u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee Rel: \u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee  </p>"},{"location":"tech_note/optimize/tolerances_and_stopping/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u8a31\u5bb9\u8aa4\u5dee\u3068\u505c\u6b62\u6761\u4ef6</li> <li>\u8a31\u5bb9\u8aa4\u5dee\u306e\u8a73\u7d30</li> </ul>"},{"location":"tech_note/path_planning/a_star/","title":"A*","text":"<p>A*\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u30b0\u30e9\u30d5\u63a2\u7d22\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u4e00\u7a2e\u3067\u3001\u30b0\u30ea\u30c3\u30c9\u72b6\u306b\u533a\u5207\u3089\u308c\u305f\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u304a\u3051\u308b\u7d4c\u8def\u8a08\u753b\u3067\u3088\u304f\u7528\u3044\u3089\u308c\u3066\u3044\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/path_planning/a_star/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>A*</li> <li>\u3088\u304f\u308f\u304b\u308bA*(A-star)\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 (Unity2D\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3064\u304d)</li> </ul>"},{"location":"tech_note/path_planning/dubins_path/","title":"Dubins\u66f2\u7dda","text":"<p>Dubins\u30d1\u30b9\u306f2\u6b21\u5143\u7a7a\u9593\u4e0a\u3067\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u5411\u304d\u3092\u4e0e\u3048\u308b\u3068\u3001\u59cb\u70b9\u3068\u7d42\u70b9\u3092\u76f4\u9032\u304b\u4e00\u5b9a\u306e\u66f2\u7387\u306e\u30ab\u30fc\u30d6\u304b\u3067\u6700\u77ed\u3068\u306a\u308b\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/path_planning/dubins_path/#_1","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Dubins\u30d1\u30b9\u3067\u306f\u76f4\u9032\u3092S\u3001\u53f3\u56de\u308a\u306e\u7d4c\u8def\u3092R\u3001\u5de6\u56de\u308a\u306e\u7d4c\u8def\u3092L\u3068\u3057\u3066\u6587\u5b57\u306e\u7d44\u307f\u5408\u308f\u305b\u3067\u3069\u3046\u3044\u3046\u5f62\u3092\u7d4c\u8def\u5316\u3092\u8868\u3059\u3002\u4f8b\u3048\u3070\u76f4\u9032\u3057\u305f\u5f8c\u306b\u53f3\u56de\u308a\u3059\u308b\u3088\u3046\u306a\u7d4c\u8def\u306fSR\u3068\u306a\u308b\u3002</p> <p>Dubins\u30d1\u30b9\u3067\u306f\u4e8c\u70b9\u9593\u3092\u7d50\u3076\u7d4c\u8def\u306f3\u533a\u9593\u304b\u3089\u306a\u308b\u7d4c\u8def\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3057\u3066\u3044\u308b\u3002\u3055\u3089\u306b\u306f6\u7a2e\u985e\u306e\u7d4c\u8def\u306e\u3069\u308c\u304b\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u307e\u3067\u8a3c\u660e\u3057\u3066\u3044\u308b\u3002</p> <p>\u5177\u4f53\u7684\u306b\u306f</p> <ul> <li>RLR</li> <li>LRL</li> <li>LSR</li> <li>LSL</li> <li>RSL</li> <li>RSR</li> </ul> <p>\u306e6\u7a2e\u985e\u3092\u7dcf\u5f53\u308a\u3059\u308c\u3070\u305d\u306e\u3046\u3061\u3069\u308c\u304b\u304c\u6700\u77ed\u3067\u5230\u9054\u3067\u304d\u308b\u7d4c\u8def\u3068\u306a\u308b\u3002</p>"},{"location":"tech_note/path_planning/dubins_path/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>Python\u306b\u3088\u308bDubins\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0</li> </ul>"},{"location":"tech_note/path_planning/dwa/","title":"DWA(Dynamic Window Approach)","text":"<p>\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u306f\u591a\u304f\u306e\u6d3e\u751f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304c\u5b58\u5728\u3059\u308b</p>"},{"location":"tech_note/path_planning/dwa/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>DWA\uff08Dynamic Window Approach\uff09\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u3066\u307f\u305f</li> <li>Dynamic Window Approach\u3092\u5229\u7528\u3057\u305fMotion planning\u306eMATLAB, Python \u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0</li> </ul>"},{"location":"tech_note/path_planning/frenet_path/","title":"\u30d5\u30ec\u30cd\u5ea7\u6a19\u7cfb","text":""},{"location":"tech_note/path_planning/frenet_path/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/path_planning/rvo/","title":"RVO","text":""},{"location":"tech_note/path_planning/rvo/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>RVO\u306b\u3088\u308b\u885d\u7a81\u56de\u907f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/path_planning/spline/","title":"\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda","text":""},{"location":"tech_note/path_planning/spline/#_2","title":"\u88dc\u9593\u66f2\u7dda\u306e\u7a2e\u985e","text":"<p>\u30ed\u30dc\u30c3\u30c8\u306e\u79fb\u52d5\u3084\u30a2\u30af\u30c1\u30e5\u30a8\u30fc\u30bf\u306e\u8ecc\u9053\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u901a\u904e\u70b9\u3060\u3051\u3092\u6307\u5b9a\u3057\u3066\u66f2\u7dda\u7684\u306b\u88dc\u9593\u3055\u305b\u3066\u8ecc\u9053\u3092\u751f\u6210\u3059\u308b\u3002\u88dc\u9593\u66f2\u7dda\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3082\u306e\u304c\u3042\u308b </p> <ul> <li>Bezier\u66f2\u7dda(\u30d9\u30b8\u30a8\u66f2\u7dda)</li> <li>Hermite\u66f2\u7dda(\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda)</li> <li>Catmull-Rom\u66f2\u7dda(\u30ad\u30e3\u30c3\u30c8\u30e0\u30eb-\u30ed\u30e0\u66f2\u7dda?)</li> <li>Cubic-Spline\u66f2\u7dda(3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda)</li> </ul> <p>\u3053\u306e\u8a18\u4e8b\u3067\u306f\u4e8c\u6b21\u5143\u5e73\u9762\u4e0a\u3067\u306e\u66f2\u7dda\u306b\u3064\u3044\u3066\u8ff0\u3079\u3066\u3044\u304f</p>"},{"location":"tech_note/path_planning/spline/#bezier","title":"Bezier\u66f2\u7dda","text":"<p>N\u500b\u306e\u5236\u5fa1\u70b9\u3092\u4f7f\u3063\u3066\u66f2\u7dda\u3092\u4f5c\u308b\u7279\u5fb4\u3068\u3057\u3066 </p> <ul> <li>\u4e00\u822c\u306b0\u70b9\u76ee, N-1\u70b9\u76ee\u3057\u304b\u901a\u904e\u3057\u306a\u3044</li> </ul> <p>\u3088\u3063\u3066\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3068\u6349\u3048\u3066\u3082\u307b\u3068\u3093\u3069\u9593\u9055\u3044\u306a\u3044\u3060\u308d\u3046</p>"},{"location":"tech_note/path_planning/spline/#n","title":"N\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda","text":"<p>N\u500b\u306e\u5236\u5fa1\u70b9\u304b\u3089\u306a\u308b\u30d9\u30b8\u30a8\u66f2\u7dda\u3067\u3042\u308bN\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u6b21\u5f0f\u3067\u8868\u3055\u308c\u308b</p> \\[ P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) \\] <p>\u3053\u3053\u3067 \\(Bn\\): \u5236\u5fa1\u70b9\u306e\u4e8c\u6b21\u5143\u5ea7\u6a19(\\(n\\) = 0, 1\u22ef\\(N\\) \u2212 1) \\(JN\\) \u2212 1, \\(i\\)(\\(t\\)): \u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570</p>"},{"location":"tech_note/path_planning/spline/#_3","title":"\u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570","text":"\\[ J_{n, i}(t) = \\left(\\begin{array}{c}n\\\\i\\end{array} \\right)t^i(1-t)^{n-i} \\] <p>\u3053\u3053\u3067\u4e8c\u9805\u4fc2\u6570</p> \\[ \\left(\\begin{array}{c}n\\\\i\\end{array} \\right) = \\frac{n!}{i!(n-i)!} \\] <p>\u4e8c\u9805\u4fc2\u6570\u304c\u3071\u3063\u3068\u51fa\u3066\u3053\u306a\u3044\u3068\u304d\u306f\u30d1\u30b9\u30ab\u30eb\u306e\u4e09\u89d2\u5f62\u3092\u8003\u3048\u308b\u3068\u65e9\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\\(n\\)\u3068\\(i\\)\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u4e0a\u304b\u3089n+1\u6bb5\u76ee\u306e(\u5de6\u304b\u3089)i\u2005+\u20051\u500b\u76ee\u304c\u4fc2\u6570\u306b\u306a\u308b</p> <p>\u4ed6\u306e\u66f2\u7dda\u3068\u306e\u6bd4\u8f03\u306e\u305f\u3081\u306bN=4\u3068\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u306e\u3067N=4\u306b\u3064\u3044\u3066\u66f8\u304d\u4e0b\u3059\u3068\u4fc2\u6570\u306f</p> \\[ \\begin{array}{l} J_{3, 0}(t) = (1-t)^3\\\\ J_{3, 1}(t) = 3(1-t)^2t\\\\ J_{3, 2}(t) = 3(1-t)t^2\\\\ J_{3, 3}(t) = t^3 \\end{array} \\] <p>\u3088\u3063\u3066\u30d9\u30b8\u30a8\u66f2\u7dda</p> \\[ P(t)=(1-t)^3 B_0 +  3(1-t)^2t B_1 +  3(1-t)t^2 B_2 + t^3 B_3 \\quad \\quad t \\in [0, 1] \\]"},{"location":"tech_note/path_planning/spline/#hermite","title":"Hermite\u66f2\u7dda","text":"<p>\u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u540c\u69d8\u4e8c\u70b9\u9593\u306e\u66f2\u7dda\u88dc\u9593\u6cd5\u3067\u3042\u308b\u3002\u7279\u5fb4\u3068\u3057\u3066 </p> <ul> <li>\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u6307\u5b9a\u3059\u308b</li> </ul> <p>\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u3092\u305d\u308c\u305e\u308c\u6b21\u306e\u3088\u3046\u306b\u7f6e\u304f P0,\u2006P1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19 v0,\u2006v1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb (\u3044\u305a\u308c\u3082\u4e8c\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b)</p> <p>3\u6b21\u5f0f\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7f6e\u304f</p> \\[ \\begin{array}{l} f_x(t) = a_x t^3 + b_x t^2 + c_x t + d_x\\\\ f_y(t) = a_y t^3 + b_y t^2 + c_y t + d_y \\quad \\quad t \\in [0, 1] \\end{array} \\] <p>\u307e\u305fP0\u7b49\u306b\u3064\u3044\u3066\u3082P0x,\u2006P0y\u304c\u5b58\u5728\u3059\u308b</p> <p>\u4eca\u3001x\u3068y\u306b\u3064\u3044\u3066\u64cd\u4f5c\u306f\u540c\u3058\u306a\u306e\u3067\u3053\u3053\u304b\u3089\u306f\u5f0f\u3092\u898b\u3084\u3059\u304f\u3059\u308b\u305f\u3081\u306bxy\u306e\u6dfb\u5b57\u306f\u7701\u7565\u3059\u308b</p> <p>f(t)\u3092\u5fae\u5206\u3059\u308b\u3068</p> \\[ f(x) = at^3 + bt^2 + ct + d\\\\ f'(x) = 3at^2 + 2bt + c \\] <p>a\u304b\u3089d\u3092\u6c42\u3081\u3066\u3044\u304f\u3002 \u4e0e\u3048\u3089\u308c\u305f\u30d1\u30e9\u30e1\u30fc\u30bf\u3088\u308a  </p> \\[ \\begin{array}{l} f(0) = P_0\\\\ f(1) = P_1\\\\ f'(0) = v_0\\\\ f'(1) = v_1 \\end{array} \\] <p>\u3088\u3063\u3066t=0\u306b\u7740\u76ee\u3059\u308b\u3068</p> \\[ d = P_0\\\\ c = v_0 \\] <p>\u307e\u305ft=1\u306b\u304a\u3044\u3066</p> \\[ \\begin{array}{l} f(1) = a + b + c + d = P_1 \u3088\u308a\\\\ c = v_0, d=P_0\u3092\u4ee3\u5165\u3057\u3066\\\\ a + b = P_1 - P_0 - v_0\\\\ \\\\ f'(1) = 3a + 2b + c = v_1 \u3088\u308a\\\\ c = v_0\u3092\u4ee3\u5165\u3057\u3066\\\\ 3a + 2b = v_1 - v_0 \\end{array} \\] <p>\u305d\u308c\u305e\u308c\u306e\u5f0f\u3092\u2460,\u2461\u3068\u3057\u3066\u2461\u22122\u00d7\u2460\u3067a\u3092\u6c42\u3081\u3066\u304b\u3089b\u306b\u3064\u3044\u3066\u3082\u89e3\u304f\u3068</p> \\[ a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1 \\] <p>\u3088\u3063\u3066</p> \\[ \\begin{array}{l} a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1\\\\ c = v_0\\\\ d = P_0 \\end{array} \\] <p>a\u301cd\u3092x,y\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u6c42\u3081\u3066fx(t),fy(t)\u306b\u4ee3\u5165\u3059\u308b\u3053\u3068\u3067Hermite\u66f2\u7dda\u3092\u63cf\u753b\u3067\u304d\u308b</p> <p>\u30e1\u30e2\u66f8\u304d\u3068\u3057\u3066\u6b8b\u3057\u3066\u304a\u304f\u304ct\u306e\u6b21\u6570\u3067\u306f\u306a\u304fP0,\u2006P1,\u2006v0,\u2006v1\u306b\u3064\u3044\u3066\u304f\u304f\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{array}{l} f(t) = \\\\ (2t^3 - 3t^2 + 1)P_0\\\\ (-2t^3 + 3t^2)P_1\\\\ (t^3 -2t^2 + t)v_0\\\\ (t^3 - t^2)v_1\\\\ \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#catmull-rom","title":"Catmull-Rom\u66f2\u7dda","text":"<p>\u5b9f\u969b\u554f\u984c\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3060\u3051\u3060\u3068\u8db3\u308a\u306a\u3044\u3053\u3068\u304c\u591a\u3044\u3068\u601d\u3046 \u305d\u3053\u3067Hermite\u66f2\u7dda\u3092\u3064\u306a\u3052\u3066\u4f5c\u3089\u308c\u308bCatmull-Rom\u66f2\u7dda\u3092\u8003\u3048\u308b\u3002\u7279\u5fb4\u306f </p> <ul> <li>N\u500b(N &gt; 1)\u306e\u70b9\u3092\u3059\u3079\u3066\u901a\u904e\u3059\u308b\u66f2\u7dda\u3092\u4f5c\u308c\u308b</li> <li>Herimite\u66f2\u7dda\u3067\u4f7f\u3063\u305f\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u5fc5\u8981\u3068\u3057\u306a\u3044</li> </ul> <p>(\u672c\u5f53\u306fHermite\u66f2\u7dda\u3068\u306f\u5225\u306bCatmull-\u66f2\u7dda\u304c\u3067\u304d\u3066\u540c\u30583\u6b21\u5f0f\u3060\u304b\u3089\u5909\u63db\u3067\u304d\u308b\u3088\u306d\u3001\u306e\u6d41\u308c\u306a\u6c17\u304c\u3059\u308b\u3051\u3069\u6587\u732e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u304b\u3063\u305f)</p> <p>i\u756a\u76ee\u306e\u7d42\u70b9\u3092i+1\u756a\u76ee\u306e\u59cb\u70b9\u306b\u3059\u308b\u3053\u3068\u3067\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u306f\u306a\u308b\u304c\u6ed1\u3089\u304b\u306b\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u3059\u308b\u305f\u3081\u306e\u62d8\u675f\u304c\u5fc5\u8981\u306b\u306a\u308b</p> <p>N\u70b9\u304b\u3089\u306a\u308b\u66f2\u7dda\u306e\u3046\u3061\u7aef\u70b9\u4ee5\u5916\u306e\u88dc\u9593\u306b\u3064\u3044\u3066\u8003\u3048\u308b i\u756a\u76ee\u306e\u70b9\u306b\u304a\u3051\u308b\u901f\u5ea6\u3092\u4e21\u96a3\u306e\u5ea7\u6a19\u304b\u3089\u4f5c\u308b\u3053\u3068\u3067\u6ed1\u3089\u304b\u306b\u3064\u306a\u3050</p> \\[ v_i = \\frac{1}{2}(P_{i+1} - P_{i-1}) \\] <p>\u66f2\u7dda\u306e\u7aef\u70b9(i\u2004=\u20040,\u2006N\u2005\u2212\u20051)\u3067\u306f\u3053\u306e\u5f0f\u304c\u4f7f\u3048\u306a\u3044\u306e\u3067\u81ea\u8eab\u306e\u5ea7\u6a19\u3068\u96a3\u306e\u5ea7\u6a19\u3067\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u4f5c\u308b</p> \\[ \\begin{array}{l} v_0 = P_1 - P_0\\\\ v_{N-1} = P_{N-1} - P_{N-2} \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#tension","title":"tension\u306b\u3064\u3044\u3066","text":"<p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#_4","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u533a\u5206\u306b\u3064\u3044\u3066","text":"<p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#cubic-spline","title":"Cubic-Spline\u66f2\u7dda","text":"<p>\u81ea\u5206\u304c\u9ad8\u5c02\u30ed\u30dc\u30b3\u30f3\u3067\u53c2\u7167\u8ecc\u9053\u306f\u3053\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3060\u3063\u305f\u3002</p> <p>\u7279\u5fb4\u3068\u3057\u3066 </p> <ul> <li>\u5165\u529b\u306fCatmull-Rom\u3068\u540c\u3058\u901a\u904e\u70b9\u306e\u307f\u3060\u304c\u3088\u308a\u6ed1\u3089\u304b\u3067\u3042\u308b</li> <li>(\u3082\u3057\u304b\u3057\u305f\u3089\u5c11\u3057\u91cd\u3044?)</li> </ul> <p>3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3067\u306f\u4ee5\u4e0b\u306e\u6761\u4ef6\u306b\u5f93\u3046\u3088\u3046\u306a\u66f2\u7dda\u3092\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f\u3053\u3068\u306b\u3088\u3063\u3066\u6c42\u3081\u308b</p> \\[ \\begin{array}{l} S_j(x_j) = y_j\\\\ S_j(x_{j+1}) = S_{j+1}(x_{j+1}) = y_{j+1}\\\\ S'_j(x_{j+1}) = S'_{j+1}(x_{j+1})\\\\ S''_j(x_{j+1}) = S''_{j+1}(x_{j+1})\\\\ S'_0(x_{0}) = S'_{n-1}(x_{n}) = 0 \\end{array} \\] <p>\u3053\u308c\u3089\u306f</p> <ul> <li>\u591a\u9805\u5f0fS\u306bx\u3092\u5165\u529b\u3059\u308b\u3068y\u3092\u51fa\u529b\u3059\u308b</li> <li>\u591a\u9805\u5f0fS\u306e\u304c\u7e4b\u304c\u3063\u3066\u3044\u3066\u5236\u5fa1\u70b9\u3092\u901a\u308b</li> <li>\u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b</li> <li>\u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u52a0\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b</li> <li>\u7aef\u70b9\u3067\u306f\u52a0\u901f\u5ea6\u306f0\u3067\u3042\u308b \u3053\u3068\u3092\u793a\u3059\u3002</li> </ul>"},{"location":"tech_note/path_planning/spline/#hermitebezier","title":"Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b","text":"<p>\u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u901a\u904e\u3057\u306a\u3044\u5ea7\u6a19\u3092\u4e0e\u3048\u308b\u305f\u3081\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089\u66f2\u7dda\u3092\u60f3\u50cf\u3057\u3065\u3089\u3044\u305f\u3081\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda\u306e\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u30894\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b\u5b9f\u88c5\u304c\u3055\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u3092\u898b\u304b\u3051\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u305d\u306e\u5b9f\u88c5\u306e\u5c0e\u51fa\u3092\u3057\u3066\u3044\u304f\u3002</p> <p>\u307e\u305a\u305d\u308c\u305e\u308c\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092 Bezier\u66f2\u7dda: B0,\u2006B1,\u2006B2,\u2006B3(\u5236\u5fa1\u70b9) Hermite\u66f2\u7dda: P0,\u2006P1,\u2006v0,\u2006v1(\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb) \u3068\u3059\u308b\u3002</p> <p>\u6b21\u306b\u305d\u308c\u305e\u308c\u5f0f\u3092\u66f8\u304d\u4e0b\u3057\u3001t\u306e\u6b21\u6570\u3054\u3068\u306b\u62ec\u308b\u3068</p> \\[ \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} \\] \\[ \\begin{array}{l} P_{herimite}(t) = \\\\ (2 P _0 - 2 P_1 + v_0 + v_1)t^3\\\\ (-3 P_0 + 3 P_1 -2 v_0  - v_1)t^2\\\\ (v_0)t^1\\\\ (P_0)t^0 \\end{array} \\] <p>Pbezier(t)\u2004=\u2004Pherimite(t)\u3068\u3057\u3066\u6052\u7b49\u5f0f\u3092\u89e3\u304f\u3068 (t0\u306b\u3064\u3044\u3066)</p> \\[ B_0 = P_0 \\] <p>(t1\u306b\u3064\u3044\u3066)</p> \\[ v_0 = -3 B_0 + 3 B_1\\\\ B_1 = P_0 + \\frac{1}{3}v_0 \\] <p>(t2\u306b\u3064\u3044\u3066)</p> \\[ -3 P_0 + 3 P_1 -2 v_0  - v_1 = 3 P_0 -6(P_0 + \\frac{1}{3} v_0) + 3 B_2\\\\ B_2 = P_1 - \\frac{1}{3} v_1 \\] <p>(t3\u306b\u3064\u3044\u3066)</p> \\[ 2 P _0 - 2 P_1 + v_0 + v_1 = - P_0 + 3(P_0 + \\frac{1}{3}v_0) - 3(P_1 - \\frac{1}{3}v_1) + B_3\\\\ B_3 = P_1 \\] <p>\u3088\u3063\u3066</p> \\[ \\begin{array}{l} B_0 = P_0\\\\   B_1 = P_0 + \\frac{1}{3}v_0\\\\ B_2 = P_1 - \\frac{1}{3} v_1\\\\ B_3 = P_1 \\end{array} \\] <p>\u3068\u3059\u308b\u3068Hermite\u66f2\u7dda\u306e\u5165\u529b\u3092Bezier\u66f2\u7dda\u3067\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u5b9f\u88c5\u3059\u308b\u306b\u5f53\u305f\u3063\u3066</p> \\[ \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}v_0\\\\ BP_2 = P_1 - \\frac{1}{3} v_1 \\end{array} \\] <p>\u3068\u4e00\u6642\u5909\u6570\u3092\u5ba3\u8a00\u3057\u3066\u3044\u308b\u3053\u3068\u3082\u3042\u308b</p>"},{"location":"tech_note/path_planning/spline/#catmull-rombezier","title":"Catmull-Rom\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b","text":"<p>Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u6c42\u3081\u3066\u3044\u308c\u3070\u4ee3\u5165\u3059\u308b\u3060\u3051</p> \\[ \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1})\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) \\end{array} \\] <p>i=0\u306e\u3068\u304d</p> \\[ \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}(P_1 - P_0)\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) (\u5909\u308f\u3089\u305a) \\end{array} \\] <p>i = N-1\u306e\u3068\u304d</p> \\[ \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1})  (\u5909\u308f\u3089\u305a)\\\\ BP_2 = P_{N-1} - \\frac{1}{3} (P_{N-1} - P_{N-2}) \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#bezier_1","title":"\u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b","text":"<p>\u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f</p> \\[ f(t) = a t^3 + b t^2 + c t + d \\] <p>\u306b\u3064\u3044\u3066Bezier\u66f2\u7dda\u3068\u6052\u7b49\u5f0f\u3068\u3057\u3066\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b(Hermite-&gt;Bezier\u306e\u6642\u3068\u540c\u3058)</p> \\[ \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} \\] <p>\u3088\u3063\u3066</p> \\[ \\begin{array}{l} a = B_0 + 3 B_1 -3 B_2 + B_3\\\\ b = 3 B_0 -6 B_1 + 3 B_2\\\\ c = -3 B_0 + 3 B_1\\\\ d = B_0 \\end{array} \\] <p>\u3053\u308c\u3092\u89e3\u304f\u3068</p> \\[ \\begin{array}{l} B_0 = d\\\\ B_1 = d + \\frac{1}{3}c\\\\ B_2 = \\frac{1}{3}b + \\frac{2}{3}c + d\\\\ B_3 = a + b + c + d \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#_5","title":"\u4f4d\u7f6e\u30fb\u901f\u5ea6\u30fb\u52a0\u901f\u5ea6","text":"<p>Bezier\u66f2\u7dda\u306e\u5b9a\u7fa9\u3088\u308a\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570\u306b\u3088\u308b\u91cd\u307f\u3092\u305d\u308c\u305e\u308c</p> \\[ B = \\left[B_0, B_1, B_2, B_3\\right] \\] \\[ W = \\left[ \\begin{array}{c} -t^3 + 3t^2 - 3t + 1\\\\ 3t^3 -6 t^2 +3 t\\\\ -3 t^3 + t^2\\\\ t^3 \\end{array} \\right] \\] <p>\u3068\u30d9\u30af\u30c8\u30eb\u8868\u8a18\u3057\u305f\u5834\u5408\u3001\u4f4d\u7f6e\u306f\u6b21\u5f0f\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p> \\[ P(t) = B \\cdot W \\] <p>\u3053\u3053\u3067W\u3092\u4fc2\u6570\u3068tn\u306b\u5206\u89e3\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ W = W_m T =   \\left [\\begin{array}{c} -1 &amp; 3 &amp; -3 &amp; 1\\\\ 3 &amp; -6 &amp; 3 &amp; 0\\\\ -3 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] \\] <p>\u3053\u308c\u3092\u4f7f\u3046\u3068\u4f4d\u7f6e\u306e\u5f0f\u306f\u6b21\u306e\u3088\u3046\u306b\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b</p> \\[ P(t) = B  W_m T = \\left[B_0, B_1, B_2, B_3\\right] \\left [\\begin{array}{c} -1 &amp; 3 &amp; -3 &amp; 1\\\\ 3 &amp; -6 &amp; 3 &amp; 0\\\\ -3 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] \\] <p>T\u306e\u8981\u7d20\u3092t\u30671\u56de\u5fae\u5206\u30012\u56de\u5fae\u5206\u3057\u3066\u3059\u308b\u3053\u3068\u3067\u901f\u5ea6\u3001\u52a0\u901f\u5ea6\u3082\u8868\u73fe\u53ef\u80fd\u3067\u3042\u308b \u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408</p> \\[ T =  \\left [\\begin{array}{c} 3t^2\\\\ 2t\\\\ 1\\\\ 0 \\end{array} \\right ] \\] <p>\u52a0\u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408</p> \\[ T =  \\left [\\begin{array}{c} 6t\\\\ 2\\\\ 0\\\\ 0 \\end{array} \\right ] \\]"},{"location":"tech_note/path_planning/spline/#de-casteljaubezier","title":"De Casteljau\u6cd5\u306b\u3088\u308bBezier\u66f2\u7dda\u306e\u5206\u5272","text":"<p>\u89e3\u6790\u7684\u306b\u9023\u7d9a\u306a\u95a2\u6570\u3068\u3057\u3066\u66f2\u7dda\u304c\u5f97\u3089\u308c\u3066\u3082\u5b9f\u7528\u4e0a\u306f\u76f4\u7dda\u8fd1\u4f3c\u3057\u3066\u4f7f\u3046\u307f\u305f\u3044\u306a\u306e\u306f \u305d\u3093\u306a\u3068\u304d\u5a92\u4ecb\u5909\u6570t\u3067\u7b49\u5206\u3059\u308b\u3053\u3068\u3092\u307e\u305a\u601d\u3044\u3064\u304f\u3060\u308d\u3046\u304c\u66f2\u7387\u304c\u5c0f\u3055\u3044\u3068\u3053\u308d\u3067\u7121\u99c4\u306b\u5206\u5272\u3055\u308c\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3057\u3001\u66f2\u7387\u304c\u5927\u304d\u3044\u3068\u3053\u308d\u3067\u5206\u5272\u304c\u8db3\u308a\u305a\u306b\u4e0a\u624b\u304f\u66f2\u7dda\u8fd1\u4f3c\u3067\u304d\u306a\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\u76f4\u7dda\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306b\u306f\u66f2\u7387\u306b\u3088\u3063\u3066\u5206\u5272\u3059\u308b\u533a\u5206\u306e\u9577\u3055\u3092\u5909\u3048\u305f\u307b\u3046\u304c\u8fd1\u4f3c\u5ea6\u304b\u3089\u8003\u3048\u308b\u3068\u5408\u7406\u7684\u3060\u308d\u3046\u3002</p> <p>Bezier\u66f2\u7dda</p> \\[ P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) \\quad \\quad t \\in [0, 1] \\] <p>\u3092t0\u30672\u3064\u306e\u533a\u9593\u306b\u5206\u5272\u3059\u308b</p> \\[ P_0(t) = \\sum_{i = 0}^{N-1}B_{0i} J_{N-1, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] \\] \\[ P_1(t) = \\sum_{i = 0}^{N-1}B_{1i} J_{N-1, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] \\] <p>\u4eca\u3001\u898b\u3084\u3059\u3055\u306e\u305f\u3081\u306bn\u2004=\u2004N\u2005\u2212\u20051\u3068\u3057\u3066\u304a\u304f</p> \\[ P_0(t) = \\sum_{i = 0}^{n}B_{0i} J_{n, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] \\] \\[ P_1(t) = \\sum_{i = 0}^{n}B_{1i} J_{n, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] \\] <p>\u3053\u306e\u3068\u304dB0n,\u2006B1n\u306e\u8a08\u7b97\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u518d\u5e30\u7684\u306b\u4e0e\u3048\u3089\u308c\u308b</p> \\[ \\begin{array}{l} B_i^{(0)} := B_i \\quad \\quad \\quad i = 0, 1 \\cdots n\\\\ B_i^{(j)} := B_i^{(j-1)}(1-t_0) + B_{i+1}^{(j-1)}t_0 i \\quad \\quad i = 0, 1 \\cdots (n-j), \\quad  j = 1, 2 \\cdots n\\\\ \\end{array} \\] <p>\u3068\u5b9a\u7fa9\u3057\u305f\u3068\u304d</p> \\[ \\begin{array}{l} B_{0n} = B_0^{(i)}\\\\ B_{1n}= B_i^{(n-1)} \\end{array} \\] <p>N\u2004=\u20044\u306b\u3064\u3044\u3066\u7dda\u5f62\u88dc\u9593\u95a2\u6570lerp(a,\u2006b,\u2006t)\u3092\u5b9a\u7fa9\u3057\u305f\u4e0a\u3067\u66f8\u304d\u4e0b\u3057\u3066\u307f\u308b</p> \\[ lerp(a, b, t) := a(1-t) + bt \\quad \\quad t \\in [0, 1] \\] <p>\u3068\u3057\u3066\u5206\u5272\u524d\u306e\u4fc2\u6570B\u2004=\u2004[B0,\u2006B1,\u2006B2,\u2006B3],\u5206\u5272\u5f8c\u306e\u4fc2\u6570\u3092\u305d\u308c\u305e\u308cSB0\u2004=\u2004[B00,\u2006B01,\u2006B02,\u2006B03],SB1\u2004=\u2004[B10,\u2006B11,\u2006B12,\u2006B13]\u3068\u3057\u3066t0\u3067B\u3092\u5206\u5272\u3059\u308b\u3068</p> \\[ SB_0 =  \\left[ \\begin{array}{l} B_0\\\\ lerp(B_0, B_1, t_0)\\\\ lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0)\\\\ lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0) \\end{array} \\right] \\] \\[ SB_1 =  \\left[ \\begin{array}{l} lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0)\\\\ lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0)\\\\ lerp(B_2, B_3, t_0)\\\\ B_3 \\end{array} \\right] \\]"},{"location":"tech_note/path_planning/spline/#_6","title":"\u66f2\u7dda\u306e\u9577\u3055","text":"<p>Bezier\u66f2\u7dda\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b Bezier\u66f2\u7dda\u3067\u306a\u3044\u66f2\u7dda\u306b\u3064\u3044\u3066\u306fBezier\u66f2\u7dda\u306b\u5909\u63db\u3067\u304d\u308b\u306e\u3067\u3053\u3053\u3067\u306f\u8003\u3048\u306a\u3044\u3082\u306e\u3068\u3059\u308b</p>"},{"location":"tech_note/path_planning/spline/#_7","title":"\u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u3066\u307f\u308b","text":"<p>\u53b3\u5bc6\u306b\u8003\u3048\u305a\u306b\u3042\u308b\u7a0b\u5ea6\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3053\u3068\u3092\u8003\u3048\u308b \u4e0b\u306e\u56f3\u3088\u308a\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u9577\u3055\u306f\u5927\u96d1\u628a\u306b\u898b\u3066\u3082|P3\u2212P0|\u4ee5\u4e0a\u3067|P1\u2212P0|\u2005+\u2005|P2\u2212P1|\u2005+\u2005|P3\u2212P2|\u4ee5\u4e0b\u3067\u3042\u308b\u3053\u3068\u304c\u898b\u3066\u53d6\u308c\u308b\u3060\u308d\u3046</p> <p></p> <p>(\u51fa\u5178\uff1a1.\u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u306f)</p> <p>\u4ecaMinLength\u3068MaxLength\u3092\u6b21\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3059\u308b</p> \\[ \\begin{aligned} MinLnegth &amp;= |P_3-P_0|\\\\ &amp;= \\sqrt{(P_{3x}-P_{0x})^2 + (P_{3y}-P_{0y})^2}\\\\ MaxLength &amp;= |P_1-P_0| + |P_2-P_1| + |P_3-P_2|\\\\ &amp;= \\sqrt{(P_{1x}-P_{0x})^2 + (P_{1y}-P_{0y})^2} +  \\sqrt{(P_{2x}-P_{1x})^2 + (P_{2y}-P_{1y})^2} + \\sqrt{(P_{3x}-P_{2x})^2 + (P_{3y}-P_{2y})^2} \\end{aligned} \\] <p>(Pn\u306f\u524d\u9805\u307e\u3067Bn\u3068\u8a18\u8ff0\u3057\u3066\u3044\u305f\u3051\u3069\u753b\u50cf\u3092\u4f5c\u308b\u306e\u304c\u9762\u5012\u304f\u3055\u304f\u3066\u6301\u3063\u3066\u304d\u305f\u306e\u306b\u5408\u308f\u305b\u305f\u3060\u3051\u306a\u306e\u3067\u8aa4\u89e3\u3057\u306a\u3044\u3067\u306d)</p> <p>\u3053\u306e\u5e73\u5747\u3092\u5927\u4f53\u306e\u9577\u3055\u3068\u3057\u3066\u5b9a\u7fa9\u3059\u308b</p> \\[ EstimateLength = \\frac{MinLength + MaxLength}{2} \\] <p>\u3059\u308b\u3068\u8aa4\u5dee\u306f\u5927\u304d\u304f\u3066\u3082\u5dee\u306e\u534a\u5206\u3067\u3042\u308b</p> \\[ MaxError = \\frac{MaxLength - MinLength}{2} \\]"},{"location":"tech_note/path_planning/spline/#_8","title":"\u8a31\u5bb9\u8aa4\u5dee\u306e\u60c5\u5831\u3092\u4f7f\u3063\u3066\u89e3\u50cf\u5ea6\u3092\u6700\u9069\u5316\u3059\u308b","text":"<p>\u4e0a\u8a18\u306e\u65b9\u6cd5\u3067\u300c\u5927\u4f53\u306e\u300d\u9577\u3055\u304c\u6c42\u307e\u308b\u3002MaxError\u306e\u5024\u304c\u5927\u304d\u3051\u308c\u3070\u66f2\u7dda\u306e\u524d\u8ff0\u306e\u65b9\u6cd5\u3067\u5206\u89e3\u3057\u3066\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u518d\u5e30\u7684\u306a\u51e6\u7406\u306b\u306a\u308b\u3060\u308d\u3046\u3002\u3053\u3053\u3067\u6ce8\u610f\u3059\u308b\u306e\u306fMaxError\u306f\u3042\u304f\u307e\u3067MinLength\u3068MaxLength\u304b\u3089\u898b\u305f\u8aa4\u5dee\u306e\u6700\u5927\u3067\u7cbe\u5ea6\u304c\u307b\u3057\u3044\u304b\u3089\u3068\u8a00\u3063\u3066MaxError\u304c0.001\u3092\u4e0b\u56de\u308b\u307e\u3067\u5206\u5272\u3057\u7d9a\u3051\u308b\u306a\u3093\u3066\u5fc5\u8981\u306f\u306a\u3044\u3002\u691c\u8a3c\u306f\u3057\u3066\u306a\u3044\u304c0.1\u3001\u5c0f\u3055\u304f\u3066\u30820.05\u3092\u4e0b\u56de\u3063\u3066\u3044\u308c\u3070\u5341\u5206\u306a\u7cbe\u5ea6\u3092\u5f97\u3089\u308c\u308b\u3068\u601d\u3046\u3002</p>"},{"location":"tech_note/path_planning/spline/#_9","title":"\u533a\u9593\u3092\u6307\u5b9a\u3057\u3066\u9577\u3055\u3092\u6c42\u3081\u308b","text":"<p>\u4e0a\u3067\u6c42\u3081\u305f\u9577\u3055\u306ft\u304c0\u304b\u30891\u307e\u3067\u306e\u9577\u3055\u3068\u6349\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u4efb\u610f\u306et\u306e\u533a\u9593\u306b\u304a\u3051\u308b\u9577\u3055\u306b\u3064\u3044\u3066\u62e1\u5f35\u3059\u308b\u306b\u306f\u533a\u9593\u306e\u5206\u5272\u3092\u6d3b\u7528\u3059\u308b</p> <p>t0\u304b\u3089t1\u306e\u7bc4\u56f2\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3068\u304d t0\u2004=\u20040\u306e\u3068\u304d -&gt; t1\u3067\u5206\u5272\u3057\u305f\u524d\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 t1\u2004=\u20041\u306e\u3068\u304d -&gt; t0\u3067\u5206\u5272\u3057\u3066\u5f8c\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 \u305d\u308c\u4ee5\u5916\u306e\u3068\u304d -&gt; \u5206\u5272\u3092\u4e8c\u56de\u884c\u3063\u3066\u533a\u9593\u3092\u51fa\u3057\u3066\u304b\u3089\u9577\u3055\u3092\u51fa\u3059</p>"},{"location":"tech_note/path_planning/spline/#1","title":"\u6570\u5024\u7684\u306b\u901f\u5ea6\u30921\u306b\u3059\u308b","text":"<p>\u5a92\u4ecb\u5909\u6570t\u3092\u7528\u3044\u3066t\u3092\u52d5\u304b\u3057\u305f\u3068\u304d\u306b\u66f2\u7dda\u306e\u4e0a\u3092\u79fb\u52d5\u3059\u308b\u70b9\u306e\u901f\u5ea6\u306f\u4e00\u5b9a\u3067\u306f\u306a\u3044\u3002Catmull-Rom\u66f2\u7dda\u3084Cubic-Spline\u66f2\u7dda\u3067\u306f\u901f\u5ea6\u3092\u6307\u5b9a\u3057\u306a\u3044\u305f\u3081\u901f\u5ea6\u306b\u3064\u3044\u3066\u8003\u3048\u306b\u304f\u3044\u3002 \u901f\u5ea6\u3092\u7dda\u5f62\u5316\u3059\u308b\u3088\u3046\u306a\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u3066\u5a92\u4ecb\u5909\u6570\u3068\u3057\u3066\u66f2\u7dda\u306e\u95a2\u6570\u306b\u6e21\u3059\u3053\u3068\u306b\u306a\u308b\u304c\u3053\u306e\u95a2\u6570\u306f\u89e3\u6790\u7684\u306b\u6c42\u3081\u308b\u306e\u306f\u3067\u304d\u306a\u3044(\u3068\u601d\u3046)\u306e\u3067\u6570\u5024\u7684\u306b\u5b9f\u88c5\u3059\u308b\u65b9\u6cd5\u3092\u3068\u308b</p> <p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#_10","title":"\u66f2\u7387","text":"<p>\u8a73\u7d30\u306f\u7701\u7565\u3059\u308b\u304c\u5fd8\u308c\u304c\u3061\u306a\u306e\u3067\u66f8\u3044\u3066\u304a\u304f</p> <p>\u66f2\u7387\u03ba\u3068\u66f2\u7387\u534a\u5f84R\u306e\u95a2\u4fc2</p> \\[ \\kappa = \\frac{1}{R} \\] <p>\u901f\u5ea6\u30d9\u30af\u30c8\u30ebv\u3068\u52a0\u901f\u5ea6\u30d9\u30af\u30c8\u30eba\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d</p> \\[ R = \\frac{|v|^3}{|v\\times a|} \\]"},{"location":"tech_note/path_planning/spline/#todo","title":"(Todo)\u4efb\u610f\u306e\u5ea7\u6a19\u304b\u3089\u4e00\u756a\u8fd1\u3044\u66f2\u7dda\u4e0a\u306e\u70b9\u3092\u51fa\u3059","text":"<p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#_11","title":"\u5186\u5f27\u8fd1\u4f3c","text":"<p>\u5186\u5468\u4e0a\u306e\u4e8c\u70b9\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u305d\u306e\u4e8c\u70b9\u3092\u7d50\u3076\u5186\u5f27\u3092Hermite\u66f2\u7dda\u3067\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8003\u3048\u308b\u3002</p> <p>\u524d\u63d0\u6761\u4ef6\u3068\u3057\u3066</p> <ul> <li>\u4e8c\u70b9\u306f\u4e00\u3064\u306e\u5186\u5468\u4e0a\u306b\u3042\u308b</li> </ul> <p>Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\\(P_0\\), \\(P_1\\), \\(v_0\\), \\(v_1\\)\u306e\u3046\u3061\\(P_0\\), \\(P_1\\)\u306f\u4e0e\u3048\u3089\u308c\u305f\u4e8c\u70b9\u3001\\(v_0\\), \\(v_1\\)\u306e\u65b9\u5411\u306f\u5186\u306b\u6b63\u63a5\u3067\u5927\u304d\u3055\u306f\u4ee5\u4e0b\u3067\u8fd1\u4f3c\u3055\u308c\u308b</p> \\[ \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \\] <p>\u3053\u3053\u3067\\(\\theta\\)\u306f\u5186\u5f27\u306e\u89d2\u5ea6\u3001\\(r\\)\u306f\u5186\u306e\u534a\u5f84</p> <p>\u307e\u305f\u3053\u306e\u8fd1\u4f3c\u306f\\(\\theta &lt; \\pi\\)\u306e\u3068\u304d\u306b\u6709\u52b9\u3067\u3042\u308a\u305d\u308c\u4ee5\u4e0a\u3067\u306f\u8457\u3057\u304f\u5186\u5f27\u304b\u3089\u96e2\u308c\u3066\u3057\u307e\u3046\u305f\u3081\u6ce8\u610f\u304c\u5fc5\u8981</p>"},{"location":"tech_note/path_planning/spline/#_12","title":"\u7279\u6b8a\u306a\u6761\u4ef6\u3067\u306e\u5186\u5f27\u8fd1\u4f3c(\u5f0f\u5909\u5f62)","text":"<p>\u65e2\u77e5\u306e\u30d1\u30e9\u30e1\u30fc\u30bf</p> <ul> <li>\\(r\\)</li> <li>\\(P_0\\), \\(P_1\\)</li> <li>\\(v_0\\), \\(v_1\\)\u306e\u65b9\u5411</li> </ul> \\[ cos\\theta = \\frac{v_0 \\cdot v_1}{|v_0| |v_1|} \\] <p>\u534a\u89d2\u516c\u5f0f</p> \\[ cos\\theta = \\sqrt{\\frac{1+cos\\theta}{2}} \\] <p>\u534a\u89d2\u516c\u5f0f</p> \\[ \\tan\\frac{\\theta}{4} = \\sqrt{ \\frac{1-\\cos{ \\frac{\\theta}{2}}}{1+\\cos{\\frac{\\theta}{2}}}  } \\] \\[ \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \\]"},{"location":"tech_note/path_planning/spline/#_13","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30d9\u30b8\u30a7\u66f2\u7dda</li> <li>\u30b2\u30fc\u30e0\u30d7\u30ed\u30b0\u30e9\u30de\u306e\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30c8\u30ea\u30c3\u30af\u66f2\u7dda\u5165\u9580(Hermite Curve)</li> <li>t-pot\u300e3\u6b21\u66f2\u7dda\u300f</li> <li>\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b0\u30e9\u30d5\u30a3\u30af\u30b9\u8ad6</li> <li>\u7c21\u7565\u5316\u3057\u305f3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u751f\u6210\u65b9\u6cd5</li> <li>\uff13\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u88dc\u9593\u306e\u6982\u8981\u3068C++, Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9</li> <li> <p>De Casteljau\u2019s algorithm</p> </li> <li> <p>\u30d9\u30b8\u30a7\u66f2\u7dda\u3067\u63cf\u304f\u5186\u5f27\u3068\u672c\u7269\u306e\u5186\u5f27\u306e\u5dee\uff08\u4e2d\u5fc3\u89d2\u306b\u3064\u3044\u3066\u4e00\u822c\u5316\uff09</p> </li> </ul>"},{"location":"tech_note/path_planning/wave_propagation/","title":"Wave propagation","text":"<p>Wave propagation\u306f\u30b0\u30ea\u30c3\u30c9\u306e\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u4e00\u7a2e\u3067\u3042\u308b\u3002A*\u3088\u308a\u5c48\u6298\u304c\u5c11\u306a\u3044\u5f62\u306e\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u3002</p>"},{"location":"tech_note/path_planning/wave_propagation/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>Path Planning #2 Wave Propagation, Potential Fields &amp; Modern(ish) C++ (YouTube)</li> </ul>"},{"location":"tech_note/software_design/design_pattern/","title":"\u30c7\u30b6\u30a4\u30f3\u30d1\u30bf\u30fc\u30f3","text":""},{"location":"tech_note/software_design/solid/","title":"SOLID\u539f\u5247","text":"<p>SOLID\u539f\u5247\u3068\u306f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u5de5\u5b66\u306e\u7528\u8a9e\u3067\u3001\u7279\u306b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u3067\u7528\u3044\u3089\u308c\u308b5\u3064\u306e\u539f\u5247\u306e\u982d\u6587\u5b57\u3092\u53d6\u3063\u305f\u3082\u306e\u3002 \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u8a2d\u8a08\u3092\u3088\u308a\u5e73\u6613\u304b\u3064\u67d4\u8edf\u306b\u3057\u3066\u4fdd\u5b88\u3057\u3084\u3059\u304f\u3059\u308b\u3053\u3068\u3092\u76ee\u7684\u306b\u3057\u3066\u3044\u308b\u3002\u305d\u306e\u7279\u5fb4\u306f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u4ef2\u4ecb\u306b\u3057\u3066\u306e\u6a5f\u80fd\u306e\u4f7f\u7528\u3068\u3001\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306b\u3088\u308b\u6a5f\u80fd\u306e\u6ce8\u5165\u3067\u3042\u308b\u3002</p> <p>SOLID\u306f\u3001\u6b21\u306e5\u3064\u306e\u539f\u5247\u304b\u3089\u306a\u308b\u3002</p> <ul> <li>\u5358\u4e00\u8cac\u4efb\u306e\u539f\u5247 (single-responsibility principle)</li> <li>\u958b\u653e\u9589\u9396\u306e\u539f\u5247\uff08open/closed principle\uff09</li> <li>\u30ea\u30b9\u30b3\u30d5\u306e\u7f6e\u63db\u539f\u5247\uff08Liskov substitution principle\uff09</li> <li>\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u5206\u96e2\u306e\u539f\u5247 (interface segregation principle)</li> <li>\u4f9d\u5b58\u6027\u9006\u8ee2\u306e\u539f\u5247\uff08dependency inversion principle\uff09</li> </ul>"},{"location":"tech_note/software_design/solid/#_1","title":"\u5358\u4e00\u8cac\u4efb\u306e\u539f\u5247","text":"<p>\u300c\u5909\u66f4\u3059\u308b\u305f\u3081\u306e\u7406\u7531\u304c\u3001\u4e00\u3064\u306e\u30af\u30e9\u30b9\u306b\u5bfe\u3057\u3066\u4e00\u3064\u4ee5\u4e0a\u3042\u3063\u3066\u306f\u306a\u3089\u306a\u3044\u300d</p> <p>\u5404\u30af\u30e9\u30b9\u306f\u305d\u308c\u305e\u308c\u3072\u3068\u3064\u3060\u3051\u306e\u8cac\u52d9(=\u63d0\u4f9b\u6a5f\u80fd)\u3092\u6301\u3064\u3079\u304d\u3067\u3042\u308a\u3001\u30b2\u30fc\u30e0\u3092\u4f8b\u306b\u53d6\u308c\u3070\u30b2\u30fc\u30e0\u306e\u9032\u884c\u30ed\u30b8\u30c3\u30af\u3092\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u306f\u63cf\u753b\u3084\u30b5\u30a6\u30f3\u30c9\u306e\u51e6\u7406\u307e\u3067\u3092\u62c5\u5f53\u3057\u306a\u3044\u3053\u3068\u306b\u306a\u308b\u3002</p>"},{"location":"tech_note/software_design/solid/#_2","title":"\u958b\u653e\u9589\u9396\u306e\u539f\u5247","text":"<p>\u300c\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u5b9f\u4f53\uff08\u30af\u30e9\u30b9\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u95a2\u6570\u306a\u3069\uff09\u306f\u3001\u62e1\u5f35\u306b\u5bfe\u3057\u3066\u958b\u304b\u308c\u3066\u3044\u308b\u3079\u304d\u3067\u3042\u308a\u3001\u4fee\u6b63\u306b\u5bfe\u3057\u3066\u9589\u3058\u3066\u3044\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u300d</p> <p>\u30af\u30e9\u30b9\u3092\u5909\u66f4\u3059\u308b\u3068\u305d\u306e\u30af\u30e9\u30b9\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u5168\u3066\u306e\u30b7\u30b9\u30c6\u30e0\u306b\u5f71\u97ff\u304c\u3042\u308b\u3002\u5f71\u97ff\u3092\u6700\u5c0f\u9650\u306b\u6291\u3048\u308b\u305f\u3081\u30d0\u30b0\u4fee\u6b63\u3084\u5909\u66f4\u306f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306b\u307e\u3067\u5909\u66f4\u3092\u52a0\u3048\u305a\u9589\u3058\u305f\u3082\u306e\u3067\u5728\u308b\u3079\u304d\u3067\u3001\u9006\u306b\u958b\u3044\u305f\u3082\u306e\u3067\u3042\u308b\u306e\u306f\u6a5f\u80fd\u8ffd\u52a0\u306a\u3069\u306e\u62e1\u5f35\u306e\u307f\u3067\u3042\u308b\u3079\u304d</p>"},{"location":"tech_note/software_design/solid/#_3","title":"\u30ea\u30b9\u30b3\u30d5\u306e\u7f6e\u63db\u539f\u5247","text":"<p>\u300c\u3042\u308b\u57fa\u5e95\u30af\u30e9\u30b9\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u306a\u3044\u3057\u53c2\u7167\u3092\u6271\u3063\u3066\u3044\u308b\u95a2\u6570\u7fa4\u306f\u3001\u305d\u306e\u6d3e\u751f\u30af\u30e9\u30b9\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8a73\u7d30\u3092\u77e5\u3089\u306a\u304f\u3066\u3082\u6271\u3048\u308b\u3088\u3046\u306b\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u300d</p> <p>\u5b50\u30af\u30e9\u30b9\u306f\u89aa\u30af\u30e9\u30b9\u306e\u4ed5\u69d8\u3092\u6e80\u305f\u3059\u3079\u304d\u3067\u3042\u308b</p>"},{"location":"tech_note/software_design/solid/#_4","title":"\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u5206\u96e2\u306e\u539f\u5247","text":"<p>\u300c\u6c4e\u7528\u306a\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u304c\u4e00\u3064\u3042\u308b\u3088\u308a\u3082\u3001\u5404\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u7279\u5316\u3057\u305f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u304c\u305f\u304f\u3055\u3093\u3042\u3063\u305f\u65b9\u304c\u3088\u3044\u300d</p> <p>\u4f3c\u305f\u6a5f\u80fd\u3092\u63d0\u4f9b\u3059\u308b\u30af\u30e9\u30b9\u3067\u3082\u7528\u9014\u3054\u3068\u306b\u6a5f\u80fd\u5206\u5316\u3055\u308c\u308b\u3079\u304d\u3067\u3001\u5de8\u5927\u306a\u5171\u901a\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u4f5c\u308b\u3053\u3068\u306f\u4e88\u671f\u3057\u306a\u3044\u30d0\u30b0\u3092\u767a\u751f\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b</p>"},{"location":"tech_note/software_design/solid/#_5","title":"\u4f9d\u5b58\u6027\u9006\u8ee2\u306e\u539f\u5247","text":"<p>\u300c\u4e0a\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3044\u304b\u306a\u308b\u3082\u306e\u3082\u4e0b\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u6301\u3061\u8fbc\u3093\u3067\u306f\u306a\u3089\u306a\u3044\u3002\u53cc\u65b9\u3068\u3082\u5177\u8c61\u3067\u306f\u306a\u304f\u3001\u62bd\u8c61\uff08\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306a\u3069\uff09\u306b\u4f9d\u5b58\u3059\u308b\u3079\u304d\u3067\u3042\u308b\u300d</p> <p>\u3042\u308b\u30af\u30e9\u30b9\u304c\u5225\u30af\u30e9\u30b9\u3092\u4e0b\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u3084\u30e1\u30f3\u30d0\u3068\u3057\u3066\u4f7f\u3046\u969b\u306b\u306f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u901a\u3058\u3066\u95a2\u4fc2\u6027\u304c\u62bd\u8c61\u5316\u3055\u308c\u308b\u3053\u3068\u3067\u4f9d\u5b58\u5ea6\u3092\u6e1b\u3089\u3059\u3079\u304d</p>"},{"location":"tech_note/software_design/solid/#_6","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>SOLID</li> <li>\u30a4\u30e9\u30b9\u30c8\u3067\u7406\u89e3\u3059\u308bSOLID\u539f\u5247</li> </ul>"},{"location":"tech_note/system/discrete/","title":"\u96e2\u6563\u5316","text":"<p>\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u30b7\u30b9\u30c6\u30e0\u30e2\u30c7\u30eb\u3092\u6271\u3046\u969b\u306b\u306f\u3075\u308b\u307e\u3044\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b\u305f\u3081\u306b\u9023\u7d9a\u6642\u9593\u9818\u57df\u3084s\u9818\u57df\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u4ee5\u4e0b\u306b\u96e2\u6563\u5316\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u8ff0\u3079\u308b\u3002</p>"},{"location":"tech_note/system/discrete/#_2","title":"\u96e2\u6563\u5316\u624b\u6cd5\u3068\u65b9\u6cd5","text":"<ul> <li>ZOH\u6cd5(0\u6b21\u30db\u30fc\u30eb\u30c9)</li> <li>\u5f8c\u9000\u5dee\u5206\u6cd5</li> <li>\u30aa\u30a4\u30e9\u30fc\u6cd5</li> <li>\u53cc\u4e00\u6b21\u5909\u63db</li> </ul>"},{"location":"tech_note/system/discrete/#_3","title":"\u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316","text":"<p>\u4f1d\u9054\u95a2\u6570</p> \\[ G(s) = \\frac{num(s)}{den(s)} \\] <p>\u306b\u5bfe\u3057\u3066</p> \\[ s = \\frac{2}{T} \\frac{z-1}{z+1} \\] <p>\u3068\u3057\u3066z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306b\u5909\u63db\u3057\u305f\u5f8c</p> \\[ \\frac{y}{u} = \\frac{num(z)}{den(z)} \\] <p>\u306e\u5f62\u3092\u5909\u5f62\u3059\u308b\u3053\u3068\u3067</p> \\[ y = f(u, u^{-1}, u^{-2} \\cdots, y^{-1}, y^{-2} \\cdots) \\] <p>\u3092\u5f97\u308b\u3002</p>"},{"location":"tech_note/system/discrete/#_4","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316","text":"<p>Waring</p> <p>Todo</p>"},{"location":"tech_note/system/discrete/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u96e2\u6563\u5316\u624b\u6cd5\u306e\u6bd4\u8f03 [Python Scipy]</li> <li>\u96e2\u6563\u5316 (Wikipedia)</li> <li>\u53cc\u4e00\u6b21\u5909\u63db (Wikipedia)</li> <li>\u9023\u7d9a\u7cfb\u306e\u4ee3\u8868\u7684\u306a\u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316</li> </ul>"},{"location":"tech_note/system/link_dynamics/","title":"\u30ea\u30f3\u30af\u30ed\u30dc\u30c3\u30c8\u306e\u904b\u52d5\u30e2\u30c7\u30eb\u306e\u5c0e\u51fa","text":"<p>\u30cb\u30e5\u30fc\u30c8\u30f3\u30fb\u30aa\u30a4\u30e9\u30fc\u6cd5\u306b\u3088\u308b\u5c0e\u51fa</p>"},{"location":"tech_note/system/link_dynamics/#_2","title":"\u30d1\u30e9\u30e1\u30fc\u30bf","text":"<p>\\({}^i\\Omega_i\\) \u5404\u30ea\u30f3\u30af\u306e\u89d2\u901f\u5ea6 \\({}^i\\dot{\\Omega}_i\\) \u5404\u30ea\u30f3\u30af\u306e\u89d2\u901f\u5ea6 \\({}^iV_i\\) \u5404\u30ea\u30f3\u30af\u306e\u901f\u5ea6 \\({}^i\\dot{V}_i\\) \u5404\u30ea\u30f3\u30af\u306e\u52a0\u901f\u5ea6  </p> <p>\\({}^i\\dot{Vc}_i\\) \u5404\u30ea\u30f3\u30af\u306e\u91cd\u5fc3\u306e\u52a0\u901f\u5ea6  </p> <p>\\({}^iR_{i+i}\\) \u5ea7\u6a19\\(i\\)\u304b\u3089\\(i+1\\)\u3078\u306e\u5909\u63db\u884c\u5217  </p> <p>\\({}^iFc_i\\) \u529b \\({}^iNc_i\\) \u30c8\u30eb\u30af  </p> <p>\\({}^iF_i\\) \u529b \\({}^iN_i\\) \u30c8\u30eb\u30af  </p>"},{"location":"tech_note/system/link_dynamics/#_3","title":"\u9806\u65b9\u5411\u8a08\u7b97","text":""},{"location":"tech_note/system/link_dynamics/#_4","title":"\u9006\u65b9\u5411\u8a08\u7b97","text":"\\[ {}^iF_i = {}^i_{i+1}R^{i+1}F_{i+1} + {}^iFc_{i} \\\\ {}^iN_i = {}^iNc_i + {}^i_{i+1}R^{i+1} N_{i+1} + {}^iPc_i \\times {}^iFc_{i}+{}^iP_{i+1} \\times {}^i_{i+1}R^{i+1} {}^{i+1}F_{i+1} \\]"},{"location":"tech_note/system/state_space_system/","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe","text":"<p>\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u3068\u306f\u5165\u529b\u3068\u51fa\u529b\u3068\u72b6\u614b\u5909\u6570\u3092\u4f7f\u3063\u305f\u4e00\u968e\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3067\u8868\u3057\u305f\u6570\u5b66\u7684\u30e2\u30c7\u30eb\u3067\u3042\u308b\u3002</p> \\[ \\begin{array}{lll} \\dot{x}(t) &amp;=&amp; Ax(t) + Bu(t)\\\\ y(t) &amp;=&amp; Cx(t) + Du(t) \\end{array} \\]"},{"location":"tech_note/system/state_space_system/#_2","title":"\u53ef\u5236\u5fa1\u6027","text":"<p>\u53ef\u5236\u5fa1\u6027\u3068\u306f\u6709\u9650\u6642\u9593\u306e\u5165\u529b\u3067\u521d\u671f\u72b6\u614b\u304b\u3089\u4efb\u610f\u306e\u72b6\u614b\u306b\u5909\u5316\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u5236\u5fa1\u3067\u3042\u308b\u3068\u3044\u3046\u3002</p> \\[ \\rm{rank} \\left[ B \\space AB \\space A^2B \\cdots A^{n-1}B\\right] = n \\]"},{"location":"tech_note/system/state_space_system/#_3","title":"\u53ef\u89b3\u6e2c\u6027","text":"<p>\u53ef\u89b3\u6e2c\u6027\u3068\u306f\u30b7\u30b9\u30c6\u30e0\u306e\u51fa\u529b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u3067\u30b7\u30b9\u30c6\u30e0\u306e\u5185\u90e8\u72b6\u614b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u89b3\u6e2c\u3067\u3042\u308b\u3068\u3044\u3046\u3002</p> \\[ \\rm{rank} \\begin{bmatrix}  C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n-1} \\end{bmatrix} = n \\]"},{"location":"tech_note/system/state_space_system/#_4","title":"\u6b63\u6e96\u5f62","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306e\u751f\u606f\u884c\u5217\u306b\u3088\u3063\u3066\u540c\u5024\u5909\u63db\u3057\u3066\u3082\u57fa\u672c\u7684\u306a\u6027\u8cea\u306f\u5909\u5316\u3057\u306a\u3044\u3002\u4e2d\u3067\u3082\u6709\u540d\u306a\u6b63\u6e96\u5f62\u3092\u7d39\u4ecb\u3059\u308b</p>"},{"location":"tech_note/system/state_space_system/#_5","title":"\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62","text":"<p>\u5909\u63db\u884c\u5217\u306b\u53ef\u5236\u5fa1\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u5909\u63db\u3092\u884c\u3046\u3002\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092\\(U_c\\)\u3068\u3057\u3066</p> \\[ \\begin{array}{lll} \\tilde{A} = U_c^{-1} A U_c \\\\ \\tilde{B} = U_c^{-1} B \\\\ \\tilde{C} = C U_c \\\\ \\tilde{D} = D \\end{array} \\]"},{"location":"tech_note/system/state_space_system/#_6","title":"\u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62","text":"<p>\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306b\u5bfe\u3057\u3066\u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62\u306f\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3002</p> \\[ \\begin{array}{lll} A_o = A_c^T \\\\ B_o = C_c^T \\\\ C_o = B_c^T \\\\ D_o = D_c \\end{array} \\]"},{"location":"tech_note/system/transfer_function/","title":"\u4f1d\u9054\u95a2\u6570","text":"<p>\u4f1d\u9054\u95a2\u6570\u3068\u306f1\u5165\u529b1\u51fa\u529b\u30b7\u30b9\u30c6\u30e0\u306e\u5165\u51fa\u529b\u95a2\u4fc2\u3092\u8868\u3059\u95a2\u6570\u306e\u4e00\u7a2e\u3067\u3042\u308b\u3002 \u30b7\u30b9\u30c6\u30e0\u306e\u5168\u3066\u306e\u5909\u6570\u306e\u521d\u671f\u5024\u30920\u3068\u3057\u3066\u5165\u529b\u4fe1\u53f7\u3068\u51fa\u529b\u4fe1\u53f7\u306e\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u3092\\(X(s)\\),\\(Y(s)\\)\u3068\u3059\u308b\u3068 </p> \\[ G(s) = \\frac{Y(s)}{X(s)} \\] <p>\u3067\u8868\u3055\u308c\u308b\u3002</p> <p>\u6642\u9593\u9818\u57df\u306e\u5fae\u5206\u65b9\u7a0b\u5f0f\u7b49\u3067\u8868\u3055\u308c\u308b\u30e2\u30c7\u30eb\u3092\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u306b\u3088\u308a\u8907\u7d20\u5e73\u9762\u306b\u5199\u50cf\u3092\u53d6\u308b\u3002 \u5468\u6ce2\u6570\u9818\u57df\u306e\u5468\u6ce2\u6570\u4f1d\u9054\u95a2\u6570\u306f\u5b89\u5b9a\u6027\u306a\u3069\u306e\u89e3\u6790\u30fb\u8a55\u4fa1\u306b\u7528\u3044\u3089\u308c\u308b\u3002 \u7279\u6027\u306e\u8a55\u4fa1\u65b9\u6cd5\u3068\u3057\u3066\u30dc\u30fc\u30c9\u7dda\u56f3\u3084\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u7528\u3044\u305f\u3082\u306e\u304c\u3042\u308b\u3002</p> <p>\u4f1d\u9054\u95a2\u6570\u306f\u5206\u6bcd\u5206\u5b50\u306e\u4fc2\u6570\u3092\u884c\u5217\u306b\u914d\u7f6e\u3059\u308b\u3053\u3068\u3067\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306b\u5909\u63db\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"tech_note/system/transfer_function/#_2","title":"\u4f1d\u9054\u95a2\u6570\u4f8b","text":"\u8aac\u660e \u4f1d\u9054\u95a2\u6570 \u96e2\u6563\u4f1d\u9054\u95a2\u6570(\u53cc\u4e00\u6b21\u5909\u63db) \u7a4d\u5206\u8981\u7d20 \\(\\dfrac{1}{s}\\) \\(\\dfrac{T}{2} \\dfrac{z+1}{z-1}\\) \u5fae\u5206\u8981\u7d20 \\(s\\) - \u7121\u99c4\u6642\u9593\u8981\u7d20 \\(e^{-s\\tau}\\) - 1\u6b21\u9045\u308c \\(\\dfrac{\\omega}{s + \\omega}\\) \\(\\dfrac{T\\omega z + T\\omega}{(T\\omega + 2)z + (T\\omega - 2)}\\) 2\u6b21\u9045\u308c \\(\\dfrac{\\omega^2}{s^2 + 2\\zeta\\omega s + \\omega^2}\\) \\(\\dfrac{(T^2\\omega^2)z^2 + (2T^2\\omega^2)z + (T^2\\omega^2)}{(4+ 4T\\zeta \\omega +T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4-4T\\zeta \\omega + T^2\\omega^2)}\\)"},{"location":"tech_note/system/transfer_function/#_3","title":"\u5468\u6ce2\u6570\u3068\u6642\u5b9a\u6570","text":"<p>\u4f1d\u9054\u95a2\u6570\u3084\u30dc\u30fc\u30c9\u7dda\u56f3\u3067\u8b70\u8ad6\u3059\u308b\u3068\u304d\u306f\u5468\u6ce2\u6570\u306e\u5358\u4f4d\u304c[rad/s]\u3067\u3042\u308b\u3053\u3068\u304c\u591a\u3044\u3002[Hz]\u3068\u306e\u95a2\u4fc2\u306f</p> \\[ \\omega = 2\\pi f \\] <p>\u6642\u5b9a\u6570\u3068\u5468\u6ce2\u6570\u306e\u95a2\u4fc2\u306f</p> \\[ \\tau = \\frac{1}{\\omega} \\]"},{"location":"tech_note/system/transfer_function/#_4","title":"\u53c2\u8003\u6587\u732e","text":""}]}