{"config":{"lang":["ja"],"separator":"[\\s\\-\u3000\u3001\u3002\uff0c\uff0e]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"cpp_robotics","text":"<p>\u5236\u5fa1\u5de5\u5b66\u3001\u6700\u9069\u5316\u3001\u9006\u904b\u52d5\u5b66\u306a\u3069\u30ed\u30dc\u30c6\u30a3\u30af\u30b9\u306b\u591a\u7528\u3055\u308c\u308b\u6280\u8853\u3092\u30d1\u30c3\u30b1\u30fc\u30b8\u5316\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea</p>"},{"location":"#_1","title":"\u6a5f\u80fd","text":""},{"location":"#_2","title":"\u4f1d\u9054\u95a2\u6570\u30fb\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u8868\u73fe\u3068\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3","text":"<p>\u4f1d\u9054\u95a2\u6570\u3084\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u30af\u30e9\u30b9\u3092\u4f7f\u7528\u3057\u3066\u30b7\u30b9\u30c6\u30e0\u3092\u8868\u73fe\u3057\u3001\u5fdc\u7b54\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b</p>"},{"location":"#_3","title":"\u69d8\u3005\u306a\u5236\u5fa1\u5668\u306b\u3088\u308b\u5236\u5fa1\u7cfb\u306e\u5b9f\u73fe","text":"<p>PID\u5236\u5fa1\u5668\u3001LQR\u3001\u6975\u914d\u7f6e\u7b49\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3001MPC\u7b49\u306e\u5236\u5fa1\u7cfb\u3092\u69cb\u6210\u3059\u308b</p>"},{"location":"#_4","title":"\u6700\u9069\u5316","text":"<p>\u9023\u7d9a\u95a2\u6570\u306e\u6700\u9069\u5316\u3067\u6700\u9069\u5236\u5fa1\u306e\u5b9f\u73fe\u3092\u88dc\u52a9</p>"},{"location":"#_5","title":"\u30d5\u30a3\u30eb\u30bf","text":"<p>\u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3084\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u306f\u3058\u3081\u3001\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3084\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3001\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u7b49</p>"},{"location":"#_6","title":"\u9006\u904b\u52d5\u5b66","text":"<p>\u79fb\u52d5\u6a5f\u69cb\u3084\u30ed\u30dc\u30c3\u30c8\u306e\u30a2\u30fc\u30e0\u306e\u9006\u904b\u52d5\u5b66\u3092\u89e3\u304f\u305f\u3081\u306e\u30af\u30e9\u30b9</p>"},{"location":"#_7","title":"\u5358\u4f4d\u30af\u30e9\u30b9","text":"<p>SI\u5358\u4f4d\u7cfb\u3092\u5b9f\u88c5\u3057\u3066\u3042\u308a\u7269\u7406\u7684\u306a\u610f\u5473\u3092\u5bfe\u5fdc\u3055\u305b\u306a\u304c\u3089\u306e\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u304c\u53ef\u80fd \u7d44\u7acb\u5358\u4f4d\u306b\u3082\u5bfe\u5fdc</p>"},{"location":"#_8","title":"\u983b\u7e41\u306b\u4f7f\u7528\u3059\u308b\u30d9\u30af\u30c8\u30eb\u6f14\u7b97\u30af\u30e9\u30b9","text":"<p>Vector2 Vector3 Vector4 Quaternion Transform\u3092\u7528\u610f \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u6f14\u7b97\u3084\u30ce\u30eb\u30e0\u3001\u56de\u8ee2\u306e\u51e6\u7406\u3092\u7c21\u5358\u306b\u8a18\u8ff0</p>"},{"location":"#_9","title":"\u30e2\u30fc\u30bf\u30fc\u30af\u30e9\u30b9","text":"<p>DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u3092\u4f7f\u3063\u3066\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3</p>"},{"location":"#_10","title":"\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0","text":"<p>A*\u3001wave propagation\u3001\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3001Dubins\u66f2\u7dda</p>"},{"location":"#_11","title":"\u305d\u306e\u4ed6\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Kd\u6728, k-means\u6cd5, ICP\u30de\u30c3\u30c1\u30f3\u30b0\u7b49</p>"},{"location":"doxybook/classes/","title":"Classes","text":"<ul> <li>namespace cpp_robotics <ul> <li>class AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) <ul> <li>class DiffTri </li> </ul> </li> <li>class ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 <ul> <li>struct Problem </li> <li>struct Result </li> </ul> </li> <li>class AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b </li> <li>class AutoDiffAdaptor \u81ea\u52d5\u5fae\u5206\u3067\u30e4\u30b3\u30d3\u30a2\u30f3\u3092\u6c42\u3081\u308b\u30af\u30e9\u30b9 </li> <li>class BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </li> <li>class ButterworthFilter \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf </li> <li>class CatumullRom2D Catumull\u66f2\u7dda </li> <li>struct Circle \u5186\u30af\u30e9\u30b9 </li> <li>struct Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 </li> <li>class ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 </li> <li>class CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda </li> <li>struct DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </li> <li>struct DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </li> <li>class DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf </li> <li>class DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 <ul> <li>struct Kinematics </li> </ul> </li> <li>class Differentiator \u7591\u4f3c\u5fae\u5206\u5668 </li> <li>class Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b </li> <li>class DiscretTransferFunction </li> <li>class DubinsPath Dubins\u30d1\u30b9 <ul> <li>struct PlanningResult </li> </ul> </li> <li>class ExtendedKalmanFilter </li> <li>class FilterConnector </li> <li>class FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 </li> <li>struct GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb </li> <li>class HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </li> <li>class Integrator \u7a4d\u5206\u5668 </li> <li>class KDTree k-d\u6728 <ul> <li>struct Node </li> </ul> </li> <li>class KMeansMethod K-means\u6cd5 </li> <li>class KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf </li> <li>struct Line \u76f4\u7dda\u30af\u30e9\u30b9 </li> <li>class LinearMPC \u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9 </li> <li>class LinearRegulatorMPC </li> <li>struct LinkConfig </li> <li>class LinkRobot </li> <li>class LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc </li> <li>class MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb <ul> <li>struct Config </li> </ul> </li> <li>class NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 </li> <li>class NctfController NCTF\u5236\u5fa1\u5668 </li> <li>class NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf </li> <li>class Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb <ul> <li>struct Config </li> </ul> </li> <li>class Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb <ul> <li>struct Config </li> </ul> </li> <li>class PID PID\u5236\u5fa1\u5668 <ul> <li>struct pid_param_t </li> </ul> </li> <li>class PID2 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 <ul> <li>struct pid_param_t </li> </ul> </li> <li>class PSMC <ul> <li>struct param_t </li> </ul> </li> <li>struct Polynomial \u591a\u9805\u5f0f </li> <li>class PurePursuit Pure pursuit\u5236\u5fa1\u5668 </li> <li>struct Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 </li> <li>class QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 <ul> <li>struct Param </li> <li>struct Result </li> </ul> </li> <li>class Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 </li> <li>class RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 </li> <li>struct Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) </li> <li>class SISOPFC </li> <li>class SQP SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) <ul> <li>struct Problem </li> <li>struct Result </li> </ul> </li> <li>class Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b </li> <li>class SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 <ul> <li>struct func_list_t </li> </ul> </li> <li>class Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 <ul> <li>struct segment_info_t </li> <li>struct segment_t </li> </ul> </li> <li>class StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb </li> <li>class SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </li> <li>class Timer </li> <li>class TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb <ul> <li>class CircularBuffer </li> </ul> </li> <li>struct Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 </li> <li>struct Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 </li> <li>struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 </li> <li>struct Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </li> <li>struct Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </li> <li>struct Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </li> <li>class VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf <ul> <li>class DiffPair </li> </ul> </li> <li>class XY2degRobot <ul> <li>struct Kinematics </li> </ul> </li> <li>namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 </li> <li>namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 <ul> <li>struct GridNode </li> </ul> </li> <li>namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 <ul> <li>struct spline_c </li> </ul> </li> <li>namespace unit \u5358\u4f4d\u7cfb <ul> <li>struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 </li> <li>struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 </li> <li>class Unit \u5358\u4f4d\u30af\u30e9\u30b9 </li> <li>namespace prefix <ul> <li>struct pfx_div </li> <li>struct pfx_inv </li> <li>struct pfx_min </li> <li>struct pfx_mul </li> </ul> </li> <li>namespace tag <ul> <li>struct is_normal_tag </li> <li>struct is_normal_tag&lt; 0 &gt; </li> <li>struct is_normal_tag&lt;-1 &gt; </li> </ul> </li> <li>namespace unit_dimention </li> </ul> </li> <li>struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 </li> <li>class Unit \u5358\u4f4d\u30af\u30e9\u30b9 </li> <li>namespace prefix <ul> <li>struct pfx_div </li> <li>struct pfx_inv </li> <li>struct pfx_min </li> <li>struct pfx_mul </li> </ul> </li> <li>namespace tag <ul> <li>struct is_normal_tag </li> <li>struct is_normal_tag&lt; 0 &gt; </li> <li>struct is_normal_tag&lt;-1 &gt; </li> </ul> </li> <li>namespace unit_dimention </li> </ul> </li> <li>namespace std </li> <li>namespace unit_dim_assem </li> </ul> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/examples/","title":"Examples","text":"<p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/files/","title":"Files","text":"<ul> <li>dir include <ul> <li>dir include/cpp_robotics <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>dir include/cpp_robotics/algorithm <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/arm_ik <ul> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/chassis <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/controller <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/filter <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/geometry <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/motor <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/optimize <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/path_planning <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/system <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/unit <ul> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/utility <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>dir include/cpp_robotics/vector <ul> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> <li>file hpp </li> </ul> </li> </ul> </li> </ul> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/groups/","title":"Modules","text":"<p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/namespaces/","title":"Namespaces","text":"<ul> <li>namespace cpp_robotics <ul> <li>namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 </li> <li>namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 </li> <li>namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 </li> <li>namespace unit \u5358\u4f4d\u7cfb <ul> <li>namespace prefix </li> <li>namespace tag </li> <li>namespace unit_dimention </li> </ul> </li> <li>namespace prefix </li> <li>namespace tag </li> <li>namespace unit_dimention </li> </ul> </li> <li>namespace std </li> <li>namespace unit_dim_assem </li> </ul> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/related_pages/","title":"Pages","text":"<p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/","title":"cpp_robotics::AccelerationLimitFilter","text":"<p>\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f)  More...</p> <p><code>#include &lt;acceleration_limit_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#public-functions","title":"Public Functions","text":"Name AccelerationLimitFilter(double acc_max, double Ts, double gpd, double Kx, double Kv, std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt) AccelerationLimitFilter(double acc_max, double Ts, std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt) virtual void reset() virtual double filtering(double u) double Ts() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#detailed-description","title":"Detailed Description","text":"<pre><code>class cpp_robotics::AccelerationLimitFilter;\n</code></pre> <p>\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) </p> <p>\u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-accelerationlimitfilter","title":"function AccelerationLimitFilter","text":"<pre><code>inline AccelerationLimitFilter(\ndouble acc_max,\ndouble Ts,\ndouble gpd,\ndouble Kx,\ndouble Kv,\nstd::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-accelerationlimitfilter_1","title":"function AccelerationLimitFilter","text":"<pre><code>inline AccelerationLimitFilter(\ndouble acc_max,\ndouble Ts,\nstd::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline virtual double filtering(\ndouble u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/","title":"cpp_robotics::AccelerationLimitFilter::DiffTri","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#public-functions","title":"Public Functions","text":"Name DiffTri(double gpd, double Ts) void reset() std::tuple&lt; double, double, double &gt; filtering(double u)"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#function-difftri","title":"function DiffTri","text":"<pre><code>inline DiffTri(\ndouble gpd,\ndouble Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter_1_1DiffTri/#function-filtering","title":"function filtering","text":"<pre><code>inline std::tuple&lt; double, double, double &gt; filtering(\ndouble u\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/","title":"cpp_robotics::ActiveSetMethod","text":"<p>\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 </p> <p><code>#include &lt;active_set_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-classes","title":"Public Classes","text":"Name struct Problem struct Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-functions","title":"Public Functions","text":"Name Result solve(Problem prob, Eigen::VectorXd x)"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#function-solve","title":"function solve","text":"<pre><code>inline Result solve(\nProblem prob,\nEigen::VectorXd x\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/","title":"cpp_robotics::AngleRange","text":"<p>\u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b </p> <p><code>#include &lt;angle_range.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-types","title":"Public Types","text":"Name using std::pair&lt; double, double &gt; range_pair_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-functions","title":"Public Functions","text":"Name AngleRange() =default void add_range(const AngleRange &amp; range) void add_range(double start, double end) size_t size() const AngleRange invert() const double most_near_by(double angle) bool in_range_part(range_pair_t &amp; range, double angle) bool in_range(double angle) std::vector&lt; range_pair_t &gt; ranges() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-attributes","title":"Public Attributes","text":"Name constexpr static double PI"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#using-range_pair_t","title":"using range_pair_t","text":"<pre><code>using cpp_robotics::AngleRange::range_pair_t =  std::pair&lt;double, double&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-anglerange","title":"function AngleRange","text":"<pre><code>AngleRange() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-add_range","title":"function add_range","text":"<pre><code>inline void add_range(\nconst AngleRange &amp; range\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-add_range_1","title":"function add_range","text":"<pre><code>inline void add_range(\ndouble start,\ndouble end\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-size","title":"function size","text":"<pre><code>inline size_t size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-invert","title":"function invert","text":"<pre><code>inline AngleRange invert() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-most_near_by","title":"function most_near_by","text":"<pre><code>inline double most_near_by(\ndouble angle\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-in_range_part","title":"function in_range_part","text":"<pre><code>inline bool in_range_part(\nrange_pair_t &amp; range,\ndouble angle\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-in_range","title":"function in_range","text":"<pre><code>inline bool in_range(\ndouble angle\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-ranges","title":"function ranges","text":"<pre><code>inline std::vector&lt; range_pair_t &gt; ranges() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#variable-pi","title":"variable PI","text":"<pre><code>static constexpr static double PI = M_PI;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/","title":"cpp_robotics::AutoDiffAdaptor","text":"<p>\u81ea\u52d5\u5fae\u5206\u3067\u30e4\u30b3\u30d3\u30a2\u30f3\u3092\u6c42\u3081\u308b\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;auto_diff.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#public-types","title":"Public Types","text":"Name enum @0 using Eigen::Matrix&lt; Scalar, NX, 1 &gt; InputVector using Eigen::Matrix&lt; Scalar, NY, 1 &gt; ValueVector using Eigen::Matrix&lt; Scalar, NY, NX &gt; JacobianMatrix using Eigen::Matrix&lt; Scalar, NX, NX &gt; HessianMatrix"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#public-functions","title":"Public Functions","text":"Name AutoDiffAdaptor(Functor &amp; functor)\u5f15\u6570/\u623b\u308a\u5024\u304c\u9759\u7684\u30b5\u30a4\u30ba\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b\u5834\u5408\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf AutoDiffAdaptor(Functor &amp; functor, const size_t input_size, const size_t value_size)\u5f15\u6570/\u623b\u308a\u5024\u304c\u52d5\u7684\u30b5\u30a4\u30ba\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b\u5834\u5408\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf void evalute(const InputVector &amp; x, ValueVector &amp; y)\u95a2\u6570\u306e\u8a55\u4fa1 ValueVector evalute(const InputVector &amp; x)\u95a2\u6570\u306e\u8a55\u4fa1 std::function&lt; ValueVector(InputVector)&gt; evalute_func() std::function&lt; double(InputVector)&gt; evalute_func_scalar() void jacobian(const InputVector &amp; x, JacobianMatrix &amp; jac)\u30e4\u30b3\u30d3\u30a2\u30f3\u306e\u8a55\u4fa1 JacobianMatrix jacobian(const InputVector &amp; x)\u30e4\u30b3\u30d3\u30a2\u30f3\u306e\u8a55\u4fa1 std::function&lt; JacobianMatrix(InputVector)&gt; jacobian_func() std::function&lt; Eigen::Matrix&lt; Scalar, NX, 1 &gt;InputVector)&gt; jacobian_func_row_vector()"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Functor ,\nclass DerType  =Eigen::VectorXd,\ntypename Scalar  =double,\nint NX =Eigen::Dynamic,\nint NY =Eigen::Dynamic&gt;\nclass cpp_robotics::AutoDiffAdaptor;\n</code></pre> <p>\u81ea\u52d5\u5fae\u5206\u3067\u30e4\u30b3\u30d3\u30a2\u30f3\u3092\u6c42\u3081\u308b\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>Functor \u95a2\u6570\u306e\u30af\u30e9\u30b9, template static void eval_func(const Eigen::Matrix&amp; x, Eigen::Matrix&amp; y)\u3092\u6301\u3064\u5fc5\u8981\u304c\u3042\u308b  <li>DerType </li> <li>Scalar </li> <li>NX </li> <li>NY </li>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#enum-0","title":"enum @0","text":"Enumerator Value Description InputsAtCompileTime NX ValuesAtCompileTime NY"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#using-inputvector","title":"using InputVector","text":"<pre><code>using cpp_robotics::AutoDiffAdaptor&lt; Functor, DerType, Scalar, NX, NY &gt;::InputVector =  Eigen::Matrix&lt;Scalar, NX, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#using-valuevector","title":"using ValueVector","text":"<pre><code>using cpp_robotics::AutoDiffAdaptor&lt; Functor, DerType, Scalar, NX, NY &gt;::ValueVector =  Eigen::Matrix&lt;Scalar, NY, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#using-jacobianmatrix","title":"using JacobianMatrix","text":"<pre><code>using cpp_robotics::AutoDiffAdaptor&lt; Functor, DerType, Scalar, NX, NY &gt;::JacobianMatrix =  Eigen::Matrix&lt;Scalar, NY, NX&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#using-hessianmatrix","title":"using HessianMatrix","text":"<pre><code>using cpp_robotics::AutoDiffAdaptor&lt; Functor, DerType, Scalar, NX, NY &gt;::HessianMatrix =  Eigen::Matrix&lt;Scalar, NX, NX&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-autodiffadaptor","title":"function AutoDiffAdaptor","text":"<pre><code>inline AutoDiffAdaptor(\nFunctor &amp; functor\n)\n</code></pre> <p>\u5f15\u6570/\u623b\u308a\u5024\u304c\u9759\u7684\u30b5\u30a4\u30ba\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b\u5834\u5408\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf </p> <p>Parameters: </p> <ul> <li>functor </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-autodiffadaptor_1","title":"function AutoDiffAdaptor","text":"<pre><code>inline AutoDiffAdaptor(\nFunctor &amp; functor,\nconst size_t input_size,\nconst size_t value_size\n)\n</code></pre> <p>\u5f15\u6570/\u623b\u308a\u5024\u304c\u52d5\u7684\u30b5\u30a4\u30ba\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b\u5834\u5408\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf </p> <p>Parameters: </p> <ul> <li>functor </li> <li>input_size \u95a2\u6570\u306e\u5f15\u6570\u306e\u6b21\u5143 </li> <li>value_size \u95a2\u6570\u306e\u623b\u308a\u5024\u306e\u6b21\u5143 </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-evalute","title":"function evalute","text":"<pre><code>inline void evalute(\nconst InputVector &amp; x,\nValueVector &amp; y\n)\n</code></pre> <p>\u95a2\u6570\u306e\u8a55\u4fa1 </p> <p>Parameters: </p> <ul> <li>x </li> <li>y </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-evalute_1","title":"function evalute","text":"<pre><code>inline ValueVector evalute(\nconst InputVector &amp; x\n)\n</code></pre> <p>\u95a2\u6570\u306e\u8a55\u4fa1 </p> <p>Parameters: </p> <ul> <li>x </li> </ul> <p>Return: ValueVector </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-evalute_func","title":"function evalute_func","text":"<pre><code>inline std::function&lt; ValueVector(InputVector)&gt; evalute_func()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-evalute_func_scalar","title":"function evalute_func_scalar","text":"<pre><code>inline std::function&lt; double(InputVector)&gt; evalute_func_scalar()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-jacobian","title":"function jacobian","text":"<pre><code>inline void jacobian(\nconst InputVector &amp; x,\nJacobianMatrix &amp; jac\n)\n</code></pre> <p>\u30e4\u30b3\u30d3\u30a2\u30f3\u306e\u8a55\u4fa1 </p> <p>Parameters: </p> <ul> <li>x </li> <li>jac </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-jacobian_1","title":"function jacobian","text":"<pre><code>inline JacobianMatrix jacobian(\nconst InputVector &amp; x\n)\n</code></pre> <p>\u30e4\u30b3\u30d3\u30a2\u30f3\u306e\u8a55\u4fa1 </p> <p>Parameters: </p> <ul> <li>x </li> </ul> <p>Return: JacobianMatrix </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-jacobian_func","title":"function jacobian_func","text":"<pre><code>inline std::function&lt; JacobianMatrix(InputVector)&gt; jacobian_func()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1AutoDiffAdaptor/#function-jacobian_func_row_vector","title":"function jacobian_func_row_vector","text":"<pre><code>inline std::function&lt; Eigen::Matrix&lt; Scalar, NX, 1 &gt;InputVector)&gt; jacobian_func_row_vector()\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/","title":"cpp_robotics::BandPassFilter","text":"<p>\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;band_pass_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#public-functions","title":"Public Functions","text":"Name BandPassFilter(double omega, double zeta, double dt)Construct a new Notch Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97 double zeta() const\u92ed\u3055\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-bandpassfilter","title":"function BandPassFilter","text":"<pre><code>inline BandPassFilter(\ndouble omega,\ndouble zeta,\ndouble dt\n)\n</code></pre> <p>Construct a new Notch Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] </li> <li>zeta \u92ed\u3055 </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\ndouble u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97 </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-zeta","title":"function zeta","text":"<pre><code>inline double zeta() const\n</code></pre> <p>\u92ed\u3055\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/","title":"cpp_robotics::ButterworthFilter","text":"<p>\u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;butterworth_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#public-functions","title":"Public Functions","text":"Name ButterworthFilter(double omega, size_t n, double dt)Construct a new Butterworth Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6642\u5b9a\u6570\u306e\u53d6\u5f97 size_t n() const\u30d5\u30a3\u30eb\u30bf\u306e\u6b21\u6570"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-butterworthfilter","title":"function ButterworthFilter","text":"<pre><code>inline ButterworthFilter(\ndouble omega,\nsize_t n,\ndouble dt\n)\n</code></pre> <p>Construct a new Butterworth Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>n \u30d5\u30a3\u30eb\u30bf\u306e\u6b21\u6570 </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\ndouble u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6642\u5b9a\u6570\u306e\u53d6\u5f97 </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ButterworthFilter/#function-n","title":"function n","text":"<pre><code>inline size_t n() const\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u306e\u6b21\u6570 </p> <p>Return: size_t </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/","title":"cpp_robotics::CatumullRom2D","text":"<p>Catumull\u66f2\u7dda </p> <p><code>#include &lt;spline.hpp&gt;</code></p> <p>Inherits from cpp_robotics::Spline2D</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#public-functions","title":"Public Functions","text":"Name CatumullRom2D(std::vector&lt; Vector2d &gt; &amp; points, const double error =0.1)"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#additional-inherited-members","title":"Additional inherited members","text":"<p>Protected Classes inherited from cpp_robotics::Spline2D</p> Name struct segment_info_t struct segment_t <p>Public Functions inherited from cpp_robotics::Spline2D</p> Name Spline2D() =default bool is_empty() size_t size() size_t point_num() double length() double length(size_t i) Vector2d position(double t) Vector2d velocity(double t) Vector2d acceleration(double t) <p>Protected Functions inherited from cpp_robotics::Spline2D</p> Name segment_info_t get_segmet_idx(const double t) <p>Protected Attributes inherited from cpp_robotics::Spline2D</p> Name std::vector&lt; segment_t &gt; _spline bool _is_empty size_t _size double _all_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#function-catumullrom2d","title":"function CatumullRom2D","text":"<pre><code>inline CatumullRom2D(\nstd::vector&lt; Vector2d &gt; &amp; points,\nconst double error =0.1\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/","title":"cpp_robotics::ConstraintArray","text":"<p>\u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 </p> <p><code>#include &lt;constraint.hpp&gt;</code></p> <p>Inherits from std::vector&lt; Constraint &gt;</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#public-functions","title":"Public Functions","text":"Name ConstraintArray() =default ConstraintArray(std::initializer_list&lt; Constraint &gt; con) std::vector&lt; double &gt; eval(const Eigen::VectorXd &amp; x) const double eval_sum(const Eigen::VectorXd &amp; x) const bool all_satisfy(const Eigen::VectorXd &amp; x, const double tol) const std::vector&lt; Constraint &gt;::size_type eq_constraint_size() const std::vector&lt; Constraint &gt;::size_type ineq_constraint_size() const std::vector&lt; Constraint &gt; gen_eq_constraint_list() const std::vector&lt; Constraint &gt; gen_ineq_constraint_list() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-constraintarray","title":"function ConstraintArray","text":"<pre><code>ConstraintArray() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-constraintarray_1","title":"function ConstraintArray","text":"<pre><code>inline ConstraintArray(\nstd::initializer_list&lt; Constraint &gt; con\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eval","title":"function eval","text":"<pre><code>inline std::vector&lt; double &gt; eval(\nconst Eigen::VectorXd &amp; x\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eval_sum","title":"function eval_sum","text":"<pre><code>inline double eval_sum(\nconst Eigen::VectorXd &amp; x\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-all_satisfy","title":"function all_satisfy","text":"<pre><code>inline bool all_satisfy(\nconst Eigen::VectorXd &amp; x,\nconst double tol\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eq_constraint_size","title":"function eq_constraint_size","text":"<pre><code>inline std::vector&lt; Constraint &gt;::size_type eq_constraint_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-ineq_constraint_size","title":"function ineq_constraint_size","text":"<pre><code>inline std::vector&lt; Constraint &gt;::size_type ineq_constraint_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-gen_eq_constraint_list","title":"function gen_eq_constraint_list","text":"<pre><code>inline std::vector&lt; Constraint &gt; gen_eq_constraint_list() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-gen_ineq_constraint_list","title":"function gen_ineq_constraint_list","text":"<pre><code>inline std::vector&lt; Constraint &gt; gen_ineq_constraint_list() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/","title":"cpp_robotics::CubicSpline","text":"<p>3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda </p> <p><code>#include &lt;spline.hpp&gt;</code></p> <p>Inherits from cpp_robotics::Spline2D</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#public-functions","title":"Public Functions","text":"Name CubicSpline(std::vector&lt; Vector2d &gt; &amp; points, const double error =0.1)"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#additional-inherited-members","title":"Additional inherited members","text":"<p>Protected Classes inherited from cpp_robotics::Spline2D</p> Name struct segment_info_t struct segment_t <p>Public Functions inherited from cpp_robotics::Spline2D</p> Name Spline2D() =default bool is_empty() size_t size() size_t point_num() double length() double length(size_t i) Vector2d position(double t) Vector2d velocity(double t) Vector2d acceleration(double t) <p>Protected Functions inherited from cpp_robotics::Spline2D</p> Name segment_info_t get_segmet_idx(const double t) <p>Protected Attributes inherited from cpp_robotics::Spline2D</p> Name std::vector&lt; segment_t &gt; _spline bool _is_empty size_t _size double _all_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#function-cubicspline","title":"function CubicSpline","text":"<pre><code>inline CubicSpline(\nstd::vector&lt; Vector2d &gt; &amp; points,\nconst double error =0.1\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/","title":"cpp_robotics::DelayFilter","text":"<p>\u9045\u5ef6\u30d5\u30a3\u30eb\u30bf  More...</p> <p><code>#include &lt;delay_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#public-functions","title":"Public Functions","text":"Name DelayFilter(double delay_time, double Ts) virtual void reset() virtual double filtering(double u)"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#detailed-description","title":"Detailed Description","text":"<pre><code>class cpp_robotics::DelayFilter;\n</code></pre> <p>\u9045\u5ef6\u30d5\u30a3\u30eb\u30bf </p> <p>G(s) = e^(-T*s) \u9045\u5ef6\u6642\u9593\u306f\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593\u306e\u6574\u6570\u500d\u306e\u307f </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-delayfilter","title":"function DelayFilter","text":"<pre><code>inline DelayFilter(\ndouble delay_time,\ndouble Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline virtual double filtering(\ndouble u\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/","title":"cpp_robotics::DeltaRobotIk","text":"<p>\u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 </p> <p><code>#include &lt;delta_robot.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#public-types","title":"Public Types","text":"Name enum uint8_t IkSolveMethod"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#public-functions","title":"Public Functions","text":"Name DeltaRobotIk(double wb, double wp, double l1, double l2, IkSolveMethod method =IkSolveMethod::Analytical) Eigen::Vector3d solve_fk(Eigen::Vector3d joint_angles) Eigen::Vector3d solve_ik(Eigen::Vector3d pos, Eigen::Vector3d joint_angles0 =Eigen::Vector3d::Zero())"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#enum-iksolvemethod","title":"enum IkSolveMethod","text":"Enumerator Value Description Analytical Numerical"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#function-deltarobotik","title":"function DeltaRobotIk","text":"<pre><code>inline DeltaRobotIk(\ndouble wb,\ndouble wp,\ndouble l1,\ndouble l2,\nIkSolveMethod method =IkSolveMethod::Analytical\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#function-solve_fk","title":"function solve_fk","text":"<pre><code>inline Eigen::Vector3d solve_fk(\nEigen::Vector3d joint_angles\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#function-solve_ik","title":"function solve_ik","text":"<pre><code>inline Eigen::Vector3d solve_ik(\nEigen::Vector3d pos,\nEigen::Vector3d joint_angles0 =Eigen::Vector3d::Zero()\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/","title":"cpp_robotics::Differentiator","text":"<p>\u7591\u4f3c\u5fae\u5206\u5668  More...</p> <p><code>#include &lt;differentiator.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#public-functions","title":"Public Functions","text":"Name Differentiator(double omega, double dt)Construct a new Differentiator object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6642\u5b9a\u6570\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#detailed-description","title":"Detailed Description","text":"<pre><code>class cpp_robotics::Differentiator;\n</code></pre> <p>\u7591\u4f3c\u5fae\u5206\u5668 </p> <p>G(s) = omega*s / (s + omega) \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-differentiator","title":"function Differentiator","text":"<pre><code>inline Differentiator(\ndouble omega,\ndouble dt\n)\n</code></pre> <p>Construct a new Differentiator object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\ndouble u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6642\u5b9a\u6570\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/","title":"cpp_robotics::Discret","text":"<p>\u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b </p> <p><code>#include &lt;discret.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#public-functions","title":"Public Functions","text":"Name template &lt;typename Derived &gt; auto discretize_a(const Eigen::MatrixBase&lt; Derived &gt; &amp; A, const double Ts) template &lt;typename Derived1 ,typename Derived2 &gt; auto discretize_b(const Eigen::MatrixBase&lt; Derived1 &gt; &amp; A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp; B, const double &amp; Ts, size_t hdiv =1000) template &lt;typename Derived1 ,typename Derived2 &gt; auto discritize(const Eigen::MatrixBase&lt; Derived1 &gt; &amp; A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp; B, const double &amp; Ts, size_t hdiv =1000)\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discretize_a","title":"function discretize_a","text":"<pre><code>template &lt;typename Derived &gt;\nstatic inline auto discretize_a(\nconst Eigen::MatrixBase&lt; Derived &gt; &amp; A,\nconst double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discretize_b","title":"function discretize_b","text":"<pre><code>template &lt;typename Derived1 ,\ntypename Derived2 &gt;\nstatic inline auto discretize_b(\nconst Eigen::MatrixBase&lt; Derived1 &gt; &amp; A,\nconst Eigen::MatrixBase&lt; Derived2 &gt; &amp; B,\nconst double &amp; Ts,\nsize_t hdiv =1000\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discritize","title":"function discritize","text":"<pre><code>template &lt;typename Derived1 ,\ntypename Derived2 &gt;\nstatic inline auto discritize(\nconst Eigen::MatrixBase&lt; Derived1 &gt; &amp; A,\nconst Eigen::MatrixBase&lt; Derived2 &gt; &amp; B,\nconst double &amp; Ts,\nsize_t hdiv =1000\n)\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> <li>Ts </li> <li>hdiv </li> </ul> <p>Template Parameters: </p> <ul> <li>Derived1 </li> <li>Derived2 </li> </ul> <p>Return: auto </p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/","title":"cpp_robotics::DiscretTransferFunction","text":"<p><code>#include &lt;discret.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/#public-functions","title":"Public Functions","text":"Name std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; discritize(const std::vector&lt; double &gt; &amp; num, const std::vector&lt; double &gt; &amp; den, const double Ts)"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscretTransferFunction/#function-discritize","title":"function discritize","text":"<pre><code>static inline std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; discritize(\nconst std::vector&lt; double &gt; &amp; num,\nconst std::vector&lt; double &gt; &amp; den,\nconst double Ts\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/","title":"cpp_robotics::DubinsPath","text":"<p>Dubins\u30d1\u30b9 </p> <p><code>#include &lt;dubins_path.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-types","title":"Public Types","text":"Name enum class Mode"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-functions","title":"Public Functions","text":"Name DubinsPath(Transformd start, Transformd end, double cavature) double length() const double segment_length(size_t i) const Transformd position(double len) const std::string path_type() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#enum-mode","title":"enum Mode","text":"Enumerator Value Description LRL RLR LSL LSR RSL RSR NONE"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-dubinspath","title":"function DubinsPath","text":"<pre><code>inline DubinsPath(\nTransformd start,\nTransformd end,\ndouble cavature\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-length","title":"function length","text":"<pre><code>inline double length() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-segment_length","title":"function segment_length","text":"<pre><code>inline double segment_length(\nsize_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-position","title":"function position","text":"<pre><code>inline Transformd position(\ndouble len\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-path_type","title":"function path_type","text":"<pre><code>inline std::string path_type() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/","title":"cpp_robotics::ExtendedKalmanFilter","text":"<p><code>#include &lt;extended_kalman_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-functions","title":"Public Functions","text":"Name ExtendedKalmanFilter(const double dt, size_t input_size, size_t state_size, size_t observe_size) void reset(Eigen::VectorXd new_x, Eigen::MatrixXd new_P) Eigen::VectorXd filtering(Eigen::VectorXd u, Eigen::VectorXd z) double dt() const Eigen::VectorXd get_x() const Eigen::MatrixXd get_P() const virtual Eigen::VectorXd system(Eigen::VectorXd x, Eigen::VectorXd u) =0\u30b7\u30b9\u30c6\u30e0 virtual Eigen::VectorXd observe(Eigen::VectorXd x) =0\u89b3\u6e2c virtual void system_noise_conv(Eigen::MatrixXd &amp; Q, Eigen::VectorXd x, Eigen::VectorXd u) =0\u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217 virtual void observe_noise_conv(Eigen::MatrixXd &amp; R, Eigen::VectorXd x, Eigen::VectorXd u) =0\u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 virtual void linearized_system_matrix(Eigen::MatrixXd &amp; F, Eigen::VectorXd x, Eigen::VectorXd u)\u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217 virtual void linearized_observe_matrix(Eigen::MatrixXd &amp; H, Eigen::VectorXd x)\u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-attributes","title":"Public Attributes","text":"Name Eigen::VectorXd x \u72b6\u614b\u91cf Eigen::MatrixXd F \u9077\u79fb\u884c\u5217 Eigen::MatrixXd B \u5236\u5fa1\u884c\u5217 Eigen::MatrixXd H \u89b3\u6e2c\u884c\u5217 Eigen::MatrixXd Q \u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd R \u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd P \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#protected-attributes","title":"Protected Attributes","text":"Name const double dt_ const size_t input_size_ const size_t state_size_ const size_t observe_size_"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-extendedkalmanfilter","title":"function ExtendedKalmanFilter","text":"<pre><code>inline ExtendedKalmanFilter(\nconst double dt,\nsize_t input_size,\nsize_t state_size,\nsize_t observe_size\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-reset","title":"function reset","text":"<pre><code>inline void reset(\nEigen::VectorXd new_x,\nEigen::MatrixXd new_P\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline Eigen::VectorXd filtering(\nEigen::VectorXd u,\nEigen::VectorXd z\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-dt","title":"function dt","text":"<pre><code>inline double dt() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-get_x","title":"function get_x","text":"<pre><code>inline Eigen::VectorXd get_x() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-get_p","title":"function get_P","text":"<pre><code>inline Eigen::MatrixXd get_P() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-system","title":"function system","text":"<pre><code>virtual Eigen::VectorXd system(\nEigen::VectorXd x,\nEigen::VectorXd u\n) =0\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-observe","title":"function observe","text":"<pre><code>virtual Eigen::VectorXd observe(\nEigen::VectorXd x\n) =0\n</code></pre> <p>\u89b3\u6e2c </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-system_noise_conv","title":"function system_noise_conv","text":"<pre><code>virtual void system_noise_conv(\nEigen::MatrixXd &amp; Q,\nEigen::VectorXd x,\nEigen::VectorXd u\n) =0\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-observe_noise_conv","title":"function observe_noise_conv","text":"<pre><code>virtual void observe_noise_conv(\nEigen::MatrixXd &amp; R,\nEigen::VectorXd x,\nEigen::VectorXd u\n) =0\n</code></pre> <p>\u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-linearized_system_matrix","title":"function linearized_system_matrix","text":"<pre><code>inline virtual void linearized_system_matrix(\nEigen::MatrixXd &amp; F,\nEigen::VectorXd x,\nEigen::VectorXd u\n)\n</code></pre> <p>\u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-linearized_observe_matrix","title":"function linearized_observe_matrix","text":"<pre><code>inline virtual void linearized_observe_matrix(\nEigen::MatrixXd &amp; H,\nEigen::VectorXd x\n)\n</code></pre> <p>\u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-x","title":"variable x","text":"<pre><code>Eigen::VectorXd x;\n</code></pre> <p>\u72b6\u614b\u91cf </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-f","title":"variable F","text":"<pre><code>Eigen::MatrixXd F;\n</code></pre> <p>\u9077\u79fb\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-b","title":"variable B","text":"<pre><code>Eigen::MatrixXd B;\n</code></pre> <p>\u5236\u5fa1\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-h","title":"variable H","text":"<pre><code>Eigen::MatrixXd H;\n</code></pre> <p>\u89b3\u6e2c\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre> <p>\u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-r","title":"variable R","text":"<pre><code>Eigen::MatrixXd R;\n</code></pre> <p>\u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-p","title":"variable P","text":"<pre><code>Eigen::MatrixXd P;\n</code></pre> <p>\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-dt_","title":"variable dt_","text":"<pre><code>const double dt_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-input_size_","title":"variable input_size_","text":"<pre><code>const size_t input_size_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-state_size_","title":"variable state_size_","text":"<pre><code>const size_t state_size_;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-observe_size_","title":"variable observe_size_","text":"<pre><code>const size_t observe_size_;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/","title":"cpp_robotics::FilterConnector","text":"<p>More...</p> <p><code>#include &lt;filter_connector.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-types","title":"Public Types","text":"Name using std::variant&lt; FILTER_TYPE... &gt; variant_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-functions","title":"Public Functions","text":"Name FilterConnector()"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-attributes","title":"Public Attributes","text":"Name constexpr size_t filter_count"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class ... FILTER_TYPE&gt;\nclass cpp_robotics::FilterConnector;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#using-variant_type","title":"using variant_type","text":"<pre><code>using cpp_robotics::FilterConnector&lt; FILTER_TYPE &gt;::variant_type =  std::variant&lt;FILTER_TYPE...&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#function-filterconnector","title":"function FilterConnector","text":"<pre><code>inline FilterConnector()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#variable-filter_count","title":"variable filter_count","text":"<pre><code>static constexpr size_t filter_count = sizeof...(FILTER_TYPE);\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/","title":"cpp_robotics::FilterStateHolder","text":"<p>\u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;filter_state_holder.hpp&gt;</code></p> <p>Inherits from BASE_FILTER_TYPE</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#public-functions","title":"Public Functions","text":"Name void set_input(double u) double filtering() double u() const double y() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class BASE_FILTER_TYPE &gt;\nclass cpp_robotics::FilterStateHolder;\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>BASE_FILTER_TYPE </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-set_input","title":"function set_input","text":"<pre><code>inline void set_input(\ndouble u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-u","title":"function u","text":"<pre><code>inline double u() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-y","title":"function y","text":"<pre><code>inline double y() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/","title":"cpp_robotics::HighPassFilter","text":"<p>\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;high_pass_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#public-functions","title":"Public Functions","text":"Name HighPassFilter(double omega, double dt)Construct a new High Pass Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6642\u5b9a\u6570\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-highpassfilter","title":"function HighPassFilter","text":"<pre><code>inline HighPassFilter(\ndouble omega,\ndouble dt\n)\n</code></pre> <p>Construct a new High Pass Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\ndouble u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6642\u5b9a\u6570\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/","title":"cpp_robotics::Integrator","text":"<p>\u7a4d\u5206\u5668 </p> <p><code>#include &lt;integrator.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#public-functions","title":"Public Functions","text":"Name Integrator(double dt)Construct a new Integrator object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#function-integrator","title":"function Integrator","text":"<pre><code>inline Integrator(\ndouble dt\n)\n</code></pre> <p>Construct a new Integrator object. </p> <p>Parameters: </p> <ul> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\ndouble u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/","title":"cpp_robotics::KDTree","text":"<p>k-d\u6728  More...</p> <p><code>#include &lt;kdtree.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-types","title":"Public Types","text":"Name using POINT_T point_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-functions","title":"Public Functions","text":"Name KDTree() =default KDTree(std::vector&lt; point_type &gt; point, size_t dimention) void clear() void build(std::vector&lt; point_type &gt; point, size_t dimention) size_t nn_search(const point_type &amp; point) const std::vector&lt; size_t &gt; nn_search(const std::vector&lt; point_type &gt; &amp; point) const std::vector&lt; size_t &gt; knn_search(const point_type &amp; point, size_t k) const std::vector&lt; size_t &gt; radius_search(const point_type &amp; point, double radius) const std::vector&lt; point_type &gt; get_points(const std::vector&lt; size_t &gt; &amp; idx) const std::vector&lt; point_type &gt; knn_search_points(const point_type &amp; point, size_t k) const std::vector&lt; point_type &gt; radius_search_points(const point_type &amp; point, double radius) const void debug_node()"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class POINT_T &gt;\nclass cpp_robotics::KDTree;\n</code></pre> <p>k-d\u6728 </p> <p>Template Parameters: </p> <ul> <li>POINT_T \u30c7\u30fc\u30bf\u578b </li> <li>DIM \u6b21\u5143\u30b5\u30a4\u30ba </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#using-point_type","title":"using point_type","text":"<pre><code>using cpp_robotics::KDTree&lt; POINT_T &gt;::point_type =  POINT_T;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-kdtree","title":"function KDTree","text":"<pre><code>KDTree() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-kdtree_1","title":"function KDTree","text":"<pre><code>inline KDTree(\nstd::vector&lt; point_type &gt; point,\nsize_t dimention\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-clear","title":"function clear","text":"<pre><code>inline void clear()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-build","title":"function build","text":"<pre><code>inline void build(\nstd::vector&lt; point_type &gt; point,\nsize_t dimention\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-nn_search","title":"function nn_search","text":"<pre><code>inline size_t nn_search(\nconst point_type &amp; point\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-nn_search_1","title":"function nn_search","text":"<pre><code>inline std::vector&lt; size_t &gt; nn_search(\nconst std::vector&lt; point_type &gt; &amp; point\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-knn_search","title":"function knn_search","text":"<pre><code>inline std::vector&lt; size_t &gt; knn_search(\nconst point_type &amp; point,\nsize_t k\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-radius_search","title":"function radius_search","text":"<pre><code>inline std::vector&lt; size_t &gt; radius_search(\nconst point_type &amp; point,\ndouble radius\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-get_points","title":"function get_points","text":"<pre><code>inline std::vector&lt; point_type &gt; get_points(\nconst std::vector&lt; size_t &gt; &amp; idx\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-knn_search_points","title":"function knn_search_points","text":"<pre><code>inline std::vector&lt; point_type &gt; knn_search_points(\nconst point_type &amp; point,\nsize_t k\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-radius_search_points","title":"function radius_search_points","text":"<pre><code>inline std::vector&lt; point_type &gt; radius_search_points(\nconst point_type &amp; point,\ndouble radius\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-debug_node","title":"function debug_node","text":"<pre><code>inline void debug_node()\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/","title":"cpp_robotics::KMeansMethod","text":"<p>K-means\u6cd5  More...</p> <p><code>#include &lt;k_means_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-types","title":"Public Types","text":"Name using PointType point_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-functions","title":"Public Functions","text":"Name KMeansMethod() =default std::vector&lt; size_t &gt; fit(std::vector&lt; point_t &gt; &amp; data_set, size_t cluster_size, size_t max_iter =1000)\u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b size_t predict(const point_t &amp; x)\u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class PointType &gt;\nclass cpp_robotics::KMeansMethod;\n</code></pre> <p>K-means\u6cd5 </p> <p>Template Parameters: </p> <ul> <li>PointType \u30c7\u30fc\u30bf\u578b </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#using-point_t","title":"using point_t","text":"<pre><code>using cpp_robotics::KMeansMethod&lt; PointType &gt;::point_t =  PointType;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-kmeansmethod","title":"function KMeansMethod","text":"<pre><code>KMeansMethod() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-fit","title":"function fit","text":"<pre><code>inline std::vector&lt; size_t &gt; fit(\nstd::vector&lt; point_t &gt; &amp; data_set,\nsize_t cluster_size,\nsize_t max_iter =1000\n)\n</code></pre> <p>\u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>data_set \u70b9\u7fa4\u30c7\u30fc\u30bf </li> <li>cluster_size \u751f\u6210\u3059\u308b\u30af\u30e9\u30b9\u30bf\u306e\u30b5\u30a4\u30ba </li> <li>max_iter \u6700\u5927\u53cd\u5fa9\u56de\u6570 </li> </ul> <p>Return: std::vector data_set\u306e\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-predict","title":"function predict","text":"<pre><code>inline size_t predict(\nconst point_t &amp; x\n)\n</code></pre> <p>\u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>x \u70b9\u30c7\u30fc\u30bf </li> </ul> <p>Return: size_t \u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/","title":"cpp_robotics::KalmanFilter","text":"<p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf  More...</p> <p><code>#include &lt;kalman_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type using Eigen::Matrix&lt; value_type, state_size, 1 &gt; x_vec_t using Eigen::Matrix&lt; value_type, input_size, 1 &gt; u_vec_t using Eigen::Matrix&lt; value_type, observe_size, 1 &gt; z_vec_t using Eigen::Matrix&lt; value_type, state_size, state_size &gt; f_mat_t using Eigen::Matrix&lt; value_type, state_size, input_size &gt; g_mat_t using Eigen::Matrix&lt; value_type, observe_size, state_size &gt; h_mat_t using Eigen::Matrix&lt; value_type, state_size, state_size &gt; q_mat_t using Eigen::Matrix&lt; value_type, observe_size, observe_size &gt; r_mat_t using Eigen::Matrix&lt; value_type, state_size, state_size &gt; p_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-functions","title":"Public Functions","text":"Name KalmanFilter() =default void reset(x_vec_t x, p_mat_t P) x_vec_t filtering(u_vec_t u, z_vec_t z) x_vec_t get_x() p_mat_t get_P()"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-attributes","title":"Public Attributes","text":"Name constexpr size_t state_size constexpr size_t input_size constexpr size_t observe_size f_mat_t F g_mat_t G h_mat_t H q_mat_t Q r_mat_t R"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE ,\nsize_t STATE_SIZE,\nsize_t INPUT_SIZE,\nsize_t OBSERVE_SIZE&gt;\nclass cpp_robotics::KalmanFilter;\n</code></pre> <p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf </p> <p>Template Parameters: </p> <ul> <li>FLOATING_TYPE \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b </li> <li>STATE_SIZE \u72b6\u614b\u91cf\u306e\u30b5\u30a4\u30ba </li> <li>INPUT_SIZE \u5165\u529b\u91cf\u306e\u30b5\u30a4\u30ba </li> <li>OBSERVE_SIZE \u89b3\u6e2c\u91cf\u306e\u30b5\u30a4\u30ba </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-x_vec_t","title":"using x_vec_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::x_vec_t =  Eigen::Matrix&lt;value_type, state_size, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-u_vec_t","title":"using u_vec_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::u_vec_t =  Eigen::Matrix&lt;value_type, input_size, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-z_vec_t","title":"using z_vec_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::z_vec_t =  Eigen::Matrix&lt;value_type, observe_size, 1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-f_mat_t","title":"using f_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::f_mat_t =  Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-g_mat_t","title":"using g_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::g_mat_t =  Eigen::Matrix&lt;value_type, state_size, input_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-h_mat_t","title":"using h_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::h_mat_t =  Eigen::Matrix&lt;value_type, observe_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-q_mat_t","title":"using q_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::q_mat_t =  Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-r_mat_t","title":"using r_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::r_mat_t =  Eigen::Matrix&lt;value_type, observe_size, observe_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-p_mat_t","title":"using p_mat_t","text":"<pre><code>using cpp_robotics::KalmanFilter&lt; FLOATING_TYPE, STATE_SIZE, INPUT_SIZE, OBSERVE_SIZE &gt;::p_mat_t =  Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-kalmanfilter","title":"function KalmanFilter","text":"<pre><code>KalmanFilter() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-reset","title":"function reset","text":"<pre><code>inline void reset(\nx_vec_t x,\np_mat_t P\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline x_vec_t filtering(\nu_vec_t u,\nz_vec_t z\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-get_x","title":"function get_x","text":"<pre><code>inline x_vec_t get_x()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-get_p","title":"function get_P","text":"<pre><code>inline p_mat_t get_P()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-state_size","title":"variable state_size","text":"<pre><code>static constexpr size_t state_size = STATE_SIZE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-input_size","title":"variable input_size","text":"<pre><code>static constexpr size_t input_size = INPUT_SIZE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-observe_size","title":"variable observe_size","text":"<pre><code>static constexpr size_t observe_size = OBSERVE_SIZE;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-f","title":"variable F","text":"<pre><code>f_mat_t F;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-g","title":"variable G","text":"<pre><code>g_mat_t G;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-h","title":"variable H","text":"<pre><code>h_mat_t H;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-q","title":"variable Q","text":"<pre><code>q_mat_t Q;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-r","title":"variable R","text":"<pre><code>r_mat_t R;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/","title":"cpp_robotics::LinearMPC","text":"<p>\u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9 </p> <p><code>#include &lt;linear_mpc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#public-functions","title":"Public Functions","text":"Name LinearMPC(const Eigen::MatrixXd &amp; Ad, const Eigen::MatrixXd &amp; Bd, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R, const Eigen::MatrixXd &amp; Qf, const size_t N, std::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt)Construct a new Linear MPC object. std::tuple&lt; bool, Eigen::VectorXd &gt; control(const Eigen::VectorXd &amp; x0, const std::vector&lt; Eigen::VectorXd &gt; &amp; x_ref, bool warm_start =true)\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 std::tuple&lt; bool, Eigen::VectorXd &gt; control(const Eigen::VectorXd &amp; x0, const Eigen::VectorXd &amp; x_ref, bool warm_start =true)\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 QuadProg::Result latest_qp_result() const Eigen::MatrixXd Ad() const Eigen::MatrixXd Bd() const Eigen::MatrixXd Q() const Eigen::MatrixXd R() const Eigen::MatrixXd Qf() const size_t N() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-linearmpc","title":"function LinearMPC","text":"<pre><code>inline LinearMPC(\nconst Eigen::MatrixXd &amp; Ad,\nconst Eigen::MatrixXd &amp; Bd,\nconst Eigen::MatrixXd &amp; Q,\nconst Eigen::MatrixXd &amp; R,\nconst Eigen::MatrixXd &amp; Qf,\nconst size_t N,\nstd::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt\n)\n</code></pre> <p>Construct a new Linear MPC object. </p> <p>Parameters: </p> <ul> <li>Ad \u72b6\u614b\u884c\u5217 </li> <li>Bd \u5165\u529b\u884c\u5217 </li> <li>Q \u72b6\u614b\u91cd\u307f\u884c\u5217 </li> <li>R \u5165\u529b\u91cd\u307f\u884c\u5217 </li> <li>Qf \u6700\u7d42\u72b6\u614b\u91cd\u307f\u884c\u5217 </li> <li>N \u30db\u30e9\u30a4\u30be\u30f3\u9577\u3055 </li> <li>u_limit \u5236\u5fa1\u5165\u529b\u7bc4\u56f2 </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-control","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, Eigen::VectorXd &gt; control(\nconst Eigen::VectorXd &amp; x0,\nconst std::vector&lt; Eigen::VectorXd &gt; &amp; x_ref,\nbool warm_start =true\n)\n</code></pre> <p>\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>x0 \u72b6\u614b </li> <li>x_ref \u76ee\u6a19\u5024 </li> <li>warm_start </li> </ul> <p>Return: std::tuple \u6700\u9069\u5316\u306e\u6210\u529f/\u5931\u6557\u3001\u6700\u9069\u5165\u529b"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-control_1","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, Eigen::VectorXd &gt; control(\nconst Eigen::VectorXd &amp; x0,\nconst Eigen::VectorXd &amp; x_ref,\nbool warm_start =true\n)\n</code></pre> <p>\u6700\u9069\u5165\u529b\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>x0 \u72b6\u614b </li> <li>x_ref \u76ee\u6a19\u5024 </li> <li>warm_start </li> </ul> <p>Return: std::tuple \u6700\u9069\u5316\u306e\u6210\u529f/\u5931\u6557\u3001\u6700\u9069\u5165\u529b"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-latest_qp_result","title":"function latest_qp_result","text":"<pre><code>inline QuadProg::Result latest_qp_result() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-ad","title":"function Ad","text":"<pre><code>inline Eigen::MatrixXd Ad() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-bd","title":"function Bd","text":"<pre><code>inline Eigen::MatrixXd Bd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-q","title":"function Q","text":"<pre><code>inline Eigen::MatrixXd Q() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-r","title":"function R","text":"<pre><code>inline Eigen::MatrixXd R() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-qf","title":"function Qf","text":"<pre><code>inline Eigen::MatrixXd Qf() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearMPC/#function-n","title":"function N","text":"<pre><code>inline size_t N() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/","title":"cpp_robotics::LinearRegulatorMPC","text":"<p><code>#include &lt;linear_regulator_mpc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#public-functions","title":"Public Functions","text":"Name LinearRegulatorMPC(const Eigen::MatrixXd &amp; Ad, const Eigen::MatrixXd &amp; Bd, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R, const Eigen::MatrixXd &amp; Qf, const size_t N, std::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt) void set_initial_input(const std::vector&lt; Eigen::VectorXd &gt; &amp; u0) std::tuple&lt; bool, Eigen::VectorXd &gt; control(const Eigen::VectorXd &amp; x0, bool warm_start =true) QuadProg::Result latest_qp_result() const Eigen::MatrixXd Ad() const Eigen::MatrixXd Bd() const Eigen::MatrixXd Q() const Eigen::MatrixXd R() const Eigen::MatrixXd Qf() const size_t N() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-linearregulatormpc","title":"function LinearRegulatorMPC","text":"<pre><code>inline LinearRegulatorMPC(\nconst Eigen::MatrixXd &amp; Ad,\nconst Eigen::MatrixXd &amp; Bd,\nconst Eigen::MatrixXd &amp; Q,\nconst Eigen::MatrixXd &amp; R,\nconst Eigen::MatrixXd &amp; Qf,\nconst size_t N,\nstd::optional&lt; std::pair&lt; Eigen::VectorXd, Eigen::VectorXd &gt;&gt; u_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-set_initial_input","title":"function set_initial_input","text":"<pre><code>inline void set_initial_input(\nconst std::vector&lt; Eigen::VectorXd &gt; &amp; u0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-control","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, Eigen::VectorXd &gt; control(\nconst Eigen::VectorXd &amp; x0,\nbool warm_start =true\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-latest_qp_result","title":"function latest_qp_result","text":"<pre><code>inline QuadProg::Result latest_qp_result() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-ad","title":"function Ad","text":"<pre><code>inline Eigen::MatrixXd Ad() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-bd","title":"function Bd","text":"<pre><code>inline Eigen::MatrixXd Bd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-q","title":"function Q","text":"<pre><code>inline Eigen::MatrixXd Q() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-r","title":"function R","text":"<pre><code>inline Eigen::MatrixXd R() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-qf","title":"function Qf","text":"<pre><code>inline Eigen::MatrixXd Qf() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinearRegulatorMPC/#function-n","title":"function N","text":"<pre><code>inline size_t N() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/","title":"cpp_robotics::LinkRobot","text":"<p><code>#include &lt;link_robot.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#public-functions","title":"Public Functions","text":"Name LinkRobot(std::vector&lt; LinkConfig &gt; &amp; config) void show_kinematics() void show_dynamics() size_t degree() const Eigen::Vector3d forward_kinematics(Eigen::VectorXd joint_param) Eigen::VectorXd inverse_kinematics(Eigen::Vector3d pos, Eigen::Vector3d euler_angle) std::tuple&lt; Eigen::MatrixXd, Eigen::VectorXd &gt; forward_dynamics_matrix(Eigen::VectorXd pos, Eigen::VectorXd vel) Eigen::VectorXd dynamics(Eigen::VectorXd pos, Eigen::VectorXd vel, Eigen::VectorXd acc) Eigen::VectorXd forward_dynamics(Eigen::VectorXd pos, Eigen::VectorXd vel, Eigen::VectorXd force)"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-linkrobot","title":"function LinkRobot","text":"<pre><code>inline LinkRobot(\nstd::vector&lt; LinkConfig &gt; &amp; config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-show_kinematics","title":"function show_kinematics","text":"<pre><code>inline void show_kinematics()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-show_dynamics","title":"function show_dynamics","text":"<pre><code>inline void show_dynamics()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-degree","title":"function degree","text":"<pre><code>inline size_t degree() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-forward_kinematics","title":"function forward_kinematics","text":"<pre><code>inline Eigen::Vector3d forward_kinematics(\nEigen::VectorXd joint_param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-inverse_kinematics","title":"function inverse_kinematics","text":"<pre><code>inline Eigen::VectorXd inverse_kinematics(\nEigen::Vector3d pos,\nEigen::Vector3d euler_angle\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-forward_dynamics_matrix","title":"function forward_dynamics_matrix","text":"<pre><code>inline std::tuple&lt; Eigen::MatrixXd, Eigen::VectorXd &gt; forward_dynamics_matrix(\nEigen::VectorXd pos,\nEigen::VectorXd vel\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-dynamics","title":"function dynamics","text":"<pre><code>inline Eigen::VectorXd dynamics(\nEigen::VectorXd pos,\nEigen::VectorXd vel,\nEigen::VectorXd acc\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LinkRobot/#function-forward_dynamics","title":"function forward_dynamics","text":"<pre><code>inline Eigen::VectorXd forward_dynamics(\nEigen::VectorXd pos,\nEigen::VectorXd vel,\nEigen::VectorXd force\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/","title":"cpp_robotics::LowPassFilter","text":"<p>\u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc </p> <p><code>#include &lt;low_pass_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#public-functions","title":"Public Functions","text":"Name LowPassFilter(double omega, double dt)Construct a new Low Pass Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-lowpassfilter","title":"function LowPassFilter","text":"<pre><code>inline LowPassFilter(\ndouble omega,\ndouble dt\n)\n</code></pre> <p>Construct a new Low Pass Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\ndouble u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s]\u306e\u53d6\u5f97 </p> <p>Return: double </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/","title":"cpp_robotics::MecanumIk","text":"<p>\u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;mecanum_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-classes","title":"Public Classes","text":"Name struct Config"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-functions","title":"Public Functions","text":"Name MecanumIk(double width, double length) MecanumIk(Config config) std::array&lt; double, 4 &gt; calculate(Transformd velocity) Config config() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-mecanumik","title":"function MecanumIk","text":"<pre><code>inline MecanumIk(\ndouble width,\ndouble length\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-mecanumik_1","title":"function MecanumIk","text":"<pre><code>inline MecanumIk(\nConfig config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-calculate","title":"function calculate","text":"<pre><code>inline std::array&lt; double, 4 &gt; calculate(\nTransformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-config","title":"function config","text":"<pre><code>inline Config config() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/","title":"cpp_robotics::NDT2d","text":"<p>2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 </p> <p><code>#include &lt;ndt.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/#public-functions","title":"Public Functions","text":"Name NDT2d() =default"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/#function-ndt2d","title":"function NDT2d","text":"<pre><code>NDT2d() =default\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/","title":"cpp_robotics::NctfController","text":"<p>NCTF\u5236\u5fa1\u5668 </p> <p><code>#include &lt;nctf.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-functions","title":"Public Functions","text":"Name std::function&lt; double(double)&gt; make_simple_nct(double max_velocity, double slope) NctfController(double max_velocity, double nct_slope, PID::pid_param_t pid_param, double dt) NctfController(std::function&lt; double(double)&gt; nct, PID::pid_param_t pid_param, double dt) void reset() double control(double target, double state) double control(double e) std::function&lt; double(double)&gt; nct() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-make_simple_nct","title":"function make_simple_nct","text":"<pre><code>static inline std::function&lt; double(double)&gt; make_simple_nct(\ndouble max_velocity,\ndouble slope\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nctfcontroller","title":"function NctfController","text":"<pre><code>inline NctfController(\ndouble max_velocity,\ndouble nct_slope,\nPID::pid_param_t pid_param,\ndouble dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nctfcontroller_1","title":"function NctfController","text":"<pre><code>inline NctfController(\nstd::function&lt; double(double)&gt; nct,\nPID::pid_param_t pid_param,\ndouble dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-control","title":"function control","text":"<pre><code>inline double control(\ndouble target,\ndouble state\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-control_1","title":"function control","text":"<pre><code>inline double control(\ndouble e\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nct","title":"function nct","text":"<pre><code>inline std::function&lt; double(double)&gt; nct() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/","title":"cpp_robotics::NotchFilter","text":"<p>\u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;notch_filter.hpp&gt;</code></p> <p>Inherits from cpp_robotics::TransferFunction</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#public-functions","title":"Public Functions","text":"Name NotchFilter(double omega, double zeta, double d, double dt)Construct a new Notch Filter object. double filtering(double u)\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b double omega() const\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] double zeta() const\u92ed\u3055 double d() const\u6df1\u3055"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from cpp_robotics::TransferFunction</p> Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-notchfilter","title":"function NotchFilter","text":"<pre><code>inline NotchFilter(\ndouble omega,\ndouble zeta,\ndouble d,\ndouble dt\n)\n</code></pre> <p>Construct a new Notch Filter object. </p> <p>Parameters: </p> <ul> <li>omega \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] </li> <li>zeta \u92ed\u3055 </li> <li>d \u6df1\u3055(0.0\u3067\u4e00\u756a\u6df1\u304f\u30011.0\u306b\u8fd1\u3065\u3051\u308b\u307b\u3069\u30d5\u30a3\u30eb\u30bf\u306e\u52b9\u679c\u304c\u5f31\u304f\u306a\u308b) </li> <li>dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline double filtering(\ndouble u\n)\n</code></pre> <p>\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3059\u308b </p> <p>Parameters: </p> <ul> <li>u </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-omega","title":"function omega","text":"<pre><code>inline double omega() const\n</code></pre> <p>\u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-zeta","title":"function zeta","text":"<pre><code>inline double zeta() const\n</code></pre> <p>\u92ed\u3055 </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-d","title":"function d","text":"<pre><code>inline double d() const\n</code></pre> <p>\u6df1\u3055 </p> <p>Return: double </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/","title":"cpp_robotics::Omni3Ik","text":"<p>3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-classes","title":"Public Classes","text":"Name struct Config"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-functions","title":"Public Functions","text":"Name Omni3Ik(double radius, double first_wheel_angle =M_PI/6) Omni3Ik(Config config) std::array&lt; double, 3 &gt; calculate(Transformd velocity) Config config() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-omni3ik","title":"function Omni3Ik","text":"<pre><code>inline Omni3Ik(\ndouble radius,\ndouble first_wheel_angle =M_PI/6\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-omni3ik_1","title":"function Omni3Ik","text":"<pre><code>inline Omni3Ik(\nConfig config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-calculate","title":"function calculate","text":"<pre><code>inline std::array&lt; double, 3 &gt; calculate(\nTransformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-config","title":"function config","text":"<pre><code>inline Config config() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/","title":"cpp_robotics::Omni4Ik","text":"<p>4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-classes","title":"Public Classes","text":"Name struct Config"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-functions","title":"Public Functions","text":"Name Omni4Ik(double radius, double first_wheel_angle =M_PI/4) Omni4Ik(Config config) std::array&lt; double, 4 &gt; calculate(Transformd velocity) Config config() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-omni4ik","title":"function Omni4Ik","text":"<pre><code>inline Omni4Ik(\ndouble radius,\ndouble first_wheel_angle =M_PI/4\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-omni4ik_1","title":"function Omni4Ik","text":"<pre><code>inline Omni4Ik(\nConfig config\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-calculate","title":"function calculate","text":"<pre><code>inline std::array&lt; double, 4 &gt; calculate(\nTransformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-config","title":"function config","text":"<pre><code>inline Config config() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/","title":"cpp_robotics::PID","text":"<p>PID\u5236\u5fa1\u5668 </p> <p><code>#include &lt;pid.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#public-classes","title":"Public Classes","text":"Name struct pid_param_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#public-functions","title":"Public Functions","text":"Name PID(pid_param_t param) void set_param(pid_param_t param) void reset() double calculate(double error)"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-pid","title":"function PID","text":"<pre><code>inline PID(\npid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-set_param","title":"function set_param","text":"<pre><code>inline void set_param(\npid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\ndouble error\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/","title":"cpp_robotics::PID2","text":"<p>2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 </p> <p><code>#include &lt;pid2.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#public-classes","title":"Public Classes","text":"Name struct pid_param_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#public-functions","title":"Public Functions","text":"Name PID2 create_PI_D(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt) PID2 create_I_PD(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt) PID2 create_feed_foward_pid2(double Ts, double gpd, double Kpff, double Kdff, double Kpfb, double Kifb, double Kdfb, std::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt) PID2(pid_param_t param) void set_param(pid_param_t param) void reset() double calculate(double target, double present)"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-create_pi_d","title":"function create_PI_D","text":"<pre><code>static inline PID2 create_PI_D(\ndouble Ts,\ndouble gpd,\ndouble Kp,\ndouble Ki,\ndouble Kd,\nstd::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-create_i_pd","title":"function create_I_PD","text":"<pre><code>static inline PID2 create_I_PD(\ndouble Ts,\ndouble gpd,\ndouble Kp,\ndouble Ki,\ndouble Kd,\nstd::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-create_feed_foward_pid2","title":"function create_feed_foward_pid2","text":"<pre><code>static inline PID2 create_feed_foward_pid2(\ndouble Ts,\ndouble gpd,\ndouble Kpff,\ndouble Kdff,\ndouble Kpfb,\ndouble Kifb,\ndouble Kdfb,\nstd::optional&lt; std::pair&lt; double, double &gt;&gt; output_limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-pid2","title":"function PID2","text":"<pre><code>inline PID2(\npid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-set_param","title":"function set_param","text":"<pre><code>inline void set_param(\npid_param_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\ndouble target,\ndouble present\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/","title":"cpp_robotics::PSMC","text":"<p><code>#include &lt;psmc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#public-classes","title":"Public Classes","text":"Name struct param_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#public-functions","title":"Public Functions","text":"Name PSMC() PSMC(param_t param) PSMC(double p, double d, double Hs, double dt) PSMC(double p, double d, double Hs, double min_output, double max_output, double dt) void reset() void set_param(param_t param) double calculate(double target_val, double now_val) double calculate(double target_val, double now_val, double target_velocity, double now_velocity) double &amp; Kp() double &amp; Kd() double &amp; Hs()"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc","title":"function PSMC","text":"<pre><code>inline PSMC()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc_1","title":"function PSMC","text":"<pre><code>inline PSMC(\nparam_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc_2","title":"function PSMC","text":"<pre><code>inline PSMC(\ndouble p,\ndouble d,\ndouble Hs,\ndouble dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-psmc_3","title":"function PSMC","text":"<pre><code>inline PSMC(\ndouble p,\ndouble d,\ndouble Hs,\ndouble min_output,\ndouble max_output,\ndouble dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-set_param","title":"function set_param","text":"<pre><code>inline void set_param(\nparam_t param\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\ndouble target_val,\ndouble now_val\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-calculate_1","title":"function calculate","text":"<pre><code>inline double calculate(\ndouble target_val,\ndouble now_val,\ndouble target_velocity,\ndouble now_velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-kp","title":"function Kp","text":"<pre><code>inline double &amp; Kp()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-kd","title":"function Kd","text":"<pre><code>inline double &amp; Kd()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PSMC/#function-hs","title":"function Hs","text":"<pre><code>inline double &amp; Hs()\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/","title":"cpp_robotics::PurePursuit","text":"<p>Pure pursuit\u5236\u5fa1\u5668 </p> <p><code>#include &lt;pure_pursuit.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#public-functions","title":"Public Functions","text":"Name PurePursuit(double K) void set_K(double K) std::tuple&lt; bool, double &gt; control(std::function&lt; Vector2d(double)&gt; traj_ref, double traj_progress, Vector2d pos_present, double vel, double angle_present)"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-purepursuit","title":"function PurePursuit","text":"<pre><code>inline PurePursuit(\ndouble K\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-set_k","title":"function set_K","text":"<pre><code>inline void set_K(\ndouble K\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-control","title":"function control","text":"<pre><code>inline std::tuple&lt; bool, double &gt; control(\nstd::function&lt; Vector2d(double)&gt; traj_ref,\ndouble traj_progress,\nVector2d pos_present,\ndouble vel,\ndouble angle_present\n)\n</code></pre> <p>Parameters: </p> <ul> <li>traj_ref \u59cb\u70b9\u304b\u3089\u306e\u9577\u3055\u306b\u3088\u308b\u7d4c\u8def\u306e\u95a2\u6570 </li> <li>traj_progress \u73fe\u5728\u306e\u7d4c\u8def\u4e0a\u306e\u9577\u3055\u4f4d\u7f6e </li> <li>pos_present \u73fe\u5728\u306e\u5ea7\u6a19 </li> <li>target_angle_offset traj_ref\u304b\u3089\u76ee\u6a19\u5ea7\u6a19\u3092\u53d6\u3063\u3066\u304d\u305f\u6642\u306b\u4f4d\u7f6e\u8aa4\u5dee\u304b\u3089\u89d2\u5ea6\u3092\u51fa\u3057\u305f\u6642\u306b\u52a0\u3048\u308b\u30aa\u30d5\u30bb\u30c3\u30c8 </li> <li>vel \u73fe\u5728\u306e\u9032\u884c\u65b9\u5411\u306e\u901f\u5ea6 </li> <li>angle_present \u73fe\u5728\u306e\u30ed\u30dc\u30c3\u30c8\u306eYaw\u89d2\u5ea6 </li> </ul> <p>Return: std::tuple [Pure Pursuit\u304c\u6709\u52b9\u306a\u51fa\u529b\u3092\u8fd4\u3059\u304b, \u51fa\u529b\u5024]  <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/","title":"cpp_robotics::QuadProg","text":"<p>\u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 </p> <p><code>#include &lt;quadprog.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-classes","title":"Public Classes","text":"Name struct Param struct Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-functions","title":"Public Functions","text":"Name void set_problem_size(const size_t valiable_size, const size_t ineq_constraint_size, const size_t eq_constraint_size) void debug_prog() Result solve(Eigen::VectorXd x_init) double evaluate(const Eigen::VectorXd &amp; x) Eigen::VectorXd grad_lagrange(const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; u, const Eigen::VectorXd &amp; v) bool satisfy(const Eigen::MatrixXd &amp; x, double eps =1e-5)"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-attributes","title":"Public Attributes","text":"Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd Aeq Eigen::VectorXd beq Eigen::MatrixXd A Eigen::VectorXd b Param param"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-set_problem_size","title":"function set_problem_size","text":"<pre><code>inline void set_problem_size(\nconst size_t valiable_size,\nconst size_t ineq_constraint_size,\nconst size_t eq_constraint_size\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-debug_prog","title":"function debug_prog","text":"<pre><code>inline void debug_prog()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-solve","title":"function solve","text":"<pre><code>inline Result solve(\nEigen::VectorXd x_init\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-evaluate","title":"function evaluate","text":"<pre><code>inline double evaluate(\nconst Eigen::VectorXd &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-grad_lagrange","title":"function grad_lagrange","text":"<pre><code>inline Eigen::VectorXd grad_lagrange(\nconst Eigen::VectorXd &amp; x,\nconst Eigen::VectorXd &amp; u,\nconst Eigen::VectorXd &amp; v\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-satisfy","title":"function satisfy","text":"<pre><code>inline bool satisfy(\nconst Eigen::MatrixXd &amp; x,\ndouble eps =1e-5\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-c","title":"variable c","text":"<pre><code>Eigen::VectorXd c;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-aeq","title":"variable Aeq","text":"<pre><code>Eigen::MatrixXd Aeq;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-beq","title":"variable beq","text":"<pre><code>Eigen::VectorXd beq;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-a","title":"variable A","text":"<pre><code>Eigen::MatrixXd A;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-b","title":"variable b","text":"<pre><code>Eigen::VectorXd b;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-param","title":"variable param","text":"<pre><code>Param param;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/","title":"cpp_robotics::RandomGenerator","text":"<p>std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668  More...</p> <p><code>#include &lt;random.hpp&gt;</code></p> <p>Inherits from Distribution</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-types","title":"Public Types","text":"Name using Distribution distribution_t using EngineMethod engine_method_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-functions","title":"Public Functions","text":"Name template &lt;typename ... Arg&gt;  RandomGenerator(Arg ... arg)\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 distribution_t::result_type value()\u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class Distribution ,\nclass EngineMethod  =std::mt19937&gt;\nclass cpp_robotics::RandomGenerator;\n</code></pre> <p>std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 </p> <p>Template Parameters: </p> <ul> <li>Distribution \u4e71\u6570\u306e\u5206\u5e03, std::normal_distribution\u7b49  <li>EngineMethod \u7591\u4f3c\u4e71\u6570\u751f\u6210\u6cd5, std::mt19937\u7b49 </li>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#using-distribution_t","title":"using distribution_t","text":"<pre><code>using cpp_robotics::RandomGenerator&lt; Distribution, EngineMethod &gt;::distribution_t =  Distribution;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#using-engine_method_t","title":"using engine_method_t","text":"<pre><code>using cpp_robotics::RandomGenerator&lt; Distribution, EngineMethod &gt;::engine_method_t =  EngineMethod;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#function-randomgenerator","title":"function RandomGenerator","text":"<pre><code>template &lt;typename ... Arg&gt;\ninline RandomGenerator(\nArg ... arg\n)\n</code></pre> <p>\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 </p> <p>Parameters: </p> <ul> <li>arg </li> </ul> <p>Template Parameters: </p> <ul> <li>Arg </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#function-value","title":"function value","text":"<pre><code>inline distribution_t::result_type value()\n</code></pre> <p>\u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046 </p> <p>Return: distribution_t::result_type </p> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/","title":"cpp_robotics::SISOPFC","text":"<p><code>#include &lt;pfc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#public-functions","title":"Public Functions","text":"Name SISOPFC(const Eigen::MatrixXd &amp; Ad, const Eigen::VectorXd &amp; Bd, const Eigen::VectorXd &amp; Cd, const double delay, const double target_responce_time, const double dt)Construct a new SISOPFC object. double calculate(std::function&lt; double(double)&gt; ref_target, double now_state) double calculate(std::function&lt; double(double)&gt; ref_target, double now_state, double prev_input) double prev_input() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-sisopfc","title":"function SISOPFC","text":"<pre><code>inline SISOPFC(\nconst Eigen::MatrixXd &amp; Ad,\nconst Eigen::VectorXd &amp; Bd,\nconst Eigen::VectorXd &amp; Cd,\nconst double delay,\nconst double target_responce_time,\nconst double dt\n)\n</code></pre> <p>Construct a new SISOPFC object. </p> <p>Parameters: </p> <ul> <li>Ad </li> <li>Bd </li> <li>Cd </li> <li>delay </li> <li>target_responce_time </li> <li>dt </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-calculate","title":"function calculate","text":"<pre><code>inline double calculate(\nstd::function&lt; double(double)&gt; ref_target,\ndouble now_state\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-calculate_1","title":"function calculate","text":"<pre><code>inline double calculate(\nstd::function&lt; double(double)&gt; ref_target,\ndouble now_state,\ndouble prev_input\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SISOPFC/#function-prev_input","title":"function prev_input","text":"<pre><code>inline double prev_input() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/","title":"cpp_robotics::SQP","text":"<p>SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) </p> <p><code>#include &lt;sqp.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-classes","title":"Public Classes","text":"Name struct Problem struct Result"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-types","title":"Public Types","text":"Name using std::function&lt; double(Eigen::VectorXd)&gt; func_type using std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad_func_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-functions","title":"Public Functions","text":"Name Result solve(Problem prob, const Eigen::VectorXd &amp; x0, std::optional&lt; std::function&lt; void(Eigen::VectorXd)&gt;&gt; callback =std::nullopt)"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#using-func_type","title":"using func_type","text":"<pre><code>using cpp_robotics::SQP::func_type =  std::function&lt;double(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#using-grad_func_type","title":"using grad_func_type","text":"<pre><code>using cpp_robotics::SQP::grad_func_type =  std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#function-solve","title":"function solve","text":"<pre><code>inline Result solve(\nProblem prob,\nconst Eigen::VectorXd &amp; x0,\nstd::optional&lt; std::function&lt; void(Eigen::VectorXd)&gt;&gt; callback =std::nullopt\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/","title":"cpp_robotics::Singleton","text":"<p>\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b  More...</p> <p><code>#include &lt;singleton.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-types","title":"Public Types","text":"Name using T class_t using std::shared_ptr&lt; class_t &gt; shared_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-functions","title":"Public Functions","text":"Name shared_t get_shared_instance()\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass cpp_robotics::Singleton;\n</code></pre> <p>\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b </p> <p>Template Parameters: </p> <ul> <li>T \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u3067\u751f\u6210\u3057\u305f\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u578b </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#using-class_t","title":"using class_t","text":"<pre><code>using cpp_robotics::Singleton&lt; T &gt;::class_t =  T;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#using-shared_t","title":"using shared_t","text":"<pre><code>using cpp_robotics::Singleton&lt; T &gt;::shared_t =  std::shared_ptr&lt;class_t&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#function-get_shared_instance","title":"function get_shared_instance","text":"<pre><code>static inline shared_t get_shared_instance()\n</code></pre> <p>\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059 </p> <p>Return: shared_t \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306eshared_ptr </p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/","title":"cpp_robotics::SisoFeedbackSystem","text":"<p>\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 </p> <p><code>#include &lt;siso_system.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-classes","title":"Public Classes","text":"Name struct func_list_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-functions","title":"Public Functions","text":"Name SisoFeedbackSystem() =default SisoFeedbackSystem(func_list_t fn, double dt) void reset() double responce(double target) double Ts() const double u() const double y() const std::function&lt; double(double)&gt; make_control_function() operator std::function&lt; double(double )"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-sisofeedbacksystem","title":"function SisoFeedbackSystem","text":"<pre><code>SisoFeedbackSystem() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-sisofeedbacksystem_1","title":"function SisoFeedbackSystem","text":"<pre><code>inline SisoFeedbackSystem(\nfunc_list_t fn,\ndouble dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-responce","title":"function responce","text":"<pre><code>inline double responce(\ndouble target\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-u","title":"function u","text":"<pre><code>inline double u() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-y","title":"function y","text":"<pre><code>inline double y() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-make_control_function","title":"function make_control_function","text":"<pre><code>inline std::function&lt; double(double)&gt; make_control_function()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-operator-stdfunction-double","title":"function operator std::function&lt; double","text":"<pre><code>inline operator std::function&lt; double(\ndouble )\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/","title":"cpp_robotics::Spline2D","text":"<p>2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 </p> <p><code>#include &lt;spline.hpp&gt;</code></p> <p>Inherited by cpp_robotics::CatumullRom2D, cpp_robotics::CubicSpline</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-classes","title":"Protected Classes","text":"Name struct segment_info_t struct segment_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#public-functions","title":"Public Functions","text":"Name Spline2D() =default bool is_empty() size_t size() size_t point_num() double length() double length(size_t i) Vector2d position(double t) Vector2d velocity(double t) Vector2d acceleration(double t)"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-functions","title":"Protected Functions","text":"Name segment_info_t get_segmet_idx(const double t)"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-attributes","title":"Protected Attributes","text":"Name std::vector&lt; segment_t &gt; _spline bool _is_empty size_t _size double _all_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-spline2d","title":"function Spline2D","text":"<pre><code>Spline2D() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-is_empty","title":"function is_empty","text":"<pre><code>inline bool is_empty()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-size","title":"function size","text":"<pre><code>inline size_t size()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-point_num","title":"function point_num","text":"<pre><code>inline size_t point_num()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-length","title":"function length","text":"<pre><code>inline double length()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-length_1","title":"function length","text":"<pre><code>inline double length(\nsize_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-position","title":"function position","text":"<pre><code>inline Vector2d position(\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-velocity","title":"function velocity","text":"<pre><code>inline Vector2d velocity(\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-acceleration","title":"function acceleration","text":"<pre><code>inline Vector2d acceleration(\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-get_segmet_idx","title":"function get_segmet_idx","text":"<pre><code>inline segment_info_t get_segmet_idx(\nconst double t\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_spline","title":"variable _spline","text":"<pre><code>std::vector&lt; segment_t &gt; _spline;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_is_empty","title":"variable _is_empty","text":"<pre><code>bool _is_empty;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_size","title":"variable _size","text":"<pre><code>size_t _size;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_all_length","title":"variable _all_length","text":"<pre><code>double _all_length;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/","title":"cpp_robotics::StateSpaceSystem","text":"<p>\u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb </p> <p><code>#include &lt;state_space_system.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#public-functions","title":"Public Functions","text":"Name StateSpaceSystem() =default template &lt;typename DerivedA ,typename DerivedB ,typename DerivedC &gt;  StateSpaceSystem(const Eigen::MatrixBase&lt; DerivedA &gt; &amp; A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp; B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp; C, const double Ts) template &lt;typename DerivedA ,typename DerivedB ,typename DerivedC &gt; void set_continuous(const Eigen::MatrixBase&lt; DerivedA &gt; &amp; A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp; B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp; C, const double Ts, const bool skip_state_reset =false) template &lt;typename DerivedA ,typename DerivedB ,typename DerivedC &gt; void set_discrite(const Eigen::MatrixBase&lt; DerivedA &gt; &amp; Ad, const Eigen::MatrixBase&lt; DerivedB &gt; &amp; Bd, const Eigen::MatrixBase&lt; DerivedC &gt; &amp; Cd, const double Ts, const bool skip_state_reset =false) size_t state_size() const size_t input_size() const size_t output_size() const bool is_siso_model() const void set_state_zero() void set_state(const Eigen::VectorXd &amp; x) void set_state(const double &amp; x) auto responce(const Eigen::VectorXd &amp; u) double responce(double u) std::optional&lt; Eigen::MatrixXd &gt; A() const std::optional&lt; Eigen::MatrixXd &gt; B() const double Ts() const Eigen::MatrixXd Ad() const Eigen::MatrixXd Bd() const Eigen::MatrixXd C() const Eigen::MatrixXd Cd() const Eigen::VectorXd x() const Eigen::VectorXd y() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-statespacesystem","title":"function StateSpaceSystem","text":"<pre><code>StateSpaceSystem() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-statespacesystem_1","title":"function StateSpaceSystem","text":"<pre><code>template &lt;typename DerivedA ,\ntypename DerivedB ,\ntypename DerivedC &gt;\ninline StateSpaceSystem(\nconst Eigen::MatrixBase&lt; DerivedA &gt; &amp; A,\nconst Eigen::MatrixBase&lt; DerivedB &gt; &amp; B,\nconst Eigen::MatrixBase&lt; DerivedC &gt; &amp; C,\nconst double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_continuous","title":"function set_continuous","text":"<pre><code>template &lt;typename DerivedA ,\ntypename DerivedB ,\ntypename DerivedC &gt;\ninline void set_continuous(\nconst Eigen::MatrixBase&lt; DerivedA &gt; &amp; A,\nconst Eigen::MatrixBase&lt; DerivedB &gt; &amp; B,\nconst Eigen::MatrixBase&lt; DerivedC &gt; &amp; C,\nconst double Ts,\nconst bool skip_state_reset =false\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_discrite","title":"function set_discrite","text":"<pre><code>template &lt;typename DerivedA ,\ntypename DerivedB ,\ntypename DerivedC &gt;\ninline void set_discrite(\nconst Eigen::MatrixBase&lt; DerivedA &gt; &amp; Ad,\nconst Eigen::MatrixBase&lt; DerivedB &gt; &amp; Bd,\nconst Eigen::MatrixBase&lt; DerivedC &gt; &amp; Cd,\nconst double Ts,\nconst bool skip_state_reset =false\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-state_size","title":"function state_size","text":"<pre><code>inline size_t state_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-input_size","title":"function input_size","text":"<pre><code>inline size_t input_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-output_size","title":"function output_size","text":"<pre><code>inline size_t output_size() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-is_siso_model","title":"function is_siso_model","text":"<pre><code>inline bool is_siso_model() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state_zero","title":"function set_state_zero","text":"<pre><code>inline void set_state_zero()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state","title":"function set_state","text":"<pre><code>inline void set_state(\nconst Eigen::VectorXd &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state_1","title":"function set_state","text":"<pre><code>inline void set_state(\nconst double &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-responce","title":"function responce","text":"<pre><code>inline auto responce(\nconst Eigen::VectorXd &amp; u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-responce_1","title":"function responce","text":"<pre><code>inline double responce(\ndouble u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-a","title":"function A","text":"<pre><code>inline std::optional&lt; Eigen::MatrixXd &gt; A() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-b","title":"function B","text":"<pre><code>inline std::optional&lt; Eigen::MatrixXd &gt; B() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-ad","title":"function Ad","text":"<pre><code>inline Eigen::MatrixXd Ad() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-bd","title":"function Bd","text":"<pre><code>inline Eigen::MatrixXd Bd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-c","title":"function C","text":"<pre><code>inline Eigen::MatrixXd C() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-cd","title":"function Cd","text":"<pre><code>inline Eigen::MatrixXd Cd() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-x","title":"function x","text":"<pre><code>inline Eigen::VectorXd x() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-y","title":"function y","text":"<pre><code>inline Eigen::VectorXd y() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/","title":"cpp_robotics::SwerveIk","text":"<p>\u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb </p> <p><code>#include &lt;swerve_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-types","title":"Public Types","text":"Name using std::array&lt; Vector2d, 4 &gt; VecArray"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-functions","title":"Public Functions","text":"Name SwerveIk(const double width, const double length) SwerveIk(VecArray wheel_place) VecArray calculate(Transformd velocity) VecArray wheel_place() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#using-vecarray","title":"using VecArray","text":"<pre><code>using cpp_robotics::SwerveIk::VecArray =  std::array&lt;Vector2d, 4&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-swerveik","title":"function SwerveIk","text":"<pre><code>inline SwerveIk(\nconst double width,\nconst double length\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-swerveik_1","title":"function SwerveIk","text":"<pre><code>inline SwerveIk(\nVecArray wheel_place\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-calculate","title":"function calculate","text":"<pre><code>inline VecArray calculate(\nTransformd velocity\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-wheel_place","title":"function wheel_place","text":"<pre><code>inline VecArray wheel_place() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/","title":"cpp_robotics::Timer","text":"<p><code>#include &lt;timer.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#public-functions","title":"Public Functions","text":"Name void start() void stop() double second() double millisecond()"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-start","title":"function start","text":"<pre><code>inline void start()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-stop","title":"function stop","text":"<pre><code>inline void stop()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-second","title":"function second","text":"<pre><code>inline double second()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1Timer/#function-millisecond","title":"function millisecond","text":"<pre><code>inline double millisecond()\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/","title":"cpp_robotics::TransferFunction","text":"<p>\u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb </p> <p><code>#include &lt;transfer_function.hpp&gt;</code></p> <p>Inherited by cpp_robotics::BandPassFilter, cpp_robotics::ButterworthFilter, cpp_robotics::Differentiator, cpp_robotics::HighPassFilter, cpp_robotics::Integrator, cpp_robotics::LowPassFilter, cpp_robotics::NotchFilter</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#public-functions","title":"Public Functions","text":"Name TransferFunction make_first_order_system(const double T, const double Ts) TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts) TransferFunction() =default TransferFunction(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double Ts) void set_continuous(std::vector&lt; double &gt; num, std::vector&lt; double &gt; den, const double dt) void set_discrite(std::vector&lt; double &gt; num_disc, std::vector&lt; double &gt; den_disc, const double dt) double Ts() const\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f virtual void reset(double state =0) double responce(double u) size_t num_deg(size_t num_idx =0) const size_t den_deg(size_t num_idx =0) const std::vector&lt; double &gt; num_array() const std::vector&lt; double &gt; den_array() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-make_first_order_system","title":"function make_first_order_system","text":"<pre><code>static inline TransferFunction make_first_order_system(\nconst double T,\nconst double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-make_second_order_system","title":"function make_second_order_system","text":"<pre><code>static inline TransferFunction make_second_order_system(\nconst double omega,\nconst double zeta,\nconst double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-transferfunction","title":"function TransferFunction","text":"<pre><code>TransferFunction() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-transferfunction_1","title":"function TransferFunction","text":"<pre><code>inline TransferFunction(\nstd::vector&lt; double &gt; num,\nstd::vector&lt; double &gt; den,\nconst double Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-set_continuous","title":"function set_continuous","text":"<pre><code>inline void set_continuous(\nstd::vector&lt; double &gt; num,\nstd::vector&lt; double &gt; den,\nconst double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-set_discrite","title":"function set_discrite","text":"<pre><code>inline void set_discrite(\nstd::vector&lt; double &gt; num_disc,\nstd::vector&lt; double &gt; den_disc,\nconst double dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre> <p>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f </p> <p>Return: double </p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset(\ndouble state =0\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-responce","title":"function responce","text":"<pre><code>inline double responce(\ndouble u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-num_deg","title":"function num_deg","text":"<pre><code>inline size_t num_deg(\nsize_t num_idx =0\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-den_deg","title":"function den_deg","text":"<pre><code>inline size_t den_deg(\nsize_t num_idx =0\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-num_array","title":"function num_array","text":"<pre><code>inline std::vector&lt; double &gt; num_array() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-den_array","title":"function den_array","text":"<pre><code>inline std::vector&lt; double &gt; den_array() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/","title":"cpp_robotics::TransferFunction::CircularBuffer","text":"<p>More...</p> <p>Inherits from std::vector&lt; T &gt;</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#public-functions","title":"Public Functions","text":"Name void reset_position() T &amp; at_circular(size_t idx) void insert_front(T val)"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass cpp_robotics::TransferFunction::CircularBuffer;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#function-reset_position","title":"function reset_position","text":"<pre><code>inline void reset_position()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#function-at_circular","title":"function at_circular","text":"<pre><code>inline T &amp; at_circular(\nsize_t idx\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction_1_1CircularBuffer/#function-insert_front","title":"function insert_front","text":"<pre><code>inline void insert_front(\nT val\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/","title":"cpp_robotics::VelocityLimitFilter","text":"<p>\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf </p> <p><code>#include &lt;velocity_limit_filter.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-functions","title":"Public Functions","text":"Name VelocityLimitFilter(double v_max, double dt) VelocityLimitFilter(double v_max, double dt, std::pair&lt; double, double &gt; limit) VelocityLimitFilter(double v_max, double dt, double gpd, double fb_gain, std::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt) virtual void reset() void reset(double u) virtual double filtering(double u) double Ts() const"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter","title":"function VelocityLimitFilter","text":"<pre><code>inline VelocityLimitFilter(\ndouble v_max,\ndouble dt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter_1","title":"function VelocityLimitFilter","text":"<pre><code>inline VelocityLimitFilter(\ndouble v_max,\ndouble dt,\nstd::pair&lt; double, double &gt; limit\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter_2","title":"function VelocityLimitFilter","text":"<pre><code>inline VelocityLimitFilter(\ndouble v_max,\ndouble dt,\ndouble gpd,\ndouble fb_gain,\nstd::optional&lt; std::pair&lt; double, double &gt;&gt; limit =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-reset","title":"function reset","text":"<pre><code>inline virtual void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-reset_1","title":"function reset","text":"<pre><code>inline void reset(\ndouble u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-filtering","title":"function filtering","text":"<pre><code>inline virtual double filtering(\ndouble u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-ts","title":"function Ts","text":"<pre><code>inline double Ts() const\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/","title":"cpp_robotics::VelocityLimitFilter::DiffPair","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#public-functions","title":"Public Functions","text":"Name DiffPair(double gpd, double Ts) void reset() void reset(double u) std::tuple&lt; double, double &gt; filtering(double u)"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-diffpair","title":"function DiffPair","text":"<pre><code>inline DiffPair(\ndouble gpd,\ndouble Ts\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-reset_1","title":"function reset","text":"<pre><code>inline void reset(\ndouble u\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter_1_1DiffPair/#function-filtering","title":"function filtering","text":"<pre><code>inline std::tuple&lt; double, double &gt; filtering(\ndouble u\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/","title":"cpp_robotics::XY2degRobot","text":"<p><code>#include &lt;xy_2deg_robot.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#public-types","title":"Public Types","text":"Name enum uint8_t IkSolveMethod"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#public-functions","title":"Public Functions","text":"Name XY2degRobot(double l1, double l2, IkSolveMethod method =IkSolveMethod::Analytical) Eigen::Vector2d solve_fk(double joint_angle1, double joint_angle2) Eigen::Vector2d solve_fk(Eigen::Vector2d joint_angles) Eigen::Vector2d solve_ik(Eigen::Vector2d pos, Eigen::Vector2d joint_angles0 =Eigen::Vector2d::Zero())"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#enum-iksolvemethod","title":"enum IkSolveMethod","text":"Enumerator Value Description Analytical Numerical"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#function-xy2degrobot","title":"function XY2degRobot","text":"<pre><code>inline XY2degRobot(\ndouble l1,\ndouble l2,\nIkSolveMethod method =IkSolveMethod::Analytical\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#function-solve_fk","title":"function solve_fk","text":"<pre><code>inline Eigen::Vector2d solve_fk(\ndouble joint_angle1,\ndouble joint_angle2\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#function-solve_fk_1","title":"function solve_fk","text":"<pre><code>inline Eigen::Vector2d solve_fk(\nEigen::Vector2d joint_angles\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1XY2degRobot/#function-solve_ik","title":"function solve_ik","text":"<pre><code>inline Eigen::Vector2d solve_ik(\nEigen::Vector2d pos,\nEigen::Vector2d joint_angles0 =Eigen::Vector2d::Zero()\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/","title":"cpp_robotics::unit::Unit","text":"<p>\u5358\u4f4d\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-types","title":"Public Types","text":"Name using T value_type using UnitDimType unit_dimention_type using P prefix_type using Unit&lt; T, UnitDimType, P &gt; unit_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-functions","title":"Public Functions","text":"Name Unit() =default constexpr Unit(T val) constexpr T value() const constexpr T raw_value() const constexpr unit_type operator+() const constexpr unit_type operator-() const constexpr unit_type operator+(const unit_type &amp; rhl) const constexpr unit_type operator-(const unit_type &amp; rhl) const constexpr auto operator*(const unit_type &amp; rhl) const constexpr unit_type &amp; operator+=(const unit_type &amp; rhl) constexpr unit_type &amp; operator-=(const unit_type &amp; rhl) template &lt;int R_Tag&gt; constexpr operator Unit&lt; value_type, unit_dimention_type, prefix_type, R_Tag &gt;() const template &lt;class R_P &gt; constexpr operator Unit&lt; value_type, unit_dimention_type, R_P, tag &gt;() const constexpr operator value_type() const constexpr bool operator==(const unit_type &amp; r_value) constexpr bool operator!=(const unit_type &amp; r_value)"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-attributes","title":"Public Attributes","text":"Name constexpr int tag"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T ,\nclass UnitDimType ,\nclass P ,\nint Tag =-1&gt;\nclass cpp_robotics::unit::Unit;\n</code></pre> <p>\u5358\u4f4d\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>T \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u578b </li> <li>UnitDimType \u6b21\u5143 </li> <li>P \u63a5\u982d\u8f9e </li> <li>Tag \u540c\u6b21\u5143\u306e\u5358\u4f4d\u7cfb\u3092\u533a\u5225\u3059\u308b\u30bf\u30b0 </li> </ul>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::value_type =  T;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-unit_dimention_type","title":"using unit_dimention_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::unit_dimention_type =  UnitDimType;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-prefix_type","title":"using prefix_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::prefix_type =  P;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-unit_type","title":"using unit_type","text":"<pre><code>using cpp_robotics::unit::Unit&lt; T, UnitDimType, P, Tag &gt;::unit_type =  Unit&lt;T, UnitDimType, P&gt;;\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-unit","title":"function Unit","text":"<pre><code>Unit() =default\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-unit_1","title":"function Unit","text":"<pre><code>inline constexpr Unit(\nT val\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-value","title":"function value","text":"<pre><code>inline constexpr T value() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-raw_value","title":"function raw_value","text":"<pre><code>inline constexpr T raw_value() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr unit_type operator+() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr unit_type operator-() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_1","title":"function operator+","text":"<pre><code>inline constexpr unit_type operator+(\nconst unit_type &amp; rhl\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr unit_type operator-(\nconst unit_type &amp; rhl\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_2","title":"function operator*","text":"<pre><code>inline constexpr auto operator*(\nconst unit_type &amp; rhl\n) const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_3","title":"function operator+=","text":"<pre><code>inline constexpr unit_type &amp; operator+=(\nconst unit_type &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr unit_type &amp; operator-=(\nconst unit_type &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-unit-value_type-unit_dimention_type-prefix_type-r_tag","title":"function operator Unit&lt; value_type, unit_dimention_type, prefix_type, R_Tag &gt;","text":"<pre><code>template &lt;int R_Tag&gt;\ninline constexpr operator Unit&lt; value_type, unit_dimention_type, prefix_type, R_Tag &gt;() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-unit-value_type-unit_dimention_type-r_p-tag","title":"function operator Unit&lt; value_type, unit_dimention_type, R_P, tag &gt;","text":"<pre><code>template &lt;class R_P &gt;\ninline constexpr operator Unit&lt; value_type, unit_dimention_type, R_P, tag &gt;() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-value_type","title":"function operator value_type","text":"<pre><code>inline constexpr operator value_type() const\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_4","title":"function operator==","text":"<pre><code>inline constexpr bool operator==(\nconst unit_type &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_5","title":"function operator!=","text":"<pre><code>inline constexpr bool operator!=(\nconst unit_type &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#variable-tag","title":"variable tag","text":"<pre><code>static constexpr int tag = Tag;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/","title":"cpp_robotics::ActiveSetMethod::Problem","text":"<p><code>#include &lt;active_set_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-functions","title":"Public Functions","text":"Name Problem() =default Problem(size_t x_size_) void add_inequality_constraint(const Eigen::MatrixXd &amp; An, Eigen::VectorXd bn) void add_equality_constraint(const Eigen::MatrixXd &amp; An, Eigen::VectorXd bn)"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-attributes","title":"Public Attributes","text":"Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd A Eigen::VectorXd b size_t max_iter size_t max_iter_get_initial_feasible_x size_t x_size size_t constraint_size double alpha"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-problem","title":"function Problem","text":"<pre><code>Problem() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-problem_1","title":"function Problem","text":"<pre><code>inline Problem(\nsize_t x_size_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-add_inequality_constraint","title":"function add_inequality_constraint","text":"<pre><code>inline void add_inequality_constraint(\nconst Eigen::MatrixXd &amp; An,\nEigen::VectorXd bn\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-add_equality_constraint","title":"function add_equality_constraint","text":"<pre><code>inline void add_equality_constraint(\nconst Eigen::MatrixXd &amp; An,\nEigen::VectorXd bn\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-q","title":"variable Q","text":"<pre><code>Eigen::MatrixXd Q;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-c","title":"variable c","text":"<pre><code>Eigen::VectorXd c;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-a","title":"variable A","text":"<pre><code>Eigen::MatrixXd A;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-b","title":"variable b","text":"<pre><code>Eigen::VectorXd b;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 1000;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-max_iter_get_initial_feasible_x","title":"variable max_iter_get_initial_feasible_x","text":"<pre><code>size_t max_iter_get_initial_feasible_x = 1000;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-x_size","title":"variable x_size","text":"<pre><code>size_t x_size = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-constraint_size","title":"variable constraint_size","text":"<pre><code>size_t constraint_size = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-alpha","title":"variable alpha","text":"<pre><code>double alpha = 1.1;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/","title":"cpp_robotics::ActiveSetMethod::Result","text":"<p><code>#include &lt;active_set_method.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#public-attributes","title":"Public Attributes","text":"Name bool is_solved Eigen::VectorXd x_opt Eigen::VectorXd lambda_opt size_t iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-is_solved","title":"variable is_solved","text":"<pre><code>bool is_solved = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-x_opt","title":"variable x_opt","text":"<pre><code>Eigen::VectorXd x_opt;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-lambda_opt","title":"variable lambda_opt","text":"<pre><code>Eigen::VectorXd lambda_opt;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-iter_cnt","title":"variable iter_cnt","text":"<pre><code>size_t iter_cnt = 0;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/","title":"cpp_robotics::Circle","text":"<p>\u5186\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-functions","title":"Public Functions","text":"Name Circle() =default constexpr Circle(const Vector2d &amp; center, const double r) constexpr bool has_area() const constexpr double area() const constexpr Vector2d angle_pos(const double theta) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-attributes","title":"Public Attributes","text":"Name Vector2d center double r"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-circle","title":"function Circle","text":"<pre><code>Circle() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-circle_1","title":"function Circle","text":"<pre><code>inline constexpr Circle(\nconst Vector2d &amp; center,\nconst double r\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-angle_pos","title":"function angle_pos","text":"<pre><code>inline constexpr Vector2d angle_pos(\nconst double theta\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#variable-center","title":"variable center","text":"<pre><code>Vector2d center;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#variable-r","title":"variable r","text":"<pre><code>double r;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/","title":"cpp_robotics::Constraint","text":"<p>\u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 </p> <p><code>#include &lt;constraint.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-types","title":"Public Types","text":"Name enum uint8_t Type using std::function&lt; double(Eigen::VectorXd)&gt; func_type using std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad_func_type using std::function&lt; Eigen::MatrixXd(Eigen::VectorXd)&gt; hessian_func_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-functions","title":"Public Functions","text":"Name Constraint(Type type_, func_type con_) double eval(const Eigen::VectorXd &amp; x) const bool satisfy(const Eigen::VectorXd &amp; x, const double tol) const Eigen::VectorXd grad(Eigen::VectorXd x) Eigen::MatrixXd hessian(Eigen::VectorXd x)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-attributes","title":"Public Attributes","text":"Name Type type func_type con_f std::optional&lt; grad_func_type &gt; con_grad_f std::optional&lt; hessian_func_type &gt; con_hessian_f"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#enum-type","title":"enum Type","text":"Enumerator Value Description Eq Ineq"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-func_type","title":"using func_type","text":"<pre><code>using cpp_robotics::Constraint::func_type =  std::function&lt;double(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-grad_func_type","title":"using grad_func_type","text":"<pre><code>using cpp_robotics::Constraint::grad_func_type =  std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-hessian_func_type","title":"using hessian_func_type","text":"<pre><code>using cpp_robotics::Constraint::hessian_func_type =  std::function&lt;Eigen::MatrixXd(Eigen::VectorXd)&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-constraint","title":"function Constraint","text":"<pre><code>inline Constraint(\nType type_,\nfunc_type con_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-eval","title":"function eval","text":"<pre><code>inline double eval(\nconst Eigen::VectorXd &amp; x\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-satisfy","title":"function satisfy","text":"<pre><code>inline bool satisfy(\nconst Eigen::VectorXd &amp; x,\nconst double tol\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-grad","title":"function grad","text":"<pre><code>inline Eigen::VectorXd grad(\nEigen::VectorXd x\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-hessian","title":"function hessian","text":"<pre><code>inline Eigen::MatrixXd hessian(\nEigen::VectorXd x\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-type","title":"variable type","text":"<pre><code>Type type;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_f","title":"variable con_f","text":"<pre><code>func_type con_f;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_grad_f","title":"variable con_grad_f","text":"<pre><code>std::optional&lt; grad_func_type &gt; con_grad_f;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_hessian_f","title":"variable con_hessian_f","text":"<pre><code>std::optional&lt; hessian_func_type &gt; con_hessian_f;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/","title":"cpp_robotics::DCGearedMotorParam","text":"<p>\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </p> <p><code>#include &lt;dc_motor_param.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-functions","title":"Public Functions","text":"Name constexpr DCGearedMotorParam(Volt voltage_, DCMotorParam motor_, GearHeadParam gear_head_, const double optional_gear_ratio_ =1) constexpr Rpm calcu_gear_head_steady_free_velocity(Volt v) const constexpr Rpm calcu_endpoint_steady_free_velocity(Volt v) const constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration(Inertia optional_inertina =0) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-attributes","title":"Public Attributes","text":"Name const Volt voltage const DCMotorParam motor const GearHeadParam gear_head const double optional_gear_ratio"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-dcgearedmotorparam","title":"function DCGearedMotorParam","text":"<pre><code>inline constexpr DCGearedMotorParam(\nVolt voltage_,\nDCMotorParam motor_,\nGearHeadParam gear_head_,\nconst double optional_gear_ratio_ =1\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_gear_head_steady_free_velocity","title":"function calcu_gear_head_steady_free_velocity","text":"<pre><code>inline constexpr Rpm calcu_gear_head_steady_free_velocity(\nVolt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_endpoint_steady_free_velocity","title":"function calcu_endpoint_steady_free_velocity","text":"<pre><code>inline constexpr Rpm calcu_endpoint_steady_free_velocity(\nVolt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_endpoint_max_angular_accleleration","title":"function calcu_endpoint_max_angular_accleleration","text":"<pre><code>inline constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration(\nInertia optional_inertina =0\n) const\n</code></pre> <p>\u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u304c\u767a\u751f\u3055\u305b\u3089\u308c\u308b\u6700\u5927\u306e\u89d2\u52a0\u901f\u5ea6\u3092\u8a08\u7b97\u3059\u308b</p> <p>optional_inertina: \u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u306e\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-voltage","title":"variable voltage","text":"<pre><code>const Volt voltage;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-motor","title":"variable motor","text":"<pre><code>const DCMotorParam motor;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-gear_head","title":"variable gear_head","text":"<pre><code>const GearHeadParam gear_head;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-optional_gear_ratio","title":"variable optional_gear_ratio","text":"<pre><code>const double optional_gear_ratio;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/","title":"cpp_robotics::DCMotorParam","text":"<p>DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb </p> <p><code>#include &lt;dc_motor_param.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-functions","title":"Public Functions","text":"Name constexpr DCMotorParam(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm Rm, Henry Lm, TorqueConstant Kt, BackEmfConstant Ke, Inertia Im, Second curr_set_time =0.1f) constexpr DCMotorParam(const DCMotorParam &amp; ) =default constexpr void set_current_setting_time(Second Tc) constexpr Rpm calcu_steady_free_velocity(Volt v) const constexpr Ampere calcu_stall_current(Volt v) const constexpr Torque calcu_stall_torque(Volt v) const constexpr AngularAcceleration calcu_max_free_angular_acceleration(Volt v) const constexpr Second get_Tm() const constexpr AngularVelocity get_Wi() const constexpr double get_Kip(Volt volt) const constexpr double get_Kii(Volt volt) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-attributes","title":"Public Attributes","text":"Name const Volt nominal_voltage const Rpm free_speed const Ampere free_current const Ohm resistance const Henry inductance const TorqueConstant torque_constant const BackEmfConstant back_emf_constance const FrictionConstant friction_constant const Inertia rotor_inertia const Second time_constant"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-dcmotorparam","title":"function DCMotorParam","text":"<pre><code>inline constexpr DCMotorParam(\nVolt nominal_voltage,\nRpm free_speed,\nAmpere free_current,\nOhm Rm,\nHenry Lm,\nTorqueConstant Kt,\nBackEmfConstant Ke,\nInertia Im,\nSecond curr_set_time =0.1f\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-dcmotorparam_1","title":"function DCMotorParam","text":"<pre><code>constexpr DCMotorParam(\nconst DCMotorParam &amp; ) =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-set_current_setting_time","title":"function set_current_setting_time","text":"<pre><code>inline constexpr void set_current_setting_time(\nSecond Tc\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_steady_free_velocity","title":"function calcu_steady_free_velocity","text":"<pre><code>inline constexpr Rpm calcu_steady_free_velocity(\nVolt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_stall_current","title":"function calcu_stall_current","text":"<pre><code>inline constexpr Ampere calcu_stall_current(\nVolt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_stall_torque","title":"function calcu_stall_torque","text":"<pre><code>inline constexpr Torque calcu_stall_torque(\nVolt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_max_free_angular_acceleration","title":"function calcu_max_free_angular_acceleration","text":"<pre><code>inline constexpr AngularAcceleration calcu_max_free_angular_acceleration(\nVolt v\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_tm","title":"function get_Tm","text":"<pre><code>inline constexpr Second get_Tm() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_wi","title":"function get_Wi","text":"<pre><code>inline constexpr AngularVelocity get_Wi() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_kip","title":"function get_Kip","text":"<pre><code>inline constexpr double get_Kip(\nVolt volt\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_kii","title":"function get_Kii","text":"<pre><code>inline constexpr double get_Kii(\nVolt volt\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-nominal_voltage","title":"variable nominal_voltage","text":"<pre><code>const Volt nominal_voltage;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-free_speed","title":"variable free_speed","text":"<pre><code>const Rpm free_speed;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-free_current","title":"variable free_current","text":"<pre><code>const Ampere free_current;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-resistance","title":"variable resistance","text":"<pre><code>const Ohm resistance;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-inductance","title":"variable inductance","text":"<pre><code>const Henry inductance;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-torque_constant","title":"variable torque_constant","text":"<pre><code>const TorqueConstant torque_constant;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-back_emf_constance","title":"variable back_emf_constance","text":"<pre><code>const BackEmfConstant back_emf_constance;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-friction_constant","title":"variable friction_constant","text":"<pre><code>const FrictionConstant friction_constant;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-rotor_inertia","title":"variable rotor_inertia","text":"<pre><code>const Inertia rotor_inertia;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-time_constant","title":"variable time_constant","text":"<pre><code>const Second time_constant;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/","title":"cpp_robotics::DeltaRobotIk::Kinematics","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#public-functions","title":"Public Functions","text":"Name Kinematics(double wb, double wp, double l1, double l2) template &lt;typename T &gt; Eigen::Matrix&lt; T, 3, 1 &gt; solve_fk(const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; angles) Eigen::Vector3d solve_ik_analytical(Eigen::Vector3d pos) template &lt;typename T &gt; void eval_func(const Eigen::Matrix&lt; T, 3, 1 &gt; &amp; x, Eigen::Matrix&lt; T, 1, 1 &gt; &amp; y)"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#public-attributes","title":"Public Attributes","text":"Name Eigen::Vector3d target_pos const double wb const double wp const double l1 const double l2"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#function-kinematics","title":"function Kinematics","text":"<pre><code>inline Kinematics(\ndouble wb,\ndouble wp,\ndouble l1,\ndouble l2\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#function-solve_fk","title":"function solve_fk","text":"<pre><code>template &lt;typename T &gt;\ninline Eigen::Matrix&lt; T, 3, 1 &gt; solve_fk(\nconst Eigen::Matrix&lt; T, 3, 1 &gt; &amp; angles\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#function-solve_ik_analytical","title":"function solve_ik_analytical","text":"<pre><code>inline Eigen::Vector3d solve_ik_analytical(\nEigen::Vector3d pos\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#function-eval_func","title":"function eval_func","text":"<pre><code>template &lt;typename T &gt;\ninline void eval_func(\nconst Eigen::Matrix&lt; T, 3, 1 &gt; &amp; x,\nEigen::Matrix&lt; T, 1, 1 &gt; &amp; y\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#variable-target_pos","title":"variable target_pos","text":"<pre><code>Eigen::Vector3d target_pos;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#variable-wb","title":"variable wb","text":"<pre><code>const double wb;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#variable-wp","title":"variable wp","text":"<pre><code>const double wp;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#variable-l1","title":"variable l1","text":"<pre><code>const double l1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DeltaRobotIk_1_1Kinematics/#variable-l2","title":"variable l2","text":"<pre><code>const double l2;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/","title":"cpp_robotics::DubinsPath::PlanningResult","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#public-attributes","title":"Public Attributes","text":"Name double t double p double q Mode mode"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-t","title":"variable t","text":"<pre><code>double t = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-p","title":"variable p","text":"<pre><code>double p = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-q","title":"variable q","text":"<pre><code>double q = 0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-mode","title":"variable mode","text":"<pre><code>Mode mode = Mode::NONE;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/","title":"cpp_robotics::GearHeadParam","text":"<p>\u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb </p> <p><code>#include &lt;dc_motor_param.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-functions","title":"Public Functions","text":"Name constexpr GearHeadParam(double ratio_, double efficiency_)"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-attributes","title":"Public Attributes","text":"Name const double ratio const double efficiency"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#function-gearheadparam","title":"function GearHeadParam","text":"<pre><code>inline constexpr GearHeadParam(\ndouble ratio_,\ndouble efficiency_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#variable-ratio","title":"variable ratio","text":"<pre><code>const double ratio;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#variable-efficiency","title":"variable efficiency","text":"<pre><code>const double efficiency;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/","title":"cpp_robotics::KDTree::Node","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#public-attributes","title":"Public Attributes","text":"Name int idx int axis std::unique_ptr&lt; Node &gt;[2] child"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-idx","title":"variable idx","text":"<pre><code>int idx = -1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-axis","title":"variable axis","text":"<pre><code>int axis = -1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-child","title":"variable child","text":"<pre><code>std::unique_ptr&lt; Node &gt;[2] child = {nullptr, nullptr};\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/","title":"cpp_robotics::Line","text":"<p>\u76f4\u7dda\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-functions","title":"Public Functions","text":"Name Line() =default constexpr Line(const Vector2d &amp; p0, const Vector2d &amp; p1) void set(const Vector2d &amp; p0_, const Vector2d &amp; p1_) constexpr double length() const constexpr double angle() const constexpr Vector2d lerp(const double t) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-attributes","title":"Public Attributes","text":"Name Vector2d p0 Vector2d p1"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-line","title":"function Line","text":"<pre><code>Line() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-line_1","title":"function Line","text":"<pre><code>inline constexpr Line(\nconst Vector2d &amp; p0,\nconst Vector2d &amp; p1\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-set","title":"function set","text":"<pre><code>inline void set(\nconst Vector2d &amp; p0_,\nconst Vector2d &amp; p1_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-length","title":"function length","text":"<pre><code>inline constexpr double length() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-angle","title":"function angle","text":"<pre><code>inline constexpr double angle() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector2d lerp(\nconst double t\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#variable-p0","title":"variable p0","text":"<pre><code>Vector2d p0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#variable-p1","title":"variable p1","text":"<pre><code>Vector2d p1;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/","title":"cpp_robotics::LinkConfig","text":"<p><code>#include &lt;link_robot.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#public-types","title":"Public Types","text":"Name enum class LinkType using GiNaC::ex ex using GiNaC::symbol symbol using GiNaC::lst lst using Eigen::Matrix&lt; ex, Eigen::Dynamic, 1 &gt; VectorXex using Eigen::Matrix&lt; ex, 3, 1 &gt; Vector3ex using Eigen::Transform&lt; ex, 3, Eigen::Affine &gt; Affine3ex using Eigen::Translation&lt; ex, 3 &gt; Translation3ex using Eigen::AngleAxis&lt; ex &gt; AngleAxisex using Eigen::Matrix&lt; ex, 3, 3 &gt; Matrix3ex"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#public-attributes","title":"Public Attributes","text":"Name LinkType link_type Eigen::Translation3d position double mass Eigen::Translation3d link_com Eigen::Matrix3d I"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#enum-linktype","title":"enum LinkType","text":"Enumerator Value Description RotationX RotationY RotationZ"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-ex","title":"using ex","text":"<pre><code>using cpp_robotics::LinkConfig::ex =  GiNaC::ex;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-symbol","title":"using symbol","text":"<pre><code>using cpp_robotics::LinkConfig::symbol =  GiNaC::symbol;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-lst","title":"using lst","text":"<pre><code>using cpp_robotics::LinkConfig::lst =  GiNaC::lst;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-vectorxex","title":"using VectorXex","text":"<pre><code>using cpp_robotics::LinkConfig::VectorXex =  Eigen::Matrix&lt;ex,Eigen::Dynamic,1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-vector3ex","title":"using Vector3ex","text":"<pre><code>using cpp_robotics::LinkConfig::Vector3ex =  Eigen::Matrix&lt;ex,3,1&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-affine3ex","title":"using Affine3ex","text":"<pre><code>using cpp_robotics::LinkConfig::Affine3ex =  Eigen::Transform&lt;ex,3,Eigen::Affine&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-translation3ex","title":"using Translation3ex","text":"<pre><code>using cpp_robotics::LinkConfig::Translation3ex =  Eigen::Translation&lt;ex,3&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-angleaxisex","title":"using AngleAxisex","text":"<pre><code>using cpp_robotics::LinkConfig::AngleAxisex =  Eigen::AngleAxis&lt;ex&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#using-matrix3ex","title":"using Matrix3ex","text":"<pre><code>using cpp_robotics::LinkConfig::Matrix3ex =  Eigen::Matrix&lt;ex, 3, 3&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#variable-link_type","title":"variable link_type","text":"<pre><code>LinkType link_type;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#variable-position","title":"variable position","text":"<pre><code>Eigen::Translation3d position;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#variable-mass","title":"variable mass","text":"<pre><code>double mass;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#variable-link_com","title":"variable link_com","text":"<pre><code>Eigen::Translation3d link_com;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1LinkConfig/#variable-i","title":"variable I","text":"<pre><code>Eigen::Matrix3d I;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/","title":"cpp_robotics::MecanumIk::Config","text":"<p><code>#include &lt;mecanum_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#public-attributes","title":"Public Attributes","text":"Name double width double length"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#variable-width","title":"variable width","text":"<pre><code>double width;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#variable-length","title":"variable length","text":"<pre><code>double length;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/","title":"cpp_robotics::Omni3Ik::Config","text":"<p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#public-attributes","title":"Public Attributes","text":"Name double radius double first_wheel_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#variable-radius","title":"variable radius","text":"<pre><code>double radius;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#variable-first_wheel_angle","title":"variable first_wheel_angle","text":"<pre><code>double first_wheel_angle = M_PI/6;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/","title":"cpp_robotics::Omni4Ik::Config","text":"<p><code>#include &lt;omni_ik.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#public-attributes","title":"Public Attributes","text":"Name double radius double first_wheel_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#variable-radius","title":"variable radius","text":"<pre><code>double radius;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#variable-first_wheel_angle","title":"variable first_wheel_angle","text":"<pre><code>double first_wheel_angle = M_PI/4;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/","title":"cpp_robotics::PID2::pid_param_t","text":"<p><code>#include &lt;pid2.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#public-attributes","title":"Public Attributes","text":"Name double Ts double gpd double Kp double Ki double Kd double b double c std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-ts","title":"variable Ts","text":"<pre><code>double Ts;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-gpd","title":"variable gpd","text":"<pre><code>double gpd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-kp","title":"variable Kp","text":"<pre><code>double Kp;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-ki","title":"variable Ki","text":"<pre><code>double Ki;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-kd","title":"variable Kd","text":"<pre><code>double Kd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-b","title":"variable b","text":"<pre><code>double b;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-c","title":"variable c","text":"<pre><code>double c;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2_1_1pid__param__t/#variable-output_limit","title":"variable output_limit","text":"<pre><code>std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/","title":"cpp_robotics::PID::pid_param_t","text":"<p><code>#include &lt;pid.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#public-attributes","title":"Public Attributes","text":"Name double Ts double gpd double Kp double Ki double Kd std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-ts","title":"variable Ts","text":"<pre><code>double Ts;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-gpd","title":"variable gpd","text":"<pre><code>double gpd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-kp","title":"variable Kp","text":"<pre><code>double Kp;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-ki","title":"variable Ki","text":"<pre><code>double Ki;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-kd","title":"variable Kd","text":"<pre><code>double Kd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID_1_1pid__param__t/#variable-output_limit","title":"variable output_limit","text":"<pre><code>std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/","title":"cpp_robotics::PSMC::param_t","text":"<p><code>#include &lt;psmc.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#public-attributes","title":"Public Attributes","text":"Name double Ts double Kp double Kd double Hs std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-ts","title":"variable Ts","text":"<pre><code>double Ts;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-kp","title":"variable Kp","text":"<pre><code>double Kp;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-kd","title":"variable Kd","text":"<pre><code>double Kd;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-hs","title":"variable Hs","text":"<pre><code>double Hs;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1PSMC_1_1param__t/#variable-output_limit","title":"variable output_limit","text":"<pre><code>std::optional&lt; std::pair&lt; double, double &gt; &gt; output_limit;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/","title":"cpp_robotics::Polynomial","text":"<p>\u591a\u9805\u5f0f </p> <p><code>#include &lt;polynomial.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#public-functions","title":"Public Functions","text":"Name Polynomial() =default Polynomial(std::initializer_list&lt; double &gt; coeff) Polynomial(const std::vector&lt; double &gt; &amp; coeff) template &lt;class IteratorType &gt;  Polynomial(IteratorType begin, IteratorType end) void set_degree(size_t deg) size_t size() const size_t degree() const std::vector&lt; double &gt; coeff() const double &amp; at(size_t i) double at(size_t i) const double &amp; at_degree(size_t i) double at_degree(size_t i) const double &amp; operator[](size_t i) double operator[](size_t i) const void check_degree() double evalute(double x) const void swap(Polynomial &amp; poly) double operator()(double x) const Polynomial operator+() const Polynomial operator-() const Polynomial operator+(double s) const Polynomial operator-(double s) const Polynomial &amp; operator+=(double s)\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b Polynomial &amp; operator-=(double s)\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u6e1b\u7b97\u3059\u308b Polynomial operator*(double s) const\u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 Polynomial &amp; operator*=(double s)\u81ea\u8eab\u3092s\u500d\u3059\u308b Polynomial operator/(double s) const\u591a\u9805\u5f0f\u30921/s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 Polynomial &amp; operator/=(double s)\u81ea\u8eab\u30921/s\u500d\u3059\u308b Polynomial operator*(const Polynomial &amp; p) const\u591a\u9805\u5f0f\u540c\u58eb\u306e\u7a4d\u3092\u53d6\u308b Polynomial &amp; operator*=(const Polynomial &amp; p) Polynomial operator+(Polynomial poly) const\u591a\u9805\u5f0f\u540c\u58eb\u306e\u548c\u3092\u53d6\u308b Polynomial &amp; operator+=(Polynomial poly)\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u52a0\u7b97\u3059\u308b Polynomial operator-(Polynomial poly) const Polynomial &amp; operator-=(Polynomial poly)\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u6e1b\u7b97\u3059\u308b Polynomial expand(std::vector&lt; double &gt; roots)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friends","title":"Friends","text":"Name Polynomial operator*(double s, const Polynomial &amp; poly) \u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 bool operator==(const Polynomial &amp; lhs, const Polynomial &amp; rhs) bool operator!=(const Polynomial &amp; lhs, const Polynomial &amp; rhs)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial","title":"function Polynomial","text":"<pre><code>Polynomial() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_1","title":"function Polynomial","text":"<pre><code>inline Polynomial(\nstd::initializer_list&lt; double &gt; coeff\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_2","title":"function Polynomial","text":"<pre><code>inline Polynomial(\nconst std::vector&lt; double &gt; &amp; coeff\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_3","title":"function Polynomial","text":"<pre><code>template &lt;class IteratorType &gt;\ninline Polynomial(\nIteratorType begin,\nIteratorType end\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-set_degree","title":"function set_degree","text":"<pre><code>inline void set_degree(\nsize_t deg\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-size","title":"function size","text":"<pre><code>inline size_t size() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-degree","title":"function degree","text":"<pre><code>inline size_t degree() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-coeff","title":"function coeff","text":"<pre><code>inline std::vector&lt; double &gt; coeff() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at","title":"function at","text":"<pre><code>inline double &amp; at(\nsize_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_1","title":"function at","text":"<pre><code>inline double at(\nsize_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_degree","title":"function at_degree","text":"<pre><code>inline double &amp; at_degree(\nsize_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_degree_1","title":"function at_degree","text":"<pre><code>inline double at_degree(\nsize_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator","title":"function operator[]","text":"<pre><code>inline double &amp; operator[](\nsize_t i\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_1","title":"function operator[]","text":"<pre><code>inline double operator[](\nsize_t i\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-check_degree","title":"function check_degree","text":"<pre><code>inline void check_degree()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-evalute","title":"function evalute","text":"<pre><code>inline double evalute(\ndouble x\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\nPolynomial &amp; poly\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_2","title":"function operator()","text":"<pre><code>inline double operator()(\ndouble x\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_3","title":"function operator+","text":"<pre><code>inline Polynomial operator+() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-","title":"function operator-","text":"<pre><code>inline Polynomial operator-() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_4","title":"function operator+","text":"<pre><code>inline Polynomial operator+(\ndouble s\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_1","title":"function operator-","text":"<pre><code>inline Polynomial operator-(\ndouble s\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_5","title":"function operator+=","text":"<pre><code>inline Polynomial &amp; operator+=(\ndouble s\n)\n</code></pre> <p>\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline Polynomial &amp; operator-=(\ndouble s\n)\n</code></pre> <p>\u591a\u9805\u5f0f\u306e0\u6b21\u306e\u9805\u306b\u5024\u3092\u6e1b\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_6","title":"function operator*","text":"<pre><code>inline Polynomial operator*(\ndouble s\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_7","title":"function operator*=","text":"<pre><code>inline Polynomial &amp; operator*=(\ndouble s\n)\n</code></pre> <p>\u81ea\u8eab\u3092s\u500d\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_8","title":"function operator/","text":"<pre><code>inline Polynomial operator/(\ndouble s\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u30921/s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_9","title":"function operator/=","text":"<pre><code>inline Polynomial &amp; operator/=(\ndouble s\n)\n</code></pre> <p>\u81ea\u8eab\u30921/s\u500d\u3059\u308b </p> <p>Parameters: </p> <ul> <li>s </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_10","title":"function operator*","text":"<pre><code>inline Polynomial operator*(\nconst Polynomial &amp; p\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u540c\u58eb\u306e\u7a4d\u3092\u53d6\u308b </p> <p>Parameters: </p> <ul> <li>p </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_11","title":"function operator*=","text":"<pre><code>inline Polynomial &amp; operator*=(\nconst Polynomial &amp; p\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_12","title":"function operator+","text":"<pre><code>inline Polynomial operator+(\nPolynomial poly\n) const\n</code></pre> <p>\u591a\u9805\u5f0f\u540c\u58eb\u306e\u548c\u3092\u53d6\u308b </p> <p>Parameters: </p> <ul> <li>poly </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_13","title":"function operator+=","text":"<pre><code>inline Polynomial &amp; operator+=(\nPolynomial poly\n)\n</code></pre> <p>\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u52a0\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>poly </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_3","title":"function operator-","text":"<pre><code>inline Polynomial operator-(\nPolynomial poly\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_4","title":"function operator-=","text":"<pre><code>inline Polynomial &amp; operator-=(\nPolynomial poly\n)\n</code></pre> <p>\u81ea\u8eab\u306b\u4ed6\u306e\u591a\u9805\u5f0f\u3092\u6e1b\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>poly </li> </ul> <p>Return: Polynomial&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-expand","title":"function expand","text":"<pre><code>static inline Polynomial expand(\nstd::vector&lt; double &gt; roots\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator","title":"friend operator*","text":"<pre><code>friend Polynomial operator*(\ndouble s,\n\nconst Polynomial &amp; poly\n);\n</code></pre> <p>\u591a\u9805\u5f0f\u3092s\u500d\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>s </li> <li>poly </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator_1","title":"friend operator==","text":"<pre><code>friend bool operator==(\nconst Polynomial &amp; lhs,\n\nconst Polynomial &amp; rhs\n);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator_2","title":"friend operator!=","text":"<pre><code>friend bool operator!=(\nconst Polynomial &amp; lhs,\n\nconst Polynomial &amp; rhs\n);\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/","title":"cpp_robotics::Quad","text":"<p>\u56db\u89d2\u5f62\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-functions","title":"Public Functions","text":"Name Quad() =default constexpr Quad(const std::array&lt; Vector2d, 4 &gt; &amp; points) constexpr Quad(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2, const Vector2d &amp; p3) void set(const Vector2d &amp; p0_, const Vector2d &amp; p1_, const Vector2d &amp; p2_, const Vector2d &amp; p3_) constexpr bool has_area() const constexpr double area() const constexpr std::array&lt; Vector2d, 4 &gt; vertex() const constexpr std::array&lt; Line, 4 &gt; outline() const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-attributes","title":"Public Attributes","text":"Name Vector2d p0 Vector2d p1 Vector2d p2 Vector2d p3"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad","title":"function Quad","text":"<pre><code>Quad() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad_1","title":"function Quad","text":"<pre><code>inline constexpr Quad(\nconst std::array&lt; Vector2d, 4 &gt; &amp; points\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad_2","title":"function Quad","text":"<pre><code>inline constexpr Quad(\nconst Vector2d &amp; p0,\nconst Vector2d &amp; p1,\nconst Vector2d &amp; p2,\nconst Vector2d &amp; p3\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-set","title":"function set","text":"<pre><code>inline void set(\nconst Vector2d &amp; p0_,\nconst Vector2d &amp; p1_,\nconst Vector2d &amp; p2_,\nconst Vector2d &amp; p3_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-vertex","title":"function vertex","text":"<pre><code>inline constexpr std::array&lt; Vector2d, 4 &gt; vertex() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-outline","title":"function outline","text":"<pre><code>inline constexpr std::array&lt; Line, 4 &gt; outline() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p0","title":"variable p0","text":"<pre><code>Vector2d p0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p1","title":"variable p1","text":"<pre><code>Vector2d p1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p2","title":"variable p2","text":"<pre><code>Vector2d p2;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p3","title":"variable p3","text":"<pre><code>Vector2d p3;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/","title":"cpp_robotics::QuadProg::Param","text":"<p><code>#include &lt;quadprog.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#public-attributes","title":"Public Attributes","text":"Name double tol_step double tol_con double t size_t max_iter bool print_variable"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-tol_step","title":"variable tol_step","text":"<pre><code>double tol_step = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-tol_con","title":"variable tol_con","text":"<pre><code>double tol_con = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-t","title":"variable t","text":"<pre><code>double t = 0.5;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 100;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-print_variable","title":"variable print_variable","text":"<pre><code>bool print_variable = false;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/","title":"cpp_robotics::QuadProg::Result","text":"<p><code>#include &lt;quadprog.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#public-attributes","title":"Public Attributes","text":"Name bool is_solved Eigen::VectorXd x Eigen::VectorXd lambda_ineq Eigen::VectorXd lambda_eq size_t iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-is_solved","title":"variable is_solved","text":"<pre><code>bool is_solved = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-x","title":"variable x","text":"<pre><code>Eigen::VectorXd x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-lambda_ineq","title":"variable lambda_ineq","text":"<pre><code>Eigen::VectorXd lambda_ineq;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-lambda_eq","title":"variable lambda_eq","text":"<pre><code>Eigen::VectorXd lambda_eq;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-iter_cnt","title":"variable iter_cnt","text":"<pre><code>size_t iter_cnt = 0;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/","title":"cpp_robotics::Quaternion","text":"<p>\u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;quaternion.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-functions","title":"Public Functions","text":"Name constexpr Quaternion() constexpr Quaternion(value_type nx, value_type ny, value_type nz, value_type nw) Quaternion get_product(Quaternion q) constexpr Quaternion conjugate() const constexpr value_type norm() const constexpr void normalize() constexpr Quaternion get_normalized() const constexpr void set_rpy(value_type roll, value_type pitch, value_type yaw) constexpr Vector3d get_rpy() const constexpr value_type operator[](const int index) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type z value_type w"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nclass cpp_robotics::Quaternion;\n</code></pre> <p>\u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>FLOATING_TYPE </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Quaternion&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-quaternion","title":"function Quaternion","text":"<pre><code>inline constexpr Quaternion()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-quaternion_1","title":"function Quaternion","text":"<pre><code>inline constexpr Quaternion(\nvalue_type nx,\nvalue_type ny,\nvalue_type nz,\nvalue_type nw\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_product","title":"function get_product","text":"<pre><code>inline Quaternion get_product(\nQuaternion q\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-conjugate","title":"function conjugate","text":"<pre><code>inline constexpr Quaternion conjugate() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-norm","title":"function norm","text":"<pre><code>inline constexpr value_type norm() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-normalize","title":"function normalize","text":"<pre><code>inline constexpr void normalize()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline constexpr Quaternion get_normalized() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-set_rpy","title":"function set_rpy","text":"<pre><code>inline constexpr void set_rpy(\nvalue_type roll,\nvalue_type pitch,\nvalue_type yaw\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_rpy","title":"function get_rpy","text":"<pre><code>inline constexpr Vector3d get_rpy() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-operator","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\nconst int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-z","title":"variable z","text":"<pre><code>value_type z;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-w","title":"variable w","text":"<pre><code>value_type w;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/","title":"cpp_robotics::Rect","text":"<p>\u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-functions","title":"Public Functions","text":"Name Rect() =default constexpr Rect(const Vector2d &amp; center, const Vector2d &amp; size) void set(const Vector2d &amp; center_, const Vector2d &amp; size_) constexpr bool has_area() const constexpr double area() const constexpr std::array&lt; Vector2d, 4 &gt; vertex() const constexpr std::array&lt; Line, 4 &gt; outline() const constexpr Quad as_quad() const constexpr Quad get_rotated(double angle) const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-attributes","title":"Public Attributes","text":"Name Vector2d center Vector2d size"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-rect","title":"function Rect","text":"<pre><code>Rect() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-rect_1","title":"function Rect","text":"<pre><code>inline constexpr Rect(\nconst Vector2d &amp; center,\nconst Vector2d &amp; size\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-set","title":"function set","text":"<pre><code>inline void set(\nconst Vector2d &amp; center_,\nconst Vector2d &amp; size_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-vertex","title":"function vertex","text":"<pre><code>inline constexpr std::array&lt; Vector2d, 4 &gt; vertex() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-outline","title":"function outline","text":"<pre><code>inline constexpr std::array&lt; Line, 4 &gt; outline() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-as_quad","title":"function as_quad","text":"<pre><code>inline constexpr Quad as_quad() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-get_rotated","title":"function get_rotated","text":"<pre><code>inline constexpr Quad get_rotated(\ndouble angle\n) const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#variable-center","title":"variable center","text":"<pre><code>Vector2d center;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#variable-size","title":"variable size","text":"<pre><code>Vector2d size;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/","title":"cpp_robotics::SQP::Problem","text":"<p><code>#include &lt;sqp.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#public-attributes","title":"Public Attributes","text":"Name func_type func std::optional&lt; grad_func_type &gt; grad ConstraintArray con bool use_slsqp double tol_step double tol_con size_t max_iter bool print_variable"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-func","title":"variable func","text":"<pre><code>func_type func;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-grad","title":"variable grad","text":"<pre><code>std::optional&lt; grad_func_type &gt; grad;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-con","title":"variable con","text":"<pre><code>ConstraintArray con;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-use_slsqp","title":"variable use_slsqp","text":"<pre><code>bool use_slsqp = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-tol_step","title":"variable tol_step","text":"<pre><code>double tol_step = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-tol_con","title":"variable tol_con","text":"<pre><code>double tol_con = 1e-6;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-max_iter","title":"variable max_iter","text":"<pre><code>size_t max_iter = 100;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-print_variable","title":"variable print_variable","text":"<pre><code>bool print_variable = false;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/","title":"cpp_robotics::SQP::Result","text":"<p><code>#include &lt;sqp.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#public-attributes","title":"Public Attributes","text":"Name bool is_solved Eigen::VectorXd x size_t iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-is_solved","title":"variable is_solved","text":"<pre><code>bool is_solved = false;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-x","title":"variable x","text":"<pre><code>Eigen::VectorXd x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-iter_cnt","title":"variable iter_cnt","text":"<pre><code>size_t iter_cnt = 0;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/","title":"cpp_robotics::SisoFeedbackSystem::func_list_t","text":"<p><code>#include &lt;siso_system.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#public-attributes","title":"Public Attributes","text":"Name std::function&lt; void(void)&gt; controller_reset std::function&lt; double(double)&gt; controller std::function&lt; void(void)&gt; system_reset std::function&lt; double(double)&gt; system"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-controller_reset","title":"variable controller_reset","text":"<pre><code>std::function&lt; void(void)&gt; controller_reset;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-controller","title":"variable controller","text":"<pre><code>std::function&lt; double(double)&gt; controller;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-system_reset","title":"variable system_reset","text":"<pre><code>std::function&lt; void(void)&gt; system_reset;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-system","title":"variable system","text":"<pre><code>std::function&lt; double(double)&gt; system;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/","title":"cpp_robotics::Spline2D::segment_info_t","text":"<p><code>#include &lt;spline.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#public-attributes","title":"Public Attributes","text":"Name size_t i double t"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#variable-i","title":"variable i","text":"<pre><code>size_t i;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#variable-t","title":"variable t","text":"<pre><code>double t;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/","title":"cpp_robotics::Spline2D::segment_t","text":"<p><code>#include &lt;spline.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#public-attributes","title":"Public Attributes","text":"Name spline::spline_c coeff double length"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#variable-coeff","title":"variable coeff","text":"<pre><code>spline::spline_c coeff;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#variable-length","title":"variable length","text":"<pre><code>double length;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/","title":"cpp_robotics::Transform","text":"<p>2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;transform.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type using Vector2&lt; value_type &gt; vector_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-functions","title":"Public Functions","text":"Name Transform() =defaultConstruct a new Field Vector 2 object. constexpr Transform(const value_type _x, const value_type _y, const value_type _theta)Construct a new Field Vector 2 object. constexpr Transform(const vector_type &amp; _xy, const value_type _theta)Construct a new Field Vector 2 object. constexpr Transform(const Transform &amp; ) =defaultConstruct a new Field Vector 2 object. constexpr vector_type make_vector2() constxy\u6210\u5206\u306eVector2\u3092\u751f\u6210 constexpr void set(value_type vx, value_type vy, value_type vtheta) value_type distance() const\u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 void rotate(const value_type theta)\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate(const value_type rotX, const value_type rotY, const value_type theta)\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate(vector_type rotPos, const value_type theta)\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void set_polar(const value_type radius, const value_type angle, const value_type robotTheta)\u6975\u5ea7\u6a19\u6307\u5b9a bool is_zero() const bool is_zero_pos() const bool is_zero_angle() const bool has_nan() const constexpr bool operator==(const Transform v) const constexpr bool operator!=(const Transform &amp; v) const constexpr Transform operator+(const Transform &amp; v) const constexpr Transform operator-(const Transform &amp; v) const constexpr Transform &amp; operator+=(const Transform &amp; v) constexpr Transform &amp; operator-=(const Transform &amp; v) constexpr Transform operator+(const vector_type &amp; v) const constexpr Transform operator-(const vector_type &amp; v) const constexpr Transform operator+(const value_type angle) const constexpr Transform operator-(const value_type angle) const constexpr Transform &amp; operator+=(const vector_type &amp; v) constexpr Transform &amp; operator-=(const vector_type &amp; v) constexpr Transform &amp; operator+=(const value_type angle) constexpr Transform &amp; operator-=(const value_type angle) constexpr Transform operator*(const value_type value) const constexpr Transform operator/(const value_type value) const constexpr Transform &amp; operator*=(const value_type value) constexpr Transform &amp; operator/=(const value_type value) value_type &amp; operator[](const int index) constexpr value_type operator[](const int index) const constexpr value_type get_angle(Transform &amp; a, Transform &amp; b)Get the Angle object. value_type get_distance(Transform &amp; a, Transform &amp; b)Get the Distance object. Transform get_lerp(Transform &amp; a, Transform &amp; b, const value_type t)lerp function constexpr Transform origin()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type theta"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Transform;\n</code></pre> <p>2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Transform&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#using-vector_type","title":"using vector_type","text":"<pre><code>using cpp_robotics::Transform&lt; FLOATING_TYPE &gt;::vector_type =  Vector2&lt;value_type&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform","title":"function Transform","text":"<pre><code>Transform() =default\n</code></pre> <p>Construct a new Field Vector 2 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_1","title":"function Transform","text":"<pre><code>inline constexpr Transform(\nconst value_type _x,\nconst value_type _y,\nconst value_type _theta\n)\n</code></pre> <p>Construct a new Field Vector 2 object. </p> <p>Parameters: </p> <ul> <li>x </li> <li>y </li> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_2","title":"function Transform","text":"<pre><code>inline constexpr Transform(\nconst vector_type &amp; _xy,\nconst value_type _theta\n)\n</code></pre> <p>Construct a new Field Vector 2 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_3","title":"function Transform","text":"<pre><code>constexpr Transform(\nconst Transform &amp; ) =default\n</code></pre> <p>Construct a new Field Vector 2 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-make_vector2","title":"function make_vector2","text":"<pre><code>inline constexpr vector_type make_vector2() const\n</code></pre> <p>xy\u6210\u5206\u306eVector2\u3092\u751f\u6210 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-set","title":"function set","text":"<pre><code>inline constexpr void set(\nvalue_type vx,\nvalue_type vy,\nvalue_type vtheta\n)\n</code></pre> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vtheta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-distance","title":"function distance","text":"<pre><code>inline value_type distance() const\n</code></pre> <p>\u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate","title":"function rotate","text":"<pre><code>inline void rotate(\nconst value_type theta\n)\n</code></pre> <p>\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate_1","title":"function rotate","text":"<pre><code>inline void rotate(\nconst value_type rotX,\nconst value_type rotY,\nconst value_type theta\n)\n</code></pre> <p>\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>rotX </li> <li>rotY </li> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate_2","title":"function rotate","text":"<pre><code>inline void rotate(\nvector_type rotPos,\nconst value_type theta\n)\n</code></pre> <p>\u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>rotPos </li> <li>theta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-set_polar","title":"function set_polar","text":"<pre><code>inline void set_polar(\nconst value_type radius,\nconst value_type angle,\nconst value_type robotTheta\n)\n</code></pre> <p>\u6975\u5ea7\u6a19\u6307\u5b9a </p> <p>Parameters: </p> <ul> <li>radius </li> <li>angle </li> <li>robotTheta </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero","title":"function is_zero","text":"<pre><code>inline bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero_pos","title":"function is_zero_pos","text":"<pre><code>inline bool is_zero_pos() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero_angle","title":"function is_zero_angle","text":"<pre><code>inline bool is_zero_angle() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-has_nan","title":"function has_nan","text":"<pre><code>inline bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator","title":"function operator==","text":"<pre><code>inline constexpr bool operator==(\nconst Transform v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_1","title":"function operator!=","text":"<pre><code>inline constexpr bool operator!=(\nconst Transform &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_2","title":"function operator+","text":"<pre><code>inline constexpr Transform operator+(\nconst Transform &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Transform operator-(\nconst Transform &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_3","title":"function operator+=","text":"<pre><code>inline constexpr Transform &amp; operator+=(\nconst Transform &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_1","title":"function operator-=","text":"<pre><code>inline constexpr Transform &amp; operator-=(\nconst Transform &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_4","title":"function operator+","text":"<pre><code>inline constexpr Transform operator+(\nconst vector_type &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_2","title":"function operator-","text":"<pre><code>inline constexpr Transform operator-(\nconst vector_type &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_5","title":"function operator+","text":"<pre><code>inline constexpr Transform operator+(\nconst value_type angle\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_3","title":"function operator-","text":"<pre><code>inline constexpr Transform operator-(\nconst value_type angle\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_6","title":"function operator+=","text":"<pre><code>inline constexpr Transform &amp; operator+=(\nconst vector_type &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_4","title":"function operator-=","text":"<pre><code>inline constexpr Transform &amp; operator-=(\nconst vector_type &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_7","title":"function operator+=","text":"<pre><code>inline constexpr Transform &amp; operator+=(\nconst value_type angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_5","title":"function operator-=","text":"<pre><code>inline constexpr Transform &amp; operator-=(\nconst value_type angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_8","title":"function operator*","text":"<pre><code>inline constexpr Transform operator*(\nconst value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_9","title":"function operator/","text":"<pre><code>inline constexpr Transform operator/(\nconst value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_10","title":"function operator*=","text":"<pre><code>inline constexpr Transform &amp; operator*=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_11","title":"function operator/=","text":"<pre><code>inline constexpr Transform &amp; operator/=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Transform&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_12","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\nconst int index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_13","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\nconst int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_angle","title":"function get_angle","text":"<pre><code>static inline constexpr value_type get_angle(\nTransform &amp; a,\nTransform &amp; b\n)\n</code></pre> <p>Get the Angle object. </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_distance","title":"function get_distance","text":"<pre><code>static inline value_type get_distance(\nTransform &amp; a,\nTransform &amp; b\n)\n</code></pre> <p>Get the Distance object. </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_lerp","title":"function get_lerp","text":"<pre><code>static inline Transform get_lerp(\nTransform &amp; a,\nTransform &amp; b,\nconst value_type t\n)\n</code></pre> <p>lerp function </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-origin","title":"function origin","text":"<pre><code>static inline constexpr Transform origin()\n</code></pre> <p>Return: Transform</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-theta","title":"variable theta","text":"<pre><code>value_type theta;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/","title":"cpp_robotics::Triangle","text":"<p>\u4e09\u89d2\u5f62\u30af\u30e9\u30b9 </p> <p><code>#include &lt;shape.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-functions","title":"Public Functions","text":"Name Triangle() =default constexpr Triangle(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2) void set(const Vector2d &amp; p0_, const Vector2d &amp; p1_, const Vector2d &amp; p2_) constexpr bool has_area() const constexpr double area() const constexpr std::array&lt; Vector2d, 3 &gt; vertex() const constexpr std::array&lt; Line, 3 &gt; outline() const"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-attributes","title":"Public Attributes","text":"Name Vector2d p0 Vector2d p1 Vector2d p2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-triangle","title":"function Triangle","text":"<pre><code>Triangle() =default\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-triangle_1","title":"function Triangle","text":"<pre><code>inline constexpr Triangle(\nconst Vector2d &amp; p0,\nconst Vector2d &amp; p1,\nconst Vector2d &amp; p2\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-set","title":"function set","text":"<pre><code>inline void set(\nconst Vector2d &amp; p0_,\nconst Vector2d &amp; p1_,\nconst Vector2d &amp; p2_\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-has_area","title":"function has_area","text":"<pre><code>inline constexpr bool has_area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-area","title":"function area","text":"<pre><code>inline constexpr double area() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-vertex","title":"function vertex","text":"<pre><code>inline constexpr std::array&lt; Vector2d, 3 &gt; vertex() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-outline","title":"function outline","text":"<pre><code>inline constexpr std::array&lt; Line, 3 &gt; outline() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p0","title":"variable p0","text":"<pre><code>Vector2d p0;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p1","title":"variable p1","text":"<pre><code>Vector2d p1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p2","title":"variable p2","text":"<pre><code>Vector2d p2;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/","title":"cpp_robotics::Vector2","text":"<p>2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb  More...</p> <p><code>#include &lt;vector2.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-functions","title":"Public Functions","text":"Name Vector2() =defaultConstruct a new Vector 2 object. constexpr Vector2(value_type vx, value_type vy)Construct a new Vector 2 object. constexpr Vector2(const Vector2 &amp; ) =defaultConstruct a new Vector 2 object. constexpr void set(const value_type vx, const value_type vy)\u5024\u306e\u4ee3\u5165 void set_polar(const value_type radius, const value_type theta)\u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 constexpr value_type dot(const Vector2 &amp; v) const constexpr value_type cross(const Vector2 &amp; v) const constexpr value_type norm_sq() const constexpr value_type norm() const\u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 void normalize()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 constexpr value_type angle() const\u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 constexpr Vector2 get_normalized()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 void rotate(const value_type theta)\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 constexpr Vector2 get_rotated(const value_type theta) const\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 constexpr bool is_zero() const constexpr bool has_nan() const constexpr Vector2 yx() const constexpr Vector2 nyx() const constexpr Vector2 ynx() const constexpr Vector2 nxy() const constexpr Vector2 xny() const constexpr Vector2 lerp(const Vector2 &amp; b, const value_type t) const constexpr Vector2 operator+() const constexpr Vector2 operator-() const constexpr bool operator==(const Vector2 &amp; v) const constexpr bool operator!=(const Vector2 &amp; v) const constexpr Vector2 operator+(const Vector2 &amp; v) const constexpr Vector2 operator-(const Vector2 &amp; v) const constexpr Vector2 &amp; operator+=(const Vector2 &amp; v) constexpr Vector2 &amp; operator-=(const Vector2 &amp; v) constexpr Vector2 &amp; operator*=(const value_type value) constexpr Vector2 &amp; operator/=(const value_type value) value_type &amp; operator[](const size_t index) constexpr value_type operator[](const size_t index) const constexpr value_type dot(const Vector2 &amp; a, const Vector2 &amp; b) constexpr value_type angle(const Vector2 &amp; a, const Vector2 &amp; b) constexpr value_type distance(const Vector2 &amp; a, const Vector2 &amp; b) constexpr Vector2 lerp(const Vector2 &amp; a, const Vector2 &amp; b, const value_type t) constexpr Vector2 zero() constexpr Vector2 up() constexpr Vector2 down() constexpr Vector2 right() constexpr Vector2 left()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friends","title":"Friends","text":"Name constexpr friend Vector2 operator/(const Vector2 &amp; v, const value_type value) constexpr friend Vector2 operator*(const Vector2 &amp; v, const Scaler s) constexpr friend Vector2 operator*(const Scaler s, const Vector2 &amp; v)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Vector2;\n</code></pre> <p>2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Vector2&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2","title":"function Vector2","text":"<pre><code>Vector2() =default\n</code></pre> <p>Construct a new Vector 2 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2_1","title":"function Vector2","text":"<pre><code>inline constexpr Vector2(\nvalue_type vx,\nvalue_type vy\n)\n</code></pre> <p>Construct a new Vector 2 object. </p> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2_2","title":"function Vector2","text":"<pre><code>constexpr Vector2(\nconst Vector2 &amp; ) =default\n</code></pre> <p>Construct a new Vector 2 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-set","title":"function set","text":"<pre><code>inline constexpr void set(\nconst value_type vx,\nconst value_type vy\n)\n</code></pre> <p>\u5024\u306e\u4ee3\u5165 </p> <p>Parameters: </p> <ul> <li>vx value_type </li> <li>vy </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-set_polar","title":"function set_polar","text":"<pre><code>inline void set_polar(\nconst value_type radius,\nconst value_type theta\n)\n</code></pre> <p>\u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 </p> <p>Parameters: </p> <ul> <li>radius \u534a\u5f84 </li> <li>theta \u89d2\u5ea6[rad] </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-dot","title":"function dot","text":"<pre><code>inline constexpr value_type dot(\nconst Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-cross","title":"function cross","text":"<pre><code>inline constexpr value_type cross(\nconst Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-norm_sq","title":"function norm_sq","text":"<pre><code>inline constexpr value_type norm_sq() const\n</code></pre> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-norm","title":"function norm","text":"<pre><code>inline constexpr value_type norm() const\n</code></pre> <p>\u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-normalize","title":"function normalize","text":"<pre><code>inline void normalize()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-angle","title":"function angle","text":"<pre><code>inline constexpr value_type angle() const\n</code></pre> <p>\u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline constexpr Vector2 get_normalized()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-rotate","title":"function rotate","text":"<pre><code>inline void rotate(\nconst value_type theta\n)\n</code></pre> <p>\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 </p> <p>Parameters: </p> <ul> <li>theta [rad] </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-get_rotated","title":"function get_rotated","text":"<pre><code>inline constexpr Vector2 get_rotated(\nconst value_type theta\n) const\n</code></pre> <p>\u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>theta </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-is_zero","title":"function is_zero","text":"<pre><code>inline constexpr bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-has_nan","title":"function has_nan","text":"<pre><code>inline constexpr bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-yx","title":"function yx","text":"<pre><code>inline constexpr Vector2 yx() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-nyx","title":"function nyx","text":"<pre><code>inline constexpr Vector2 nyx() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-ynx","title":"function ynx","text":"<pre><code>inline constexpr Vector2 ynx() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-nxy","title":"function nxy","text":"<pre><code>inline constexpr Vector2 nxy() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-xny","title":"function xny","text":"<pre><code>inline constexpr Vector2 xny() const\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector2 lerp(\nconst Vector2 &amp; b,\nconst value_type t\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr Vector2 operator+() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Vector2 operator-() const\n</code></pre> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_1","title":"function operator==","text":"<pre><code>inline constexpr bool operator==(\nconst Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_2","title":"function operator!=","text":"<pre><code>inline constexpr bool operator!=(\nconst Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_3","title":"function operator+","text":"<pre><code>inline constexpr Vector2 operator+(\nconst Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr Vector2 operator-(\nconst Vector2 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_4","title":"function operator+=","text":"<pre><code>inline constexpr Vector2 &amp; operator+=(\nconst Vector2 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr Vector2 &amp; operator-=(\nconst Vector2 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_5","title":"function operator*=","text":"<pre><code>inline constexpr Vector2 &amp; operator*=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_6","title":"function operator/=","text":"<pre><code>inline constexpr Vector2 &amp; operator/=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector2&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_7","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\nconst size_t index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_8","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\nconst size_t index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-dot_1","title":"function dot","text":"<pre><code>static inline constexpr value_type dot(\nconst Vector2 &amp; a,\nconst Vector2 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-angle_1","title":"function angle","text":"<pre><code>static inline constexpr value_type angle(\nconst Vector2 &amp; a,\nconst Vector2 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-distance","title":"function distance","text":"<pre><code>static inline constexpr value_type distance(\nconst Vector2 &amp; a,\nconst Vector2 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-lerp_1","title":"function lerp","text":"<pre><code>static inline constexpr Vector2 lerp(\nconst Vector2 &amp; a,\nconst Vector2 &amp; b,\nconst value_type t\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-zero","title":"function zero","text":"<pre><code>static inline constexpr Vector2 zero()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-up","title":"function up","text":"<pre><code>static inline constexpr Vector2 up()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-down","title":"function down","text":"<pre><code>static inline constexpr Vector2 down()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-right","title":"function right","text":"<pre><code>static inline constexpr Vector2 right()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-left","title":"function left","text":"<pre><code>static inline constexpr Vector2 left()\n</code></pre> <p>Return: const Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator","title":"friend operator/","text":"<pre><code>friend constexpr friend Vector2 operator/(\nconst Vector2 &amp; v,\n\nconst value_type value\n);\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator_1","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector2 operator*(\nconst Vector2 &amp; v,\n\nconst Scaler s\n);\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> <li>s </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector2</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator_2","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector2 operator*(\nconst Scaler s,\n\nconst Vector2 &amp; v\n);\n</code></pre> <p>Parameters: </p> <ul> <li>s </li> <li>v </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector2</p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/","title":"cpp_robotics::Vector3","text":"<p>3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb  More...</p> <p><code>#include &lt;vector3.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-functions","title":"Public Functions","text":"Name Vector3() =defaultConstruct a new Vector 3 object. constexpr Vector3(value_type vx, value_type vy, value_type vz)Construct a new Vector 3 object. Vector3(const Vector3 &amp; v) =defaultConstruct a new Vector 3 object. void set(value_type vx, value_type vy, value_type vz) constexpr value_type dot(const Vector3 &amp; v) const constexpr Vector3 cross(const Vector3 &amp; v) const constexpr value_type norm_sq() const value_type norm()Get the Magnitude object. void normalize()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector3 get_normalized()Get the Normalized object. constexpr bool is_zero() const constexpr bool has_nan() const constexpr Vector3 lerp(const Vector3 &amp; b, const value_type t) const constexpr Vector3 operator+() const constexpr Vector3 operator-() const bool operator==(const Vector3 &amp; v) const bool operator!=(const Vector3 &amp; v) const constexpr Vector3 operator+(const Vector3 &amp; v) const constexpr Vector3 operator-(const Vector3 &amp; v) const constexpr Vector3 &amp; operator+=(const Vector3 &amp; v) constexpr Vector3 &amp; operator-=(const Vector3 &amp; v) constexpr Vector3 &amp; operator*=(const value_type value) constexpr Vector3 &amp; operator/=(const value_type value) value_type &amp; operator[](const int index) constexpr value_type operator[](const int index) const constexpr value_type dot(const Vector3 &amp; a, const Vector3 &amp; b) value_type distance(const Vector3 &amp; a, const Vector3 &amp; b) constexpr Vector3 lerp(const Vector3 &amp; a, const Vector3 &amp; b, const value_type t) constexpr Vector3 zero() constexpr Vector3 forward() constexpr Vector3 back() constexpr Vector3 up() constexpr Vector3 down() constexpr Vector3 right() constexpr Vector3 left()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type z"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friends","title":"Friends","text":"Name constexpr friend Vector3 operator/(const Vector3 &amp; v, const value_type value) constexpr friend Vector3 operator*(const Vector3 &amp; v, const Scaler s) constexpr friend Vector3 operator*(const Scaler s, const Vector3 &amp; v)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Vector3;\n</code></pre> <p>3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Vector3&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3","title":"function Vector3","text":"<pre><code>Vector3() =default\n</code></pre> <p>Construct a new Vector 3 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3_1","title":"function Vector3","text":"<pre><code>inline constexpr Vector3(\nvalue_type vx,\nvalue_type vy,\nvalue_type vz\n)\n</code></pre> <p>Construct a new Vector 3 object. </p> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3_2","title":"function Vector3","text":"<pre><code>Vector3(\nconst Vector3 &amp; v\n) =default\n</code></pre> <p>Construct a new Vector 3 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-set","title":"function set","text":"<pre><code>inline void set(\nvalue_type vx,\nvalue_type vy,\nvalue_type vz\n)\n</code></pre> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-dot","title":"function dot","text":"<pre><code>inline constexpr value_type dot(\nconst Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-cross","title":"function cross","text":"<pre><code>inline constexpr Vector3 cross(\nconst Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-norm_sq","title":"function norm_sq","text":"<pre><code>inline constexpr value_type norm_sq() const\n</code></pre> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-norm","title":"function norm","text":"<pre><code>inline value_type norm()\n</code></pre> <p>Get the Magnitude object. </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-normalize","title":"function normalize","text":"<pre><code>inline void normalize()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline Vector3 get_normalized()\n</code></pre> <p>Get the Normalized object. </p> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-is_zero","title":"function is_zero","text":"<pre><code>inline constexpr bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-has_nan","title":"function has_nan","text":"<pre><code>inline constexpr bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector3 lerp(\nconst Vector3 &amp; b,\nconst value_type t\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr Vector3 operator+() const\n</code></pre> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Vector3 operator-() const\n</code></pre> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_2","title":"function operator!=","text":"<pre><code>inline bool operator!=(\nconst Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_3","title":"function operator+","text":"<pre><code>inline constexpr Vector3 operator+(\nconst Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr Vector3 operator-(\nconst Vector3 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_4","title":"function operator+=","text":"<pre><code>inline constexpr Vector3 &amp; operator+=(\nconst Vector3 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr Vector3 &amp; operator-=(\nconst Vector3 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_5","title":"function operator*=","text":"<pre><code>inline constexpr Vector3 &amp; operator*=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_6","title":"function operator/=","text":"<pre><code>inline constexpr Vector3 &amp; operator/=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector3&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_7","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\nconst int index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_8","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\nconst int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-dot_1","title":"function dot","text":"<pre><code>static inline constexpr value_type dot(\nconst Vector3 &amp; a,\nconst Vector3 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-distance","title":"function distance","text":"<pre><code>static inline value_type distance(\nconst Vector3 &amp; a,\nconst Vector3 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-lerp_1","title":"function lerp","text":"<pre><code>static inline constexpr Vector3 lerp(\nconst Vector3 &amp; a,\nconst Vector3 &amp; b,\nconst value_type t\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-zero","title":"function zero","text":"<pre><code>static inline constexpr Vector3 zero()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-forward","title":"function forward","text":"<pre><code>static inline constexpr Vector3 forward()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-back","title":"function back","text":"<pre><code>static inline constexpr Vector3 back()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-up","title":"function up","text":"<pre><code>static inline constexpr Vector3 up()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-down","title":"function down","text":"<pre><code>static inline constexpr Vector3 down()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-right","title":"function right","text":"<pre><code>static inline constexpr Vector3 right()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-left","title":"function left","text":"<pre><code>static inline constexpr Vector3 left()\n</code></pre> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-z","title":"variable z","text":"<pre><code>value_type z;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator","title":"friend operator/","text":"<pre><code>friend constexpr friend Vector3 operator/(\nconst Vector3 &amp; v,\n\nconst value_type value\n);\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator_1","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector3 operator*(\nconst Vector3 &amp; v,\n\nconst Scaler s\n);\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> <li>s </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector3</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator_2","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector3 operator*(\nconst Scaler s,\n\nconst Vector3 &amp; v\n);\n</code></pre> <p>Parameters: </p> <ul> <li>s </li> <li>v </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector3</p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/","title":"cpp_robotics::Vector4","text":"<p>4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb  More...</p> <p><code>#include &lt;vector4.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-types","title":"Public Types","text":"Name using FLOATING_TYPE value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-functions","title":"Public Functions","text":"Name Vector4() =defaultConstruct a new Vector 4 object. constexpr Vector4(value_type vx, value_type vy, value_type vz, value_type vw)Construct a new Vector 4 object. Vector4(const Vector4 &amp; v) =defaultConstruct a new Vector 4 object. void set(value_type vx, value_type vy, value_type vz, value_type vw) constexpr value_type dot(const Vector4 &amp; v) const constexpr value_type norm_sq() const value_type norm()Get the Magnitude object. void normalize()\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector4 get_normalized()Get the Normalized object. constexpr bool is_zero() const constexpr bool has_nan() const constexpr Vector4 lerp(const Vector4 &amp; b, const value_type t) const constexpr Vector4 operator+() const constexpr Vector4 operator-() const bool operator==(const Vector4 &amp; v) const bool operator!=(const Vector4 &amp; v) const constexpr Vector4 operator+(const Vector4 &amp; v) const constexpr Vector4 operator-(const Vector4 &amp; v) const constexpr Vector4 operator*(const value_type value) const constexpr Vector4 operator/(const value_type value) const constexpr Vector4 &amp; operator+=(const Vector4 &amp; v) constexpr Vector4 &amp; operator-=(const Vector4 &amp; v) constexpr Vector4 &amp; operator*=(const value_type value) constexpr Vector4 &amp; operator/=(const value_type value) value_type &amp; operator[](const int index) constexpr value_type operator[](const int index) const constexpr value_type dot(const Vector4 &amp; a, const Vector4 &amp; b) value_type distance(const Vector4 &amp; a, const Vector4 &amp; b) constexpr Vector4 lerp(const Vector4 &amp; a, const Vector4 &amp; b, const value_type t) constexpr Vector4 zero()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-attributes","title":"Public Attributes","text":"Name value_type x value_type y value_type z value_type w"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friends","title":"Friends","text":"Name constexpr friend Vector4 operator*(Scaler s, Vector4 v)"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename FLOATING_TYPE &gt;\nstruct cpp_robotics::Vector4;\n</code></pre> <p>4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#using-value_type","title":"using value_type","text":"<pre><code>using cpp_robotics::Vector4&lt; FLOATING_TYPE &gt;::value_type =  FLOATING_TYPE;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4","title":"function Vector4","text":"<pre><code>Vector4() =default\n</code></pre> <p>Construct a new Vector 4 object. </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4_1","title":"function Vector4","text":"<pre><code>inline constexpr Vector4(\nvalue_type vx,\nvalue_type vy,\nvalue_type vz,\nvalue_type vw\n)\n</code></pre> <p>Construct a new Vector 4 object. </p> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> <li>vw </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4_2","title":"function Vector4","text":"<pre><code>Vector4(\nconst Vector4 &amp; v\n) =default\n</code></pre> <p>Construct a new Vector 4 object. </p> <p>Parameters: </p> <ul> <li>v </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-set","title":"function set","text":"<pre><code>inline void set(\nvalue_type vx,\nvalue_type vy,\nvalue_type vz,\nvalue_type vw\n)\n</code></pre> <p>Parameters: </p> <ul> <li>vx </li> <li>vy </li> <li>vz </li> <li>vw </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-dot","title":"function dot","text":"<pre><code>inline constexpr value_type dot(\nconst Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-norm_sq","title":"function norm_sq","text":"<pre><code>inline constexpr value_type norm_sq() const\n</code></pre> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-norm","title":"function norm","text":"<pre><code>inline value_type norm()\n</code></pre> <p>Get the Magnitude object. </p> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-normalize","title":"function normalize","text":"<pre><code>inline void normalize()\n</code></pre> <p>\u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-get_normalized","title":"function get_normalized","text":"<pre><code>inline Vector4 get_normalized()\n</code></pre> <p>Get the Normalized object. </p> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-is_zero","title":"function is_zero","text":"<pre><code>inline constexpr bool is_zero() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-has_nan","title":"function has_nan","text":"<pre><code>inline constexpr bool has_nan() const\n</code></pre> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr Vector4 lerp(\nconst Vector4 &amp; b,\nconst value_type t\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator","title":"function operator+","text":"<pre><code>inline constexpr Vector4 operator+() const\n</code></pre> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-","title":"function operator-","text":"<pre><code>inline constexpr Vector4 operator-() const\n</code></pre> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_2","title":"function operator!=","text":"<pre><code>inline bool operator!=(\nconst Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_3","title":"function operator+","text":"<pre><code>inline constexpr Vector4 operator+(\nconst Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-_1","title":"function operator-","text":"<pre><code>inline constexpr Vector4 operator-(\nconst Vector4 &amp; v\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_4","title":"function operator*","text":"<pre><code>inline constexpr Vector4 operator*(\nconst value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_5","title":"function operator/","text":"<pre><code>inline constexpr Vector4 operator/(\nconst value_type value\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_6","title":"function operator+=","text":"<pre><code>inline constexpr Vector4 &amp; operator+=(\nconst Vector4 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-_2","title":"function operator-=","text":"<pre><code>inline constexpr Vector4 &amp; operator-=(\nconst Vector4 &amp; v\n)\n</code></pre> <p>Parameters: </p> <ul> <li>v </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_7","title":"function operator*=","text":"<pre><code>inline constexpr Vector4 &amp; operator*=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_8","title":"function operator/=","text":"<pre><code>inline constexpr Vector4 &amp; operator/=(\nconst value_type value\n)\n</code></pre> <p>Parameters: </p> <ul> <li>value </li> </ul> <p>Return: Vector4&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_9","title":"function operator[]","text":"<pre><code>inline value_type &amp; operator[](\nconst int index\n)\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: value_type&amp; </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_10","title":"function operator[]","text":"<pre><code>inline constexpr value_type operator[](\nconst int index\n) const\n</code></pre> <p>Parameters: </p> <ul> <li>index </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-dot_1","title":"function dot","text":"<pre><code>static inline constexpr value_type dot(\nconst Vector4 &amp; a,\nconst Vector4 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: constexpr value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-distance","title":"function distance","text":"<pre><code>static inline value_type distance(\nconst Vector4 &amp; a,\nconst Vector4 &amp; b\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> </ul> <p>Return: value_type </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-lerp_1","title":"function lerp","text":"<pre><code>static inline constexpr Vector4 lerp(\nconst Vector4 &amp; a,\nconst Vector4 &amp; b,\nconst value_type t\n)\n</code></pre> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>t </li> </ul> <p>Return: constexpr Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-zero","title":"function zero","text":"<pre><code>static inline constexpr Vector4 zero()\n</code></pre> <p>Return: Vector4</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-x","title":"variable x","text":"<pre><code>value_type x;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-y","title":"variable y","text":"<pre><code>value_type y;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-z","title":"variable z","text":"<pre><code>value_type z;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-w","title":"variable w","text":"<pre><code>value_type w;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friends_1","title":"Friends","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friend-operator","title":"friend operator*","text":"<pre><code>friend constexpr friend Vector4 operator*(\nScaler s,\n\nVector4 v\n);\n</code></pre> <p>Parameters: </p> <ul> <li>s </li> <li>v </li> </ul> <p>Template Parameters: </p> <ul> <li>Scaler </li> </ul> <p>Return: constexpr Vector4</p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/","title":"cpp_robotics::XY2degRobot::Kinematics","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#public-functions","title":"Public Functions","text":"Name Kinematics(double l1, double l2) template &lt;typename T &gt; Eigen::Matrix&lt; T, 2, 1 &gt; solve_fk(const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x) Eigen::Vector2d solve_ik_analytical(Eigen::Vector2d pos) template &lt;typename T &gt; void eval_func(const Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x, Eigen::Matrix&lt; T, 1, 1 &gt; &amp; y)"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#public-attributes","title":"Public Attributes","text":"Name Eigen::Vector2d target_pos const double l1 const double l2"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#function-kinematics","title":"function Kinematics","text":"<pre><code>inline Kinematics(\ndouble l1,\ndouble l2\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#function-solve_fk","title":"function solve_fk","text":"<pre><code>template &lt;typename T &gt;\ninline Eigen::Matrix&lt; T, 2, 1 &gt; solve_fk(\nconst Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#function-solve_ik_analytical","title":"function solve_ik_analytical","text":"<pre><code>inline Eigen::Vector2d solve_ik_analytical(\nEigen::Vector2d pos\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#function-eval_func","title":"function eval_func","text":"<pre><code>template &lt;typename T &gt;\ninline void eval_func(\nconst Eigen::Matrix&lt; T, 2, 1 &gt; &amp; x,\nEigen::Matrix&lt; T, 1, 1 &gt; &amp; y\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#variable-target_pos","title":"variable target_pos","text":"<pre><code>Eigen::Vector2d target_pos;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#variable-l1","title":"variable l1","text":"<pre><code>const double l1;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1XY2degRobot_1_1Kinematics/#variable-l2","title":"variable l2","text":"<pre><code>const double l2;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/","title":"cpp_robotics::grid_path_planning_utils::GridNode","text":"<p><code>#include &lt;grid_path_planning_utils.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-functions","title":"Public Functions","text":"Name GridNode() bool operator==(const GridNode &amp; o) bool operator==(const Eigen::Vector2i &amp; o) bool operator&lt;(const GridNode &amp; o) int score()"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-attributes","title":"Public Attributes","text":"Name Eigen::Vector2i pos Eigen::Vector2i parent int cost int hcost"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-gridnode","title":"function GridNode","text":"<pre><code>inline GridNode()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst GridNode &amp; o\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst Eigen::Vector2i &amp; o\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator_2","title":"function operator&lt;","text":"<pre><code>inline bool operator&lt;(\nconst GridNode &amp; o\n)\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-score","title":"function score","text":"<pre><code>inline int score()\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-pos","title":"variable pos","text":"<pre><code>Eigen::Vector2i pos;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-parent","title":"variable parent","text":"<pre><code>Eigen::Vector2i parent;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-cost","title":"variable cost","text":"<pre><code>int cost;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-hcost","title":"variable hcost","text":"<pre><code>int hcost;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/","title":"cpp_robotics::spline::spline_c","text":"<p><code>#include &lt;spline.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#public-attributes","title":"Public Attributes","text":"Name Vector4d xb Vector4d yb"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#variable-xb","title":"variable xb","text":"<pre><code>Vector4d xb;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#variable-yb","title":"variable yb","text":"<pre><code>Vector4d yb;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/","title":"cpp_robotics::unit::Prefix","text":"<p>\u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from PrefixBase</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-types","title":"Public Types","text":"Name using Prefix&lt; N, D &gt; type"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t num constexpr uint32_t den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;uint32_t N,\nuint32_t D&gt;\nstruct cpp_robotics::unit::Prefix;\n</code></pre> <p>\u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 </p> <p>Template Parameters: </p> <ul> <li>N </li> <li>D </li> </ul>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#using-type","title":"using type","text":"<pre><code>using cpp_robotics::unit::Prefix&lt; N, D &gt;::type =  Prefix&lt;N, D&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#variable-num","title":"variable num","text":"<pre><code>static constexpr uint32_t num = N / std::gcd(N, D);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#variable-den","title":"variable den","text":"<pre><code>static constexpr uint32_t den = D / std::gcd(N, D);\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/","title":"cpp_robotics::UnitType","text":"<p>SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9  More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#public-attributes","title":"Public Attributes","text":"Name constexpr int dim1 \u30e1\u30fc\u30c8\u30eb(m) constexpr int dim2 \u30ad\u30ed\u30b0\u30e9\u30e0(kg) constexpr int dim3 \u79d2(s) constexpr int dim4 \u30a2\u30f3\u30da\u30a2(A) constexpr int dim5 \u30b1\u30eb\u30d3\u30f3(K) constexpr int dim6 \u30e2\u30eb(mol) constexpr int dim7 \u30ab\u30f3\u30c7\u30e9(cd)"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;int DIM1,\nint DIM2,\nint DIM3,\nint DIM4,\nint DIM5,\nint DIM6,\nint DIM7&gt;\nstruct cpp_robotics::UnitType;\n</code></pre> <p>SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim1","title":"variable dim1","text":"<pre><code>static constexpr int dim1 = DIM1;\n</code></pre> <p>\u30e1\u30fc\u30c8\u30eb(m) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim2","title":"variable dim2","text":"<pre><code>static constexpr int dim2 = DIM2;\n</code></pre> <p>\u30ad\u30ed\u30b0\u30e9\u30e0(kg) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim3","title":"variable dim3","text":"<pre><code>static constexpr int dim3 = DIM3;\n</code></pre> <p>\u79d2(s) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim4","title":"variable dim4","text":"<pre><code>static constexpr int dim4 = DIM4;\n</code></pre> <p>\u30a2\u30f3\u30da\u30a2(A) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim5","title":"variable dim5","text":"<pre><code>static constexpr int dim5 = DIM5;\n</code></pre> <p>\u30b1\u30eb\u30d3\u30f3(K) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim6","title":"variable dim6","text":"<pre><code>static constexpr int dim6 = DIM6;\n</code></pre> <p>\u30e2\u30eb(mol) </p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim7","title":"variable dim7","text":"<pre><code>static constexpr int dim7 = DIM7;\n</code></pre> <p>\u30ab\u30f3\u30c7\u30e9(cd) </p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/","title":"cpp_robotics::unit::prefix::pfx_div","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-types","title":"Public Types","text":"Name using Prefix&lt; raw_num, raw_den &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P1 ,\nclass P2 &gt;\nstruct cpp_robotics::unit::prefix::pfx_div;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_div&lt; P1, P2 &gt;::prefix =  Prefix&lt;raw_num, raw_den&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#variable-raw_num","title":"variable raw_num","text":"<pre><code>static constexpr uint32_t raw_num = P1::num * P2::den;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#variable-raw_den","title":"variable raw_den","text":"<pre><code>static constexpr uint32_t raw_den = P1::den * P2::num;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/","title":"cpp_robotics::unit::prefix::pfx_inv","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#public-types","title":"Public Types","text":"Name using Prefix&lt; P::den, P::num &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P &gt;\nstruct cpp_robotics::unit::prefix::pfx_inv;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_inv&lt; P &gt;::prefix =  Prefix&lt;P::den, P::num&gt;;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/","title":"cpp_robotics::unit::prefix::pfx_min","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-types","title":"Public Types","text":"Name using Prefix&lt; raw_num, raw_den &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P1 ,\nclass P2 &gt;\nstruct cpp_robotics::unit::prefix::pfx_min;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_min&lt; P1, P2 &gt;::prefix =  Prefix&lt;raw_num, raw_den&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#variable-raw_num","title":"variable raw_num","text":"<pre><code>static constexpr uint32_t raw_num = std::min(P1::num * P2::den, P2::num * P1::den);\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#variable-raw_den","title":"variable raw_den","text":"<pre><code>static constexpr uint32_t raw_den = P1::den * P2::den;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/","title":"cpp_robotics::unit::prefix::pfx_mul","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-types","title":"Public Types","text":"Name using Prefix&lt; raw_num, raw_den &gt; prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-attributes","title":"Public Attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class P1 ,\nclass P2 &gt;\nstruct cpp_robotics::unit::prefix::pfx_mul;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#using-prefix","title":"using prefix","text":"<pre><code>using cpp_robotics::unit::prefix::pfx_mul&lt; P1, P2 &gt;::prefix =  Prefix&lt;raw_num, raw_den&gt;;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#variable-raw_num","title":"variable raw_num","text":"<pre><code>static constexpr uint32_t raw_num = P2::num * P1::num;\n</code></pre>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#variable-raw_den","title":"variable raw_den","text":"<pre><code>static constexpr uint32_t raw_den = P2::den * P1::den;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag/","title":"cpp_robotics::unit::tag::is_normal_tag","text":"<p>More...</p> <p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from std::false_type</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;int Tag&gt;\nstruct cpp_robotics::unit::tag::is_normal_tag;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3-1_01_4/","title":"cpp_robotics::unit::tag::is_normal_tag&lt;-1 &gt;","text":"<p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from std::true_type</p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3_010_01_4/","title":"cpp_robotics::unit::tag::is_normal_tag&lt; 0 &gt;","text":"<p><code>#include &lt;unit_core.hpp&gt;</code></p> <p>Inherits from std::true_type</p> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/a__star_8hpp/","title":"include/cpp_robotics/path_planning/a_star.hpp","text":""},{"location":"doxybook/Files/a__star_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/a__star_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"grid_path_planning_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::vector&lt;Eigen::Vector2i&gt; a_star(const Eigen::Vector2i&amp; start, const Eigen::Vector2i&amp; end, const Eigen::MatrixXi&amp; map)\n{\nusing namespace grid_path_planning_utils;\n\nif(not contain_in_map(map, start) || not contain_in_map(map, end))\nreturn {start};\n\nconst static std::array&lt;Eigen::Vector2i,8&gt; nb = {Eigen::Vector2i{1,0}, {0,1}, {-1,0}, {0,-1},\n{1,1}, {-1,1}, {-1,-1}, {1,-1}};\n\nstd::list&lt;GridNode&gt; open;\nstd::list&lt;GridNode&gt; closed;\nGridNode sn;\nsn.pos = start;\nsn.parent = start;\nsn.cost = 0;\nsn.hcost = dist(start,end);\n\n// first step open\nopen.push_back(sn);\nwhile(not open.empty())\n{\n// \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u9078\u3076\n// Todo: \u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u308c\u3070\u8907\u6570\u958b\u304f?\n// \u30b4\u30fc\u30eb\u306b\u5230\u9054\u3059\u308b\u76f4\u524d\u306b\u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u3063\u3066\u3082\u305d\u3093\u306a\u306b\u554f\u984c\u306a\u3044\u6c17\u3082\u3059\u308b\nauto min_itr = open.begin();\nint min_score = open.front().score();\nfor(auto i = open.begin(); i != open.end(); i++)\n{\nif(min_score &gt; (*i).score())\n{\nmin_itr = i;\nmin_score = (*i).score();\n}\n}\n\n// \u30b9\u30b3\u30a2\u6700\u5c0f\u30ce\u30fc\u30c9\u3092\u57fa\u6e96\u306b\u3059\u308b\nGridNode n = *min_itr;\nopen.erase(min_itr);\n\n// \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u30af\u30ed\u30fc\u30ba\nclosed.push_back(n);\n\n// \u57fa\u6e96\u30ce\u30fc\u30c9\u304b\u30898\u65b9\u5411\u30aa\u30fc\u30d7\u30f3\nfor(size_t i = 0; i &lt; 8; i++)\n{\nEigen::Vector2i np = n.pos + nb[i];\nif(np == end)\n{\nstd::vector&lt;Eigen::Vector2i&gt; path;\npath.push_back(np);\n// closed\u304b\u3089\u9006\u9806\u306b\u30d1\u30b9\u3092\u53d6\u5f97\nEigen::Vector2i parent = closed.back().pos;\nfor(auto it = closed.rbegin(); it != closed.rend(); it++)\n{\nif((*it).pos == parent)\n{\npath.insert(path.begin(), (*it).pos);\nparent = (*it).parent;\n}\n}\nreturn path;\n}\nif(is_correct_step(np, map))\n{\nGridNode nn;\nnn.pos = np;\nnn.parent = n.pos;\nnn.cost = n.cost + 3; // \uff18\u65b9\u5411\u3069\u306e\u79fb\u52d5\u3067\u3082\u30b3\u30b9\u30c8\u306f\u540c\u7b49\u3068\u3059\u308b\nEigen::Vector2i d1 = n.pos-n.parent, d2 = nn.pos-nn.parent;\nif(d1(0) != d2(0))\nnn.cost++; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059\nif(d1(1) != d2(1))\nnn.cost++; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059\nnn.hcost = dist(np, end);\nif(not exist(open, closed, nn.pos, nn.cost + nn.hcost))\n{\nopen.push_front(nn);\n} }\n}\n}\n\nreturn {};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/","title":"include/cpp_robotics/filter/acceleration_limit_filter.hpp","text":""},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f)"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n#include \"integrator.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass AccelerationLimitFilter\n{\npublic:\nAccelerationLimitFilter(double acc_max, double Ts, double gpd, double Kx, double Kv, std::optional&lt;std::pair&lt;double, double&gt;&gt; limit = std::nullopt):\nacc_max_(acc_max), Ts_(Ts), gpd_(gpd), Kx_(Kx), Kv_(Kv), limit_(limit), diff_(Ts, gpd), vel_integ_(Ts), pos_integ_(Ts)\n{\nreset();\n}\n\n// \u76ee\u5b89\u3068\u3057\u3066\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3001\u52a0\u901f\u5ea6\u306b\u3088\u3063\u3066\u30aa\u30fc\u30d0\u30fc\u30b7\u30e5\u30fc\u30c8\u91cf\u304c\u5909\u308f\u308b\u306e\u3067\u6ce8\u610f\nAccelerationLimitFilter(double acc_max, double Ts, std::optional&lt;std::pair&lt;double, double&gt;&gt; limit = std::nullopt):\nAccelerationLimitFilter(acc_max, Ts, 0.5/Ts, 1000.0/Ts, 500.0/Ts/std::sqrt(acc_max), limit)\n{\n}\n\nvirtual void reset()\n{\ny1_ = 0;\nv1_ = 0;\ndiff_.reset();\nvel_integ_.reset();\npos_integ_.reset();\n}\n\nvirtual double filtering(double u) {\nauto[diff2, diff1, pass] = diff_.filtering(u);\n\ndouble acc = diff2 - (Kx_*(y1_-pass)) - (Kv_*(v1_-diff1));\n\nacc = std::clamp(acc, -acc_max_, acc_max_);\ndouble vel = vel_integ_.filtering(acc);\ndouble pos = pos_integ_.filtering(vel);\n\nv1_ = vel;\ny1_ = pos;\nreturn pos;\n}\n\ndouble Ts() const { return Ts_; }\n\nprivate:\nclass DiffTri\n{\npublic:\nDiffTri(double gpd, double Ts): Ts_(Ts), gpd_(gpd) { reset(); }\n\nvoid reset()\n{\nu1_ = u2_ = 0;\ndiff21_ = diff22_ = 0;\ndiff11_ = diff12_ = 0;\npass2_ = pass1_ = 0;\n}\n\nstd::tuple&lt;double, double, double&gt; filtering(double u)\n{\nconst double tau_ = 1/gpd_;\nconst double y1_coeff = (-4*tau_*tau_ + 2*Ts_*Ts_);\nconst double y2_coeff = (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_);\nconst double y_coeff = 2*tau_*tau_ + 4*tau_*Ts_ + Ts_*Ts_; // double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_;\n// double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_;\n\nconst double prev_diff2 = y1_coeff*diff21_ + y2_coeff*diff22_;\nconst double prev_diff1 = y1_coeff*diff11_ + y2_coeff*diff12_;\nconst double prev_pass  = y1_coeff*pass1_ + y2_coeff*pass2_;\n\n\ndouble diff2 = ( 4*(u -2*u1_ + u2_) - prev_diff2) / y_coeff;\ndouble diff1 = ( 2*Ts_*(u - u2_) - prev_diff1) / y_coeff;\ndouble pass = ( Ts_*Ts_*(u +2*u1_ + u2_) - prev_pass) / y_coeff;\n\nu2_ = u1_;\nu1_ = u;\n\ndiff22_ = diff21_;\ndiff21_ = diff2;\ndiff12_ = diff11_;\ndiff11_ = diff1;\npass2_ = pass1_;\npass1_ = pass;\n\nreturn {diff2, diff1, pass};\n}\n\nprivate:\ndouble Ts_, gpd_;\ndouble u1_, u2_;\ndouble diff21_, diff22_;\ndouble diff11_, diff12_;\ndouble pass1_, pass2_;\n};\n\nconst double acc_max_;\nconst double Ts_; const double gpd_; const double Kx_; const double Kv_; const std::optional&lt;std::pair&lt;double, double&gt;&gt; limit_;\n\nDiffTri diff_;\nIntegrator vel_integ_, pos_integ_;\ndouble y1_, v1_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/active__set__method_8hpp/","title":"include/cpp_robotics/optimize/active_set_method.hpp","text":""},{"location":"doxybook/Files/active__set__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/active__set__method_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct cpp_robotics::ActiveSetMethod::Problem struct cpp_robotics::ActiveSetMethod::Result"},{"location":"doxybook/Files/active__set__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"./newton_method.hpp\"\n\nnamespace cpp_robotics\n{\n\n// min 1/2 x^T Q x + cx\n// s.t. Ax &lt;= b\n// x \u7b49\u5f0f\u5236\u7d04\u306f2\u3064\u306e\u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u5909\u63db\u3059\u308b\n// o \u7b49\u5f0f\u5236\u7d04\u306f\u5e38\u306b\u30a2\u30af\u30c6\u30a3\u30d6\u3067\u3042\u308b\u3068\u3059\u308b\nclass ActiveSetMethod\n{\npublic:\nstruct Problem\n{\nProblem() = default;\n// Problem(size_t x_size_, size_t constraint_size_)\n// {\n//     x_size = x_size_;\n//     constraint_size = constraint_size_;\n//     Q = Eigen::MatrixXd::Zero(x_size, x_size);\n//     c = Eigen::VectorXd::Zero(x_size_);\n//     A = Eigen::MatrixXd::Zero(constraint_size, x_size_);\n//     b = Eigen::VectorXd::Zero(constraint_size);\n// }\n\nProblem(size_t x_size_)\n{\nx_size = x_size_;\nQ = Eigen::MatrixXd::Zero(x_size, x_size);\nc = Eigen::VectorXd::Zero(x_size_);\n}\n\n// Ax &lt;= b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b\nvoid add_inequality_constraint(const Eigen::MatrixXd &amp;An, Eigen::VectorXd bn)\n{\n// for(Eigen::MatrixXd::Index i = 0; i &lt; An.rows(); i++)\n// {\n//     if(An.row(i).norm() &lt; 1e-9)\n//         return;\n// }\n\nif(A.cols() != 0)\n{\nassert(A.cols() == An.cols());\nEigen::MatrixXd new_A(A.rows() + An.rows(), A.cols());\nnew_A &lt;&lt; A, An;\nA = new_A;\n}\nelse\n{\nA = An;\n}\n\nif(b.cols() != 0)\n{\nEigen::VectorXd new_b(b.rows() + bn.rows());\nnew_b &lt;&lt; b, bn;\nb = new_b;\n}\nelse\n{\nb = bn;\n}\n\n// std::cout &lt;&lt; \"add A\" &lt;&lt; std::endl &lt;&lt; A &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"add b\" &lt;&lt; std::endl &lt;&lt; b &lt;&lt; std::endl;\n\n\nassert(A.rows() == b.rows());\nconstraint_size = A.rows();\n}\n\n// Ax = b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b\nvoid add_equality_constraint(const Eigen::MatrixXd &amp;An, Eigen::VectorXd bn)\n{\n(void) An;\n(void) bn;\n}\n\nEigen::MatrixXd Q;\nEigen::VectorXd c;\nEigen::MatrixXd A;\nEigen::VectorXd b;\n\nsize_t max_iter = 1000;\nsize_t max_iter_get_initial_feasible_x = 1000;\n\nsize_t x_size = 0; size_t constraint_size = 0;\n\ndouble alpha = 1.1;\n};\n\nstruct Result\n{\nbool is_solved = false;\nEigen::VectorXd x_opt;\nEigen::VectorXd lambda_opt;\nsize_t iter_cnt = 0;\n};\n\nResult solve(Problem prob, Eigen::VectorXd x)\n{\nprob_ = prob;\nResult result;\n\n// \u5236\u7d04\u304c\u306a\u3044\u5834\u5408\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f\nif(prob_.constraint_size == 0)\n{\nauto grad = [&amp;](const Eigen::VectorXd &amp;x) { return (prob_.Q * x + prob_.c); };\nauto hess = [&amp;](const Eigen::VectorXd &amp;x) { (void) x; return  prob_.Q; };\nstd::tie(result.is_solved, result.x_opt, result.iter_cnt) = newton_method(grad, hess, x, 1e-6, prob_.max_iter);\nreturn result;\n}\n\n// std::cout &lt;&lt; \"--------------------\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"Q\" &lt;&lt; std::endl &lt;&lt; prob_.Q &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"c\" &lt;&lt; std::endl &lt;&lt; prob_.c &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"A\" &lt;&lt; std::endl &lt;&lt; prob_.A &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"b\" &lt;&lt; std::endl &lt;&lt; prob_.b &lt;&lt; std::endl;\n\n\n// \u521d\u671f\u5024\u306e\u30c1\u30a7\u30c3\u30af\nif(not discrimination_feasiblity(x))\n{\n// std::cout &lt;&lt; \"\u521d\u671f\u5024\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\" &lt;&lt; std::endl;\nx = get_initial_feasible_x(x);\n}\n\nauto active_idx = active_set_index(x);\n\n// debug\n// std::cout &lt;&lt; \"active_idx\" &lt;&lt; std::endl;\n// std::for_each(active_idx.begin(), active_idx.end(), [&amp;](auto idx)\n// {\n//     std::cout &lt;&lt; \"- \" &lt;&lt; idx &lt;&lt; std::endl;\n// });\n\n// \u89e3\u7121\u3057\nif (not discrimination_feasiblity(x))\n{\n// std::cout &lt;&lt; \"\u89e3\u7121\u3057 &amp; \u4fee\u6b63\u4e0d\u53ef\u80fd\" &lt;&lt; std::endl;\nreturn result;\n}\n\n// \u53cd\u5fa9\u8a08\u7b97\nresult.is_solved = false;\nfor(result.iter_cnt = 0; result.iter_cnt &lt; prob_.max_iter; result.iter_cnt++)\n{\nif(result.is_solved)\nbreak;\n\nauto [x_hat, lambda_hat] = get_solution(active_idx);\n\n// std::cout &lt;&lt; \"x_hat = \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; x_hat.transpose() &lt;&lt; std::endl &lt;&lt; std::endl;\n\n// std::cout &lt;&lt; \"lambda_hat = \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; lambda_hat.transpose() &lt;&lt; std::endl &lt;&lt; std::endl;\n\nif(not discrimination_feasiblity(x_hat))\n{\n// std::cout &lt;&lt; \"\u5b9f\u884c\u4e0d\u53ef\u80fd &amp; x_hat_dash \u4fee\u6b63\" &lt;&lt; std::endl;\n// \u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5916\u306b\u51fa\u305f\u306e\u3067\u4e2d\u306b\u623b\u3059\nx = get_x_hat_dash(x_hat, x);\nx_hat = x;\nactive_idx = active_set_index(x);\n\n// std::cout &lt;&lt; \"x_hat_dash\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; x &lt;&lt; std::endl;\n\n}\nelse\n{\n// std::cout &lt;&lt; \"\u5b9f\u884c\u53ef\u80fd\" &lt;&lt; std::endl;\n// \u6700\u9069\u6027\u306e\u5224\u5225\nif((lambda_hat.array()&gt;=0.0).count() == lambda_hat.rows())\n{\n// \u30e9\u30e0\u30c0\u304c\u5168\u3066\u8ca0\u306e\u5024\u3067\u306a\u3044 = \u5168\u3066\u306e\u5236\u7d04\u3092\u6e80\u305f\u3059 \nresult.is_solved = true;\n}\nelse\n{\n// lambda_i &lt; 0 \u304c\u5b58\u5728\u3059\u308b\u5b9f\u884c\u4e0d\u53ef\u80fd\u89e3\n// lambda_hat\u306e\u6700\u5c0f\u5024\u3092\u524a\u9664\u3057\u3066lambda\u3068\u3059\u308b\nEigen::VectorXd::Index min_idx;\nlambda_hat.minCoeff(&amp;min_idx);\nfor(auto itr = active_idx.begin(); itr != active_idx.end(); itr++)\n{\nif(*itr == static_cast&lt;size_t&gt;(min_idx))\n{\nactive_idx.erase(itr);\nbreak;\n}\n}\nstd::sort(active_idx.begin(), active_idx.end());\n}\n}\n\nresult.x_opt = x_hat;\nresult.lambda_opt = lambda_hat;\n}\n\nreturn result;\n}\n\nprivate:\nauto f(const Eigen::VectorXd &amp;x) const\n{\nreturn (0.5 * x.transpose() * prob_.Q * x + prob_.c * x);\n}\n\nauto grad_f(const Eigen::VectorXd &amp;x) const\n{\nreturn (prob_.Q * x + prob_.c);\n}\n\nauto g(const Eigen::VectorXd &amp;x) const\n{\nreturn (prob_.A*x - prob_.b);\n}\n\nauto grad_g(void) const\n{\nreturn prob_.A;\n}\n\nstd::vector&lt;size_t&gt; active_set_index(const Eigen::VectorXd &amp;x) const\n{\nauto gval = g(x);\n\nstd::vector&lt;size_t&gt; idx;\nidx.reserve(gval.rows());\nfor(Eigen::VectorXd::Index i = 0; i &lt; gval.rows(); i++)\n{\nif(std::abs(gval(i)) &lt; eps_)\nidx.push_back(i);\n}\nreturn idx;\n}\n\nstd::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt; get_solution(const std::vector&lt;size_t&gt; &amp;active_idx) const\n{\nsize_t m = prob_.A.rows();\nsize_t n = prob_.A.cols();\n\nEigen::VectorXd x_hat, lambda_hat;\n// std::cout &lt;&lt; \"active_idx.size(): \" &lt;&lt; active_idx.size() &lt;&lt; std::endl;\nif(active_idx.size() == 0)\n{\n// \u6709\u52b9\u5236\u7d04\u306a\u3057\nx_hat = prob_.Q.inverse() * -prob_.c;\nlambda_hat = Eigen::VectorXd::Zero(m);\n}\nelse\n{\n// \u6709\u52b9\u5236\u7d04\u3042\u308a\nEigen::MatrixXd Aq = Eigen::MatrixXd::Zero(active_idx.size(), prob_.A.cols());\nEigen::VectorXd bq = Eigen::VectorXd::Zero(active_idx.size());\n\nfor(size_t i = 0; i &lt; active_idx.size(); i++)\n{\nAq.row(i) = prob_.A.row(active_idx[i]);\nbq.row(i) = prob_.b.row(active_idx[i]);\n}\n\n// std::cout &lt;&lt; \"Aq= \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; Aq &lt;&lt; std::endl &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"bq= \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; bq &lt;&lt; std::endl &lt;&lt; std::endl;\n\n\nsize_t mq = Aq.rows();\n// size_t nq = Aq.cols(); // = n\n\n// tmp_a = | Aq   0   |\n//         | Q   Aq^T |\nEigen::MatrixXd tmp_a = Eigen::MatrixXd::Zero(mq+n, mq+n);\n\ntmp_a.block(0,  0, mq, n)  = Aq;\ntmp_a.block(mq, 0, n, n) = prob_.Q;\ntmp_a.block(mq, n, n,  mq) = Aq.transpose();\n\n// tmp_b = | bq |\n//         | c  |\nEigen::VectorXd tmp_b = Eigen::VectorXd(mq+n);\ntmp_b &lt;&lt; bq, -prob_.c;\n\n\n// std::cout &lt;&lt; \"tmp_a= \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; tmp_a &lt;&lt; std::endl &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"tmp_b= \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; tmp_b &lt;&lt; std::endl &lt;&lt; std::endl;\n\nEigen::VectorXd p_hat = tmp_a.fullPivLu().solve(tmp_b);\n\n// std::cout &lt;&lt; \"p_hat.size()= \" &lt;&lt; p_hat.size() &lt;&lt; std::endl;\n\n// std::cout &lt;&lt; \"p_hat= \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; p_hat &lt;&lt; std::endl &lt;&lt; std::endl;\n\nx_hat = p_hat.head(n);\nlambda_hat = Eigen::VectorXd::Zero(m);\nfor(size_t i = 0; i &lt; mq; i++)\n{\nlambda_hat(active_idx[i]) = p_hat(n + i);\n}\n\n// std::cout &lt;&lt; \"x_hat= \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; x_hat &lt;&lt; std::endl &lt;&lt; std::endl;\n\n// std::cout &lt;&lt; \"lambda_hat= \" &lt;&lt; std::endl;\n// std::cout &lt;&lt; lambda_hat &lt;&lt; std::endl &lt;&lt; std::endl;\n}\nreturn {x_hat, lambda_hat};\n}\n\n// x\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u3067\u3042\u3063\u305f\u5834\u5408\u306b\u5b9f\u884c\u53ef\u80fd\u306ax\u3092\u8fd4\u3059\n// \u6700\u9069\u6027\u306f\u554f\u308f\u306a\u3044\nEigen::VectorXd get_initial_feasible_x(Eigen::VectorXd x)\n{\nfor(size_t i = 0; i &lt; prob_.max_iter_get_initial_feasible_x; i++)\n{\nauto gval = g(x);\n\n// std::cout &lt;&lt; \"gval:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; gval.transpose() &lt;&lt; std::endl;\n\nsize_t max_g_idx = 0;\ngval.maxCoeff(&amp;max_g_idx);\n\n// std::cout &lt;&lt; \"max_g_idx: \" &lt;&lt; max_g_idx &lt;&lt; std::endl;\n\nx -= prob_.alpha * grad_g().row(max_g_idx) * std::abs( (prob_.A.row(max_g_idx) * x - prob_.b.row(max_g_idx))(0) ) / prob_.A.row(max_g_idx).squaredNorm();\n\n// std::cout &lt;&lt; \"new x:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; x.transpose() &lt;&lt; std::endl;\nif(discrimination_feasiblity(x))\nbreak;\n}\n\nreturn x;\n}\n\n// x\u304c\u5168\u3066\u306e\u6210\u7d04\u306b\u5bfe\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u304b\u30c1\u30a7\u30c3\u30af\u3059\u308b\nbool discrimination_feasiblity(const Eigen::VectorXd &amp;x) const\n{\nbool is_feasible = true;\nauto gval = g(x);\n\n// g(x) &lt;= 0 \u3092\u6e80\u305f\u3055\u306a\u3044\u3082\u306e\u304c\u4e00\u3064\u3067\u3082\u3042\u308c\u3070\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u3044\u308b\nif((gval.array() &gt; eps_).count() &gt; 0)\nis_feasible = false;\nreturn is_feasible;\n}\n\n// x_hat\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd, x\u304c\u5b9f\u884c\u53ef\u80fd\u3060\u3068\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u306ax_hat_dash\u3092\u751f\u6210\u3059\u308b\nEigen::VectorXd get_x_hat_dash(Eigen::VectorXd x_hat, Eigen::VectorXd x)\n{\ndouble t = get_t(x_hat, x);\n\n// std::cout &lt;&lt; \"t = \" &lt;&lt; t &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"x:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; x.transpose() &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"x_hat:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; x_hat.transpose() &lt;&lt; std::endl;\n\nreturn x + t * (x_hat - x);\n}\n\ndouble get_t(Eigen::VectorXd x_hat, Eigen::VectorXd x)\n{\nEigen::VectorXd gg = prob_.A * (x_hat - x);\n\nfor(Eigen::VectorXd::Index i = 0; i &lt; gg.size(); i++)\n{\nif(std::abs(gg(i)) &lt; eps_)\ngg(i) = eps_;\n}\n\n// std::cout &lt;&lt; \"gg:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; gg.transpose() &lt;&lt; std::endl;\n\nauto T = -g(x).array() / gg.array();\nauto T_selected = (T.array() &gt; 0.0); // T_selected\u306f0/1\u306e\u30d0\u30a4\u30ca\u30ea\u578b\n\nEigen::VectorXd T_nn(T_selected.count());\nsize_t row = 0;\nfor(Eigen::VectorXd::Index i = 0; i &lt; T.size(); i++)\n{\nif(T_selected[i])\nT_nn(row++) = T(i);\n}\n\n// std::cout &lt;&lt; \"-g(x):\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; (-g(x)).transpose() &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"gg:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; gg.transpose() &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"T:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; T.transpose() &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"T_nn:\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; T_nn.transpose() &lt;&lt; std::endl;\n\nif(T_selected.count() != 0)\n{\n// T_i &gt; 0 \u3092\u6e80\u305f\u3059\u3088\u3046\u305d\u306e\u3046\u3061\u6700\u5c0f\u306eT_i\u3092\u8fd4\u3059\nreturn T_nn.minCoeff();\n}\n\nreturn 0.0;\n}\n\nProblem prob_;\nstatic constexpr double eps_ = 1e-9;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/algorithm_8hpp/","title":"include/cpp_robotics/algorithm.hpp","text":""},{"location":"doxybook/Files/algorithm_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"algorithm/kdtree.hpp\"\n#include \"algorithm/icp.hpp\"\n#include \"algorithm/ndt.hpp\"\n#include \"algorithm/poly_regression.hpp\"\n#include \"algorithm/state_machine.hpp\"\n#include \"algorithm/k_means_method.hpp\"\n#include \"algorithm/mahalanobis.hpp\"\n#include \"algorithm/random.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/angle__range_8hpp/","title":"include/cpp_robotics/utility/angle_range.hpp","text":""},{"location":"doxybook/Files/angle__range_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/angle__range_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b"},{"location":"doxybook/Files/angle__range_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cstdio&gt;\n#include &lt;cmath&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\nclass AngleRange\n{\npublic:\nusing range_pair_t = std::pair&lt;double, double&gt;;\nconstexpr static double PI = M_PI;\nAngleRange() = default;\n\nvoid add_range(const AngleRange &amp;range)\n{\nfor(auto r : range.ranges_)\n{\nadd_range(r.first, r.second);\n}\n}\nvoid add_range(double start, double end)\n{\nif(start == end)\nreturn;\n\n// \u4e00\u822c\u89d2\u306b\u5206\u5272\u3057\u3066\u633f\u5165\u3059\u308b\nif(start &gt; end)\nstd::swap(start, end);\n\ndouble diff = end - start;\nstart = normalize_angle_positive(start);\nend = start + diff;\n\nif(diff &gt; 2*PI)\n{\n// \u4e00\u5468\u56de\u3063\u3066\u308b\nranges_.push_back({0, 2*PI});\n}\nelse\n{\nif(end &gt; 2*PI)\n{\nranges_.push_back({start, 2*PI});\nranges_.push_back({0, end - 2*PI});\n}\nelse\n{\nranges_.push_back({start, end});\n}\n}\n\n// ranges_\u306e\u7d50\u5408\u30fb\u5206\u5272\njoin_start:\nfor(size_t look = 0; look &lt; ranges_.size(); look++)\n{\nfor(size_t dest = 0; dest &lt; ranges_.size(); dest++)\n{\nif(look != dest)\n{\n// \u7bc4\u56f2\u304c\u304b\u3076\u3063\u3066\u305f\u3089\u7d50\u5408\u3059\u308b\nif(in_range_part(ranges_[look], ranges_[dest].first))\n{\nif(ranges_[look].second &lt; ranges_[dest].second)\nranges_[look].second = ranges_[dest].second;\nranges_.erase(ranges_.begin()+dest);\ngoto join_start;\n}\nif(in_range_part(ranges_[look], ranges_[dest].second))\n{\nif(ranges_[look].first &gt; ranges_[dest].first)\nranges_[look].first = ranges_[dest].first;\nranges_.erase(ranges_.begin()+dest);\ngoto join_start;\n}\n}\n}\n}\n\nstd::sort(ranges_.begin(), ranges_.end(), [](auto a, auto b){ return a.first &lt; b.first; });\n}\n\nsize_t size() const { return ranges_.size(); }\n\nAngleRange invert() const\n{\nAngleRange ret;\n\nif(size() == 0)\n{\nret.add_range(0.0, 2*PI);\nreturn ret;\n}\n\nfor(size_t i = 0; i &lt; size()-1; i++)\n{\nret.add_range(ranges_[i].second, ranges_[i+1].first);\n}\nret.add_range(ranges_.back().second, ranges_.front().first + 2*PI);\n\nreturn ret;\n}\n\n// \u5f15\u6570\u306e\u89d2\u5ea6\u306b\u5bfe\u3057\u7bc4\u56f2\u306e\u4e2d\u3067\u4e00\u756a\u8fd1\u3044\u89d2\u5ea6\u3092\u8a08\u7b97\u3059\u308b\ndouble most_near_by(double angle)\n{\nangle = normalize_angle_positive(angle);\nif(in_range(angle))\nreturn angle;\n\nauto inv_ranges = this-&gt;invert().ranges_;\n// 2pi\u3092\u307e\u305f\u3050\u5834\u5408\u306f\u9023\u7d50\u3055\u305b\u308b\nif(inv_ranges.front().first == 0.0 &amp;&amp; inv_ranges.back().second == 2*PI)\n{\nrange_pair_t new_back = {\ninv_ranges.back().first,\n2*PI + inv_ranges.front().second\n};\ninv_ranges.erase(inv_ranges.begin());\ninv_ranges.back() = new_back;\nif(angle &lt; inv_ranges.front().first)\nangle += 2*PI;\n}\n\nfor(auto &amp; ir : inv_ranges)\n{\nif(in_range_part(ir, angle))\n{\nif(std::abs(shortest_angular_distance(angle, ir.first)) &lt; std::abs(shortest_angular_distance(angle, ir.second)))\n{\nreturn normalize_angle_positive(ir.first);\n}\nelse\n{\nreturn normalize_angle_positive(ir.second);\n}\n}\n}\n\n// error\nreturn normalize_angle_positive(angle);\n}\n\ninline bool in_range_part(range_pair_t &amp;range, double angle)\n{\nif(range.first &lt;= angle &amp;&amp; angle &lt;= range.second)\nreturn true;\nreturn false;\n}\n\nbool in_range(double angle)\n{\nangle = normalize_angle_positive(angle);\nfor(auto range : ranges_)\n{\nif(in_range_part(range, angle))\nreturn true;\n}\nreturn false;\n}\n\nstd::vector&lt;range_pair_t&gt; ranges() const { return ranges_; }\n\nprivate:\ndouble normalize_angle_positive(double angle)\n{\nreturn std::fmod(std::fmod(angle, 2*PI) + 2*PI, 2*PI);\n}\n\ndouble normalize_angle(double angle)\n{\ndouble a = normalize_angle_positive(angle);\nif (a &gt; PI)\na -= 2*PI;\nreturn a;\n}\n\ndouble shortest_angular_distance(double from, double to)\n{\nreturn normalize_angle(to-from);\n}\n\nvoid debug()\n{\nprintf(\"debug\\n\");\nfor(auto range : ranges_)\n{\nprintf(\"(%8.2f, %8.2f)\\n\", range.first, range.second);\n}\nprintf(\"\\n\");\n}\nprivate:\nstd::vector&lt;range_pair_t&gt; ranges_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/arm__ik_8hpp/","title":"include/cpp_robotics/arm_ik.hpp","text":""},{"location":"doxybook/Files/arm__ik_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/auto__diff_8hpp/","title":"include/cpp_robotics/algorithm/auto_diff.hpp","text":""},{"location":"doxybook/Files/auto__diff_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/auto__diff_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::AutoDiffAdaptor \u81ea\u52d5\u5fae\u5206\u3067\u30e4\u30b3\u30d3\u30a2\u30f3\u3092\u6c42\u3081\u308b\u30af\u30e9\u30b9"},{"location":"doxybook/Files/auto__diff_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;unsupported/Eigen/AutoDiff&gt;\n#include &lt;functional&gt;\n#include &lt;optional&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class DerType&gt;\nusing AutoDiffScalar = Eigen::AutoDiffScalar&lt;DerType&gt;;\n\ntemplate&lt;class DerType, int NX=Eigen::Dynamic&gt;\nusing AutoDiffVector = Eigen::Matrix&lt;AutoDiffScalar&lt;DerType&gt;, NX, 1&gt;;\n\ntemplate&lt;class DerType&gt;\nstatic auto make_auto_diff_vector(const size_t &amp;dim, const std::optional&lt;DerType&gt; &amp;x = std::nullopt)\n{\nAutoDiffVector&lt;DerType&gt; ax(dim);\nfor(size_t i = 0; i &lt; dim; i++)\n{\nif(x.has_value())\nax(i).value() = x.value()(i);\nelse\nax(i).value() = 0;\nax(i).derivatives() = Eigen::VectorXd::Unit(dim, i);\n}\nreturn ax;\n}\n\ntemplate&lt;class Functor, class DerType = Eigen::VectorXd, typename Scalar = double, int NX=Eigen::Dynamic, int NY=Eigen::Dynamic&gt;\nclass AutoDiffAdaptor\n{\npublic:\nusing InputVector = Eigen::Matrix&lt;Scalar, NX, 1&gt;;\nusing ValueVector = Eigen::Matrix&lt;Scalar, NY, 1&gt;;\nusing JacobianMatrix = Eigen::Matrix&lt;Scalar, NY, NX&gt;;\nusing HessianMatrix = Eigen::Matrix&lt;Scalar, NX, NX&gt;;\nenum {\nInputsAtCompileTime = NX,\nValuesAtCompileTime = NY\n};\n\nAutoDiffAdaptor(Functor &amp;functor): functor_(functor), input_size_(NX), value_size_(NY) {}\n\nAutoDiffAdaptor(Functor &amp;functor, const size_t input_size, const size_t value_size):\nfunctor_(functor), input_size_(input_size), value_size_(value_size) {}\n\nvoid evalute(const InputVector &amp;x, ValueVector &amp;y)\n{\nreturn functor_.eval_func(x, y);\n}\n\nValueVector evalute(const InputVector &amp;x)\n{\nValueVector y;\nif constexpr(ValueVector::SizeAtCompileTime == Eigen::Dynamic)\ny.resize(value_size_);\nevalute(x, y);\nreturn y;\n}\n\nstd::function&lt;ValueVector(InputVector)&gt; evalute_func()\n{\nreturn [this](InputVector x) { return evalute(x); };\n}\n\nstd::function&lt;double(InputVector)&gt; evalute_func_scalar()\n{\nassert(value_size_ == 1);\nreturn [this](InputVector x) { return evalute(x)(0); };\n}\n\nvoid jacobian(const InputVector &amp;x, JacobianMatrix &amp;jac)\n{\nusing ADScalar = AutoDiffScalar&lt;DerType&gt;;\nusing ADInput = AutoDiffVector&lt;DerType, NX&gt;;\nusing ADValue = AutoDiffVector&lt;DerType, NY&gt;;\n\nADInput ax = x.template cast&lt;ADScalar&gt;();\nADValue ay(jac.rows());\n\nif constexpr(InputsAtCompileTime==Eigen::Dynamic)\nfor (Eigen::Index j=0; j&lt;jac.rows(); j++)\nay[j].derivatives().resize(x.rows());\n\nfor (Eigen::Index i=0; i&lt;jac.cols(); i++)\nax[i].derivatives() = DerType::Unit(x.rows(),i);\n\nfunctor_.eval_func(ax, ay);\n\nfor (Eigen::Index i=0; i&lt;jac.rows(); i++)\n{\njac.row(i) = ay[i].derivatives();\n}\n}\n\nJacobianMatrix jacobian(const InputVector &amp;x)\n{\nJacobianMatrix jac;\nif constexpr(JacobianMatrix::SizeAtCompileTime == Eigen::Dynamic)\njac.resize(value_size_, input_size_);\n\njacobian(x, jac);\nreturn jac;\n}\n\nstd::function&lt;JacobianMatrix(InputVector)&gt; jacobian_func()\n{\nreturn [this](InputVector x) { return jacobian(x); };\n}\n\nstd::function&lt;Eigen::Matrix&lt;Scalar, NX, 1&gt;(InputVector)&gt; jacobian_func_row_vector()\n{\nassert(value_size_ == 1);\nreturn [this](InputVector x) { return jacobian(x).transpose().col(0).eval(); };\n}\n\n// void hessian(const EigenVectorType &amp;x, HessianMatrix &amp;hess)\n// {\n//     assert(value_size_ == 1);\n// }\n\n// HessianMatrix hessian(const InputVector &amp;x)\n// {\n//     HessianMatrix hess;\n//     if constexpr(HessianMatrix::SizeAtCompileTime == Eigen::Dynamic)\n//         hess.resize(input_size_, input_size_);\n//     hessian(x, hess);\n//     return hess;\n// }\n\nprivate:\nFunctor &amp;functor_;\nconst size_t input_size_;\nconst size_t value_size_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/band__pass__filter_8hpp/","title":"include/cpp_robotics/filter/band_pass_filter.hpp","text":""},{"location":"doxybook/Files/band__pass__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/band__pass__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/band__pass__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n//               2*zeta*omega*s\n// G(s) = ------------------------------ \u3092\u53cc\u4e00\u6b21\u5909\u63db\n//         s^2 + 2*zeta*omega*s + omega^2\nclass BandPassFilter : public TransferFunction\n{\npublic:\nBandPassFilter(double omega, double zeta, double dt):\nomega_(omega), zeta_(zeta)\n{\nTransferFunction::set_continuous({(2*zeta_*omega_),0}, {1,(2*zeta_*omega_),(omega*omega)}, dt);\n}\n\ndouble filtering(double u) { return responce(u); } double omega() const { return omega_; }\n\ndouble zeta() const { return zeta_; }\nprivate:\nconst double omega_;\nconst double zeta_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/barrier__method_8hpp/","title":"include/cpp_robotics/optimize/barrier_method.hpp","text":""},{"location":"doxybook/Files/barrier__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/barrier__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"constraint.hpp\"\n#include \"derivative.hpp\"\n#include \"quasi_newton_method.hpp\"\n\nnamespace cpp_robotics\n{\n\n// \u5236\u7d04\u306e\u5883\u754c\u3067\u76ee\u7684\u95a2\u6570\u304c\u767a\u6563\u3059\u308b\u305f\u3081\u7b49\u5f0f\u5236\u7d04\u306f\u4f7f\u7528\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044\n// \u307e\u305f\u4e0d\u7b49\u5f0f\u5236\u7d04\u3067\u3082g(x)=0\u306e\u5883\u754c\u3092\u307e\u305f\u3050\u3053\u3068\u306f\u51fa\u6765\u306a\u3044\u306e\u3067x_init\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5185\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; barrier_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init = 10.0, const double tol = 1e-3, const size_t max_iter = 1000)\n{\nEigen::VectorXd x = x_init;\ndouble r = r_init;\nstd::function&lt;double(const Eigen::VectorXd &amp;)&gt; ext_f = [&amp;](const Eigen::VectorXd &amp; x)\n{\ndouble y = f(x);\n\nfor(auto &amp; con : constraint)\n{\nswitch(con.type)\n{\ncase Constraint::Type::Eq:\n// \u7121\u8996\nbreak;\ncase Constraint::Type::Ineq:\ny += r * std::log(std::abs(con.con_f(x))); // / std::pow(, 2);\nbreak;\n}\n}\n\nreturn y;\n};\n\nauto grad = [&amp;](Eigen::VectorXd x)\n{\nreturn derivative(ext_f, x);\n};\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\nauto [step_result, new_x, sub_itr_cnt] = quasi_newton_method(ext_f, grad, x, tol, 1);\nif(std::abs(r * constraint.eval_sum(new_x)) &lt; tol)\nreturn {true, new_x, i};\n\nx = new_x;\nr *= 1.5;\n}\nreturn {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/bfgs_8hpp/","title":"include/cpp_robotics/optimize/bfgs.hpp","text":""},{"location":"doxybook/Files/bfgs_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/bfgs_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic void bfgs_step(Eigen::MatrixXd &amp;hess, Eigen::VectorXd s, Eigen::VectorXd y)\n{\ndouble sy, sBs;\nEigen::VectorXd Bs;\n\nBs.noalias() = hess * s;\nsBs = s.dot(Bs);\nsy = s.dot(y);\n\nhess += -( Bs * Bs.transpose() )/sBs + ( y*y.transpose() )/( sy );\n}\n\nstatic void powells_modified_bfgs_step(Eigen::MatrixXd &amp;hess, Eigen::VectorXd s, Eigen::VectorXd y, Eigen::VectorXd dgg, double gamma = 0.2)\n{\n// y_tilde\nif(s.transpose()*y &lt; gamma * s.transpose()*hess*s)\n{\ndouble sy, sBs;\nEigen::VectorXd Bs;\n\nBs.noalias() = hess * s;\nsBs = s.dot(Bs);\nsy = s.dot(y);\n\ndouble beta = (1-gamma)*sBs / ( sBs - sy );\ny = beta*y + (1-beta)*hess*s;\n}\n\n// 0 &lt; sy\u306b\u306a\u308b\u307e\u3067y\u3092\u4fee\u6b63\nconst double lnrm = 1e-12;\ndouble w = 1e-6;\nint i = 0;\nif(s.dot(y) &lt; lnrm)\n{\nEigen::VectorXd v(y.size());\nwhile(s.dot(y) &lt; lnrm)\n{\nfor(int i = 0; i &lt; y.size(); i++)\n{\nif(y(i)*w &lt; lnrm &amp;&amp; y(i)*s(i) &lt; lnrm)\nv(i) = dgg(i);\nelse\nv(i) = 0;\n}\ny += w*v;\nw*= 1.1;\n\nif(1000 &lt; ++i)\n{\nbreak;\n}\n}\n}\n\nbfgs_step(hess, s, y);\n}\n\nstatic void powells_modified_bfgs_step(Eigen::MatrixXd &amp;hess, Eigen::VectorXd s, Eigen::VectorXd y, double gamma = 0.2)\n{\npowells_modified_bfgs_step(hess, s, y, Eigen::VectorXd::Zero(y.size()), gamma);\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/bode_8hpp/","title":"include/cpp_robotics/system/bode.hpp","text":""},{"location":"doxybook/Files/bode_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/bode_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include \"./transfer_function.hpp\"\n#ifdef CR_USE_MATPLOTLIB\n#include \"../third_party/matplotlib-cpp/matplotlibcpp.h\"\n#endif\n#include \"../utility/space.hpp\"\n#include \"../vector/vector2.hpp\"\n#include \"../utility/math_utils.hpp\"\n#include \"./polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; bode(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500), bool gain_db_mode = true, bool phase_deg_mode = true)\n{\nsize_t n = omegas.size();\nstd::vector&lt;double&gt; gain_db(n), phase_deg(n);\n\nVector2d num_vec, den_vec;\nauto num_array = tf.num_array();\nauto den_array = tf.den_array();\n\nPolynomial num_poly(num_array.begin(), num_array.end());\nPolynomial den_poly(den_array.begin(), den_array.end());\n\nfor(size_t i = 0; i &lt; n; i++)\n{\n// gain\n{\nnum_vec = Vector2d::zero();\nden_vec = Vector2d::zero();\n\nfor(size_t n = 0; n &lt; num_poly.size(); n++)\n{\nsize_t deg = num_poly.degree() - n;\n\nint dir;\nbool is_real;\nswitch(deg%4)\n{\ncase 0:\ndir = 1;\nis_real = true;\nbreak;\ncase 1:\ndir = 1;\nis_real = false;\nbreak;\ncase 2:\ndir = -1;\nis_real = true;\nbreak;\ncase 3:\ndir = -1;\nis_real = false;\nbreak;\n}\n\nif(is_real)\nnum_vec.x += dir * num_poly[n] * std::pow(omegas[i], deg);\nelse\nnum_vec.y += dir * num_poly[n] * std::pow(omegas[i], deg);\n}\n\nfor(size_t n = 0; n &lt; den_poly.size(); n++)\n{\nsize_t deg = den_poly.degree() - n;\n\nint dir;\nbool is_real;\nswitch(deg%4)\n{\ncase 0:\ndir = 1;\nis_real = true;\nbreak;\ncase 1:\ndir = 1;\nis_real = false;\nbreak;\ncase 2:\ndir = -1;\nis_real = true;\nbreak;\ncase 3:\ndir = -1;\nis_real = false;\nbreak;\n}\n\nif(is_real)\nden_vec.x += dir * den_poly[n] * std::pow(omegas[i], deg);\nelse\nden_vec.y += dir * den_poly[n] * std::pow(omegas[i], deg);\n}\n\ndouble gain = num_vec.norm() / den_vec.norm(); if(gain_db_mode)\ngain_db[i] = 20 * std::log10(gain);\nelse\ngain_db[i] = gain;\n}\n\n// phase\n{\nnum_vec = Vector2d::zero();\nden_vec = Vector2d::zero();\nfor(size_t didx = 0; didx &lt; tf.num_array().size(); didx++)\n{\nsize_t deg = tf.num_deg(didx);\nif(deg == 0)\n{\nnum_vec.x += tf.num_array()[didx];\n}\nelse\n{\ndouble s = std::pow(omegas[i], deg);\nnum_vec.y += s * tf.num_array()[didx];\n}\n}\n\nfor(size_t didx = 0; didx &lt; tf.den_array().size(); didx++)\n{\nsize_t deg = tf.den_deg(didx);\nif(deg == 0)\n{\nden_vec.x += tf.den_array()[didx];\n}\nelse\n{\ndouble s = std::pow(omegas[i], deg);\nden_vec.y += s * tf.den_array()[didx];\n}\n}\n\ndouble phase = std::atan(num_vec.y/num_vec.x) - std::atan(den_vec.y/den_vec.x);\nif(phase_deg_mode)\nphase_deg[i] = degrees(phase);\nelse\nphase_deg[i] = phase;\n}\n\n}\n\nreturn {gain_db, phase_deg};\n}\n\n#ifdef CR_USE_MATPLOTLIB\nstatic void bode_plot(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500))\n{\nnamespace plt = matplotlibcpp;\nauto [g, ph] = bode(tf, omegas);\n\nplt::subplot(2, 1, 1);\nplt::ylabel(\"Magnitude(dB)\");\nplt::semilogx(omegas, g);\nplt::xlim(std::pow(10,-2), std::pow(10,2));\nplt::ylim(-60, 30);\nplt::grid(true, \"both\");\n\nplt::subplot(2, 1, 2);\nplt::xlabel(\"Frequency(rad/s)\");\nplt::ylabel(\"Phase(deg)\");\nplt::semilogx(omegas, ph);\nplt::xlim(std::pow(10,-2), std::pow(10,2));\nplt::ylim(-90, 90);\nplt::yticks(std::vector&lt;double&gt;{-90, -45, 0, 45, 90});\nplt::grid(true, \"both\");\n\nplt::show();\n}\n#endif\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/bracketing__serach_8hpp/","title":"include/cpp_robotics/optimize/bracketing_serach.hpp","text":""},{"location":"doxybook/Files/bracketing__serach_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/bracketing__serach_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic double bracketing_serach(std::function&lt;double(Eigen::VectorXd)&gt; func, std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt; grad, const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;d, double gamma = 0.3, double tau = 0.9, const size_t max_iter = 1000)\n{\nauto line_func = [&amp;](double v){ return func(x + v*d); };\n\ndouble a = 1;\ndouble b = grad(x).dot(d);\ndouble lf0 = line_func(0);\nfor(size_t i = 0; i &lt; max_iter; i++){\nif(line_func(a) &lt;= lf0 + gamma * a * b){\nreturn a;\n}\na = tau * a;\n}\nreturn a;\n}\n\nstatic double bracketing_serach(std::function&lt;double(double)&gt; func, const double init = 1.0, const double beta = 0.9, const size_t max_iter = 1000)\n{\ndouble a = init;\ndouble fval = func(a);\ndouble new_fval;\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\nnew_fval = func(a*beta);\n\nif(new_fval &gt; fval)\nreturn a;\na *= beta;\nfval = new_fval;\n}\n\nreturn a;\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/butterworth__filter_8hpp/","title":"include/cpp_robotics/filter/butterworth_filter.hpp","text":""},{"location":"doxybook/Files/butterworth__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/butterworth__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::ButterworthFilter \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/butterworth__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n#include \"cpp_robotics/system/polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass ButterworthFilter : public TransferFunction\n{\npublic:\nButterworthFilter(double omega, size_t n, double dt):\nomega_(omega), n_(n)\n{\nPolynomial den_poly({1});\nif(n % 2)\n{\nden_poly *= Polynomial{1/omega_, 1};\n// n\u304c\u5947\u6570\nfor(size_t k = 1; k &lt;= (n-1)/2; k++)\n{\nint num = 2*k + n - 1;\nint den = 2*n;\nconst double k1 = -2.0*std::cos((double)(num) / (double)(den) * M_PI);\nden_poly *= Polynomial{1/omega_/omega_, k1/omega, 1};\n}\n}\nelse\n{\n// n\u304c\u5076\u6570\nfor(size_t k = 1; k &lt;= n/2; k++)\n{\nint num = 2*k + n - 1;\nint den = 2*n;\nconst double k1 = -2.0*std::cos((double)(num) / (double)(den) * M_PI);\nden_poly *= Polynomial{1/omega_/omega_, k1/omega, 1};\n}\n}\n\nstd::cout &lt;&lt; den_poly &lt;&lt; std::endl;\nTransferFunction::set_continuous({1}, den_poly.coeff(), dt);\n}\n\ndouble filtering(double u) { return responce(u); } double omega() const { return omega_; }\n\nsize_t n() const { return n_; }\n\nprivate:\nconst double omega_;\nconst size_t n_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/chassis_8hpp/","title":"include/cpp_robotics/chassis.hpp","text":""},{"location":"doxybook/Files/chassis_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"chassis/mecanum_ik.hpp\"\n#include \"chassis/omni_ik.hpp\"\n#include \"chassis/swerve_ik.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/constraint_8hpp/","title":"include/cpp_robotics/optimize/constraint.hpp","text":""},{"location":"doxybook/Files/constraint_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/constraint_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408"},{"location":"doxybook/Files/constraint_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n#include &lt;optional&gt;\n#include &lt;numeric&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"derivative.hpp\"\n\nnamespace cpp_robotics\n{\n\nstruct Constraint\n{\nusing func_type = std::function&lt;double(Eigen::VectorXd)&gt;;\nusing grad_func_type = std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\nusing hessian_func_type = std::function&lt;Eigen::MatrixXd(Eigen::VectorXd)&gt;;\n\nenum Type : uint8_t\n{\n// g(x) = 0\nEq,\n\n// g(x) &lt;= 0\nIneq\n};\n\nType type;\nfunc_type con_f;\nstd::optional&lt;grad_func_type&gt; con_grad_f;\nstd::optional&lt;hessian_func_type&gt; con_hessian_f;\n\nConstraint(Type type_, func_type con_):\ntype(type_), con_f(con_) {}\n\ndouble eval(const Eigen::VectorXd &amp;x) const\n{\nreturn con_f(x);\n}\n\nbool satisfy(const Eigen::VectorXd &amp;x, const double tol) const\n{\nconst double val = eval(x);\nif(type == Type::Eq)\n{\nreturn std::abs(val) &lt; tol;\n}\nelse\n{\nreturn val &lt; tol;\n}\n}\n\nEigen::VectorXd grad(Eigen::VectorXd x)\n{\nif(con_grad_f)\nreturn con_grad_f.value()(x);\n\nreturn derivative(con_f, x);\n}\n\nEigen::MatrixXd hessian(Eigen::VectorXd x)\n{\nif(con_hessian_f)\nreturn con_hessian_f.value()(x);\n\nreturn approx_hessian(con_f, x);\n}\n};\n\nclass ConstraintArray : public std::vector&lt;Constraint&gt;\n{\npublic:\n// std::vector&lt;Constraint&gt;::size_type size() const\n// {\n//     return this-&gt;size();\n// }\n\nConstraintArray() = default;\nConstraintArray(std::initializer_list&lt;Constraint&gt; con):\nvector(con.begin(), con.end()) {}\n\nstd::vector&lt;double&gt; eval(const Eigen::VectorXd &amp;x) const\n{\nstd::vector&lt;double&gt; val(this-&gt;size());\nfor(size_t i = 0; i &lt; this-&gt;size(); i++)\n{\n\nval[i] = this-&gt;at(i).eval(x);\n}\nreturn val;\n}\n\ndouble eval_sum(const Eigen::VectorXd &amp;x) const\n{\nauto val = eval(x);\nreturn std::accumulate(val.begin(), val.end(), 0.0);\n}\n\nbool all_satisfy(const Eigen::VectorXd &amp;x, const double tol) const\n{\nbool satisfy = true;\n\nfor(auto &amp; con : *this)\n{\nif(not con.satisfy(x, tol))\n{\n// std::cout &lt;&lt; \"not satisfy\" &lt;&lt; std::endl;\nsatisfy = false;\n}\n// else\n// {\n// std::cout &lt;&lt; \"satisfy\" &lt;&lt; std::endl;\n// \n// }\n}\nreturn satisfy;\n}\n\nstd::vector&lt;Constraint&gt;::size_type eq_constraint_size() const\n{\nstd::vector&lt;Constraint&gt;::size_type num = 0;\nfor(auto &amp; con : *this)\n{\nif(con.type == Constraint::Type::Eq)\nnum++;\n}\nreturn num;\n}\n\nstd::vector&lt;Constraint&gt;::size_type ineq_constraint_size() const\n{\nstd::vector&lt;Constraint&gt;::size_type num = 0;\nfor(auto &amp; con : *this)\n{\nif(con.type == Constraint::Type::Ineq)\nnum++;\n}\nreturn num;\n}\n\nstd::vector&lt;Constraint&gt; gen_eq_constraint_list() const\n{\nstd::vector&lt;Constraint&gt; ret;\nfor(auto &amp; con : *this)\n{\nif(con.type == Constraint::Type::Eq)\nret.push_back(con);\n}\nreturn ret;\n}\n\nstd::vector&lt;Constraint&gt; gen_ineq_constraint_list() const\n{\nstd::vector&lt;Constraint&gt; ret;\nfor(auto &amp; con : *this)\n{\nif(con.type == Constraint::Type::Ineq)\nret.push_back(con);\n}\nreturn ret;\n}\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/controller_8hpp/","title":"include/cpp_robotics/controller.hpp","text":""},{"location":"doxybook/Files/controller_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"controller/pid.hpp\"\n#include \"controller/pid2.hpp\"\n#include \"controller/lqr.hpp\"\n#include \"controller/pure_pursuit.hpp\"\n#include \"controller/nctf.hpp\"\n#include \"controller/modern_control.hpp\"\n#include \"controller/pfc.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/core_8hpp/","title":"include/cpp_robotics/core.hpp","text":""},{"location":"doxybook/Files/core_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// utility core\n#include \"utility.hpp\"\n#include \"vector.hpp\"\n#include \"unit.hpp\"\n\n// control core\n#include \"controller.hpp\"\n#include \"filter.hpp\"\n#include \"system.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/cpp__robotics_8hpp/","title":"include/cpp_robotics/cpp_robotics.hpp","text":""},{"location":"doxybook/Files/cpp__robotics_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"core.hpp\"\n\n#include \"path_planning.hpp\"\n#include \"filter.hpp\"\n#include \"chassis.hpp\"\n#include \"algorithm.hpp\"\n#include \"motor.hpp\"\n#include \"optimize.hpp\"\n\n#ifdef CR_USE_MATPLOTLIB\n#include \"third_party/matplotlib-cpp/matplotlibcpp.h\"\n#endif\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/cpp__support_8hpp/","title":"include/cpp_robotics/utility/cpp_support.hpp","text":""},{"location":"doxybook/Files/cpp__support_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/cpp__support_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\n// platform\n#if defined(linux) || defined(__linux) || defined(__linux__)\n#  define CPP_ROBOTICS_PLATFORM_LINUX\n\n#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)\n#  define CPP_ROBOTICS_PLATFORM_WINDOWS\n#endif\n\n// C++ version\n#ifdef __cplusplus\n\n#  if (__cplusplus &gt;= 201103L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201103L)\n#    define CPP_ROBOTICS_CPP11_OR_GREATER\n#  endif\n\n#  if (__cplusplus &gt;= 201402L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201402L)\n#    define CPP_ROBOTICS_CPP14_OR_GREATER\n#  endif\n\n#  if (__cplusplus &gt;= 201703L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)\n#    define CPP_ROBOTICS_CPP17_OR_GREATER\n#  endif\n\n#  if (__cplusplus &gt;= 202002L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 202002L)\n#    define CPP_ROBOTICS_CPP20_OR_GREATER\n#  endif\n\n#endif\n\n#include &lt;string_view&gt;\n\n#ifdef CPP_ROBOTICS_CPP20_OR_GREATER\n#include &lt;format&gt;\n#endif\n\nnamespace cpp_robotics\n{\n\ntemplate &lt;class ForwardIterator&gt;\nconstexpr ForwardIterator shift_left(ForwardIterator first,\nForwardIterator last,\ntypename std::iterator_traits&lt;ForwardIterator&gt;::difference_type n)\n{\nif (n &lt;= 0)\nreturn last;\nif (n &gt;= last - first)\nreturn first;\n\nForwardIterator it = first;\nForwardIterator nlast = std::prev(last, n);\nwhile (it != nlast)\n{\nForwardIterator nit = std::next(it, n);\n*it = *nit;\nit++;\n}\nreturn first + (last - first - n);\n}\n\ntemplate &lt;class ForwardIterator&gt;\nconstexpr ForwardIterator shift_right(ForwardIterator first,\nForwardIterator last,\ntypename std::iterator_traits&lt;ForwardIterator&gt;::difference_type n)\n{\nif (n &lt;= 0)\nreturn first;\nif (n &gt;= last - first)\nreturn last;\n\nForwardIterator it = std::prev(last, n);\nForwardIterator nfirst = std::prev(first, 1);\nwhile (it != nfirst)\n{\nForwardIterator nit = std::next(it, n);\n*nit = *it;\nit--;\n}\n\nreturn first + n;\n}\n\ntemplate &lt;typename... Args&gt;\nstd::string c_format(const std::string &amp;format, Args const&amp;... args)\n{\n#pragma GCC diagnostic ignored \"-Wformat-security\"\nsize_t len = std::snprintf(nullptr, 0, format.c_str(), args...);\nstd::vector&lt;char&gt; buf(len + 1);\nstd::snprintf(&amp;buf[0], len + 1, format.c_str(), args...);\nreturn std::string{&amp;buf[0], &amp;buf[0] + len};\n#pragma GCC diagnostic warning \"-Wformat-security\"\n}\n\ntemplate &lt;typename... Args&gt;\nvoid print(const std::string &amp;format, Args const&amp;... args)\n{\nstd::cout &lt;&lt; c_format(format, args...);\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dc__motor__list_8hpp/","title":"include/cpp_robotics/motor/dc_motor_list.hpp","text":""},{"location":"doxybook/Files/dc__motor__list_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/dc__motor__list_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./dc_motor_param.hpp\"\n\nnamespace cpp_robotics\n{\n\ninline constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param(\n18_V,\n20400_rpm,\n2.8_A,\n1265_mmNm,\n156_A,\n7.088e-5_H,\n2.46e-5 // \u9069\u5f53\n);\n\ninline constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param(\n18_V,\n18400_rpm,\n2.7_A,\n1216_mmNm, 130_A,\n5.872e-5_H,\n2.46e-5 // \u9069\u5f53\n);\n\ninline constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param(\n12_V,\n9100_rpm,\n0.8_A,\n450_mmNm, 36_A,\n1.820e-4_H,\n2.46e-5 // \u9069\u5f53\n);\n\n// inline constexpr DCMotorParam RS_540SH_6527  \n// {\n//     1.658e+0_ohm, \n//     7.371e-5_H, \n//     3.899e-3_Nm_per_A, \n//     6.239e-3_Nm, \n//     3.745e-2_Vs_per_rad\n// };\n\ninline constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param(\n6_V,\n12500_rpm,\n0.56_A,\n77.5_mmNm, 18_A,\n1.521e-4_H,\n2.46e-5 // \u9069\u5f53\n);\n\ninline constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param(\n18_V,\n17500_rpm,\n0.23_A,\n76.9_mmNm, 7.91_A,\n1.521e-4_H,\n2.46e-5 // \u9069\u5f53\n);\n\n// inline constexpr DCMotorParam RS_385PH_2465  \n// {\n//     3.067e+1_ohm, \n//     1.128e-3_H, \n//     1.189e-2_Nm_per_A, \n//     3.219e-3_Nm, \n//     1.330e-1_Vs_per_rad\n// };\n\ninline constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param(\n18_V,\n3520_rpm,\n755_mA,\n0.0609_ohm,\n0.0226_mH,\n46e-3_Nm_per_A,\n1.38\n);  // http://suzakugiken.jp/goods/30144/catalog-IG32.pdf\n// http://suzakugiken.jp/goods/30335/catalog-IG36P.pdf\n// http://suzakugiken.jp/goods/30045/catalog-IG42C.pdf\n\ninline constexpr GearHeadParam IG42C_4  = { 1/4.0f, 0.8f };\ninline constexpr GearHeadParam IG42C_14 = { 1/14.0f, 0.7f };\ninline constexpr GearHeadParam IG42C_17 = { 1/17.0f, 0.7f };\ninline constexpr GearHeadParam IG32_27  = { 1/27.0f, 0.7f };\ninline constexpr GearHeadParam IG32_71  = { 1/71.0f, 0.6f };\ninline constexpr GearHeadParam IG32_100 = { 1/100.0f, 0.6f };\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dc__motor__param_8hpp/","title":"include/cpp_robotics/motor/dc_motor_param.hpp","text":""},{"location":"doxybook/Files/dc__motor__param_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb"},{"location":"doxybook/Files/dc__motor__param_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb"},{"location":"doxybook/Files/dc__motor__param_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"cpp_robotics/unit.hpp\"\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics\n{\n\ninline namespace unit\n{\nusing TorqueConstant = unit_assem::unit_div&lt;Torque, Ampere&gt;::unit;\nusing BackEmfConstant = unit_assem::unit_div&lt;Volt, AngularVelocity&gt;::unit;\nusing FrictionConstant = unit_assem::unit_mul&lt;Torque, Second&gt;::unit;\n}\n\nGENERATE_UNIT_SUFFIX(cpp_robotics::TorqueConstant, Nm_per_A)\nGENERATE_UNIT_SUFFIX(cpp_robotics::BackEmfConstant, Vs_per_rad)\nGENERATE_UNIT_SUFFIX(cpp_robotics::FrictionConstant, Nms)\n\n\nstruct DCMotorParam\n{\nconst Volt nominal_voltage;               // \u516c\u79f0\u96fb\u5727[V]\nconst Rpm free_speed;                     // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]\nconst Ampere free_current;                // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]\nconst Ohm resistance;                     // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm]             (\u516c\u79f0\u96fb\u5727 / \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41)\nconst Henry inductance;                   // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H]\nconst TorqueConstant torque_constant;     // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A]            (\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af)/(\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41 - \u7121\u8ca0\u8377\u96fb\u6d41)\nconst BackEmfConstant back_emf_constance; // \u9006\u6c17\u96fb\u529b\u5b9a\u6570[V/(rad/s)]      (\u516c\u79f0\u96fb\u5727 - \u62b5\u6297*\u7121\u8ca0\u8377\u96fb\u6d41)/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]\nconst FrictionConstant friction_constant; // \u7c98\u6027\u4fc2\u6570[Nms]               (\u30c8\u30eb\u30af\u640d\u5931/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]) \u30c8\u30eb\u30af\u640d\u5931 = \u7121\u8ca0\u8377\u6642\u96fb\u6d41*\u30c8\u30eb\u30af\u5b9a\u6570\nconst Inertia rotor_inertia;              // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2]\nconst Second time_constant;               // \u96fb\u6c17\u7684\u6642\u5b9a\u6570[s]             (\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9/\u62b5\u6297)\n\nconstexpr DCMotorParam(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm Rm, Henry Lm, TorqueConstant Kt, BackEmfConstant Ke, Inertia Im, Second curr_set_time = 0.1f):\nnominal_voltage(nominal_voltage),\nfree_speed(free_speed),\nfree_current(free_current),\nresistance(Rm),\ninductance(Lm),\ntorque_constant(Kt),\nback_emf_constance(Ke),\nfriction_constant((free_current*torque_constant) / (AngularVelocity)(free_speed)),\nrotor_inertia(Im),\ntime_constant(inductance/resistance)\n{\nset_current_setting_time(curr_set_time);\n}\nconstexpr DCMotorParam(const DCMotorParam&amp;) = default;\n\nconstexpr void set_current_setting_time(Second Tc)\n{\nif((double)Tc &gt; 0.0f)\ncurrent_setting_time_ = Tc;\ncorner_frequency_ = 3.0f / current_setting_time_;\ncurrent_p_gain_base_ = (inductance*corner_frequency_).value();\ncurrent_i_gain_base_ = (resistance*corner_frequency_).value();\n}\n\nconstexpr Rpm calcu_steady_free_velocity(Volt v) const\n{\nreturn free_speed * ((double)v / (double)nominal_voltage);\n}\n\nconstexpr Ampere calcu_stall_current(Volt v) const\n{\nreturn v / resistance;\n}\n\nconstexpr Torque calcu_stall_torque(Volt v) const\n{\nreturn calcu_stall_current(v) * torque_constant;\n}\n\nconstexpr AngularAcceleration calcu_max_free_angular_acceleration(Volt v) const\n{\nreturn calcu_stall_torque(v) / rotor_inertia;\n}\n\nconstexpr Second get_Tm() const { return time_constant; }\nconstexpr AngularVelocity get_Wi() const { return corner_frequency_; }\nconstexpr double get_Kip(Volt volt) const { return current_p_gain_base_ / volt.value(); }\nconstexpr double get_Kii(Volt volt) const { return current_i_gain_base_ / volt.value(); }\n\nprivate:\nSecond current_setting_time_ = 0.1_s;\nAngularVelocity corner_frequency_ = 0;\ndouble current_p_gain_base_ = 0;\ndouble current_i_gain_base_ = 0;\n};\n\nstruct GearHeadParam\n{\nconst double ratio;\nconst double efficiency;\nconstexpr GearHeadParam(double ratio_, double efficiency_):\nratio(ratio_), efficiency(efficiency_) {}\n};\n\nstruct DCGearedMotorParam\n{\nconstexpr DCGearedMotorParam(Volt voltage_, DCMotorParam motor_, GearHeadParam gear_head_, const double optional_gear_ratio_ = 1):\nvoltage(voltage_),\nmotor(motor_),\ngear_head(gear_head_),\noptional_gear_ratio(optional_gear_ratio_)\n{\n\n}\n\nconstexpr Rpm calcu_gear_head_steady_free_velocity(Volt v) const\n{\nreturn motor.calcu_steady_free_velocity(v) * gear_head.ratio;\n}\n\nconstexpr Rpm calcu_endpoint_steady_free_velocity(Volt v) const\n{\nreturn calcu_gear_head_steady_free_velocity(v) * optional_gear_ratio;\n}\n\nconstexpr AngularAcceleration calcu_endpoint_max_angular_accleleration(Inertia optional_inertina = 0) const\n{\nreturn motor.calcu_stall_torque(voltage) / (motor.rotor_inertia + (optional_inertina * std::pow(gear_head.ratio*optional_gear_ratio, 2))) * gear_head.ratio;\n}\n\nconst Volt voltage;\nconst DCMotorParam motor;\nconst GearHeadParam gear_head;\nconst double optional_gear_ratio;\n};\n\ninline constexpr DCMotorParam generate_mabuchi_motor_param(\nVolt nominal_voltage,  // \u516c\u79f0\u96fb\u5727[V]\nRpm free_speed,        // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]\nAmpere free_current,   // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]\nTorque stall_torque,   // \u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af[Nm]\nAmpere stall_current,  // \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41[A]\nHenry inductance,      // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] (\u8a08\u6e2c\u3059\u308b)\nInertia rotor_inertia  // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2] (\u8a08\u6e2c\u3059\u308b)\n)\n{\nconst auto R = nominal_voltage/stall_current;\nreturn DCMotorParam(\nnominal_voltage,\nfree_speed,\nfree_current,\nR,\ninductance,\nstall_torque / (stall_current - free_current),\n(nominal_voltage - R*free_current) / (AngularVelocity)(free_speed),\nrotor_inertia\n);\n}\n\ninline constexpr DCMotorParam generate_maxon_brush_motor_param(\nVolt nominal_voltage,  // \u516c\u79f0\u96fb\u5727[V]\nRpm free_speed,        // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]\nAmpere free_current,   // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]\nOhm resistance,        // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm]\nHenry inductance,      // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H]\nTorqueConstant Kt,     // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A]\nInertia rotor_inertia  // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2] (\u8a08\u6e2c\u3059\u308b)\n)\n{\nreturn DCMotorParam(\nnominal_voltage,\nfree_speed,\nfree_current,\nresistance,\ninductance,\nKt,\n(nominal_voltage - resistance*free_current) / (AngularVelocity)(free_speed),\nrotor_inertia\n);\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/delay__filter_8hpp/","title":"include/cpp_robotics/filter/delay_filter.hpp","text":""},{"location":"doxybook/Files/delay__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/delay__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/delay__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n\nnamespace cpp_robotics\n{\n\nclass DelayFilter\n{\npublic:\nDelayFilter(double delay_time, double Ts)\n{\ndelay_sample_cnt_ = std::floor(delay_time/Ts);\ndelay_table_.resize(delay_sample_cnt_);\n}\n\nvirtual void reset()\n{\nfor(auto &amp;val : delay_table_)\n{\nval = 0;\n}\n}\n\nvirtual double filtering(double u)\n{\nif(delay_table_.size() == 0)\nreturn u;\n\nfor(int i = delay_table_.size() - 2; i &gt;= 0; i--)\n{\ndelay_table_[i+1] = delay_table_[i];\n}\ndelay_table_[0] = u;\nreturn delay_table_.back();\n}\n\nprivate:\nsize_t delay_sample_cnt_;\nstd::vector&lt;double&gt; delay_table_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/delta__robot_8hpp/","title":"include/cpp_robotics/arm_ik/delta_robot.hpp","text":""},{"location":"doxybook/Files/delta__robot_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/delta__robot_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66"},{"location":"doxybook/Files/delta__robot_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace cpp_robotics\n{\n\nclass DeltaRobotIk\n{\npublic:\nenum IkSolveMethod : uint8_t\n{\nAnalytical,\nNumerical\n};\nDeltaRobotIk(double wb, double wp, double l1, double l2, IkSolveMethod method = IkSolveMethod::Analytical):\nmethod_(method), kinematics_functor_(wb, wp, l1, l2), ad_(kinematics_functor_){}\n\nEigen::Vector3d solve_fk(Eigen::Vector3d joint_angles)\n{\n\n}\n\nEigen::Vector3d solve_ik(Eigen::Vector3d pos, Eigen::Vector3d joint_angles0 = Eigen::Vector3d::Zero())\n{\nif(method_ == IkSolveMethod::Analytical)\n{\n// \u89e3\u6790\u7684\u306b\u9006\u904b\u52d5\u5b66\u3092\u89e3\u304f\nreturn kinematics_functor_.solve_ik_analytical(pos);\n}\n\n// \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u4f7f\u7528\u3057\u3066\u6570\u5024\u7684\u306b\u89e3\u304f\nkinematics_functor_.target_pos = pos;\nauto [ret, rx, rcnt] = quasi_newton_method(ad_.evalute_func_scalar(), ad_.jacobian_func_row_vector(), joint_angles0);\nreturn rx;\n}\n\nprivate:\nstruct Kinematics\n{\nKinematics(double wb, double wp, double l1, double l2):\nwb(wb), wp(wp), l1(l1), l2(l2) {}\n\n// \u9806\u904b\u52d5\u5b66\ntemplate&lt;typename T&gt;\nEigen::Matrix&lt;T,3,1&gt; solve_fk(const Eigen::Matrix&lt;T,3,1&gt;&amp; angles)\n{\nEigen::Matrix&lt;T,3,1&gt; pos;\n// Todo\nreturn pos;\n} // \u9006\u904b\u52d5\u5b66\nEigen::Vector3d solve_ik_analytical(Eigen::Vector3d pos)\n{\nEigen::Vector3d angles;\n// Todo\nreturn angles;\n}\n\n// \u9006\u904b\u52d5\u5b66\u3092\u6570\u5024\u7684\u306b\u6c42\u3081\u308b\u6642\u306e\u8a55\u4fa1\u95a2\u6570\ntemplate&lt;typename T&gt;\nvoid eval_func(const Eigen::Matrix&lt;T,3,1&gt;&amp; x, Eigen::Matrix&lt;T,1,1&gt;&amp; y)\n{\nEigen::Matrix&lt;T,3,1&gt; diff = target_pos - solve_fk(x);\ny[0] = diff.dot(diff);\n}\n\nEigen::Vector3d target_pos;\n\nconst double wb;\nconst double wp;\nconst double l1;\nconst double l2;\n};\n\nIkSolveMethod method_;\nKinematics kinematics_functor_;\nAutoDiffAdaptor&lt;Kinematics, Eigen::VectorXd, double, 3, 1&gt; ad_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/derivative_8hpp/","title":"include/cpp_robotics/optimize/derivative.hpp","text":""},{"location":"doxybook/Files/derivative_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/derivative_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;limits&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic double derivative(std::function&lt;double(double)&gt; f, double x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n// \u4e2d\u592e\u5dee\u5206\nreturn ( f(x + eps) - f(x - eps) ) / (2.0*eps);\n}\n\nstatic Eigen::VectorXd derivative(std::function&lt;double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\nEigen::VectorXd der(x.rows());\nfor(Eigen::VectorXd::Index i = 0; i &lt; x.rows(); i++)\n{\nEigen::VectorXd diff = Eigen::VectorXd::Zero(x.rows());\ndiff(i) = eps;\n// \u4e2d\u592e\u5dee\u5206\nder(i) = ( f(x + diff) - f(x - diff) ) / (2.0*eps);\n}\nreturn der;\n}\n\nstatic Eigen::MatrixXd derivative(std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\nEigen::MatrixXd der;\nfor(Eigen::VectorXd::Index i = 0; i &lt; x.rows(); i++)\n{\nEigen::VectorXd diff = Eigen::VectorXd::Zero(x.rows());\ndiff(i) = eps;\n// \u4e2d\u592e\u5dee\u5206\nEigen::VectorXd der_col = ( f(x + diff) - f(x - diff) ) / (2.0*eps);\nif(i == 0)\n{\nder = Eigen::MatrixXd::Zero(der_col.size(), x.rows());\n}\nder.col(i) = der_col;\n}\nreturn der;\n}\n\nstatic double second_derivative(std::function&lt;double(double)&gt; f, double x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\n// \u4e2d\u592e2\u968e\u5dee\u5206\nreturn ( f(x + eps) - 2*f(x) + f(x - eps) ) / std::pow(eps,2);\n}\n\nstatic Eigen::MatrixXd approx_hessian(std::function&lt;double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps = std::pow(std::numeric_limits&lt;double&gt;::epsilon(), 0.5))\n{\nauto j = derivative(f, x, eps);\nreturn j * j.transpose();\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/differentiator_8hpp/","title":"include/cpp_robotics/filter/differentiator.hpp","text":""},{"location":"doxybook/Files/differentiator_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/differentiator_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668"},{"location":"doxybook/Files/differentiator_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass Differentiator : public TransferFunction\n{\npublic:\nDifferentiator(double omega, double dt): omega_(omega)\n{\nTransferFunction::set_continuous({omega_, 0}, {1, omega_}, dt);\n}\n\ndouble filtering(double u) { return responce(u); } double omega() const { return omega_; }\nprivate:\nconst double omega_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_2ea8a390efb1067dce8bd4c72d5b1bee/","title":"include/cpp_robotics/utility","text":""},{"location":"doxybook/Files/dir_2ea8a390efb1067dce8bd4c72d5b1bee/#files","title":"Files","text":"Name include/cpp_robotics/utility/angle_range.hpp include/cpp_robotics/utility/cpp_support.hpp include/cpp_robotics/utility/eigen_utils.hpp include/cpp_robotics/utility/ginac_utils.hpp include/cpp_robotics/utility/math_utils.hpp include/cpp_robotics/utility/singleton.hpp include/cpp_robotics/utility/space.hpp include/cpp_robotics/utility/timer.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_36b0cd5dd5e5d52e27c3e8401d5f16d3/","title":"include/cpp_robotics/vector","text":""},{"location":"doxybook/Files/dir_36b0cd5dd5e5d52e27c3e8401d5f16d3/#files","title":"Files","text":"Name include/cpp_robotics/vector/quaternion.hpp include/cpp_robotics/vector/transform.hpp include/cpp_robotics/vector/vector2.hpp include/cpp_robotics/vector/vector3.hpp include/cpp_robotics/vector/vector4.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_4247061a1141e797ef60959306008361/","title":"include/cpp_robotics/geometry","text":""},{"location":"doxybook/Files/dir_4247061a1141e797ef60959306008361/#files","title":"Files","text":"Name include/cpp_robotics/geometry/geometry_stream.hpp include/cpp_robotics/geometry/intersect.hpp include/cpp_robotics/geometry/shape.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_5df22cf9cb50dfe3ed59678e8c651195/","title":"include/cpp_robotics/controller","text":""},{"location":"doxybook/Files/dir_5df22cf9cb50dfe3ed59678e8c651195/#files","title":"Files","text":"Name include/cpp_robotics/controller/linear_mpc.hpp include/cpp_robotics/controller/linear_regulator_mpc.hpp include/cpp_robotics/controller/lqr.hpp include/cpp_robotics/controller/modern_control.hpp include/cpp_robotics/controller/nctf.hpp include/cpp_robotics/controller/pfc.hpp include/cpp_robotics/controller/pid.hpp include/cpp_robotics/controller/pid2.hpp include/cpp_robotics/controller/psmc.hpp include/cpp_robotics/controller/pure_pursuit.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_638b28e3ebdf4d55edeb748f267e8fbb/","title":"include/cpp_robotics/system","text":""},{"location":"doxybook/Files/dir_638b28e3ebdf4d55edeb748f267e8fbb/#files","title":"Files","text":"Name include/cpp_robotics/system/bode.hpp include/cpp_robotics/system/discret.hpp include/cpp_robotics/system/link_robot.hpp include/cpp_robotics/system/nyquist.hpp include/cpp_robotics/system/polynomial.hpp include/cpp_robotics/system/siso_system.hpp include/cpp_robotics/system/state_space_system.hpp include/cpp_robotics/system/system_transformation.hpp include/cpp_robotics/system/time_responce.hpp include/cpp_robotics/system/transfer_function.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/","title":"include/cpp_robotics","text":""},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/#directories","title":"Directories","text":"Name include/cpp_robotics/algorithm include/cpp_robotics/arm_ik include/cpp_robotics/chassis include/cpp_robotics/controller include/cpp_robotics/filter include/cpp_robotics/geometry include/cpp_robotics/motor include/cpp_robotics/optimize include/cpp_robotics/path_planning include/cpp_robotics/system include/cpp_robotics/unit include/cpp_robotics/utility include/cpp_robotics/vector"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/#files","title":"Files","text":"Name include/cpp_robotics/algorithm.hpp include/cpp_robotics/arm_ik.hpp include/cpp_robotics/chassis.hpp include/cpp_robotics/controller.hpp include/cpp_robotics/core.hpp include/cpp_robotics/cpp_robotics.hpp include/cpp_robotics/filter.hpp include/cpp_robotics/geometry.hpp include/cpp_robotics/motor.hpp include/cpp_robotics/optimize.hpp include/cpp_robotics/path_planning.hpp include/cpp_robotics/system.hpp include/cpp_robotics/unit.hpp include/cpp_robotics/utility.hpp include/cpp_robotics/vector.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_7e879dbdc5c9edf53cad9d774885e9a7/","title":"include/cpp_robotics/arm_ik","text":""},{"location":"doxybook/Files/dir_7e879dbdc5c9edf53cad9d774885e9a7/#files","title":"Files","text":"Name include/cpp_robotics/arm_ik/delta_robot.hpp include/cpp_robotics/arm_ik/xy_2deg_robot.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_87a81676224789efbbd31189f8c15377/","title":"include/cpp_robotics/motor","text":""},{"location":"doxybook/Files/dir_87a81676224789efbbd31189f8c15377/#files","title":"Files","text":"Name include/cpp_robotics/motor/dc_motor_list.hpp include/cpp_robotics/motor/dc_motor_param.hpp include/cpp_robotics/motor/motor_tf.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_b08c5c51b4051026c781f1fcc98ccd3c/","title":"include/cpp_robotics/path_planning","text":""},{"location":"doxybook/Files/dir_b08c5c51b4051026c781f1fcc98ccd3c/#files","title":"Files","text":"Name include/cpp_robotics/path_planning/a_star.hpp include/cpp_robotics/path_planning/dubins_path.hpp include/cpp_robotics/path_planning/dwa.hpp include/cpp_robotics/path_planning/frenet_frame.hpp include/cpp_robotics/path_planning/grid_path_planning_utils.hpp include/cpp_robotics/path_planning/minimum_jerk_model.hpp include/cpp_robotics/path_planning/spline.hpp include/cpp_robotics/path_planning/wave_propagation.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_bc9ad42d08f7b854efebf7d8aa67e9d1/","title":"include/cpp_robotics/chassis","text":""},{"location":"doxybook/Files/dir_bc9ad42d08f7b854efebf7d8aa67e9d1/#files","title":"Files","text":"Name include/cpp_robotics/chassis/mecanum_ik.hpp include/cpp_robotics/chassis/omni_ik.hpp include/cpp_robotics/chassis/swerve_ik.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_c2aadae018d07499e272ef7425a31e4f/","title":"include/cpp_robotics/algorithm","text":""},{"location":"doxybook/Files/dir_c2aadae018d07499e272ef7425a31e4f/#files","title":"Files","text":"Name include/cpp_robotics/algorithm/auto_diff.hpp include/cpp_robotics/algorithm/icp.hpp include/cpp_robotics/algorithm/k_means_method.hpp include/cpp_robotics/algorithm/kdtree.hpp include/cpp_robotics/algorithm/mahalanobis.hpp include/cpp_robotics/algorithm/misc.hpp include/cpp_robotics/algorithm/ndt.hpp include/cpp_robotics/algorithm/poly_regression.hpp include/cpp_robotics/algorithm/random.hpp include/cpp_robotics/algorithm/state_machine.hpp include/cpp_robotics/algorithm/transformation.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_d44c64559bbebec7f509842c48db8b23/","title":"include","text":""},{"location":"doxybook/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Name include/cpp_robotics <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_d46e09745d41c5a7827c5b81f13e5fde/","title":"include/cpp_robotics/filter","text":""},{"location":"doxybook/Files/dir_d46e09745d41c5a7827c5b81f13e5fde/#files","title":"Files","text":"Name include/cpp_robotics/filter/acceleration_limit_filter.hpp include/cpp_robotics/filter/band_pass_filter.hpp include/cpp_robotics/filter/butterworth_filter.hpp include/cpp_robotics/filter/delay_filter.hpp include/cpp_robotics/filter/differentiator.hpp include/cpp_robotics/filter/extended_kalman_filter.hpp include/cpp_robotics/filter/filter_connector.hpp include/cpp_robotics/filter/filter_state_holder.hpp include/cpp_robotics/filter/high_pass_filter.hpp include/cpp_robotics/filter/integrator.hpp include/cpp_robotics/filter/kalman_filter.hpp include/cpp_robotics/filter/low_pass_filter.hpp include/cpp_robotics/filter/notch_filter.hpp include/cpp_robotics/filter/velocity_limit_filter.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_dbe6a3823a6e2aee897d3ebf7d75d548/","title":"include/cpp_robotics/optimize","text":""},{"location":"doxybook/Files/dir_dbe6a3823a6e2aee897d3ebf7d75d548/#files","title":"Files","text":"Name include/cpp_robotics/optimize/active_set_method.hpp include/cpp_robotics/optimize/barrier_method.hpp include/cpp_robotics/optimize/bfgs.hpp include/cpp_robotics/optimize/bracketing_serach.hpp include/cpp_robotics/optimize/constraint.hpp include/cpp_robotics/optimize/derivative.hpp include/cpp_robotics/optimize/golden_serach.hpp include/cpp_robotics/optimize/interior_point_method.hpp include/cpp_robotics/optimize/lesi_doc.hpp include/cpp_robotics/optimize/linprog.hpp include/cpp_robotics/optimize/lsei_transition.hpp include/cpp_robotics/optimize/newton_method.hpp include/cpp_robotics/optimize/penalty_method.hpp include/cpp_robotics/optimize/quadprog.hpp include/cpp_robotics/optimize/quasi_newton_method.hpp include/cpp_robotics/optimize/sqp.hpp include/cpp_robotics/optimize/steepest_descent_method.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dir_f159f485fcf409cdce5089fe647e40f4/","title":"include/cpp_robotics/unit","text":""},{"location":"doxybook/Files/dir_f159f485fcf409cdce5089fe647e40f4/#files","title":"Files","text":"Name include/cpp_robotics/unit/si_unit.hpp include/cpp_robotics/unit/unit_core.hpp <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/discret_8hpp/","title":"include/cpp_robotics/system/discret.hpp","text":""},{"location":"doxybook/Files/discret_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/discret_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class cpp_robotics::DiscretTransferFunction"},{"location":"doxybook/Files/discret_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;tuple&gt;\n#include \"./polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass Discret\n{\nprivate:\ntemplate&lt;typename Derived&gt;\nstatic auto expm(const Eigen::MatrixBase&lt;Derived&gt; &amp;A)\n{\nassert(A.cols() == A.rows());\nreturn A.exp();\n}\n\ntemplate&lt;typename Derived&gt;\nstatic auto integral_expm(const Eigen::MatrixBase&lt;Derived&gt; &amp;A, const double &amp;Ts, size_t hdiv = 1000)\n{\nassert(A.cols() == A.rows());\n\n// \u30b7\u30f3\u30d7\u30bd\u30f3\u6cd5\u3067\u7a4d\u5206\nconst double h = Ts / (double)(hdiv);\nDerived S = expm(A*0) + expm(A*Ts);\n\nfor(size_t i = 1; i &lt; hdiv; i += 2)\n{\nS += 4 * expm(A*h*i);\n}\n\nfor(size_t i = 2; i &lt; hdiv; i += 2)\n{\nS += 2 * expm(A*h*i);\n}\nS *= h/3;\nreturn S;\n}\n\npublic:\ntemplate&lt;typename Derived&gt;\nstatic auto discretize_a(const Eigen::MatrixBase&lt;Derived&gt; &amp;A, const double Ts)\n{\nassert(A.cols() == A.rows());\nreturn static_cast&lt;Derived&gt;((A*Ts).exp());\n}\n\ntemplate&lt;typename Derived1, typename Derived2&gt;\nstatic auto discretize_b(const Eigen::MatrixBase&lt;Derived1&gt; &amp;A, const Eigen::MatrixBase&lt;Derived2&gt; &amp;B, const double &amp;Ts, size_t hdiv = 1000)\n{\nassert(A.rows() == A.cols());\nassert(A.rows() == B.rows());\n\nEigen::FullPivLU&lt;Derived1&gt; lu_decomp(A);\nauto rank = lu_decomp.rank();\n\nif(rank == A.rows())\n{\nif constexpr (Derived1::SizeAtCompileTime==Eigen::Dynamic)\n{\nDerived1 I = Derived1::Identity(A.rows(), A.cols());\nreturn static_cast&lt;Derived2&gt;(A.inverse() * (expm(A*Ts) - I) * B);\n}\nelse\n{\nreturn static_cast&lt;Derived2&gt;(A.inverse() * (expm(A*Ts) - Derived1::Identity()) * B);\n}\n}\n\nreturn static_cast&lt;Derived2&gt;(integral_expm(A, Ts, hdiv)*B);\n}\n\ntemplate&lt;typename Derived1, typename Derived2&gt;\nstatic auto discritize(const Eigen::MatrixBase&lt;Derived1&gt; &amp;A, const Eigen::MatrixBase&lt;Derived2&gt; &amp;B, const double &amp;Ts, size_t hdiv = 1000)\n{\nreturn std::tuple{\ndiscretize_a(A, Ts),\ndiscretize_b(A, B, Ts, hdiv)\n};\n}\n};\n\nclass DiscretTransferFunction\n{\nprivate:\n\npublic:\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; discritize(const std::vector&lt;double&gt; &amp;num, const std::vector&lt;double&gt; &amp;den, const double Ts)\n{\nassert(num.size() &lt;= den.size()); // \u30d7\u30ed\u30d1\u30fc\n\nsize_t dim = den.size();\nPolynomial num_poly, den_poly;\n\n// (2(z-1))^{num_size}*(T(z+1))^{den_size}\u3092\u5c55\u958b\u3057\u305f\u591a\u9805\u5f0f\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u3059\nauto z_poly = [&amp;](size_t num_size, size_t den_size)\n{\nstd::vector&lt;double&gt; roots(num_size+den_size, -1);\nfor(size_t i = 0; i &lt; num_size; i++)\n{\nroots[i] = +1;\n}\n\nreturn std::pow(2.0, num_size)*std::pow(Ts, den_size) * Polynomial::expand(roots);\n};\n\nfor(size_t i = 0; i &lt; den.size(); i++)\n{\nden_poly += den[i] * z_poly(den.size()-1-i, i);\n}\n\nfor(size_t i = 0; i &lt; num.size(); i++)\n{\nnum_poly += num[i] * z_poly(num.size()-1-i, i+(den.size()-num.size()));\n}\n\nreturn {num_poly.coeff(), den_poly.coeff()};\n}\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dubins__path_8hpp/","title":"include/cpp_robotics/path_planning/dubins_path.hpp","text":""},{"location":"doxybook/Files/dubins__path_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/dubins__path_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::DubinsPath Dubins\u30d1\u30b9"},{"location":"doxybook/Files/dubins__path_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"../vector/transform.hpp\"\n#include &lt;functional&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass DubinsPath\n{\npublic:\nenum class Mode\n{\nLRL,\nRLR,\nLSL,\nLSR,\nRSL,\nRSR,\n\nNONE\n};\n\nDubinsPath(Transformd start, Transformd end, double cavature):\nstart_(start), end_(end), cavature_(cavature)\n{\nauto distance = (end-start).make_vector2().get_rotated(-start.theta);\ndouble angle_distance = shortest_angular_distance(start.theta, end.theta);\nplanning_from_origin({distance, angle_distance});\nall_length_ = plan_.t + plan_.p + plan_.q;\nbuild_pos_function();\n}\n\ndouble length() const { return all_length_; }\ndouble segment_length(size_t i) const\n{\nassert(i &lt; 3);\nswitch(i)\n{\ncase 0: return plan_.t;\ncase 1: return plan_.p;\ncase 2: return plan_.q;\n}\nreturn 0;\n}\n\nTransformd position(double len) const\n{\nlen = std::clamp(len, 0.0, all_length_);\nif(len == 0)\nreturn start_;\nfor(size_t i = 0; i &lt; 3; i++)\n{\nif(len &lt; segment_length(i))\n{\nreturn pos_func_list_[i](len);\n}\nlen -= segment_length(i);\n}\nreturn end_;\n}\n\nstd::string path_type() const\n{\nswitch (plan_.mode)\n{\ncase Mode::LRL: return \"LRL\";\ncase Mode::RLR: return \"RLR\";\ncase Mode::LSL: return \"LSL\";\ncase Mode::LSR: return \"LSR\";\ncase Mode::RSL: return \"RSL\";\ncase Mode::RSR: return \"RSR\";\n\ndefault:\nreturn \"NONE\";\n}\n}\n\nprivate:\nstruct PlanningResult\n{\ndouble t = 0;\ndouble p = 0;\ndouble q = 0;\nMode mode = Mode::NONE;\n};\n\nvoid planning_from_origin(Transformd origin_to_goal)\n{\nconst auto dist = origin_to_goal.make_vector2();\n\nconst double D = dist.norm();\nconst double d = D / cavature_;\n\nconst double theta = mod2pi(dist.angle());\nconst double alpha = mod2pi(-theta);\nconst double beta = mod2pi(origin_to_goal.theta - theta);\n\nauto planner_bind = [this](auto mem_fn)\n{\nreturn std::bind(mem_fn, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);\n};\n\nstd::array planners = {\nplanner_bind(&amp;DubinsPath::LRL),\nplanner_bind(&amp;DubinsPath::RLR),\nplanner_bind(&amp;DubinsPath::LSL),\nplanner_bind(&amp;DubinsPath::LSR),\nplanner_bind(&amp;DubinsPath::RSL),\nplanner_bind(&amp;DubinsPath::RSR)\n};\n\ndouble bcost = std::numeric_limits&lt;double&gt;::max();\n\nstd::optional&lt;PlanningResult&gt; pret;\n\nfor(auto &amp;planner : planners)\n{\nif(auto ret = planner(alpha, beta, d); ret.has_value())\n{\nauto [t,p,q,mode] = ret.value();\ndouble cost = t+p+q;\nif(cost &lt; bcost)\n{\nplan_ = ret.value();\nbcost = cost;\n}\n}\n}\n}\n\nstd::optional&lt;PlanningResult&gt; LSL(double alpha, double beta, double d)\n{\nconst double sa = std::sin(alpha);\nconst double sb = std::sin(beta);\nconst double ca = std::cos(alpha);\nconst double cb = std::cos(beta);\nconst double c_ab = std::cos(alpha - beta);\n\nconst double tmp0 = d + sa - sb;\n\nconst double p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sa - sb));\nif (p_squared &lt; 0)\nreturn std::nullopt;\nconst double tmp1 = std::atan2((cb - ca), tmp0);\nconst double t = mod2pi(-alpha + tmp1);\nconst double p = std::sqrt(p_squared);\nconst double q = mod2pi(beta - tmp1);\n\nreturn PlanningResult{t, p, q, Mode::LSL};\n}\n\nstd::optional&lt;PlanningResult&gt; RSR(double alpha, double beta, double d)\n{\nconst double sa = std::sin(alpha);\nconst double sb = std::sin(beta);\nconst double ca = std::cos(alpha);\nconst double cb = std::cos(beta);\nconst double c_ab = std::cos(alpha - beta);\n\nconst double tmp0 = d - sa + sb;\nconst double p_squared = 2 + (d * d) - (2 * c_ab) + (2 * d * (sb - sa));\nif (p_squared &lt; 0)\nreturn std::nullopt;\nconst double tmp1 = std::atan2((ca - cb), tmp0);\nconst double t = mod2pi(alpha - tmp1);\nconst double p = std::sqrt(p_squared);\nconst double q = mod2pi(-beta + tmp1);\n\nreturn PlanningResult{t, p, q, Mode::RSR};\n}\n\nstd::optional&lt;PlanningResult&gt; LSR(double alpha, double beta, double d)\n{\nconst double sa = std::sin(alpha);\nconst double sb = std::sin(beta);\nconst double ca = std::cos(alpha);\nconst double cb = std::cos(beta);\nconst double c_ab = std::cos(alpha - beta);\n\nconst double p_squared = -2 + (d * d) + (2 * c_ab) + (2 * d * (sa + sb));\nif (p_squared &lt; 0)\nreturn std::nullopt;\nconst double p = std::sqrt(p_squared);\nconst double tmp2 = std::atan2((-ca - cb), (d + sa + sb)) - std::atan2(-2.0, p);\nconst double t = mod2pi(-alpha + tmp2);\nconst double q = mod2pi(-mod2pi(beta) + tmp2);\n\nreturn PlanningResult{t, p, q, Mode::LSR};\n}\n\nstd::optional&lt;PlanningResult&gt; RSL(double alpha, double beta, double d)\n{\nconst double sa = std::sin(alpha);\nconst double sb = std::sin(beta);\nconst double ca = std::cos(alpha);\nconst double cb = std::cos(beta);\nconst double c_ab = std::cos(alpha - beta);\n\nconst double p_squared = (d * d) - 2 + (2 * c_ab) - (2 * d * (sa + sb));\nif (p_squared &lt; 0)\nreturn std::nullopt;\nconst double p = std::sqrt(p_squared);\nconst double tmp2 = std::atan2((ca + cb), (d - sa - sb)) - std::atan2(2.0, p);\nconst double t = mod2pi(alpha - tmp2);\nconst double q = mod2pi(beta - tmp2);\n\nreturn PlanningResult{t, p, q, Mode::RSL};\n}\n\nstd::optional&lt;PlanningResult&gt; RLR(double alpha, double beta, double d)\n{\nconst double sa = std::sin(alpha);\nconst double sb = std::sin(beta);\nconst double ca = std::cos(alpha);\nconst double cb = std::cos(beta);\nconst double c_ab = std::cos(alpha - beta);\n\nconst double tmp_rlr = (6.0 - d * d + 2.0 * c_ab + 2.0 * d * (sa - sb)) / 8.0;\nif (std::abs(tmp_rlr) &gt; 1.0)\nreturn std::nullopt;\n\nconst double p = mod2pi(2 * M_PI - std::acos(tmp_rlr));\nconst double t = mod2pi(alpha - std::atan2(ca - cb, d - sa + sb) + mod2pi(p / 2.0));\nconst double q = mod2pi(alpha - beta - t + mod2pi(p));\nreturn PlanningResult{t, p, q, Mode::LRL};\n}\n\nstd::optional&lt;PlanningResult&gt; LRL(double alpha, double beta, double d)\n{\nconst double sa = std::sin(alpha);\nconst double sb = std::sin(beta);\nconst double ca = std::cos(alpha);\nconst double cb = std::cos(beta);\nconst double c_ab = std::cos(alpha - beta);\n\nconst double tmp_lrl = (6.0 - d * d + 2 * c_ab + 2 * d * (- sa + sb)) / 8.0;\nif (std::abs(tmp_lrl) &gt; 1)\nreturn std::nullopt;\nconst double p = mod2pi(2 * M_PI - std::acos(tmp_lrl));\nconst double t = mod2pi(-alpha - std::atan2(ca - cb, d + sa - sb) + p / 2.);\nconst double q = mod2pi(mod2pi(beta) - alpha - t + mod2pi(p));\n\nreturn PlanningResult{t, p, q, Mode::LRL};\n}\n\ndouble mod2pi(double theta)\n{\nreturn theta - 2.0 * M_PI * std::floor(theta / 2.0 / M_PI);\n}\n\nenum class SegmentType\n{\nL, S, R, NONE\n};\n\nvoid build_pos_function()\n{\nTransformd start = start_;\nfor(size_t i = 0; i &lt; 3; i++)\n{\nswitch(get_segment_type(i))\n{\ncase SegmentType::L:\n{\npos_func_list_[i] = [=](double len)\n{\nconst double r = 1/cavature_;\nconst double theta = len/r;\n\nVector2d rot_origin = start.make_vector2() + Vector2d(r,0).get_rotated(start.theta + M_PI/2);\n\nTransformd pos = start;\npos.rotate(rot_origin, theta);\npos.theta += theta;\nreturn pos;\n};\n}\nbreak;\n\ncase SegmentType::R:\n{\npos_func_list_[i] = [=](double len)\n{\nconst double r = 1/cavature_;\nconst double theta = len/r;\nVector2d rot_origin = start.make_vector2() + Vector2d(r,0).get_rotated(start.theta - M_PI/2);\n\nTransformd pos = start;\npos.rotate(rot_origin, -theta);\npos.theta += -theta;\nreturn pos;\n};\n}\nbreak;\n\ncase SegmentType::S:\n{\npos_func_list_[i] = [=](double len)\n{\nTransformd diff(Vector2d(len,0).get_rotated(start.theta), 0);\nreturn start + diff;\n};\n}\nbreak;\n\ndefault:\npos_func_list_[i] = [=](double len)\n{\n(void) len;\nreturn start_;\n};\n}\nstart = pos_func_list_[i](segment_length(i));\n}\n}\n\nSegmentType get_segment_type(size_t seg)\n{\nswitch(seg)\n{\ncase 0:\n{\nswitch(plan_.mode)\n{\ncase Mode::LRL:\ncase Mode::LSL:\ncase Mode::LSR:\nreturn SegmentType::L;\ncase Mode::RLR:\ncase Mode::RSL:\ncase Mode::RSR:\nreturn SegmentType::R;\ndefault:\nreturn SegmentType::NONE;\n}\n}\nbreak;\n\ncase 1:\n{\nswitch(plan_.mode)\n{\ncase Mode::RLR:\nreturn SegmentType::L;\ncase Mode::LRL:\nreturn SegmentType::R;\ncase Mode::LSL:\ncase Mode::LSR:\ncase Mode::RSL:\ncase Mode::RSR:\nreturn SegmentType::S;\ndefault:\nreturn SegmentType::NONE;\n}\n}\nbreak;\n\ncase 2:\n{\nswitch(plan_.mode)\n{\ncase Mode::LRL:\ncase Mode::LSL:\ncase Mode::RSL:\nreturn SegmentType::L;\ncase Mode::RLR:\ncase Mode::LSR:\ncase Mode::RSR:\nreturn SegmentType::R;\ndefault:\nreturn SegmentType::NONE;\n}\n}\nbreak;\n\ndefault:\nreturn SegmentType::NONE;\n}\n\n}\n\nprivate:\nTransformd start_, end_;\ndouble cavature_;\n\nPlanningResult plan_;\ndouble all_length_ = 0;\nstd::array&lt;std::function&lt;Transformd(double)&gt;, 3&gt; pos_func_list_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/dwa_8hpp/","title":"include/cpp_robotics/path_planning/dwa.hpp","text":""},{"location":"doxybook/Files/dwa_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/dwa_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace cpp_robotics\n{\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/eigen__utils_8hpp/","title":"include/cpp_robotics/utility/eigen_utils.hpp","text":""},{"location":"doxybook/Files/eigen__utils_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/eigen__utils_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\n// \u7591\u4f3c\u9006\u884c\u5217\ntemplate&lt;typename MatrixType&gt;\nMatrixType pseudo_inverse(const MatrixType &amp;a, double epsilon = std::numeric_limits&lt;double&gt;::epsilon()) //, Eigen::MatrixXd W = Eigen::MatrixXd())\n{\nunsigned int svd_option;\nif (a.rows() == a.cols())\n{\nsvd_option = Eigen::ComputeFullU | Eigen::ComputeFullV; // for square matrix\n}\nelse\n{\nsvd_option = Eigen::ComputeThinU | Eigen::ComputeThinV; // for non-square matrix\n}\n\nEigen::JacobiSVD&lt; MatrixType &gt; svd(a ,svd_option);\ndouble tolerance = epsilon * std::max(a.cols(), a.rows()) *svd.singularValues().array().abs()(0);\nreturn svd.matrixV() *  (svd.singularValues().array().abs() &gt; tolerance).select(svd.singularValues().array().inverse(), 0).matrix().asDiagonal() * svd.matrixU().adjoint();\n}\n\n// Singularity-Robust Inverse SR\u9006\u884c\u5217\ntemplate&lt;typename MatrixType&gt;\nMatrixType sr_inverse(const MatrixType &amp;a, double w0 = 1e-2, Eigen::MatrixXd W = Eigen::MatrixXd())\n{\nauto r = a.rows();\nauto c = a.cols();\nif(W.rows() != c|| W.cols() != c)\n{\nW = Eigen::MatrixXd::Identity(c,c);\n}\n\ndouble w = std::sqrt((a*(a.transpose())).determinant());\n\ndouble lambda = 0;\nif(w &lt; w0)\nlambda = std::pow((1-w/w0),2);\n\nauto a1 = (a*W*(a.transpose()) + lambda * Eigen::MatrixXd::Identity(r,r)).inverse();\nEigen::MatrixXd a_sr = W*a.transpose()*a1;\n\nreturn a_sr;\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/","title":"include/cpp_robotics/filter/extended_kalman_filter.hpp","text":""},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::ExtendedKalmanFilter"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/optimize/derivative.hpp\"\n\nnamespace cpp_robotics\n{\n\n/*\n[\u30e2\u30c7\u30eb]\nx(t) = F*x(t-1) + B*u(t) + w(t)\nz(t) = H*x(t) + v(t)\n\nx: \u72b6\u614b\u91cf (n*1)\nu: \u5236\u5fa1\u91cf (r*1)\nz: \u89b3\u6e2c\u91cf (p*1)\nF: \u72b6\u614b\u9077\u79fb\u884c\u5217 (n*n)\nB: \u5236\u5fa1\u884c\u5217 (n*r)\nH: \u89b3\u6e2c\u884c\u5217 (p*n)\n\nQ: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (n*n)\nw: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba (n*1) \n    N[0, Q]\u306b\u5f93\u3046\nR: \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (p*p)\nv: \u89b3\u6e2c\u30ce\u30a4\u30ba (p*1)\n    N[0, R]\u306b\u5f93\u3046\n\n[\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf]\n- \u4e88\u6e2c\n    \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\n    x = Fx + Bu\n\n    \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = FPF^T + Q\n\n- \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\n    K = PH^T(HPH^T + R)^-1\n\n    \u72b6\u614b\u63a8\u5b9a\n    x = x + K(z - Hx)\n\n    \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = (I -KH)P\n\n[\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf]\n- \u4e88\u6e2c\n    \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\n    x = f(x, u)\n\n    \u30e2\u30c7\u30eb\u7dda\u5f62\u8fd1\u4f3c\n    F = \\partial f(x,u) / \\partial x | x=x, u=u\n    H = \\partial h(x) / \\partial x | x=x\n\n    \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = FPF^T + Q\n\n- \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\n    K = PH^T(HPH^T + R)^-1\n\n    \u72b6\u614b\u63a8\u5b9a\n    x = x + K(z - h(x))\n\n    \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = (I -KH)P\n\n*/\n\nclass ExtendedKalmanFilter\n{\npublic:\nEigen::VectorXd x;\nEigen::MatrixXd F;\nEigen::MatrixXd B;\nEigen::MatrixXd H;\nEigen::MatrixXd Q;\nEigen::MatrixXd R;\nEigen::MatrixXd P;\n\nExtendedKalmanFilter(const double dt, size_t input_size, size_t state_size, size_t observe_size):\ndt_(dt), input_size_(input_size), state_size_(state_size), observe_size_(observe_size)\n{\nx = Eigen::VectorXd::Zero(state_size_);\nF = Eigen::MatrixXd::Zero(state_size, state_size);\nB = Eigen::MatrixXd::Zero(state_size, input_size);\nH = Eigen::MatrixXd::Zero(observe_size, state_size);\nQ = Eigen::MatrixXd::Zero(state_size, state_size);\nR = Eigen::MatrixXd::Zero(observe_size, observe_size);\nP = Eigen::MatrixXd::Zero(state_size, state_size);\n};\n\nvoid reset(Eigen::VectorXd new_x, Eigen::MatrixXd new_P)\n{\nx = new_x;\nP = new_P;\n}\n\nEigen::VectorXd filtering(Eigen::VectorXd u, Eigen::VectorXd z)\n{\nsystem_noise_conv(Q, x, u);\nobserve_noise_conv(R, x, u);\nlinearized_system_matrix(F, x, u);\nlinearized_observe_matrix(H, x);\n\n// \u72b6\u614b\u4e88\u6e2c\nx = system(x, u);\n\n// \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217\nP = F*P*F.transpose() + Q;\n\n// \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97\nEigen::MatrixXd K = P*H.transpose()*(R + H*P*H.transpose()).inverse();\n\n// \u72b6\u614b\u66f4\u65b0\nx += K*(z - observe(x));\n\n// \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\nP = (Eigen::MatrixXd::Identity(state_size_, state_size_) - K*H)*P;\n\nreturn x;\n}\n\ndouble dt() const { return dt_; }\nEigen::VectorXd get_x() const { return x; }\nEigen::MatrixXd get_P() const { return P; }\n\nvirtual Eigen::VectorXd system(Eigen::VectorXd x, Eigen::VectorXd u) = 0;\n\nvirtual Eigen::VectorXd observe(Eigen::VectorXd x) = 0;\n\nvirtual void system_noise_conv(Eigen::MatrixXd &amp;Q, Eigen::VectorXd x, Eigen::VectorXd u) = 0;\n\nvirtual void observe_noise_conv(Eigen::MatrixXd &amp;R, Eigen::VectorXd x, Eigen::VectorXd u) = 0;\n\nvirtual void linearized_system_matrix(Eigen::MatrixXd &amp;F, Eigen::VectorXd x, Eigen::VectorXd u)\n{\nF = derivative([&amp;](const Eigen::VectorXd &amp;x_dash){ return system(x_dash, u); }, x);\n};\n\nvirtual void linearized_observe_matrix(Eigen::MatrixXd &amp;H, Eigen::VectorXd x)\n{\nH = derivative(std::bind(&amp;ExtendedKalmanFilter::observe, this, std::placeholders::_1), x);\n}\n\nprotected:\n// \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593[s]\nconst double dt_;\n\nconst size_t input_size_;\nconst size_t state_size_;\nconst size_t observe_size_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/filter_8hpp/","title":"include/cpp_robotics/filter.hpp","text":""},{"location":"doxybook/Files/filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"filter/low_pass_filter.hpp\"\n#include \"filter/differentiator.hpp\"\n#include \"filter/integrator.hpp\"\n#include \"filter/low_pass_filter.hpp\"\n#include \"filter/high_pass_filter.hpp\"\n#include \"filter/notch_filter.hpp\"\n#include \"filter/band_pass_filter.hpp\"\n#include \"filter/delay_filter.hpp\"\n#include \"filter/velocity_limit_filter.hpp\"\n#include \"filter/acceleration_limit_filter.hpp\"\n#include \"filter/filter_state_holder.hpp\"\n#include \"filter/kalman_filter.hpp\"\n#include \"filter/extended_kalman_filter.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/filter__connector_8hpp/","title":"include/cpp_robotics/filter/filter_connector.hpp","text":""},{"location":"doxybook/Files/filter__connector_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/filter__connector_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::FilterConnector"},{"location":"doxybook/Files/filter__connector_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;array&gt;\n#include &lt;variant&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class ...FILTER_TYPE&gt;\nclass FilterConnector\n{\npublic:\nstatic constexpr size_t filter_count = sizeof...(FILTER_TYPE);\nusing variant_type = std::variant&lt;FILTER_TYPE...&gt;;\n\nFilterConnector()\n{\n\n}\n\nprivate:\nstd::array&lt;variant_type, filter_count&gt; filters_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/filter__state__holder_8hpp/","title":"include/cpp_robotics/filter/filter_state_holder.hpp","text":""},{"location":"doxybook/Files/filter__state__holder_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/filter__state__holder_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9"},{"location":"doxybook/Files/filter__state__holder_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;optional&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class BASE_FILTER_TYPE&gt;\nclass FilterStateHolder : public BASE_FILTER_TYPE\n{\npublic:\nusing BASE_FILTER_TYPE::BASE_FILTER_TYPE;\nvoid set_input(double u)\n{\nu_ = u;\n}\n\ndouble filtering()\n{\ny_ = BASE_FILTER_TYPE::filtering(u);\nreturn y_;\n}\n\ndouble u() const { return u_; }\ndouble y() const { return y_; }\nprivate:\ndouble u_ = 0, y_ = 0;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/frenet__frame_8hpp/","title":"include/cpp_robotics/path_planning/frenet_frame.hpp","text":""},{"location":"doxybook/Files/frenet__frame_8hpp/#source-code","title":"Source code","text":"<pre><code>// #pragma once\n\n// // #include \"Polynomial.hpp\"\n// // #include \"../../Control/Trajectory/Trajectory2/Trajectory2.hpp\"\n// #include &lt;cstdio&gt;\n// #include &lt;string&gt;\n// #include &lt;limits&gt;\n// #include &lt;tuple&gt;\n\n// namespace cpp_robotics\n// {\n// // template &lt;typename double&gt;\n// // void d_print_vector(const std::string name, const std::vector&lt;double&gt; &amp;vec,\n// //                   std::string fmt = \"%8.3f\")\n// // {\n// //     std::cout &lt;&lt; name &lt;&lt; \" =\" &lt;&lt; std::endl;\n// //     printf(\"[\");\n// //     for (auto &amp;val : vec) printf(fmt.c_str(), val);\n// //     printf(\"]\\n\");\n// // }\n\n\n//     /**\n//      * @brief 4\u6b21\u5f0f\u88dc\u9593\n//      * \n//      * @param x0 \u59cb\u70b9\u4f4d\u7f6e\n//      * @param v0 \u59cb\u70b9\u901f\u5ea6\n//      * @param a0 \u59cb\u70b9\u52a0\u901f\u5ea6\n//      * @param v1 \u7d42\u70b9\u901f\u5ea6\n//      * @param a1 \u7d42\u70b9\u52a0\u901f\u5ea6\n//      * @param Time \u533a\u9593\u9577\u3055\n//      */\n//     Polynomial&lt;double&gt; quartic_poly(double x0, double v0, double a0, double v1, double a1, double Time)\n//     {\n//         std::vector&lt;double&gt; coeff;\n//         coeff.resize(5);\n\n//         const double T2 = sq(Time);\n//         const double T3 = T2 * Time;\n\n//         coeff[0] = x0;\n//         coeff[1] = v0;\n//         coeff[2] = 0.5 * a0;\n//         coeff[3] = (3*(v1 - v0) - Time*(a1 + 2*a0)) / (3*T2);\n//         coeff[4] = (-2*(v1 - v0) + Time*(a1 + a0)) / (4*T3);\n\n//         return Polynomial&lt;double&gt;(coeff);\n//     }\n\n//     /**\n//      * @brief 5\u6b21\u88dc\u9593\n//      * \n//      * @tparam double \n//      * @param x0 \u59cb\u70b9\u4f4d\u7f6e\n//      * @param v0 \u59cb\u70b9\u901f\u5ea6\n//      * @param a0 \u59cb\u70b9\u52a0\u901f\u5ea6\n//      * @param x1 \u7d42\u70b9\u4f4d\u7f6e\n//      * @param v1 \u7d42\u70b9\u901f\u5ea6\n//      * @param a1 \u7d42\u70b9\u52a0\u901f\u5ea6\n//      * @param Time \u533a\u9593\u9577\u3055\n//      * @return Polynomial&lt;double&gt; \n//      */\n//     template &lt;typename double&gt;\n//     Polynomial&lt;double&gt; quintic_poly(double x0, double v0, double a0, double x1, double v1, double a1, double Time)\n//     {\n//         std::vector&lt;double&gt; coeff;\n//         coeff.resize(6);\n\n//         const double T2 = sq(Time);\n//         const double T3 = T2 * Time;\n//         const double T4 = T3 * Time;\n//         const double T5 = T4 * Time;\n\n//         coeff[0] = x0;\n//         coeff[1] = v0;\n//         coeff[2] = 0.5 * a0;\n//         coeff[3] = ( 20*(x1 - x0) -   Time*( 8*v1 + 12*v0) + T2*(a1 - 3*a0)) / (2*T3);\n//         coeff[4] = (-30*(x1 - x0) +   Time*(14*v1 + 16*v0) - T2*(a1 - 3*a0)) / (2*T4);\n//         coeff[5] = ( 12*(x1 - x0) - 6*Time*(   v1 +    v0) + T2*(a1 -   a0)) / (2*T5);\n\n//         return Polynomial&lt;double&gt;(coeff);\n//     }\n\n//     /**\n//      * @brief \u63a2\u7d22\u7bc4\u56f2\u7528\u8a2d\u5b9a\n//      * \n//      * @tparam double \n//      */\n//     struct frenet_path_config_t\n//     {\n//         double dt;\n//         double width;\n//         size_t width_num;\n//         double length_min, length_max;\n//         size_t length_num;\n//         double target_speed;\n//         double speed_interval;\n//         size_t speed_num;\n//         double K_J, K_T, K_D, K_LAT, K_LON;\n//     };\n\n//     struct frenet_path_point_t\n//     {\n//         double t;\n//         double d, d_d, d_dd, d_ddd;\n//         double s, s_d, s_dd, s_ddd;\n//         Vector2&lt;double&gt; pos;\n//         double theta;\n//         double ds;\n//         double curvature;\n//     };\n\n//     struct frenet_path_t : public std::vector&lt;frenet_path_point_t&lt;double&gt;&gt;\n//     {\n//         double cd, cv, cf;\n//     };\n\n//     struct frenet_path_state_t\n//     {\n//         double c_speed;\n//         double c_d;\n//         double c_d_d;\n//         double c_d_dd;\n//         double s0;\n//     };\n\n//     template &lt;typename double&gt;\n//     struct frenet_path_th_t\n//     {\n//         double max_speed;\n//         double max_accel;\n//         double max_curvature;\n//         double radius;\n//     };\n\n//     std::vector&lt;frenet_path_t&lt;double&gt;&gt; frenet_path(\n//         const frenet_path_config_t&lt;double&gt;&amp; config, \n//         const frenet_path_state_t&lt;double&gt;&amp; state)\n//     {\n//         double c_speed = state.c_speed;\n//         double c_d = state.c_d;\n//         double c_d_d = state.c_d_d;\n//         double c_d_dd = state.c_d_dd;\n//         double s0 = state.s0;\n\n//         auto dt = config.dt;\n//         std::vector&lt;frenet_path_t&lt;double&gt;&gt; paths;\n\n//         // \u5074\u65b9\u8ddd\u96e2\u5909\u5316\n//         for(size_t di_idx = 0; di_idx &lt; config.width_num; di_idx++)\n//         {\n//             //printf(\"di, %ld, %ld, %lf, %lf\\n\", di_idx, config.width_num-1, -config.width, config.width);\n//             double di = map&lt;double&gt;(di_idx, 0, config.width_num-1, -config.width, config.width);\n\n\n//             // \u8ddd\u96e2\u5909\u5316\n//             for(size_t Ti_idx = 0; Ti_idx &lt; config.length_num; Ti_idx++)\n//             {\n//                 double Ti = map&lt;double&gt;(Ti_idx, 0, config.length_num-1, config.length_min, config.length_max);\n\n//                 //printf(\"%lf, %lf, %lf, %lf, %lf\\n\", c_d, c_d_d, c_d_dd, di, Ti);\n//                 auto d_func = quintic_poly&lt;double&gt;(c_d, c_d_d, c_d_dd, di, 0, 0, Ti);\n//                 frenet_path_t&lt;double&gt; fp;\n//                 fp.resize(static_cast&lt;size_t&gt;(Ti/dt));\n\n//                 //d_print_vector(\"d_func\", d_func.coeff());\n\n//                 for(size_t t_idx = 0; t_idx &lt; fp.size(); t_idx++)\n//                 {\n//                     auto &amp;fpp = fp[t_idx];\n//                     fpp.t = t_idx * dt;\n//                     fpp.d = d_func(fpp.t);\n//                     //printf(\"fpp.t = %lf, d = %lf\\n\", fpp.t, fpp.d);\n//                     fpp.d_d   = d_func.polyder(1)(fpp.t);\n//                     fpp.d_dd  = d_func.polyder(2)(fpp.t);\n//                     fpp.d_ddd = d_func.polyder(3)(fpp.t);\n//                 }\n\n//                 // \u901f\u5ea6\u5909\u5316\n//                 for(size_t tv_idx = 0; tv_idx &lt; config.speed_num; tv_idx++)\n//                 {\n//                     double tv = map&lt;double&gt;(tv_idx, 0, config.speed_num-1, config.target_speed - config.speed_interval, config.target_speed + config.speed_interval);\n//                     frenet_path_t&lt;double&gt; tfp = fp;\n//                     auto s_func = quartic_poly&lt;double&gt;(s0, c_speed, 0, tv, 0, Ti);\n\n//                     double Jp = 0, Js = 0;\n//                     for(size_t t_idx = 0; t_idx &lt; tfp.size(); t_idx++)\n//                     {\n//                         auto &amp;tfpp = tfp[t_idx];\n//                         tfpp.t = t_idx * dt;\n//                         tfpp.s = s_func(tfpp.t);\n//                         tfpp.s_d   = s_func.polyder(1)(tfpp.t);\n//                         tfpp.s_dd  = s_func.polyder(2)(tfpp.t);\n//                         tfpp.s_ddd = s_func.polyder(3)(tfpp.t);\n\n//                         Jp += sq(tfpp.d_ddd);\n//                         Js += sq(tfpp.s_ddd);\n//                     }\n\n//                     double ds = sq(config.target_speed - tfp.back().s_d);\n\n//                     tfp.cd = config.K_J * Jp + config.K_T * Ti + config.K_D * sq(tfp.back().d);\n//                     tfp.cv = config.K_J * Js + config.K_T * Ti + config.K_D * ds;\n//                     tfp.cf = config.K_LAT * tfp.cd + config.K_LON * tfp.cv;\n\n//                     paths.push_back(tfp);\n//                 }\n//             }\n//         }\n\n//         return paths;\n//     }\n\n//     void frenet_path_to_global_path(std::vector&lt;frenet_path_t&lt;double&gt;&gt; &amp;fpath, const Trajectory2 &amp;ref_path)\n//     {\n//         // \u30d1\u30b9\u3054\u3068\n//         for(auto &amp;fp : fpath)\n//         {\n//             // \u70b9\u3054\u3068\n//             for(auto &amp;fpp : fp)\n//             {\n//                 auto patht = min&lt;double&gt;(fpp.s, ref_path.length());\n//                 //printf(\"patht: %lfm %lf\\n\", patht, fpp.s);\n//                 auto ref_idx = ref_path.linear_index(patht);\n\n//                 Vec2F pos = ref_path.position(ref_idx);\n//                 Vec2F vel = ref_path.velocity(ref_idx);\n//                 vel.normalize();\n//                 double yaw = vel.angle();\n//                 fpp.pos.x = pos.x + fpp.d * cos(yaw + HALF_PI);\n//                 fpp.pos.y = pos.y + fpp.d * sin(yaw + HALF_PI);\n//             }\n\n//             for(size_t i = 0; i &lt; fp.size()-1; i++)\n//             {\n//                 auto dpos = fp[i+1].pos - fp[i].pos;\n//                 if(!dpos.is_zero())\n//                 {\n//                     fp[i].theta = dpos.angle();\n//                     fp[i].ds = hypot(dpos.x, dpos.y);\n//                 }\n//                 else\n//                 {\n//                     fp[i].theta = fp[i].ds = 0;\n//                 }\n//             }\n\n//             for(size_t i = 0; i &lt; fp.size()-1; i++)\n//             {\n//                 fp[i].curvature = (fp[i+1].theta - fp[i].theta) / fp[i].ds;\n//             }\n//             fp.back().curvature = 0;\n//         }\n//     }\n\n//     bool check_collision(const Vector2&lt;double&gt; &amp;pos, double r, const std::vector&lt;Vector2&lt;double&gt;&gt;&amp; obstacles)\n//     {\n//         const double r2 = sq(r);\n//         for(auto &amp; ob : obstacles)\n//         {\n//             if(r2 &gt; (ob-pos).norm_sq())\n//                 return true; // \u885d\u7a81\u3059\u308b\u5224\u5b9a\n//         }\n//         return false;\n//     }\n\n//     void check_path(std::vector&lt;\n//         frenet_path_t&lt;double&gt;&gt; &amp;fpath, \n//         const frenet_path_th_t&lt;double&gt;&amp; ths,\n//         const std::vector&lt;Vector2&lt;double&gt;&gt;&amp; obstacles)\n//     {\n//         auto pit = fpath.begin();\n//         while(pit != fpath.end())\n//         {\n//             bool path_delete = false;\n//             for(auto &amp;fpp : (*pit))\n//             {\n//                 if(fpp.s_d &gt; ths.max_speed)\n//                     path_delete = true;\n\n//                 if(abs(fpp.s_dd) &gt; ths.max_accel)\n//                     path_delete = true;\n\n//                 // if(abs(fpp.curvature) &gt; ths.max_curvature)\n//                 //     path_delete = true;\n\n//                 if(check_collision&lt;double&gt;(fpp.pos, ths.radius, obstacles))\n//                     path_delete = true;\n//             }\n\n//             if (path_delete == true)\n//             {\n//                 //printf(\"erase\\n\");\n//                 pit = fpath.erase(pit);\n//             }\n//             else\n//             {\n//                 //printf(\"pit++;\\n\");\n//                 pit++;\n//             }\n//         }\n//     }\n\n//     std::tuple&lt;frenet_path_t&lt;double&gt;, std::vector&lt;frenet_path_t&lt;double&gt;&gt;&gt; frenet_optimal_planning(\n//         const frenet_path_config_t&lt;double&gt;&amp; config, \n//         const frenet_path_state_t&lt;double&gt;&amp; state,\n//         const Trajectory2 &amp;ref_path, \n//         const frenet_path_th_t&lt;double&gt;&amp; ths,\n//         const std::vector&lt;Vector2&lt;double&gt;&gt;&amp; obstacles)\n//     {\n//         auto frenet_paths = frenet_path(config, state);\n\n//         //printf(\"opt 1\\n\");\n\n//         frenet_path_to_global_path(frenet_paths, ref_path);\n\n//         //printf(\"opt 2\\n\");\n\n\n//         check_path&lt;double&gt;(frenet_paths, ths, obstacles);\n\n//         //printf(\"opt 3\\n\");\n\n//         auto it = frenet_paths.begin();\n//         double min_cost = (*it).cf;\n\n//         for(auto cit = frenet_paths.begin()+1; cit &lt; frenet_paths.end(); cit++)\n//         {\n//             if (min_cost &gt; (*cit).cf)\n//             {\n//                 min_cost = (*cit).cf;\n//                 it = cit;\n//             }\n//         }\n\n//         return {*it, frenet_paths};\n//     }\n// }\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/geometry_8hpp/","title":"include/cpp_robotics/geometry.hpp","text":""},{"location":"doxybook/Files/geometry_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"geometry/shape.hpp\"\n#include \"geometry/intersect.hpp\"\n#include \"geometry/geometry_stream.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/geometry__stream_8hpp/","title":"include/cpp_robotics/geometry/geometry_stream.hpp","text":""},{"location":"doxybook/Files/geometry__stream_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/geometry__stream_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;iostream&gt;\n#include \"../vector/vector2.hpp\"\n#include \"../vector/vector3.hpp\"\n#include \"../vector/vector4.hpp\"\n#include \"../vector/transform.hpp\"\n\nnamespace cpp_robotics\n{\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Vector2d&amp; v)\n{\nos &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \")\";\nreturn os;\n}\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Vector3d&amp; v)\n{\nos &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z &lt;&lt; \")\";\nreturn os;\n}\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Vector4d&amp; v)\n{\nos &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z &lt;&lt; \", \" &lt;&lt; v.w &lt;&lt; \")\";\nreturn os;\n}\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Transformd&amp; v)\n{\nos &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.theta &lt;&lt; \")\";\nreturn os;\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/ginac__utils_8hpp/","title":"include/cpp_robotics/utility/ginac_utils.hpp","text":""},{"location":"doxybook/Files/ginac__utils_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/ginac__utils_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Geometry&gt;\n#include &lt;ginac/ginac.h&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;int ROWS, int COLS&gt;\nvoid cout_exmat(const Eigen::Matrix&lt;GiNaC::ex, ROWS, COLS&gt;&amp; mat, std::string name = \"\") {\nif(name != \"\")\nstd::cout &lt;&lt; name + \": \" &lt;&lt; std::endl;\nfor(int r = 0; r &lt; mat.rows(); r++)\n{\nfor(int c = 0; c &lt; mat.cols(); c++)\n{\nstd::cout &lt;&lt; mat(r,c) &lt;&lt; \", \";\n}\nstd::cout &lt;&lt; std::endl;\n}\nstd::cout &lt;&lt; std::endl;\n}\n\ntemplate&lt;int ROWS, int COLS&gt;\nvoid simplify_indexed(Eigen::Matrix&lt;GiNaC::ex, ROWS, COLS&gt; &amp;mat) {\nfor(int r = 0; r &lt; mat.rows(); r++)\n{\nfor(int c = 0; c &lt; mat.cols(); c++)\n{\nmat(r,c) = mat(r,c).simplify_indexed();\n}\n}\n}\n\ntemplate&lt;int ROWS, int COLS&gt;\nvoid expand(Eigen::Matrix&lt;GiNaC::ex, ROWS, COLS&gt; &amp;mat) {\nfor(int r = 0; r &lt; mat.rows(); r++)\n{\nfor(int c = 0; c &lt; mat.cols(); c++)\n{\nmat(r,c) = mat(r,c).expand();\n}\n}\n}\n\ntemplate&lt;int ROWS, int COLS&gt;\nvoid subs(Eigen::Matrix&lt;GiNaC::ex, ROWS, COLS&gt; &amp;mat, const GiNaC::lst exlst) {\nfor(int r = 0; r &lt; mat.rows(); r++)\n{\nfor(int c = 0; c &lt; mat.cols(); c++)\n{\nmat(r,c) = mat(r,c).subs(exlst);\n}\n}\n}\n\ntemplate&lt;int IN_ROWS, int IN_COLS, int OUT_ROWS, int OUT_COLS&gt;\nvoid to_double_matrix(Eigen::Matrix&lt;GiNaC::ex, IN_ROWS, IN_COLS&gt; &amp;in_mat, Eigen::Matrix&lt;double, OUT_ROWS, OUT_COLS&gt; &amp;out_mat) {\nfor(int r = 0; r &lt; in_mat.rows(); r++)\n{\nfor(int c = 0; c &lt; in_mat.cols(); c++)\n{\nout_mat(r,c) = GiNaC::ex_to&lt;GiNaC::numeric&gt;(in_mat(r,c)).to_double();\n}\n}\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/golden__serach_8hpp/","title":"include/cpp_robotics/optimize/golden_serach.hpp","text":""},{"location":"doxybook/Files/golden__serach_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/golden__serach_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics {\n\nstatic double golden_search(std::function&lt;double(double)&gt; f, double low, double high, const double tol = 1e-6, const size_t max_iter = 100)\n{\nconstexpr double r = (-1.0 + std::sqrt(5)) / 2.0;\ndouble a1 = low + (1.0 - r) * (high - low);\ndouble a2 = low + (r) * (high - low);\ndouble f1 = f(a1);\ndouble f2 = f(a2);\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\nif(std::abs(high - low) &lt; tol)\nreturn 0.5 * (low + high);\n\nif(f1 &lt; f2)\n{\nhigh = a2;\na2 = a1;\na1 = low + (1.0 - r) * (high - low);\nf2 = f1;\nf1 = f(a1);\n}\nelse\n{\nlow = a1;\na1 = a2;\na2 = low + (r) * (high - low);\nf1 = f2;\nf2 = f(a2);\n}\n}\nreturn 0.5 * (low + high);\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/","title":"include/cpp_robotics/path_planning/grid_path_planning_utils.hpp","text":""},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::grid_path_planning_utils::GridNode"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics::grid_path_planning_utils\n{\n\nstruct GridNode\n{\nGridNode():\ncost(0), hcost(0)\n{\npos.setZero();\nparent.setZero();\n}\nbool operator == (const GridNode&amp; o ) { return pos == o.pos; }\nbool operator == (const Eigen::Vector2i&amp; o ) { return pos == o; }\nbool operator &lt; (const GridNode&amp; o ) { return hcost + cost &lt; o.hcost + o.cost; }\nEigen::Vector2i pos, parent;\nint cost, hcost;\nint score() { return cost + hcost; }\n};\n\nstatic bool contain_in_map(const Eigen::MatrixXi&amp; map, const Eigen::Vector2i&amp; p)\n{\nif(0 &lt;= p(0) &amp;&amp; p(0) &lt; map.rows() &amp;&amp; 0 &lt;= p(1) &amp;&amp; p(1) &lt; map.cols())\nreturn true;\nreturn false;\n}\n\nstatic int dist(const Eigen::Vector2i&amp; pos, const Eigen::Vector2i&amp; end)\n{\nconst Eigen::Vector2i d = end - pos;\nreturn std::min(std::abs(d(0)) , std::abs(d(0))); // 8\u65b9\u5411\u79fb\u52d5\u3092\u60f3\u5b9a https://qiita.com/2dgames_jp/items/f29e915357c1decbc4b7#%E6%8E%A2%E7%B4%A2%E3%82%92%E9%96%8B%E5%A7%8B\n}\n\ntemplate&lt;typename T&gt;\nbool in_range_open(T x, T min, T max) {\nreturn ((min &lt; x &amp;&amp; x &lt; max) ? true : false);\n}\n\nbool is_valid(const Eigen::Vector2i&amp; pos, size_t row, size_t col)\n{\nif(in_range_open&lt;int&gt;(pos(0), -1, row) &amp;&amp; in_range_open&lt;int&gt;(pos(1), -1, col))\nreturn true;\nreturn false;\n}\n\nbool is_wall(const Eigen::Vector2i&amp; pos, size_t row, size_t col)\n{\nif(in_range_open&lt;int&gt;(pos(0), -1, row) &amp;&amp; in_range_open&lt;int&gt;(pos(1), -1, col))\nreturn true;\nreturn false;\n}\n\nbool is_correct_step(const Eigen::Vector2i&amp; pos, const Eigen::MatrixXi&amp; map)\n{\nif(is_valid(pos, map.rows(), map.cols()))\n{\nif(not map(pos(0), pos(1)))\nreturn true;\n}\nreturn false;\n}\n\nbool exist(std::list&lt;GridNode&gt; &amp;open, std::list&lt;GridNode&gt; &amp;closed, const Eigen::Vector2i&amp; p, int cost) {\nstd::list&lt;GridNode&gt;::iterator i;\ni = std::find( closed.begin(), closed.end(), p );\nif( i != closed.end() ) { // \u65e2\u306bclosed\u5185\u306b\u5b58\u5728\u3059\u308b\nif( ( *i ).cost + ( *i ).hcost &lt; cost ) return true; // \u5b58\u5728\u3059\u308b\u306e\u3067true\u3092\u8fd4\u3059\nelse { closed.erase( i ); return false; } // \u5b58\u5728\u3059\u308b\u304c\u65b0\u3057\u304f\u898b\u3064\u304b\u3063\u305f\u307b\u3046\u304c\u30b3\u30b9\u30c8\u304c\u5c0f\u3055\u3044\u306e\u3067\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u306b\u6d88\u3057\u3066\u3001false\u3092\u8fd4\u3059\n}\ni = std::find( open.begin(), open.end(), p );\nif( i != open.end() ) { // open\u5185\u306b\u5b58\u5728\u3059\u308b\nif( ( *i ).cost + ( *i ).hcost &lt; cost ) return true; // \u4e0a\u306b\u540c\u3058\nelse { open.erase( i ); return false; }\n}\nreturn false; // \u5b58\u5728\u3057\u306a\u3044\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/high__pass__filter_8hpp/","title":"include/cpp_robotics/filter/high_pass_filter.hpp","text":""},{"location":"doxybook/Files/high__pass__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/high__pass__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/high__pass__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n// G(s) = s / (s + omega)\n// \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e\nclass HighPassFilter: public TransferFunction\n{\npublic:\nHighPassFilter(double omega, double dt):\nomega_(omega)\n{\nTransferFunction::set_continuous({1, 0}, {1, omega_}, dt);\n}\n\ndouble filtering(double u) { return responce(u); } double omega() const { return omega_; }\nprivate:\nconst double omega_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/icp_8hpp/","title":"include/cpp_robotics/algorithm/icp.hpp","text":""},{"location":"doxybook/Files/icp_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/icp_8hpp/#source-code","title":"Source code","text":"<pre><code>// https://clientver2.hatenablog.com/entry/2015/11/27/160814\n// http://nghiaho.com/?page_id=671\n\n#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"./kdtree.hpp\"\n#include \"./transformation.hpp\"\n\nnamespace cpp_robotics\n{\n\n// dest\u3092\u56de\u8ee2\u3055\u305b\u3066src\u306b\u91cd\u306d\u308b\u6642\u306e\u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u8a08\u7b97\u3059\u308b\ntemplate&lt;int DIM&gt;\nstatic std::pair&lt;Eigen::Matrix&lt;double, DIM, DIM&gt;, Eigen::Matrix&lt;double, DIM, 1&gt;&gt; calcu_transformatoin(\nstd::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; dest,\nstd::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; fixed)\n{\nassert(fixed.size() == dest.size());\nusing vector_type = Eigen::Matrix&lt;double, DIM, 1&gt;;\nusing matrix_type = Eigen::Matrix&lt;double, DIM, DIM&gt;;\n\nconst size_t dim = dest[0].size();\nconst size_t len = fixed.size();\n\n// detrend\nvector_type mean_fixed = vector_type::Zero();\nvector_type mean_dest = vector_type::Zero();\nfor(auto &amp; v : fixed)\nmean_fixed += v/static_cast&lt;double&gt;(len);\nfor(auto &amp; v : fixed)\nv -= mean_fixed;\n\nfor(auto &amp; v : dest)\nmean_dest += v/static_cast&lt;double&gt;(len);\nfor(auto &amp; v : dest)\nv -= mean_dest;\n\n// \u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u6c42\u3081\u308b\nEigen::Matrix&lt;double, DIM, DIM&gt; H = Eigen::Matrix&lt;double, DIM, DIM&gt;::Zero();\n\nfor(size_t i = 0; i &lt; len; i++)\n{\nH += dest[i] * fixed[i].transpose(); }\n\nEigen::JacobiSVD svd(H, Eigen::ComputeFullU | Eigen::ComputeFullV);\n\nmatrix_type R = svd.matrixV() * svd.matrixU().transpose();\nvector_type T = (-R*mean_dest) + mean_fixed;\nreturn {R, T};\n}\n\n// Todo: R, T\u3092\u8fd4\u3059\u3088\u3046\u306b\u3059\u308b\n// Todo: \u7d42\u4e86\u6761\u4ef6\u3064\u3051\u308b\ntemplate&lt;int DIM&gt;\nstatic std::tuple&lt;std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt;, Eigen::MatrixXd, size_t&gt; icp(\nstd::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; dest,\nconst std::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; &amp;fixed,\ndouble eps = 1e-4,\nsize_t max_iter = 100) {\nconst size_t dim = dest[0].size();\nKDTree&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; kdtree(fixed, dim);\nEigen::MatrixXd H = Eigen::MatrixXd::Identity(dim+1, dim+1);\n\nsize_t i = 0;\nfor(; i &lt; max_iter; i++)\n{\n// \u70b9\u7fa4\u73fe\u5728\u306e\u72b6\u614b\u3067\u70b9\u7fa4\u306e\u5bfe\u5fdc\u3092\u53d6\u308b\nauto nerghbor_idx = kdtree.nn_search(dest);\nstd::vector&lt;Eigen::Matrix&lt;double, DIM, 1&gt;&gt; target(nerghbor_idx.size());\nfor(size_t j = 0; j &lt; nerghbor_idx.size(); j++)\n{\n// std::cout &lt;&lt; nerghbor_idx[j] &lt;&lt; std::endl;\ntarget[j] = fixed[nerghbor_idx[j]];\n// target[j] = fixed[j]; // debug\n}\n\n// \u70b9\u7fa4\u306e\u5bfe\u5fdc\u3067\u79fb\u52d5\u91cf\u3092\u8a08\u7b97\u3059\u308b\nauto [R, T] = calcu_transformatoin(dest, target);\n\n// \u79fb\u52d5\u3055\u305b\u308b\nfor(size_t j = 0; j &lt; dest.size(); j++)\n{\ndest[j] = R*dest[j] + T;\n}\n\n// homogeneous transformation\u884c\u5217\u306e\u66f4\u65b0\nEigen::MatrixXd Ht = homogeneous(R, T);\nH *= Ht;\n\n// \u53ce\u675f\u5224\u5b9a\n}\nreturn {dest, H, i};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/integrator_8hpp/","title":"include/cpp_robotics/filter/integrator.hpp","text":""},{"location":"doxybook/Files/integrator_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/integrator_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Integrator \u7a4d\u5206\u5668"},{"location":"doxybook/Files/integrator_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n// G(s) = 1 / s\n// \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e\nclass Integrator : public TransferFunction\n{\npublic:\nIntegrator(double dt)\n{\nTransferFunction::set_continuous({1}, {1, 0}, dt);\n}\n\ndouble filtering(double u) { return responce(u); } };\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/interior__point__method_8hpp/","title":"include/cpp_robotics/optimize/interior_point_method.hpp","text":""},{"location":"doxybook/Files/interior__point__method_8hpp/#source-code","title":"Source code","text":"<pre><code>// #pragma once\n\n// #include \"./derivative.hpp\"\n// #include \"./constraint.hpp\"\n\n// namespace cpp_robotics\n// {\n\n// // \u5185\u70b9\u6cd5\n// class InteriorPointMethod\n// {\n// public:\n//     InteriorPointMethod() = default;\n\n//     struct Problem\n//     {\n//         std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f;\n//         ConstraintArray constraint;\n//         Eigen::VectorXd x_init;\n//         const double rho_tol = 1e-3;\n//         const size_t max_iter = 1000;\n//         const double constraint_merit_gain = 0.1;\n//         double slack_gain_init = 1.0;\n//     };\n\n//     struct Result\n//     {\n//         bool is_solved;\n//         Eigen::VectorXd x;\n//         size_t iter_count;\n//     };\n\n//     Result solve(Problem prob)\n//     {\n//         auto [f, constraint, x_init, rho_tol, max_iter, eta, rho] = prob;\n\n//         size_t x_dim = x_init.rows();\n//         size_t eq_cnt = constraint.eq_constraint_size();\n//         size_t ineq_cnt = constraint.ineq_constraint_size();\n//         size_t con_cnt = constraint.size();\n\n//         auto eq_con_func = constraint.gen_eq_constraint_list();\n//         auto ineq_con_func = constraint.gen_ineq_constraint_list();\n\n//         auto x = x_init;\n//         auto s = Eigen::VectorXd::Ones(ineq_cnt).eval(); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u305f\u3081\u306e\u30b9\u30e9\u30c3\u30af\u5909\u6570\n//         auto u = Eigen::VectorXd::Zero(con_cnt).eval();  // \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u5b9a\u6570\n//         // Todo: \u7b49\u5f0f\u5236\u7d04\u3068\u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u5206\u3051\u3066\u8003\u3048\u76f4\u3059\n\n//         // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\n//         auto merit_func = [&amp;](const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;s, const Eigen::VectorXd &amp;u)\n//         {\n//             double val = f(x);\n\n//             for(size_t i = 0; i &lt; ineq_cnt; i++)\n//             {\n//                 val += -rho * std::log(s(i));\n//             }\n\n//             for(size_t i = 0; i &lt; ineq_cnt; i++)\n//             {\n//                 val += -eta * std::abs( ineq_con_func[i].eval(x) + s(i) );\n//             }\n\n//             for(size_t i = 0; i &lt; eq_cnt; i++)\n//             {\n//                 val += -eta * std::abs( eq_con_func[i].eval(x) );\n//             }\n\n//             return val;\n//         };\n\n//         size_t i = 0;\n//         for(; i &lt; max_iter; i++)\n//         {\n//             // \u7d42\u4e86\u6761\u4ef6\u30c1\u30a7\u30c3\u30af\n//             if(std::abs(rho) &lt; rho_tol)\n//                 break;\n\n//             // Todo: \u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u7acb\u3066\u3066\u89e3\u304d\u3001\u305d\u308c\u305e\u308c\u306e\u66f4\u65b0\u65b9\u5411\u3092\u6c42\u3081\u308b\n//             Eigen::MatrixXd A = Eigen::MatrixXd::Zero(4, x_dim + ineq_cnt + con_cnt);\n//             Eigen::VectorXd b = Eigen::VectorXd::Zero(4, 1);\n\n//             // A.block(0,0, x_dim, x_dim) = Eigen::MatrixXd::Zero(x_dim, x_dim);\n//             // b(0) = 1;\n//             // b(1) = 1;\n//             // b(2) = 1;\n//             // b(3) = 1;\n\n//             auto dstate = A.partialPivLu().solve(b);\n\n//             auto dx = dstate.segment(0, x_dim);\n//             auto ds = dstate.segment(x_dim, ineq_cnt);\n//             auto du = dstate.segment(x_dim+ineq_cnt, con_cnt);\n\n//             // \u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\n//             // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306b\u5bfe\u3057\u3066\u63a2\u7d22\u65b9\u5411\u3092\u9069\u5fdc\u3057\u305f\u6642\u306b\u8a55\u4fa1\u5024\u304c\u6700\u5c0f\u306b\u306a\u308b\u3088\u3046\u306a\u30b9\u30c6\u30c3\u30d7\u3092\u6c42\u3081\u308b\n//             double alpha = bracketing_serach([&amp;](double v){ return merit_func(x+v*dx, s+v*ds, u+v*du); });\n\n//             // \u72b6\u614b\u91cf\u3092\u66f4\u65b0\u3059\u308b\n//             x += alpha * dx;\n//             s += alpha * ds;\n//             u += alpha * du;\n\n//             // Todo: rho\u3092\u66f4\u65b0\u3059\u308b\n//             // rho = gamma * (1) / static_cast&lt;double&gt;(ineq_cnt);\n//         }\n//     }\n\n\n// };\n\n// }\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/intersect_8hpp/","title":"include/cpp_robotics/geometry/intersect.hpp","text":""},{"location":"doxybook/Files/intersect_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/intersect_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;optional&gt;\n#include \"./shape.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace detail\n{\nstatic double distance_sq(const Vector2d &amp;begin, const Vector2d &amp;end, const Vector2d &amp;p)\n{\nconst double l2 = (begin - end).norm_sq();\n\nif (l2 == 0.0)\n{\nreturn (begin - p).norm_sq();\n}\n\nconst double t = std::clamp&lt;double&gt;((p - begin).dot(end - begin) / l2, 0.0, 1.0);\n\nconst Vector2d projection = begin + t * (end - begin);\n\nreturn (p - projection).norm_sq();\n}\n}\n\nbool intersect(const Vector2d&amp; a, const Vector2d&amp; b)\n{\nreturn (a == b);\n}\n\nbool intersect(const Vector2d&amp; a, const Line&amp; b)\n{\nreturn approx_zero(detail::distance_sq(b.p0, b.p1, a));\n}\n\nbool intersect(const Vector2d&amp; a, const Rect&amp; b)\n{\nconst auto tv = b.size/2;\nreturn ((b.center.x-tv.x &lt; a.x &amp;&amp; a.x &lt; b.center.x+tv.x) &amp;&amp;\n(b.center.y-tv.y &lt; a.y &amp;&amp; a.y &lt; b.center.y+tv.y));\n}\n\nbool intersect(const Vector2d&amp; a, const Circle&amp; b)\n{\nreturn (b.center-a).norm_sq() &lt;= square(b.r);\n}\n\n// bool intersect(const Vector2d&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Vector2d&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n\nbool intersect(const Line&amp; a, const Vector2d&amp; b)\n{\nreturn intersect(b, a);\n}\n\n// bool intersect(const Line &amp;a, const Line &amp;b)\n// {\n//     return false; // Todo\n// }\n\nbool intersect(const Line&amp; a, const Circle&amp; b)\n{\nconst Vector2d ab = a.p1 - a.p0;\nconst Vector2d ac = b.center - a.p0;\nconst Vector2d bc = b.center - a.p1;\nconst double e = ac.dot(ab);\nconst double rr = b.r * b.r;\n\nif (e &lt;= 0.0)\n{\nreturn ac.dot(ac) &lt;= rr;\n}\n\nconst double f = ab.dot(ab);\n\nif (e &gt;= f)\n{\nreturn bc.dot(bc) &lt;= rr;\n}\n\nreturn (ac.dot(ac) - e * e / f) &lt;= rr;\n}\n\n// bool intersect(const Line&amp; a, const Rect&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Line&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Line&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\nbool intersect(const Rect&amp; a, const Vector2d&amp; b)\n{\nreturn intersect(b, a); }\n\n// bool intersect(const Rect&amp; a, const Line&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Rect&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Rect&amp; a, const Circle&amp; b)\n// {\n//     return false; // Todo\n// }\n\nbool intersect(const Circle&amp; a, const Vector2d&amp; b)\n{\nreturn intersect(b, a);\n}\n\n// bool intersect(const Circle&amp; a, const Line&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Rect&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Quad&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Triangle&amp; b)\n// {\n//     return false; // Todo\n// }\n\n// bool intersect(const Circle&amp; a, const Circle&amp; b)\n// {\n//     return false; // Todo\n// }\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Vector2d&amp; b)\n{\nif(a == b)\nreturn std::vector&lt;Vector2d&gt;{a};\nreturn std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Line&amp; b)\n{\ndouble l = detail::distance_sq(b.p0, b.p1, a);\nif(approx_zero(l))\nreturn std::vector&lt;Vector2d&gt;{a};\nreturn std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Rect&amp; b)\n{\nfor(auto &amp;line : b.outline())\n{\nauto v = intersect_at(a, line);\nif(v)\nreturn v;\n}\nreturn std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Vector2d&amp; a, const Circle&amp; b)\n{\nif(approx_eq((b.center - a).norm(), b.r))\nreturn std::vector&lt;Vector2d&gt;{a};\nreturn std::nullopt;\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Line&amp; a, const Vector2d&amp; b)\n{\nreturn intersect_at(b, a);\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Line&amp; a, const Line&amp; b)\n{\nconst Vector2d r = a.p1 - a.p0;\nconst Vector2d s = b.p1 - b.p0;\nconst Vector2d qp = b.p0 - a.p0;\nconst double rxs = r.x * s.y - r.y * s.x;\nconst double qpxr = qp.x * r.y - qp.y * r.x;\nconst double qpxs = qp.x * s.y - qp.y * s.x;\nconst bool rxs_is_zero = approx_zero(rxs);\n\nif (rxs_is_zero &amp;&amp; approx_zero(qpxr))\n{\nconst double qpr = qp.dot(r);\nconst double pqs = (a.p0 - b.p0).dot(s);\nif ((0 &lt;= qpr &amp;&amp; qpr &lt;= r.dot(r)) || (0 &lt;= pqs &amp;&amp; pqs &lt;= s.dot(s)))\n{\n// Two lines are overlapping            \nreturn std::nullopt;\n}\n// Two lines are collinear but disjoint.\nreturn std::nullopt;\n}\n\nif (rxs_is_zero &amp;&amp; !approx_zero(qpxr))\n{\n// Two lines are parallel and non-intersecting.\nreturn std::nullopt;\n}\n\nconst double t = qpxs / rxs;\nconst double u = qpxr / rxs;\nif ((!rxs_is_zero) &amp;&amp; (0.0 &lt;= t &amp;&amp; t &lt;= 1.0) &amp;&amp; (0.0 &lt;= u &amp;&amp; u &lt;= 1.0))\n{\n// An intersection was found\nreturn std::vector&lt;Vector2d&gt;{ (a.p0 + t * r) };\n}\n\n// Two line segments are not parallel but do not intersect\nreturn std::nullopt;\n}\n\n// std::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Line&amp; a, const Circle&amp; b)\n// {\n//     return std::nullopt; // Todo\n// }\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Rect&amp; a, const Vector2d&amp; b)\n{\nreturn intersect_at(b, a);\n}\n\nstd::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Circle&amp; a, const Vector2d&amp; b)\n{\nreturn intersect_at(b, a);\n}\n\n// std::optional&lt;std::vector&lt;Vector2d&gt;&gt; intersect_at(const Circle&amp; a, const Line&amp; b)\n// {\n//     return intersect_at(b, a);\n// }\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/k__means__method_8hpp/","title":"include/cpp_robotics/algorithm/k_means_method.hpp","text":""},{"location":"doxybook/Files/k__means__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/k__means__method_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::KMeansMethod K-means\u6cd5"},{"location":"doxybook/Files/k__means__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class PointType&gt;\nclass KMeansMethod\n{\npublic:\nusing point_t = PointType;\nKMeansMethod() = default;\n\nstd::vector&lt;size_t&gt; fit(std::vector&lt;point_t&gt; &amp;data_set, size_t cluster_size, size_t max_iter = 1000)\n{\ncluster_size_ = cluster_size;\npoint_t zero_point = get_zero_point(data_set[0]);\nlabel_.resize(data_set.size());\nstd::vector&lt;size_t&gt; prev_label(data_set.size(), 0);\n\n// \u30e9\u30d9\u30eb\u306e\u521d\u671f\u5024\u751f\u6210\nsize_t cnt = 0;\nfor(auto &amp;label : label_)\n{\nlabel = cnt++;\ncnt %= cluster_size_;\n}\n\ncluster_center_.resize(cluster_size_);\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\n// \u30af\u30e9\u30b9\u30bf\u306e\u91cd\u5fc3\u3092\u8a08\u7b97\nstd::vector&lt;std::vector&lt;point_t&gt;&gt; dist_(cluster_size_);\nfor(auto &amp;dist_item : dist_)\n{\ndist_item.reserve(data_set.size() / cluster_size_);\n}\nfor(size_t p_idx = 0; p_idx &lt; data_set.size(); p_idx++)\n{\ndist_[label_[p_idx]].push_back(data_set[p_idx]);\n}\nfor(size_t c_idx = 0; c_idx &lt; cluster_size_; c_idx++)\n{\ncluster_center_[c_idx] = std::accumulate(dist_[c_idx].begin(), dist_[c_idx].end(), zero_point) / (double)dist_[c_idx].size();\n}\n\n// \u7dcf\u5f53\u308a\u3067\u30e9\u30d9\u30eb\u3092\u5404\u30af\u30e9\u30b9\u30bf\u91cd\u5fc3\u306b\u8fd1\u3044\u3082\u306e\u306b\u5909\u66f4\u3059\u308b\nfor(size_t p_idx = 0; p_idx &lt; data_set.size(); p_idx++)\n{\nlabel_[p_idx] = predict(data_set[p_idx]);\n}\n\n// \u30e9\u30d9\u30eb\u304c\u5909\u5316\u3057\u306a\u304b\u3063\u305f\u3089\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3092\u7d42\u4e86\nif(prev_label == label_)\nbreak;\n}\n\nreturn label_;\n}\n\nsize_t predict(const point_t &amp;x)\n{\nauto min_itr = std::min_element(cluster_center_.begin(), cluster_center_.end(), [&amp;](auto &amp;a, auto &amp;b){\nreturn (a-x).norm() &lt; (b-x).norm();\n});\nreturn std::distance(cluster_center_.begin(), min_itr);\n}\n\nprivate:\npoint_t get_zero_point(const point_t &amp;tmp)\n{\n(void) tmp;\nreturn point_t();\n}\n\nprivate:\nstd::vector&lt;size_t&gt; label_;\nstd::vector&lt;point_t&gt; cluster_center_;\nsize_t cluster_size_;\n};\n\n// \u52d5\u7684\u306aEigen\u306e\u30d9\u30af\u30c8\u30eb\u306f\u521d\u671f\u5316\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5b9f\u614b\u3092\u6301\u305f\u306a\u3044\u306e\u3067\u7279\u6b8a\u5316\ntemplate&lt;&gt;\nEigen::VectorXd KMeansMethod&lt;Eigen::VectorXd&gt;::get_zero_point(const Eigen::VectorXd &amp;tmp)\n{\nreturn Eigen::VectorXd::Zero(tmp.size());\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/kalman__filter_8hpp/","title":"include/cpp_robotics/filter/kalman_filter.hpp","text":""},{"location":"doxybook/Files/kalman__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/kalman__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/kalman__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\n/*\n[\u30e2\u30c7\u30eb]\nx(t) = F*x(t-1) + G*u(t) + w(t)\nz(t) = H*x(t) + v(t)\n\nx: \u72b6\u614b\u91cf (n*1)\nu: \u5236\u5fa1\u91cf (r*1)\nz: \u89b3\u6e2c\u91cf (p*1)\nF: \u72b6\u614b\u9077\u79fb\u884c\u5217 (n*n)\nG: \u5236\u5fa1\u884c\u5217 (n*r)\nH: \u89b3\u6e2c\u884c\u5217 (p*n)\n\nQ: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (n*n)\nw: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba (n*1) \n    N[0, Q]\u306b\u5f93\u3046\nR: \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (p*p)\nv: \u89b3\u6e2c\u30ce\u30a4\u30ba (p*1)\n    N[0, R]\u306b\u5f93\u3046\n\n[\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf]\n- \u4e88\u6e2c\n    \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\n    x = Fx + Gu\n\n    \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = FPF^T + Q\n\n- \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\n    \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\n    K = PH^T(HPH^T + R)^-1\n\n    \u72b6\u614b\u63a8\u5b9a\n    x = x + K(z - Hx)\n\n    \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\n    P = (I -KH)P\n\n*/\n\ntemplate&lt;typename FLOATING_TYPE, size_t STATE_SIZE, size_t INPUT_SIZE, size_t OBSERVE_SIZE&gt;\nclass KalmanFilter\n{\npublic:\nusing value_type = FLOATING_TYPE;\nstatic constexpr size_t state_size = STATE_SIZE;\nstatic constexpr size_t input_size = INPUT_SIZE;\nstatic constexpr size_t observe_size = OBSERVE_SIZE;\n\nusing x_vec_t = Eigen::Matrix&lt;value_type, state_size, 1&gt;;\nusing u_vec_t = Eigen::Matrix&lt;value_type, input_size, 1&gt;;\nusing z_vec_t = Eigen::Matrix&lt;value_type, observe_size, 1&gt;;\n\nusing f_mat_t = Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\nusing g_mat_t = Eigen::Matrix&lt;value_type, state_size, input_size&gt;;\nusing h_mat_t = Eigen::Matrix&lt;value_type, observe_size, state_size&gt;;\n\nusing q_mat_t = Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\nusing r_mat_t = Eigen::Matrix&lt;value_type, observe_size, observe_size&gt;;\n\nusing p_mat_t = Eigen::Matrix&lt;value_type, state_size, state_size&gt;;\n\nf_mat_t F;\ng_mat_t G;\nh_mat_t H;\nq_mat_t Q;\nr_mat_t R;\n\nKalmanFilter() = default;\n\nvoid reset(x_vec_t x, p_mat_t P)\n{\nx_ = x;\nP_ = P;\n}\n\nx_vec_t filtering(u_vec_t u, z_vec_t z)\n{\n// \u72b6\u614b\u4e88\u6e2c x = Fx + Bu\nx_ = F*x_ + G*u;\n\n// \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q\nP_ = F*P_*(F.transpose()) + Q;\n\n// \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97 K = PH^T(HPH^T + R)^-1\nauto K = P_*H.transpose() * (R + H*P_*H.transpose()).inverse();\n\n// \u72b6\u614b\u66f4\u65b0 x = x + K(z - Hx)\nx_ += K*(z - H*x_);\n\n// \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I - KH)P\nauto I = Eigen::Matrix&lt;value_type, state_size, state_size&gt;::Identity();\n\nP_ = (I - K*H)*P_;\n\nreturn x_;\n}\n\nx_vec_t get_x() { return x_; } // \u63a8\u5b9a\u3057\u305f\u72b6\u614b\np_mat_t get_P() { return P_; } // \u5171\u5206\u6563\u884c\u5217\n\nprivate:\n// \u72b6\u614b\u91cf\nx_vec_t x_;\n// \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\np_mat_t P_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/kdtree_8hpp/","title":"include/cpp_robotics/algorithm/kdtree.hpp","text":""},{"location":"doxybook/Files/kdtree_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/kdtree_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::KDTree k-d\u6728"},{"location":"doxybook/Files/kdtree_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;memory&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class POINT_T&gt;\nclass KDTree\n{\npublic:\nusing point_type = POINT_T;\n\nKDTree() = default;\nKDTree(std::vector&lt;point_type&gt; point, size_t dimention)\n{\nbuild(point, dimention);\n}\n\nvoid clear()\n{\nroot_.reset();\n}\n\nvoid build(std::vector&lt;point_type&gt; point, size_t dimention)\n{\ndimention_ = dimention;\npoints_ = point;\npidx_.resize(points_.size());\nstd::iota(pidx_.begin(), pidx_.end(), 0);\nroot_ = build_recursive(pidx_.begin(), pidx_.end(), 0);\n}\n\nsize_t nn_search(const point_type &amp;point) const\n{\nsize_t ret = 0;\ndouble min_dist = std::numeric_limits&lt;double&gt;::max();\nnn_search_recursive(root_, point, ret, min_dist);\nreturn ret;\n}\n\nstd::vector&lt;size_t&gt; nn_search(const std::vector&lt;point_type&gt; &amp;point) const\n{\nstd::vector&lt;size_t&gt; ret(point.size());\nfor(size_t i = 0; i &lt; point.size(); i++)\n{\nret[i] = nn_search(point[i]);\n}\nreturn ret;\n}\n\nstd::vector&lt;size_t&gt; knn_search(const point_type &amp;point, size_t k) const\n{\nstd::vector&lt;std::pair&lt;size_t, double&gt;&gt; pair_ret;\npair_ret.reserve(k+1);\nknn_search_recursive(root_, point, k, pair_ret);\nstd::vector&lt;size_t&gt; ret(pair_ret.size());\nfor(size_t i = 0; i &lt; pair_ret.size(); i++)\n{\nret[i] = pair_ret[i].first;\n}\nreturn ret;\n}\n\nstd::vector&lt;size_t&gt; radius_search(const point_type &amp;point, double radius) const\n{\nstd::vector&lt;size_t&gt; ret;\nradius_search_recursive(root_, point, radius, ret);\nreturn ret;\n}\n\nstd::vector&lt;point_type&gt; get_points(const std::vector&lt;size_t&gt; &amp;idx) const\n{\nstd::vector&lt;point_type&gt; ret(idx.size());\n\nfor(size_t i = 0; i &lt; idx.size(); i++)\n{\nret[i] = points_[idx[i]];\n}\n\nreturn ret;\n}\n\nstd::vector&lt;point_type&gt; knn_search_points(const point_type &amp;point, size_t k) const\n{\nauto idx = knn_search(point, k);\nreturn get_points(idx);\n}\n\nstd::vector&lt;point_type&gt; radius_search_points(const point_type &amp;point, double radius) const\n{\nauto idx = radius_search(point, radius);\nreturn get_points(idx);\n}\n\nvoid debug_node()\n{\ndebug_node_recursive(root_, 0);\n}\n\nprivate:\nstruct Node\n{\n// \u5143\u306e\u70b9\u7fa4\u3067\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\nint idx = -1;\n\n// \u5206\u5272\u8ef8\u65b9\u5411\nint axis = -1;\n\n// \u5b50\u30ce\u30fc\u30c9\nstd::unique_ptr&lt;Node&gt; child[2] = {nullptr, nullptr};\n};\n\nstd::unique_ptr&lt;Node&gt; build_recursive(std::vector&lt;size_t&gt;::iterator start, std::vector&lt;size_t&gt;::iterator end, size_t depth)\n{\nif(start == end)\nreturn nullptr;\n\nconst size_t axis = depth % dimention_;\nconst size_t mid = (std::distance(start, end)-1) / 2;\n\nstd::nth_element(start, start + mid, end, [&amp;](size_t a, size_t b){\nreturn points_[a][axis] &lt; points_[b][axis];\n});\n\nstd::unique_ptr&lt;Node&gt; node_ = std::make_unique&lt;Node&gt;();\nnode_-&gt;idx = *(start + mid);\nnode_-&gt;axis = axis;\n\nnode_-&gt;child[0] = build_recursive(start, start + mid, depth+1);\nnode_-&gt;child[1] = build_recursive(start+mid+1, end, depth+1);\n\nreturn node_;\n}\n\nvoid nn_search_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, const point_type &amp;point, size_t &amp;guess, double &amp;min_dist) const\n{\nif(node == nullptr)\nreturn;\n\nauto p = points_[node-&gt;idx];\n\nconst double dist = distance(point, p);\nif(dist &lt; min_dist)\n{\nmin_dist = dist;\nguess = node-&gt;idx;\n}\n\nconst int axis = node-&gt;axis;\nconst int dir = point[axis] &lt; p[axis] ? 0 : 1;\nnn_search_recursive(node-&gt;child[dir], point, guess, min_dist);\n\nif(dist &lt; min_dist)\nnn_search_recursive(node-&gt;child[dir], point, guess, min_dist);\n}\n\nvoid knn_search_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, const point_type &amp;point, size_t k, std::vector&lt;std::pair&lt;size_t, double&gt;&gt; &amp;result) const\n{\nif(node == nullptr)\nreturn;\n\nauto p = points_[node-&gt;idx];\n\nconst double dist = distance(point, p);\nauto val = std::make_pair(node-&gt;idx, dist);\n\n// dist\u3067\u6607\u9806\u30bd\u30fc\u30c8\u3057\u3066\u5e38\u306bk\u500b\u4ee5\u4e0b\u3092\u4fdd\u6301\u3059\u308b\nauto it = std::find_if(std::begin(result), std::end(result),\n[&amp;](const auto&amp; elem){ return val.second &lt; elem.second; });\nresult.insert(it, val);\nif (result.size() &gt; k)\nresult.resize(k);\n\nconst int axis = node-&gt;axis;\nconst int dir = point[axis] &lt; p[axis] ? 0 : 1;\nknn_search_recursive(node-&gt;child[dir], point, k, result);\n\nconst double diff = fabs(point[axis] - p[axis]);\nif (result.size() &lt; k || diff &lt; result.back().second)\nknn_search_recursive(node-&gt;child[!dir], point, k, result);\n}\n\nvoid radius_search_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, const point_type &amp;point, double radius, std::vector&lt;size_t&gt; &amp;result) const\n{\nif(node == nullptr)\nreturn;\n\nauto p = points_[node-&gt;idx];\ndouble dist = distance(p, point);\nif(dist &lt; radius)\n{\nresult.push_back(node-&gt;idx);\n}\n\nconst int axis = node-&gt;axis;\nconst int dir = point[axis] &lt; p[axis] ? 0 : 1;\nradius_search_recursive(node-&gt;child[dir], point, radius, result);\n\nconst double diff = fabs(point[axis] - p[axis]);\nif (diff &lt; radius)\nradius_search_recursive(node-&gt;child[!dir], point, radius, result);\n}\n\nvoid debug_node_recursive(const std::unique_ptr&lt;Node&gt; &amp;node, size_t depth)\n{\nif(node == nullptr)\nreturn;\n\nfor(size_t i = 0; i &lt; depth; i++)\nprintf(\"  \");\nprintf(\"%d\\n\", node-&gt;idx);\n\ndebug_node_recursive(node-&gt;child[0], depth+1);\ndebug_node_recursive(node-&gt;child[1], depth+1);\n}\n\ndouble distance(const point_type &amp;a, const point_type &amp;b) const\n{\ndouble len_sq = 0;\nfor(size_t i = 0; i &lt; dimention_; i++)\n{\nlen_sq += std::pow(a[i]-b[i], 2);\n}\nreturn std::sqrt(len_sq);\n}\n\nsize_t dimention_;\nstd::vector&lt;point_type&gt; points_;\nstd::vector&lt;size_t&gt; pidx_;\nstd::unique_ptr&lt;Node&gt; root_ = nullptr;\n\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/lesi__doc_8hpp/","title":"include/cpp_robotics/optimize/lesi_doc.hpp","text":""},{"location":"doxybook/Files/lesi__doc_8hpp/#functions","title":"Functions","text":"Name void lsei_(double * C_mat, double * D_vec, double * E_mat, double * F_vec, double * G_mat, double * H_vec, int lc_eq_mat_rows, int mc_eq_mat_rows, int le_prob_mat_rows, int me_prob_mat_rows, int lg_ineq_mat_rows, int mg_ineq_mat_rows, int n, double * x, double * xnrm, double * w_lagrange_mul, int * jw, int * mode)"},{"location":"doxybook/Files/lesi__doc_8hpp/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Files/lesi__doc_8hpp/#function-lsei_","title":"function lsei_","text":"<pre><code>static void lsei_(\ndouble * C_mat,\ndouble * D_vec,\ndouble * E_mat,\ndouble * F_vec,\ndouble * G_mat,\ndouble * H_vec,\nint lc_eq_mat_rows,\nint mc_eq_mat_rows,\nint le_prob_mat_rows,\nint me_prob_mat_rows,\nint lg_ineq_mat_rows,\nint mg_ineq_mat_rows,\nint n,\ndouble * x,\ndouble * xnrm,\ndouble * w_lagrange_mul,\nint * jw,\nint * mode\n)\n</code></pre>"},{"location":"doxybook/Files/lesi__doc_8hpp/#source-code","title":"Source code","text":"<pre><code>static void lsei_(double *C_mat, double *D_vec, double *E_mat, double *F_vec, double *G_mat,\ndouble *H_vec, int lc_eq_mat_rows, int mc_eq_mat_rows, int le_prob_mat_rows, int me_prob_mat_rows, int lg_ineq_mat_rows,\nint mg_ineq_mat_rows, int n, double *x, double *xnrm, double *w_lagrange_mul, int *jw,\nint *mode) {\n/* Initialized data */\n\nconst double epmach = 2.22e-16;\n\n/* System generated locals */\nint c_dim1, c_offset, e_dim1, e_offset, g_dim1, g_offset, i__1, i__2, i__3;\ndouble d__1;\n\n/* Local variables */\nint i, j, k, l;\ndouble t;\nint ie, if__, ig, iw, mc1;\nint krank;\n\n/*     FOR MODE=1, THE SUBROUTINE RETURNS THE SOLUTION X OF */\n/*     EQUALITY &amp; INEQUALITY CONSTRAINED LEAST SQUARES PROBLEM LSEI : */\n/*                MIN ||E_mat*X - F_vec|| */\n/*                 X */\n/*                S.T.  C_mat*X  = D_vec, */\n/*                      G_mat*X &gt;= H_vec. */\n/*     USING QR DECOMPOSITION &amp; ORTHOGONAL BASIS OF NULLSPACE OF C_mat */\n/*     CHAPTER 23.6 OF LAWSON &amp; HANSON: SOLVING LEAST SQUARES PROBLEMS. */\n/*     THE FOLLOWING DIMENSIONS OF THE ARRAYS DEFINING THE PROBLEM */\n/*     ARE NECESSARY */\n/*     DIM(E_mat) :   FORMAL (LE,N),    ACTUAL (ME,N) */\n/*     DIM(F_vec) :   FORMAL (LE  ),    ACTUAL (ME  ) */\n/*     DIM(C_mat) :   FORMAL (LC,N),    ACTUAL (MC,N) */\n/*     DIM(D_vec) :   FORMAL (LC  ),    ACTUAL (MC  ) */\n/*     DIM(G_mat) :   FORMAL (LG,N),    ACTUAL (MG,N) */\n/*     DIM(H_vec) :   FORMAL (LG  ),    ACTUAL (MG  ) */\n/*     DIM(X) :   FORMAL (N   ),    ACTUAL (N   ) */\n/*     DIM(W) :   2*MC+ME+(ME+MG)*(N-MC)  for LSEI */\n/*              +(N-MC+1)*(MG+2)+2*MG     for LSI */\n/*     DIM(JW):   MAX(MG,L) */\n/*     ON ENTRY, THE USER HAS TO PROVIDE THE ARRAYS C_mat, D_vec, E_mat, F_vec, G_mat, AND H_vec. */\n/*     ON RETURN, ALL ARRAYS WILL BE CHANGED BY THE SUBROUTINE. */\n/*     X     STORES THE SOLUTION VECTOR */\n/*     XNORM STORES THE RESIDUUM OF THE SOLUTION IN EUCLIDIAN NORM */\n/*     W     STORES THE VECTOR OF LAGRANGE MULTIPLIERS IN ITS FIRST */\n/*           MC+MG ELEMENTS */\n/*     MODE  IS A SUCCESS-FAILURE FLAG WITH THE FOLLOWING MEANINGS: */\n/*          MODE=1: SUCCESSFUL COMPUTATION */\n/*               2: ERROR RETURN BECAUSE OF WRONG DIMENSIONS (N&lt;1) */\n/*               3: ITERATION COUNT EXCEEDED BY NNLS */\n/*               4: INEQUALITY CONSTRAINTS INCOMPATIBLE */\n/*               5: MATRIX E_mat IS NOT OF FULL RANK */\n/*               6: MATRIX C_mat IS NOT OF FULL RANK */\n/*               7: RANK DEFECT IN HFTI */\n/*     18.5.1981, DIETER KRAFT, DFVLR OBERPFAFFENHOFEN */\n/*     20.3.1987, DIETER KRAFT, DFVLR OBERPFAFFENHOFEN */\n/* Parameter adjustments */\n--D_vec;\n--F_vec;\n--H_vec;\n--x;\ng_dim1 = lg_ineq_mat_rows;\ng_offset = 1 + g_dim1;\nG_mat -= g_offset;\ne_dim1 = le_prob_mat_rows;\ne_offset = 1 + e_dim1;\nE_mat -= e_offset;\nc_dim1 = lc_eq_mat_rows;\nc_offset = 1 + c_dim1;\nC_mat -= c_offset;\n--w_lagrange_mul;\n--jw;\n\n/* Function Body */\n*mode = 2;\nif (mc_eq_mat_rows &gt; n) {\ngoto L75_RETURN;;\n}\nl = n - mc_eq_mat_rows;\nmc1 = mc_eq_mat_rows + 1;\niw = (l + 1) * (mg_ineq_mat_rows + 2) + (mg_ineq_mat_rows &lt;&lt; 1) + mc_eq_mat_rows;\nie = iw + mc_eq_mat_rows + 1;\nif__ = ie + me_prob_mat_rows * l;\nig = if__ + me_prob_mat_rows;\n/*  TRIANGULARIZE C_mat AND APPLY FACTORS TO E_mat AND G_mat */\n\nfor (i = 1; i &lt;= mc_eq_mat_rows; ++i) {\n/* Computing MIN */\n\nj = MIN2(i + 1, lc_eq_mat_rows);\n// i__2 = i + 1;\n// i__3 = mc_eq_mat_rows - i;\nhouseholder_transformation(1, i, i+1, n, &amp;C_mat[i + c_dim1], lc_eq_mat_rows, &amp;w_lagrange_mul[iw + i],\n&amp;C_mat[j + c_dim1], lc_eq_mat_rows, 1, mc_eq_mat_rows - i);\n// i__2 = i + 1;\nhouseholder_transformation(2, i, i+1, n, &amp;C_mat[i + c_dim1], lc_eq_mat_rows, &amp;w_lagrange_mul[iw + i],\n&amp;E_mat[e_offset], le_prob_mat_rows, 1, me_prob_mat_rows);\n/* L10: */\n// i__2 = i + 1;\nhouseholder_transformation(2, i, i+1, n, &amp;C_mat[i + c_dim1], lc_eq_mat_rows, &amp;w_lagrange_mul[iw + i],\n&amp;G_mat[g_offset], lg_ineq_mat_rows, 1, mg_ineq_mat_rows);\n}\n/*  SOLVE C_mat*X=D_vec AND MODIFY F_vec */\n*mode = 6;\nfor(i = 1; i &lt;= mc_eq_mat_rows; i++) {\nif ((d__1 = C_mat[i + i * c_dim1], fabs(d__1)) &lt; epmach) {\ngoto L75_RETURN;\n}\n// i__1 = i - 1;\nx[i] = (D_vec[i] - ddot_sl__(i-1, &amp;C_mat[i + c_dim1], lc_eq_mat_rows, &amp;x[1], 1)) / C_mat[i + i * c_dim1];\n/* L15: */\n}\n*mode = 1;\n// w_lagrange_mul[mc1] = 0.0;\n// i__2 = mg_ineq_mat_rows; /* BUGFIX for mc_eq_mat_rows == n: changed from mg_ineq_mat_rows - mc_eq_mat_rows, SGJ 2010 */\n// dcopy___(&amp;i__2, &amp;w_lagrange_mul[mc1], 0, &amp;w_lagrange_mul[mc1], 1);\nw_lagrange_mul.segment(mc1, mg_ineq_mat_rows) = vector::zero();\nif (mc_eq_mat_rows == n) {\ngoto L50;\n}\nfor(i = 1; i &lt;= me_prob_mat_rows; i++) {\n/* L20: */\nw_lagrange_mul[if__ - 1 + i] = F_vec[i] - ddot_sl__(mc_eq_mat_rows, &amp;E_mat[i + e_dim1], le_prob_mat_rows, &amp;x[1], 1);\n}\n/*  STORE TRANSFORMED E_mat &amp; G_mat */\n\nfor(i = 1; i &lt;= me_prob_mat_rows; i++) {\n/* L25: */\ndcopy___(&amp;l, &amp;E_mat[i + mc1 * e_dim1], le_prob_mat_rows, &amp;w_lagrange_mul[ie - 1 + i], me_prob_mat_rows);\n}\n// w_lagrange_mul.segment(?,?) = E_mat\nfor(i = 1; i &lt;= mg_ineq_mat_rows; i++) {\n/* L30: */\ndcopy___(&amp;l, &amp;G_mat[i + mc1 * g_dim1], lg_ineq_mat_rows, &amp;w_lagrange_mul[ig - 1 + i], mg_ineq_mat_rows);\n}\nif (mg_ineq_mat_rows &gt; 0) {\ngoto L40;\n}\n/*  SOLVE LS WITHOUT INEQUALITY CONSTRAINTS */\n*mode = 7;\nk = MAX2(le_prob_mat_rows, n);\nt = sqrt(epmach);\nhfti_(&amp;w_lagrange_mul[ie], me_prob_mat_rows, me_prob_mat_rows, &amp;l, &amp;w_lagrange_mul[if__], &amp;k, 1, &amp;t, &amp;krank, xnrm, &amp;w_lagrange_mul[1],\n&amp;w_lagrange_mul[l + 1], &amp;jw[1]);\ndcopy___(&amp;l, &amp;w_lagrange_mul[if__], 1, &amp;x[mc1], 1);\nif (krank != l) {\ngoto L75_RETURN;;\n}\n*mode = 1;\ngoto L50;\n/*  MODIFY H_vec AND SOLVE INEQUALITY CONSTRAINED LS PROBLEM */\nL40:\nfor(i = 1; i &lt;= mg_ineq_mat_rows; i++) {\n/* L45: */\nH_vec[i] -= ddot_sl__(mc_eq_mat_rows, &amp;G_mat[i + g_dim1], lg_ineq_mat_rows, &amp;x[1], 1);\n}\nlsi_(&amp;w_lagrange_mul[ie], &amp;w_lagrange_mul[if__], &amp;w_lagrange_mul[ig], &amp;H_vec[1], me_prob_mat_rows, me_prob_mat_rows, mg_ineq_mat_rows, mg_ineq_mat_rows, &amp;l, &amp;x[mc1], xnrm,\n&amp;w_lagrange_mul[mc1], &amp;jw[1], mode);\nif (mc_eq_mat_rows == 0) {\ngoto L75_RETURN;;\n}\nt = dnrm2___(mc_eq_mat_rows, &amp;x[1], 1);\n*xnrm = sqrt(*xnrm * *xnrm + t * t);\nif (*mode != 1) {\ngoto L75_RETURN;;\n}\n/*  SOLUTION OF ORIGINAL PROBLEM AND LAGRANGE MULTIPLIERS */\nL50:\nfor(i = 1; i &lt;= me_prob_mat_rows; i++) {\n/* L55: */\nF_vec[i] = ddot_sl__(n, &amp;E_mat[i + e_dim1], le_prob_mat_rows, &amp;x[1], 1) - F_vec[i];\n}\nfor(i = 1; i &lt;= mc_eq_mat_rows; i++) {\n/* L60: */\nD_vec[i] = ddot_sl__(me_prob_mat_rows, &amp;E_mat[i * e_dim1 + 1], 1, &amp;F_vec[1], 1) -\nddot_sl__(mg_ineq_mat_rows, &amp;G_mat[i * g_dim1 + 1], 1, &amp;w_lagrange_mul[mc1], 1);\n}\nfor (i = mc_eq_mat_rows; i &gt;= 1; --i) {\n/* L65: */\ni__2 = i + 1;\nhouseholder_transformation(2, &amp;i, &amp;i__2, n, &amp;C_mat[i + c_dim1], lc_eq_mat_rows, &amp;w_lagrange_mul[iw + i], &amp;x[1],\n1, 1, 1);\n}\nfor (i = mc_eq_mat_rows; i &gt;= 1; --i) {\n/* Computing MIN */\ni__2 = i + 1;\nj = MIN2(i__2, lc_eq_mat_rows);\ni__2 = mc_eq_mat_rows - i;\nw_lagrange_mul[i] =\n(D_vec[i] - ddot_sl__(&amp;i__2, &amp;C_mat[j + i * c_dim1], 1, &amp;w_lagrange_mul[j], 1)) /\nC_mat[i + i * c_dim1];\n/* L70: */\n}\n/*  END OF SUBROUTINE LSEI */\nL75_RETURN;:\nreturn;\n} /* lsei_ */\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/linear__mpc_8hpp/","title":"include/cpp_robotics/controller/linear_mpc.hpp","text":""},{"location":"doxybook/Files/linear__mpc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/linear__mpc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::LinearMPC \u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9"},{"location":"doxybook/Files/linear__mpc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;utility&gt;\n#include &lt;optional&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize/quadprog.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass LinearMPC\n{\npublic:\nLinearMPC(const Eigen::MatrixXd &amp;Ad, const Eigen::MatrixXd &amp;Bd, const Eigen::MatrixXd &amp;Q, const Eigen::MatrixXd &amp;R, const Eigen::MatrixXd &amp;Qf, const size_t N, std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit = std::nullopt):\nAd_(Ad), Bd_(Bd), Q_(Q), R_(R), Qf_(Qf), N_(N), u_limit_(u_limit)\n{\n// \u6b63\u65b9\u884c\u5217\nassert(Ad_.rows() == Ad_.cols());\nassert(Q_.rows()  == Q_.cols());\nassert(Qf_.rows() == Qf_.cols());\nassert(R_.rows()  == R_.cols());\n\n// \nassert(Ad_.rows() == Bd_.rows());\nassert(Q_.rows() == Qf_.rows());\nassert(Ad_.rows() == Q_.rows());\nassert(Bd_.cols() == R_.cols());\n\ninput_size_ = Bd_.cols();\nstate_size_ = Ad_.rows();\n\n// N\u30b9\u30c6\u30c3\u30d7\u5206\u306e\u884c\u5217\u8868\u73fe\nAd_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_);\nEigen::MatrixXd Bd_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, input_size_*N_);\nEigen::MatrixXd Q_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_*N_);\nEigen::MatrixXd R_mat_ = Eigen::MatrixXd::Zero(input_size_*N_, input_size_*N_);\n\nEigen::MatrixXd tmp = Ad_;\nfor(size_t i = 0; i &lt; N_; i++)\n{\nAd_mat_.block(state_size_*i, 0, state_size_, state_size_) = tmp;\ntmp *= Ad_;\n}\n\ntmp = Bd_;\nfor(size_t i = 0; i &lt; N_; i++)\n{\n// \u53f3\u4e0b\u65b9\u5411\u306b\u57cb\u3081\u3066\u3044\u304f\nfor(size_t j = 0; j &lt; N_-i; j++)\n{\nBd_mat_.block(state_size_*(i+j), input_size_*j, state_size_, input_size_) = tmp;\n}\ntmp = Ad_ * tmp;\n}\n\nfor(size_t i = 0; i &lt; N_-1; i++)\n{\nQ_mat_.block(state_size_*i, state_size_*i, state_size_, state_size_) = Q_;\n}\nQ_mat_.block(state_size_*(N_-1), state_size_*(N_-1), state_size_, state_size_) = Qf_;\n\nfor(size_t i = 0; i &lt; N_; i++)\n{\nR_mat_.block(input_size_*i, input_size_*i, input_size_, input_size_) = R_;\n}\n\nH_ = Bd_mat_.transpose()*Q_mat_*Bd_mat_ + R_mat_;\ng_ = -Bd_mat_.transpose()*Q_mat_;\nqp_solver_.Q = H_;\n\nif(u_limit_)\n{\n// Todo infinity\u304c\u3042\u3063\u305f\u3089\u5236\u9650\u306a\u3057\u3068\u3044\u3046\u3053\u3068\u3067G_mat_, h_mat_\u306b\u3044\u308c\u306a\u3044\u64cd\u4f5c\u3092\u3059\u308b\nEigen::MatrixXd G_mat_ = Eigen::MatrixXd::Zero(input_size_*N_*2, input_size_*N_);\nEigen::VectorXd h_mat_ = Eigen::VectorXd::Zero(input_size_*N_*2);\n\nG_mat_.block(0,0,input_size_*N_, input_size_*N_) = Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\nG_mat_.block(input_size_*N_,0,input_size_*N_, input_size_*N_) = -Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\n\nauto &amp;[umin, umax] = u_limit_.value();\nfor(size_t i = 0; i &lt; N_; i++)\n{\nh_mat_.segment(input_size_*i, input_size_) = umax;\nh_mat_.segment(input_size_*(N_+i), input_size_) = -umin;\n}\n\nqp_solver_.A = G_mat_;\nqp_solver_.b = h_mat_;\n}\n\nU_ = Eigen::VectorXd::Zero(input_size_*N_);\n}\n\n// void set_initial_input(const std::vector&lt;Eigen::VectorXd&gt; &amp;u0)\n// {\n//     assert(u0.size() == N_);\n// }\n\nstd::tuple&lt;bool, Eigen::VectorXd&gt; control(const Eigen::VectorXd &amp;x0, const std::vector&lt;Eigen::VectorXd&gt; &amp;x_ref, bool warm_start = true)\n{\nassert(x0.size() == (Eigen::VectorXd::Index)(state_size_));\n\nEigen::VectorXd eps_mat = -Ad_mat_*x0;\nfor(size_t i = 0; i &lt; N_; i++)\n{\neps_mat.block(i*state_size_, 0, state_size_, 1) += x_ref[i];\n}\n\nqp_solver_.c = (g_*eps_mat).transpose();\nlatest_qp_result_ = qp_solver_.solve(U_);\n\nif(latest_qp_result_.is_solved)\n{\nif(warm_start)\n{\nU_ = latest_qp_result_.x;\n}\n\nreturn {true, latest_qp_result_.x.head(input_size_)};\n}\nelse\n{\nstd::cout &lt;&lt; \"???\" &lt;&lt; std::endl;\n}\n\nreturn {false, Eigen::VectorXd::Zero(input_size_)};\n}\n\nstd::tuple&lt;bool, Eigen::VectorXd&gt; control(const Eigen::VectorXd &amp;x0, const Eigen::VectorXd &amp;x_ref, bool warm_start = true)\n{\nreturn control(x0, std::vector(N_, x_ref), warm_start);\n}\n\nQuadProg::Result latest_qp_result() const { return latest_qp_result_; }\n\nEigen::MatrixXd Ad() const { return Ad_; }\nEigen::MatrixXd Bd() const { return Bd_; }\nEigen::MatrixXd Q() const { return Q_; }\nEigen::MatrixXd R() const { return R_; }\nEigen::MatrixXd Qf() const { return Qf_; }\nsize_t N() const { return N_; }\n\nprivate:\n// \u30b7\u30b9\u30c6\u30e0\nconst Eigen::MatrixXd Ad_;\nconst Eigen::MatrixXd Bd_;\nconst Eigen::MatrixXd Q_;\nconst Eigen::MatrixXd R_;\nconst Eigen::MatrixXd Qf_;\nconst size_t N_;\nconst std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit_;\nsize_t input_size_;\nsize_t state_size_;\n\nEigen::MatrixXd Ad_mat_;\n\n// QP\u30bd\u30eb\u30d0\u7528\u306e\u8a55\u4fa1\u95a2\u6570\u306e\uff12\u6b21\u5f62\u8868\u73fe\nEigen::MatrixXd H_;\nEigen::MatrixXd g_;\n\n// QP\u30bd\u30eb\u30d0\nQuadProg qp_solver_;\nEigen::VectorXd U_;\nQuadProg::Result latest_qp_result_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/","title":"include/cpp_robotics/controller/linear_regulator_mpc.hpp","text":""},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::LinearRegulatorMPC"},{"location":"doxybook/Files/linear__regulator__mpc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;utility&gt;\n#include &lt;optional&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize/quadprog.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass LinearRegulatorMPC\n{\npublic:\nLinearRegulatorMPC(const Eigen::MatrixXd &amp;Ad, const Eigen::MatrixXd &amp;Bd, const Eigen::MatrixXd &amp;Q, const Eigen::MatrixXd &amp;R, const Eigen::MatrixXd &amp;Qf, const size_t N, std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit = std::nullopt):\nAd_(Ad), Bd_(Bd), Q_(Q), R_(R), Qf_(Qf), N_(N), u_limit_(u_limit)\n{\n// \u6b63\u65b9\u884c\u5217\nassert(Ad_.rows() == Ad_.cols());\nassert(Q_.rows()  == Q_.cols());\nassert(Qf_.rows() == Qf_.cols());\nassert(R_.rows()  == R_.cols());\n\n// \nassert(Ad_.rows() == Bd_.rows());\nassert(Q_.rows() == Qf_.rows());\nassert(Ad_.rows() == Q_.rows());\nassert(Bd_.cols() == R_.cols());\n\ninput_size_ = Bd_.cols();\nstate_size_ = Ad_.rows();\n\n// N\u30b9\u30c6\u30c3\u30d7\u5206\u306e\u884c\u5217\u8868\u73fe\nEigen::MatrixXd Ad_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_);\nEigen::MatrixXd Bd_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, input_size_*N_);\nEigen::MatrixXd Q_mat_ = Eigen::MatrixXd::Zero(state_size_*N_, state_size_*N_);\nEigen::MatrixXd R_mat_ = Eigen::MatrixXd::Zero(input_size_*N_, input_size_*N_);\n\nEigen::MatrixXd tmp = Ad_;\nfor(size_t i = 0; i &lt; N_; i++)\n{\nAd_mat_.block(state_size_*i, 0, state_size_, state_size_) = tmp;\ntmp *= Ad_;\n}\n\ntmp = Bd_;\nfor(size_t i = 0; i &lt; N_; i++)\n{\n// \u53f3\u4e0b\u65b9\u5411\u306b\u57cb\u3081\u3066\u3044\u304f\nfor(size_t j = 0; j &lt; N_-i; j++)\n{\nBd_mat_.block(state_size_*(i+j), input_size_*j, state_size_, input_size_) = tmp;\n}\ntmp = Ad_ * tmp;\n}\n\nfor(size_t i = 0; i &lt; N_-1; i++)\n{\nQ_mat_.block(state_size_*i, state_size_*i, state_size_, state_size_) = Q_;\n}\nQ_mat_.block(state_size_*(N_-1), state_size_*(N_-1), state_size_, state_size_) = Qf_;\n\nfor(size_t i = 0; i &lt; N_; i++)\n{\nR_mat_.block(input_size_*i, input_size_*i, input_size_, input_size_) = R_;\n}\n\nH_ = Bd_mat_.transpose()*Q_mat_*Bd_mat_ + R_mat_;\ng_ = Bd_mat_.transpose()*Q_mat_*Ad_mat_;\nqp_solver_.Q = H_;\n\nif(u_limit_)\n{\n// Todo infinity\u304c\u3042\u3063\u305f\u3089\u5236\u9650\u306a\u3057\u3068\u3044\u3046\u3053\u3068\u3067G_mat_, h_mat_\u306b\u3044\u308c\u306a\u3044\u64cd\u4f5c\u3092\u3059\u308b\nEigen::MatrixXd G_mat_ = Eigen::MatrixXd::Zero(input_size_*N_*2, input_size_*N_);\nEigen::VectorXd h_mat_ = Eigen::VectorXd::Zero(input_size_*N_*2);\n\nG_mat_.block(0,0,input_size_*N_, input_size_*N_) = Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\nG_mat_.block(input_size_*N_,0,input_size_*N_, input_size_*N_) = -Eigen::MatrixXd::Identity(input_size_*N_, input_size_*N_);\n\nauto &amp;[umin, umax] = u_limit_.value();\nfor(size_t i = 0; i &lt; N_; i++)\n{\nh_mat_.segment(input_size_*i, input_size_) = umax;\nh_mat_.segment(input_size_*(N_+i), input_size_) = -umin;\n}\n\nqp_solver_.A = G_mat_;\nqp_solver_.b = h_mat_;\n}\n\nU_ = Eigen::VectorXd::Zero(input_size_*N_);\n}\n\nvoid set_initial_input(const std::vector&lt;Eigen::VectorXd&gt; &amp;u0)\n{\nassert(u0.size() == N_);\n}\n\nstd::tuple&lt;bool, Eigen::VectorXd&gt; control(const Eigen::VectorXd &amp;x0, bool warm_start = true)\n{\nassert(x0.size() == (Eigen::VectorXd::Index)(state_size_));\n\nqp_solver_.c = (g_*x0).transpose();\nlatest_qp_result_ = qp_solver_.solve(U_);\n\nif(latest_qp_result_.is_solved)\n{\nif(warm_start)\n{\nU_ = latest_qp_result_.x;\n}\n\nreturn {true, latest_qp_result_.x.head(input_size_)};\n}\nelse\n{\nstd::cout &lt;&lt; \"???\" &lt;&lt; std::endl;\n}\n\nreturn {false, Eigen::VectorXd::Zero(input_size_)};\n}\n\nQuadProg::Result latest_qp_result() const { return latest_qp_result_; }\n\nEigen::MatrixXd Ad() const { return Ad_; }\nEigen::MatrixXd Bd() const { return Bd_; }\nEigen::MatrixXd Q() const { return Q_; }\nEigen::MatrixXd R() const { return R_; }\nEigen::MatrixXd Qf() const { return Qf_; }\nsize_t N() const { return N_; }\n\nprivate:\n// \u30b7\u30b9\u30c6\u30e0\nconst Eigen::MatrixXd Ad_;\nconst Eigen::MatrixXd Bd_;\nconst Eigen::MatrixXd Q_;\nconst Eigen::MatrixXd R_;\nconst Eigen::MatrixXd Qf_;\nconst size_t N_;\nconst std::optional&lt;std::pair&lt;Eigen::VectorXd, Eigen::VectorXd&gt;&gt; u_limit_;\nsize_t input_size_;\nsize_t state_size_;\n\n// QP\u30bd\u30eb\u30d0\u7528\u306e\u8a55\u4fa1\u95a2\u6570\u306e\uff12\u6b21\u5f62\u8868\u73fe\nEigen::MatrixXd H_;\nEigen::MatrixXd g_;\n\n// QP\u30bd\u30eb\u30d0\nQuadProg qp_solver_;\nEigen::VectorXd U_;\nQuadProg::Result latest_qp_result_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/link__robot_8hpp/","title":"include/cpp_robotics/system/link_robot.hpp","text":""},{"location":"doxybook/Files/link__robot_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/link__robot_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::LinkConfig class cpp_robotics::LinkRobot"},{"location":"doxybook/Files/link__robot_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Geometry&gt;\n#include &lt;ginac/ginac.h&gt;\n#include \"../utility/ginac_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\nstruct LinkConfig\n{\nusing ex = GiNaC::ex;\nusing symbol = GiNaC::symbol;\nusing lst = GiNaC::lst;\n\nusing VectorXex = Eigen::Matrix&lt;ex,Eigen::Dynamic,1&gt;;\nusing Vector3ex = Eigen::Matrix&lt;ex,3,1&gt;;\nusing Affine3ex = Eigen::Transform&lt;ex,3,Eigen::Affine&gt;;\nusing Translation3ex = Eigen::Translation&lt;ex,3&gt;;\nusing AngleAxisex = Eigen::AngleAxis&lt;ex&gt;;\nusing Matrix3ex = Eigen::Matrix&lt;ex, 3, 3&gt;;\n\nenum class LinkType\n{\nRotationX,\nRotationY,\nRotationZ,\n// LinearX,\n// LinearY,\n// LinearZ\n};\nLinkType link_type;\nEigen::Translation3d position; // \u89aa\u30ea\u30f3\u30af\u304b\u3089\u306e\u76f8\u5bfe\u4f4d\u7f6e\ndouble mass;                   // \u81ea\u30ea\u30f3\u30af\u306e\u8cea\u91cf\nEigen::Translation3d link_com; // \u81ea\u30ea\u30f3\u30af\u306e\u91cd\u5fc3\nEigen::Matrix3d I;             // \u81ea\u30ea\u30f3\u30af\u306e\u6163\u6027\u884c\u5217\n// std::optional&lt;std::pair&lt;double, double&gt;&gt; limit;\n\n// Eigen::Affine3d trans_matrix(double val) const \n// {\n//     Eigen::Affine3d affine;\n//     switch(link_type)\n//     {\n//         case LinkType::RotationX:\n//             affine = Eigen::AngleAxisd(val, Eigen::Vector3d::UnitX()) * position;\n//             break;\n//         case LinkType::RotationY:\n//             affine = Eigen::AngleAxisd(val, Eigen::Vector3d::UnitY()) * position;\n//             break;\n//         case LinkType::RotationZ:\n//             affine = Eigen::AngleAxisd(val, Eigen::Vector3d::UnitZ()) * position;\n//             break;\n\n//         // case LinkType::LinearX:\n//         //     affine = position * Eigen::Translation3d(val, 0, 0);\n//         //     break;\n//         // case LinkType::LinearY:\n//         //     affine = position * Eigen::Translation3d(0, val, 0);\n//         //     break;\n//         // case LinkType::LinearZ:\n//         //     affine = position * Eigen::Translation3d(0, 0, val);\n//         //     break;\n//         default:\n//             affine = Eigen::Matrix3d::Identity();\n//     }\n\n//     return affine;\n// }\n};\n\nclass LinkRobot\n{\nusing ex = GiNaC::ex;\nusing symbol = GiNaC::symbol;\nusing lst = GiNaC::lst;\n\nusing VectorXex = Eigen::Matrix&lt;ex,Eigen::Dynamic,1&gt;;\nusing Vector3ex = Eigen::Matrix&lt;ex,3,1&gt;;\nusing Affine3ex = Eigen::Transform&lt;ex,3,Eigen::Affine&gt;;\nusing Translation3ex = Eigen::Translation&lt;ex,3&gt;;\nusing AngleAxisex = Eigen::AngleAxis&lt;ex&gt;;\nusing Matrix3ex = Eigen::Matrix&lt;ex, 3, 3&gt;;\nusing MatrixXex = Eigen::Matrix&lt;ex,Eigen::Dynamic,Eigen::Dynamic&gt;;\n\npublic:\nLinkRobot(std::vector&lt;LinkConfig&gt; &amp;config):\nconfig_(config)\n{\n// GiNaC::Digits = 2;\n\nconst size_t n = degree();\nfor(size_t i = 0; i &lt; n; i++)\n{\nsymbols_.push_back(symbol(\"q\"+std::to_string(i+1)));\ndsymbols_.push_back(symbol(\"dq\"+std::to_string(i+1), \"\\\\dot{q\"+std::to_string(i+1)+\"}\"));\nddsymbols_.push_back(symbol(\"ddq\"+std::to_string(i+1), \"\\\\ddot{q\"+std::to_string(i+1)+\"}\"));\n}\n\nauto trans_matrix = [](const LinkConfig &amp;config, ex val) -&gt; Affine3ex {\nusing LinkType = LinkConfig::LinkType;\nAffine3ex affine;\nauto position_ex = config.position.cast&lt;ex&gt;();\nswitch(config.link_type)\n{\ncase LinkType::RotationX:\naffine = AngleAxisex(val, Vector3ex::UnitX()) * position_ex;\nbreak;\ncase LinkType::RotationY:\naffine = AngleAxisex(val, Vector3ex::UnitY()) * position_ex;\nbreak;\ncase LinkType::RotationZ:\naffine = AngleAxisex(val, Vector3ex::UnitZ()) * position_ex;\nbreak;\n\n// case LinkType::LinearX:\n//     affine = position_ex * Translation3ex(val, 0, 0);\n//     break;\n// case LinkType::LinearY:\n//     affine = position_ex * Translation3ex(0, val, 0);\n//     break;\n// case LinkType::LinearZ:\n//     affine = position_ex * Translation3ex(0, 0, val);\n//     break;\ndefault:\naffine = Matrix3ex::Identity();\n}\n\nreturn affine;\n};\n\nauto rot = [](const LinkConfig &amp;config, ex val) -&gt; Matrix3ex\n{\nusing LinkType = LinkConfig::LinkType;\nAffine3ex affine;\nswitch(config.link_type)\n{\ncase LinkType::RotationX:\naffine = AngleAxisex(val, Vector3ex::UnitX());\nbreak;\ncase LinkType::RotationY:\naffine = AngleAxisex(val, Vector3ex::UnitY());\nbreak;\ncase LinkType::RotationZ:\naffine = AngleAxisex(val, Vector3ex::UnitZ());\nbreak;\ndefault:\naffine = Matrix3ex::Identity();\n}\nreturn affine.matrix().block(0,0,3,3);\n};\n\nauto axis = [&amp;](const LinkConfig &amp;config) -&gt; Vector3ex\n{\nswitch (config.link_type)\n{\ncase LinkConfig::LinkType::RotationX:\nreturn Vector3ex::UnitX();\nbreak;\ncase LinkConfig::LinkType::RotationY:\nreturn Vector3ex::UnitY();\nbreak;\ncase LinkConfig::LinkType::RotationZ:\nreturn Vector3ex::UnitZ();\nbreak;\ndefault:\nreturn Vector3ex::Zero();\n}\n};\n\nforward_kinematics_ex_ = Vector3ex::Zero();\nfor(size_t i = 0; i &lt; n; i++)\n{\nauto &amp;config = config_[i];\nauto q = symbols_[i];\nauto af = trans_matrix(config, q);\nforward_kinematics_ex_ = af*forward_kinematics_ex_;\n}\n\njacobian_.resize(forward_kinematics_ex_.rows(), degree());\nfor(int r = 0; r &lt; jacobian_.rows(); r++)\n{\nauto &amp;p = forward_kinematics_ex_[r];\nfor(int c = 0; c &lt; jacobian_.cols(); c++)\n{\njacobian_(r, c) = p.diff(symbols_[c]);\n// std::cout &lt;&lt; jacobian_(r, c) &lt;&lt; \",\\t\";\n}\n// std::cout &lt;&lt; std::endl;\n}\n\n// step2\nstd::vector&lt;Vector3ex&gt;  w(n+1);  // \u89d2\u901f\u5ea6\nstd::vector&lt;Vector3ex&gt; dw(n+1); // \u89d2\u52a0\u901f\u5ea6\nstd::vector&lt;Vector3ex&gt; dv(n+1); // \u52a0\u901f\u5ea6\n\nw[0].setZero();\ndw[0].setZero();\n\nsymbol g(\"g\");\ndv[0] &lt;&lt; 0, g, 0; // Todo\n\nstd::vector&lt;Vector3ex&gt; p_hat; // i\u304b\u3089i+1\u306e\u4f4d\u7f6e\u30d9\u30af\u30c8\u30eb\np_hat.reserve(n+1);\np_hat.push_back(Vector3ex::Zero());\nfor(size_t i = 0; i &lt; n ; i++)\n{\np_hat.push_back(config_[i].position.vector().cast&lt;ex&gt;());\n}\n\nfor(size_t i = 0; i &lt; n; i++)\n{\nprintf(\"////////////////////////\\n\");\n\nauto &amp;q = symbols_[i];\nauto &amp;dq = dsymbols_[i];\nauto &amp;ddq = ddsymbols_[i];\nMatrix3ex RT = rot(config_[i],q).transpose();\nauto axisq = axis(config_[i]); // Todo: \u56de\u8ee2\u3068\u4e26\u9032\u3067\u5206\u3051\u308b\nw[i+1]  = RT*w[i] + axisq * dq;\ndw[i+1] = RT*dw[i] + axisq*ddq + (RT*w[i]).cross(axisq*dq);\ndv[i+1] = RT*( dv[i] + dw[i].cross(p_hat[i]) + w[i].cross(w[i].cross(p_hat[i])) ); simplify_indexed(dv[i+1]);\n\ncout_exmat(w[i+1].transpose().eval(), std::string(\"w\"));\ncout_exmat(dw[i+1].transpose().eval(), \"dw\");\ncout_exmat(dv[i+1].eval(), \"dv\");\n\nauto &amp;w_ = w[i+1];\nauto &amp;dw_ = dw[i+1];\nauto &amp;dv_ = dv[i+1];\nauto m = config_[i].mass;\nauto I = config_[i].I.cast&lt;ex&gt;().eval();\nauto s = config_[i].link_com.vector().cast&lt;ex&gt;().eval();\nVector3ex fc = m*(dv_ + dw_.cross(s) + w_.cross(w_.cross(s)));\nVector3ex nc = I*dw_ + w_.cross(I*w_);\n\ncout_exmat(fc, \"fc\");\ncout_exmat(nc, \"nc\");\n}\n\nstd::vector&lt;Vector3ex&gt; fvec(n+1); // for\u306e\u8a18\u8ff0\u7c21\u7565\u5316\u306e\u305f\u3081\u306b\u6700\u5f8c\u306b0\u3092\u5165\u308c\u3066\u304a\u304f\nstd::vector&lt;Vector3ex&gt; nvec(n+1); // for\u306e\u8a18\u8ff0\u7c21\u7565\u5316\u306e\u305f\u3081\u306b\u6700\u5f8c\u306b0\u3092\u5165\u308c\u3066\u304a\u304f \nfvec.back().setZero();\nnvec.back().setZero();\n// \u5148\u7aef\u304b\u3089\u571f\u53f0\u65b9\u5411\u306b\u95a2\u7bc0\u306e\u529b\u30fb\u30c8\u30eb\u30af\u3092\u6c42\u3081\u308b\ntau_.resize(n);\nfor(size_t ri = 0; ri &lt; n; ri++)\n{\nprintf(\"rev////////////////////////\\n\");\nsize_t i = n-1-ri;\nauto &amp;q = symbols_[i];\nauto &amp;dq = dsymbols_[i];\nauto &amp;ddq = ddsymbols_[i];\nauto &amp;w_ = w[i+1];\nauto &amp;dw_ = dw[i+1];\nauto &amp;dv_ = dv[i+1];\nauto m = config_[i].mass;\nauto p = config_[i].position.vector().cast&lt;ex&gt;().eval();\nauto s = config_[i].link_com.vector().cast&lt;ex&gt;().eval();\nauto I = config_[i].I.cast&lt;ex&gt;().eval();\nauto axisq = axis(config_[i]); Matrix3ex R;\nif(ri == 0)\n{\nR = Matrix3ex::Identity();\n}\nelse\n{\nR = rot(config_[i+1], symbols_[i+1]);\n}\n\nVector3ex fc = m*(dv_ + dw_.cross(s) + w_.cross(w_.cross(s)));\nVector3ex nc = I*dw_ + w_.cross(I*w_);\nauto Rfvec = (R*fvec[i+1]).eval();\nexpand(Rfvec);\nsimplify_indexed(Rfvec);\n\nfvec[i] = fc + Rfvec;\nnvec[i] = nc + R*nvec[i+1] + s.cross(fc) + p.cross(Rfvec);\n\nexpand(fvec[i]);\nsimplify_indexed(fvec[i]);\nexpand(nvec[i]);\nsimplify_indexed(nvec[i]);\n\n// cout_exmat(fvec[i], \"fvec[i]\");\n// cout_exmat(nvec[i], \"nvec[i]\");\n\n// Todo: \u56de\u8ee2\u3068\u4e26\u9032\u3067\u5206\u5c90\u3055\u305b\u308b\ntau_[i] = axisq.dot(nvec[i]);\n}\n\n// \u6b21\u6570\u3054\u3068\u306b\u5206\u89e3\nHq_.resize(n,n);\ngq_.resize(n);\ncq_ = tau_;\nfor(size_t r = 0; r &lt; n; r++)\n{\ngq_[r] = tau_[r].collect(g).coeff(g);\ncq_[r] -= gq_[r]*g;\n\nfor(size_t c = 0; c &lt; n; c++)\n{\nHq_(r, c) = tau_[r].collect(ddsymbols_[c]).coeff(ddsymbols_[c]);\ncq_[r] -= Hq_(r, c)*ddsymbols_[c];\n}\n}\n\nsimplify_indexed(Hq_);\nsimplify_indexed(cq_);\nsimplify_indexed(gq_);\n\n// cout_exmat(Hq_, \"H\");\n// cout_exmat(cq_, \"c\");\n// cout_exmat(gq_, \"g\");\n\n}\n\nvoid show_kinematics()\n{\nstd::cout &lt;&lt; \"////////// kinematics //////////\" &lt;&lt; std::endl; cout_exmat(forward_kinematics_ex_, \"forward kinematics\");\n}\n\nvoid show_dynamics()\n{\nstd::cout &lt;&lt; \"////////// dynamics //////////\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"tau = H(q)*ddq + c(q, dq) + g(q)*g\" &lt;&lt; std::endl &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"where\" &lt;&lt; std::endl;\ncout_exmat(Hq_, \"H(q)\");\ncout_exmat(cq_, \"c(q, dq)\");\ncout_exmat(gq_, \"g(g)\");\n}\n\nsize_t degree() const\n{\nreturn config_.size();\n}\n\nEigen::Vector3d forward_kinematics(Eigen::VectorXd joint_param)\n{\nlst q;\nfor(size_t i = 0; i &lt; degree(); i++)\n{\nq.append(symbols_[i]==joint_param[i]);\n}\n\nEigen::Vector3d pos;\nfor(size_t i = 0; i &lt; 3; i++)\n{\npos[i] = GiNaC::ex_to&lt;GiNaC::numeric&gt;(forward_kinematics_ex_[i].subs(q)).to_double();\n}\nreturn pos;\n}\n\nEigen::VectorXd inverse_kinematics(Eigen::Vector3d pos, Eigen::Vector3d euler_angle)\n{\nconst size_t n = degree();\n\nEigen::VectorXd q(n);\n\nreturn q;\n}\n\n// \u9806\u904b\u52d5\u5b66\u554f\u984c\n// A \\\\ddot(q) + b = \\tau\n// return A, b\nstd::tuple&lt;Eigen::MatrixXd, Eigen::VectorXd&gt; forward_dynamics_matrix(Eigen::VectorXd pos, Eigen::VectorXd vel)\n{\nconst size_t n = degree();\nEigen::MatrixXd A(n,n);\nEigen::VectorXd c(n);\nEigen::VectorXd g(n);\n\nlst exlst;\nfor(size_t i = 0; i &lt; n; i++)\n{\nexlst.append(symbols_[i] == pos[i]);\nexlst.append(dsymbols_[i] == vel[i]);\n}\n\nMatrixXex tmp;\n\ntmp = Hq_;\nsubs(tmp, exlst);\n\nto_double_matrix(tmp, A);\n\ntmp = cq_;\nsubs(tmp, exlst);\nto_double_matrix(tmp, c);\n\ntmp = gq_;\nsubs(tmp, exlst);\nto_double_matrix(tmp, g);\n\nreturn {A, c+g*9.81};\n}\n\n// \u4e00\u822c\u5316\u5ea7\u6a19\u3067\u306e\u4f4d\u7f6e\u30fb\u901f\u5ea6\u30fb\u52a0\u901f\u5ea6\u304b\u3089\u4e00\u822c\u5316\u529b\u3092\u6c42\u3081\u308b\nEigen::VectorXd dynamics(Eigen::VectorXd pos, Eigen::VectorXd vel, Eigen::VectorXd acc)\n{\nauto [A, b] = forward_dynamics_matrix(pos, vel);\nreturn A*acc + b;\n}\n\nEigen::VectorXd forward_dynamics(Eigen::VectorXd pos, Eigen::VectorXd vel, Eigen::VectorXd force)\n{\nconst size_t n = degree();\nauto [A, b] = forward_dynamics_matrix(pos, vel);\nreturn A.fullPivLu().solve(force - b); // Todo\n}\n\nprivate:\nstd::vector&lt;LinkConfig&gt; &amp;config_;\n\nstd::vector&lt;symbol&gt; symbols_;\nstd::vector&lt;symbol&gt; dsymbols_;\nstd::vector&lt;symbol&gt; ddsymbols_;\n\nVector3ex forward_kinematics_ex_;\nMatrixXex jacobian_;\n\n// \u904b\u52d5\u65b9\u7a0b\u5f0f\nVectorXex tau_;\nMatrixXex Hq_;\nVectorXex cq_;\nVectorXex gq_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/linprog_8hpp/","title":"include/cpp_robotics/optimize/linprog.hpp","text":""},{"location":"doxybook/Files/linprog_8hpp/#source-code","title":"Source code","text":"<pre><code>// #pragma once\n\n// #include &lt;tuple&gt;\n// #include &lt;functional&gt;\n// #include &lt;Eigen/Dense&gt;\n\n// namespace cpp_robotics\n// {\n\n// // \u7dda\u5f62\u8a08\u753b\u6cd5\n// // min f^T x\n// // sub A x &lt; b\n// //     (Aeq x = beq)\n// //     (l &lt;= x &lt;= u)\n// class LinProgSolver\n// {\n//     Eigen::MatrixXd f;\n//     Eigen::MatrixXd A;\n//     Eigen::VectorXd b;\n\n//     std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; solve(Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000)\n//     {\n\n//     }\n// };\n\n// }\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/low__pass__filter_8hpp/","title":"include/cpp_robotics/filter/low_pass_filter.hpp","text":""},{"location":"doxybook/Files/low__pass__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/low__pass__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc"},{"location":"doxybook/Files/low__pass__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n// G(s) = omega / (s + omega)\nclass LowPassFilter : public TransferFunction\n{\npublic:\nLowPassFilter(double omega, double dt):\nomega_(omega)\n{\nTransferFunction::set_continuous({omega_}, {1, omega_}, dt);\n}\n\ndouble filtering(double u) { return responce(u); } double omega() const { return omega_; }\nprivate:\nconst double omega_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/lqr_8hpp/","title":"include/cpp_robotics/controller/lqr.hpp","text":""},{"location":"doxybook/Files/lqr_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/lqr_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;optional&gt;\n\nnamespace cpp_robotics\n{\n\nstatic std::optional&lt;Eigen::MatrixXd&gt; solve_riccati_arimoto_potter(const Eigen::MatrixXd &amp;A,\nconst Eigen::MatrixXd &amp;B,\nconst Eigen::MatrixXd &amp;Q,\nconst Eigen::MatrixXd &amp;R)\n{\nconst uint dim_x = A.rows();\nconst uint dim_u = B.cols();\nEigen::MatrixXd Ham = Eigen::MatrixXd::Zero(2 * dim_x, 2 * dim_x);\nHam &lt;&lt; A, -B * R.inverse() * B.transpose(), -Q, -A.transpose();\nEigen::EigenSolver&lt;Eigen::MatrixXd&gt; Eigs(Ham);\nEigen::MatrixXcd eigvec = Eigen::MatrixXcd::Zero(2 * dim_x, dim_x);\nint j = 0;\nfor (size_t i = 0; i &lt; 2 * dim_x; ++i)\n{\nif (Eigs.eigenvalues()[i].real() &lt; 0.0)\n{\neigvec.col(j) = Eigs.eigenvectors().block(0, i, 2 * dim_x, 1);\nj++;\n}\n}\nEigen::MatrixXcd Vs_1, Vs_2;\nVs_1 = eigvec.block(0, 0, dim_x, dim_x);\nVs_2 = eigvec.block(dim_x, 0, dim_x, dim_x);\nreturn (Vs_2 * Vs_1.inverse()).real();\n}\n\n// \u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306e\u884c\u5217\u3068\u30d9\u30af\u30c8\u30eb\u3068\u91cd\u307f\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b\nstatic Eigen::MatrixXd lqr(const Eigen::MatrixXd &amp;A,\nconst Eigen::MatrixXd &amp;B,\nconst Eigen::MatrixXd &amp;Q,\nconst Eigen::MatrixXd &amp;R)\n{\nauto P = solve_riccati_arimoto_potter(A, B, Q, R);\nreturn R.inverse() * B.transpose() * P.value();\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/lsei__transition_8hpp/","title":"include/cpp_robotics/optimize/lsei_transition.hpp","text":""},{"location":"doxybook/Files/lsei__transition_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/lsei__transition_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace cpp_robotics\n{\n\n// min || Cx + d ||_2^2 \n//  to\n// min 1/2 x^TQx + c^Tx\n// https://jp.mathworks.com/help/optim/ug/least-squares-model-fitting-algorithms.html#buc5ri4\nstd::tuple&lt;Eigen::MatrixXd, Eigen::VectorXd&gt; lsi2qp(const Eigen::MatrixXd &amp;C, const Eigen::VectorXd &amp;d)\n{\nreturn {2*C.transpose()*C, (2*C.transpose()*d)};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/mahalanobis_8hpp/","title":"include/cpp_robotics/algorithm/mahalanobis.hpp","text":""},{"location":"doxybook/Files/mahalanobis_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/mahalanobis_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\ndouble mahalanobis(const Eigen::VectorXd &amp;a, const Eigen::VectorXd &amp;b, const Eigen::MatrixXd cov_inv)\n{\nauto diff = a-b;\nreturn std::sqrt( diff.dot( cov_inv*diff ) );\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/math__utils_8hpp/","title":"include/cpp_robotics/utility/math_utils.hpp","text":""},{"location":"doxybook/Files/math__utils_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570"},{"location":"doxybook/Files/math__utils_8hpp/#defines","title":"Defines","text":"Name M_PI"},{"location":"doxybook/Files/math__utils_8hpp/#macros-documentation","title":"Macros Documentation","text":""},{"location":"doxybook/Files/math__utils_8hpp/#define-m_pi","title":"define M_PI","text":"<pre><code>#define M_PI 3.141592653589793238462643383279\n</code></pre>"},{"location":"doxybook/Files/math__utils_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n\n#ifndef M_PI\n#define M_PI 3.141592653589793238462643383279\n#endif \n\nnamespace cpp_robotics\n{\ninline namespace constants\n{\nconstexpr double PI         = 3.1415926535897932384626433832795;\n\nconstexpr double HALF_PI    = PI / 2.0;\n\nconstexpr double TWO_PI     = PI * 2.0;\n\nconstexpr double DEG_TO_RAD = PI / 180.0;\n\nconstexpr double RAD_TO_DEG = 180.0 / PI;\n\nconstexpr double EULER      = 2.718281828459045235360287471352;\n\nconstexpr double GRAVITY    = 9.807;\n\nconstexpr double Nm2gfm     = (1/GRAVITY);\n\nconstexpr double gfm2Nm     = GRAVITY;\n\nconstexpr double mNm2gfcm   = (Nm2gfm * 100);\n\nconstexpr double gfcm2mNm   = (gfm2Nm / 100);\n}\n\ntemplate&lt;typename T&gt;\nstatic constexpr bool in_range_open(T x, T min, T max) {\nreturn ((min &lt; x &amp;&amp; x &lt; max) ? true : false);\n}\n\ntemplate&lt;typename T&gt;\nstatic constexpr bool in_range(T x, T min, T max) {\nreturn ((min &lt;= x &amp;&amp; x &lt;= max) ? true : false);\n}\n\ntemplate&lt;typename T&gt;\nstatic constexpr int sgn(T x) {\nreturn (x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0);\n}\n\ntemplate&lt;typename T&gt;\nstatic constexpr double radians(T deg) {\nreturn (deg*DEG_TO_RAD);\n}\n\ntemplate&lt;typename T&gt;\nstatic constexpr double degrees(T rad)\n{\nreturn (rad*RAD_TO_DEG);\n}\n\nstatic inline double normalize_angle_positive(double angle)\n{\nreturn std::fmod(std::fmod(angle, TWO_PI) + TWO_PI, TWO_PI);\n}\n\nstatic inline double normalize_angle(double angle)\n{\ndouble a = normalize_angle_positive(angle);\nif (a &gt; PI)\na -= TWO_PI;\nreturn a;\n}\n\nstatic inline double shortest_angular_distance(double from, double to)\n{\nreturn normalize_angle(to-from);\n}\n\nstatic inline double nearest_angle(double from, double to)\n{\nreturn from + normalize_angle(to-from);\n}\n\n\nconstexpr inline double square(const double x) { return x*x; }\nconstexpr inline double cubic(const double x) { return x*x*x; }\nconstexpr inline double lerp(const double a, const double b, const double t) { return a + (b-a)*t; }\nconstexpr inline double approx_eq(const double a, const double b) { return (std::abs(a-b) &lt; 1e-12); }\nconstexpr inline double approx_zero(const double a) { return (std::abs(a) &lt; 1e-12); }\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/mecanum__ik_8hpp/","title":"include/cpp_robotics/chassis/mecanum_ik.hpp","text":""},{"location":"doxybook/Files/mecanum__ik_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/mecanum__ik_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::MecanumIk::Config"},{"location":"doxybook/Files/mecanum__ik_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/vector/transform.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass MecanumIk\n{\npublic:\nstruct Config\n{\ndouble width;\ndouble length;\n};\n\nMecanumIk(double width, double length):\nMecanumIk(Config{width, length}) {}\n\nMecanumIk(Config config):\nconfig_(config)\n{\nconst double norm = (config_.width + config_.length)/2.0;\nconv_mat_ &lt;&lt; -1,  1, norm,\n-1, -1, norm,\n1, -1, norm,\n1,  1, norm;\n}\n\nstd::array&lt;double, 4&gt; calculate(Transformd velocity)\n{\nstd::array&lt;double, 4&gt; wv;\nEigen::Map&lt;Eigen::Vector4d&gt; wv_vec(wv.data());\nEigen::Vector3d v(velocity.x, velocity.y, velocity.theta);\nwv_vec = conv_mat_ * v;\nreturn wv;\n}\n\nConfig config() const { return config_; }\n\nprivate:\nConfig config_;\nEigen::Matrix&lt;double, 4, 3&gt; conv_mat_;\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/minimum__jerk__model_8hpp/","title":"include/cpp_robotics/path_planning/minimum_jerk_model.hpp","text":""},{"location":"doxybook/Files/minimum__jerk__model_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/minimum__jerk__model_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace cpp_robotics\n{\n\nstatic double normalized_mjm_position(double t)\n{\ndouble t3 = t * t * t;\nreturn ( ((6.0*t - 15.0)*t + 10.0)*t3 );\n}\n\nstatic double normalized_mjm_velocity(double t)\n{\ndouble t2 = t * t;\nreturn ( ((30.0*t - 60.0)*t + 30.0)*t2 );\n}\n\nstatic double normalized_mjm_acceleration(double t)\n{\nreturn ( ((120.0*t - 180.0)*t + 60.0)*t );\n}\n\nstatic double normalized_mjm_jerk(double t)\n{\nreturn (360.0*t - 360.0)*t + 60.0;\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/misc_8hpp/","title":"include/cpp_robotics/algorithm/misc.hpp","text":""},{"location":"doxybook/Files/misc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/misc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\nnamespace cpp_robotics\n{\n\n// constexpr unsigned long fact(const unsigned long n)\n// {\n//     if(n == 0)\n//         return 1;\n//     return n * fact(n-1);\n// }\n\n// constexpr unsigned long combination(const unsigned long n, const unsigned long r)\n// {\n//     if (n == 0)\n//         return 1;\n//     else if (r == 0)\n//         return 1;\n//     else if (n == r)\n//         return 1;\n//     else\n//         return combination(n - 1, r) + combination(n - 1, r - 1);\n// }\n\n// template&lt;int N, int R, typename Callable&gt;\n// constexpr void combi_call_impl(int num, size_t K[R], int p, int w, int n, int r, Callable &amp;&amp; f)\n// {\n//     std::array&lt;size_t, R&gt; comb = {};\n\n//     if (p &gt; 0)\n//     {\n//         for (int i = 0; i &lt;= w; i++)\n//         {\n//             K[p] = i;\n//             combi_call_impl(num, K, p - 1, w - i, n, r, f);\n//         }\n//     }\n//     else\n//     {\n//         int m = 0, pick = 0;\n\n//         for (int i = 1; i &lt;= r; i++)\n//         {\n//             for (int j = 0; j &lt; K[i]; j++, m++)\n//                 pick++;\n//             comb[m] = pick;\n//             m++;\n//         }\n//         f(num, p);\n//         num++;\n//     }\n// }\n\n// template&lt;int N, int R, typename Callable&gt;\n// constexpr void combi_call(Callable &amp;&amp; f)\n// {\n\n//     size_t K[R] = {};\n//     size_t num = 0;\n\n//     combi_call_impl(num, K, R, N-R, N, R, f);\n\n//     // auto combi_impl = [&amp;f, &amp;comb, &amp;K, &amp;num, &amp;combi_impl](int p, int w, int n, int r) {\n//     //     if (p &gt; 0)\n//     //     {\n//     //         for (int i = 0; i &lt;= w; i++)\n//     //         {\n//     //             K[p] = i;\n//     //             combi_impl(p - 1, w - i, n, r);\n//     //         }\n//     //     }\n//     //     else\n//     //     {\n//     //         int m = 0, pick = 0;\n\n//     //         for (int i = 1; i &lt;= r; i++)\n//     //         {\n//     //             for (int j = 0; j &lt; K[i]; j++, m++)\n//     //                 pick++;\n//     //             comb[m] = pick;\n//     //             m++;\n//     //         });\n//     //         f(num, p);\n//     //         num++;\n//     //     }\n//     // }(R, N - R, N, R);\n\n// }\n\n// template&lt;int N = 5, int R = 3&gt;\n// constexpr auto combi_call_test()\n// {\n//     std::array&lt;std::array&lt;size_t, R&gt;, combination(N, R)&gt; re = {};\n//     combi_call&lt;N, R&gt;([&amp;re](size_t num, auto p){\n//         //re[num] = p;\n//     });\n\n//     return re;\n// }\n\n// template&lt;size_t conum&gt;\n// using twcoeff = std::array&lt;size_t, conum&gt;;\n\n// template&lt;&gt;\n// using twcoeff = std::array&lt;size_t, 3&gt;{1, 2, 1};\n\n// template&lt;&gt;\n// using twcoeff = std::array&lt;size_t, 4&gt;{1, 3, 3, 1};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/modern__control_8hpp/","title":"include/cpp_robotics/controller/modern_control.hpp","text":""},{"location":"doxybook/Files/modern__control_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/modern__control_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"../system/state_space_system.hpp\"\n#include \"../system/polynomial.hpp\"\n\nnamespace cpp_robotics\n{\nstatic Eigen::MatrixXd controllability_matrix(const Eigen::MatrixXd&amp; A, const Eigen::VectorXd&amp; B)\n{\nassert(A.rows() == A.cols());\nassert(A.rows() == B.size());\nconst int dim = A.rows();\n\nEigen::MatrixXd Uc(dim, dim);\nEigen::VectorXd colv = B;\n\nfor(int i = 0; i &lt; dim; i++)\n{\nUc.col(i) = colv;\ncolv = A * colv;\n}\n\nreturn Uc;\n}\n\nstatic bool is_controllable(const Eigen::MatrixXd&amp; A, const Eigen::VectorXd&amp; B)\n{\nconst int dim = A.rows();\nEigen::FullPivLU&lt;Eigen::MatrixXd&gt; lu(controllability_matrix(A, B));\nreturn (lu.rank() == dim);\n}\n\nstatic bool is_controllable(const StateSpaceSystem&amp; sys)\n{\nreturn is_controllable(sys.A().value(), sys.B().value());\n}\n\nstatic Eigen::MatrixXd observability_matrix(const Eigen::MatrixXd&amp; A, const Eigen::RowVectorXd&amp; C)\n{\nassert(A.rows() == A.cols());\nassert(A.rows() == C.size());\nconst int dim = A.rows();\n\nEigen::MatrixXd Uo(dim, dim);\nEigen::RowVectorXd colv = C;\n\nfor(int i = 0; i &lt; dim; i++)\n{\nUo.row(i) = colv;\ncolv = colv * A;\n}\n\nreturn Uo;\n}\n\nstatic bool is_observable(const Eigen::MatrixXd&amp; A, const Eigen::RowVectorXd&amp; C)\n{\nconst int dim = A.rows();\nEigen::FullPivLU&lt;Eigen::MatrixXd&gt; lu(observability_matrix(A, C));\nreturn (lu.rank() == dim);\n}\n\nstatic bool is_observable(const StateSpaceSystem&amp; sys)\n{\nreturn is_observable(sys.A().value(), sys.C());\n}\n\nenum class CanonicalizeMode\n{\n// MODEL,\nCOMPANION,\nOBSERBAVLE,\nCONTROLLABLE\n};\n\n// https://www.mathworks.com/help/control/ug/canonical-state-space-realizations.html\nstatic std::tuple&lt;Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd&gt; canonicalize_system(const Eigen::MatrixXd&amp; A, const Eigen::MatrixXd&amp; B, const Eigen::MatrixXd&amp; C, CanonicalizeMode mode = CanonicalizeMode::COMPANION)\n{\n// if(mode == MODEL)\n// else\nif(mode == CanonicalizeMode::CONTROLLABLE || mode == CanonicalizeMode::COMPANION || mode == CanonicalizeMode::OBSERBAVLE)\n{\nif(mode == CanonicalizeMode::CONTROLLABLE)\n{\nauto [A_tilda, B_tilda, C_tilda] = canonicalize_system(A, B, C, CanonicalizeMode::COMPANION);\nreturn {\nA_tilda.transpose(),\nC_tilda.transpose(),\nB_tilda.transpose()\n};\n}\nelse\n{\nEigen::MatrixXd Uc = controllability_matrix(A, B);\nEigen::MatrixXd Ucinv = Uc.inverse();\nreturn {\nUcinv*A*Uc,\nUcinv*B,\nC*Uc\n};\n}\n}\n\nreturn canonicalize_system(A, B, C, CanonicalizeMode::COMPANION);\n}\n\nstatic std::tuple&lt;Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd&gt; canonicalize_system(const StateSpaceSystem&amp; sys, CanonicalizeMode mode = CanonicalizeMode::COMPANION)\n{\nreturn canonicalize_system(sys.A().value(), sys.B().value(), sys.C(), mode);\n}\n\n// https://ossyaritoori.hatenablog.com/entry/2018/05/16/%E6%A5%B5%E9%85%8D%E7%BD%AE%E3%81%AE%E5%AE%9F%E8%A3%85%EF%BC%9A%E3%82%A2%E3%83%83%E3%82%AB%E3%83%BC%E3%83%9E%E3%83%B3%E6%B3%95%E3%81%AEMATLAB%E5%AE%9F%E8%A3%85#Outline\nstatic Eigen::VectorXd place(const StateSpaceSystem&amp; sys, std::vector&lt;double&gt; poles)\n{\nassert(sys.state_size() == poles.size());\nassert(sys.is_siso_model());\n\nauto pole_poly = Polynomial::expand(poles);\n\nauto Uc = controllability_matrix(sys.A().value(), sys.B().value());\n\nEigen::MatrixXd tmp = Eigen::MatrixXd::Zero(sys.state_size(), sys.state_size());\nEigen::MatrixXd An = Eigen::MatrixXd::Identity(sys.state_size(), sys.state_size());\n\nfor(size_t i = 0; i &lt; sys.state_size(); i++)\n{\ntmp += pole_poly.at_degree(i)*An;\nAn *= sys.A().value();\n}\ntmp += An;\n\nreturn (Uc.inverse() * tmp).row(sys.state_size()-1);\n}\n\n// \u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\\tilda{A}\u306e\u4fc2\u6570\u6bd4\u8f03\u306b\u3088\u308a\u6975\u914d\u7f6e\u3092\u884c\u3046\n// https://www.youtube.com/watch?v=yiFgI6Oos88\n//     static Eigen::VectorXd place(const StateSpaceSystem&amp; sys, std::vector&lt;double&gt; poles)\n//     {\n\n//     }\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/motor_8hpp/","title":"include/cpp_robotics/motor.hpp","text":""},{"location":"doxybook/Files/motor_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"motor/dc_motor_param.hpp\"\n#include \"motor/dc_motor_list.hpp\"\n#include \"motor/motor_tf.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/motor__tf_8hpp/","title":"include/cpp_robotics/motor/motor_tf.hpp","text":""},{"location":"doxybook/Files/motor__tf_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/motor__tf_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./dc_motor_param.hpp\"\n#include \"../system/transfer_function.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic TransferFunction make_motor_vel_tf(const DCMotorParam &amp;motor, const double dt)\n{\nreturn TransferFunction({motor.torque_constant}, {motor.inductance*motor.rotor_inertia, motor.resistance*motor.rotor_inertia, motor.torque_constant*motor.back_emf_constance}, dt);\n}\n\nstatic TransferFunction make_motor_pos_tf(const DCMotorParam &amp;motor, const double dt)\n{\nauto vel_tf = make_motor_vel_tf(motor, dt);\nauto new_den = vel_tf.den_array();\nnew_den.push_back(0);\nreturn TransferFunction(vel_tf.num_array(), new_den, dt);\n}\n\nstatic TransferFunction make_geared_motor_vel_tf(const DCGearedMotorParam &amp;geared_motor, const double dt)\n{\nauto &amp;motor = geared_motor.motor;\nauto &amp;gear_head = geared_motor.gear_head;\nreturn TransferFunction({motor.torque_constant * gear_head.ratio }, {motor.inductance*motor.rotor_inertia, motor.resistance*motor.rotor_inertia, motor.torque_constant*motor.back_emf_constance}, dt);\n}\n\nstatic TransferFunction make_geared_motor_pos_tf(const DCGearedMotorParam &amp;geared_motor, const double dt)\n{\nauto vel_tf = make_geared_motor_vel_tf(geared_motor, dt);\nauto new_den = vel_tf.den_array();\nnew_den.push_back(0);\nreturn TransferFunction(vel_tf.num_array(), new_den, dt);\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/nctf_8hpp/","title":"include/cpp_robotics/controller/nctf.hpp","text":""},{"location":"doxybook/Files/nctf_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/nctf_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668"},{"location":"doxybook/Files/nctf_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include \"./pid.hpp\"\n#include \"../filter/differentiator.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass NctfController\n{\npublic:\nstatic std::function&lt;double(double)&gt; make_simple_nct(double max_velocity, double slope)\n{\nreturn [=](double e){ return -max_velocity*std::tanh(e*slope/max_velocity); };\n}\n\nNctfController(double max_velocity, double nct_slope, PID::pid_param_t pid_param, double dt):\nNctfController(make_simple_nct(max_velocity, nct_slope), pid_param, dt)\n{\n\n}\n\nNctfController(std::function&lt;double(double)&gt; nct, PID::pid_param_t pid_param, double dt):\nnct_(nct),\ndiff_(pid_param.gpd, dt),\npid_(pid_param)\n{\n\n}\n\nvoid reset()\n{\ndiff_.reset();\npid_.reset();\n}\n\ndouble control(double target, double state) { return control(target-state); }\ndouble control(double e)\n{\ndouble state_e_dot = diff_.filtering(e);\ndouble nct_e_dot = nct_(e);\nreturn pid_.calculate(-(nct_e_dot - state_e_dot));\n}\n\nstd::function&lt;double(double)&gt; nct() const\n{\nreturn nct_;\n}\n\nprivate:\nstd::function&lt;double(double)&gt; nct_;\nDifferentiator diff_;\nPID pid_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/ndt_8hpp/","title":"include/cpp_robotics/algorithm/ndt.hpp","text":""},{"location":"doxybook/Files/ndt_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/ndt_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9"},{"location":"doxybook/Files/ndt_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./kdtree.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass NDT2d\n{\npublic:\nNDT2d() = default;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/newton__method_8hpp/","title":"include/cpp_robotics/optimize/newton_method.hpp","text":""},{"location":"doxybook/Files/newton__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/newton__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; newton_method(std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, std::function&lt;Eigen::MatrixXd(const Eigen::VectorXd &amp;)&gt; hesse, Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000)\n{\nEigen::VectorXd x = x_init;\nEigen::VectorXd dx;\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\ndx = grad(x);\n\nif(dx.norm() &lt; tol)\n{\nreturn {true, x, i};\n}\n\nx -= (hesse(x).inverse() * dx);\n}\n\nreturn {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/notch__filter_8hpp/","title":"include/cpp_robotics/filter/notch_filter.hpp","text":""},{"location":"doxybook/Files/notch__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/notch__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/notch__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n\nnamespace cpp_robotics\n{\n\n//         s^2 + d*2*zeta*omega*s + omega^2\n// G(s) = -------------------------------- \u3092\u53cc\u4e00\u6b21\u5909\u63db\n//          s^2 + 2*zeta*omega*s + omega^2\nclass NotchFilter : public TransferFunction\n{\npublic:\nNotchFilter(double omega, double zeta, double d, double dt):\nomega_(omega), zeta_(zeta), d_(d)\n{\nTransferFunction::set_continuous({1, (d_*2*zeta_*omega_), (omega_*omega_)}, {1, (2*zeta_*omega_), (omega_*omega_)}, dt);\n}\n\ndouble filtering(double u) { return responce(u); } double omega() const { return omega_; }\n\ndouble zeta() const { return zeta_; }\n\ndouble d() const { return d_; }\nprivate:\nconst double omega_;\nconst double zeta_;\nconst double d_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/nyquist_8hpp/","title":"include/cpp_robotics/system/nyquist.hpp","text":""},{"location":"doxybook/Files/nyquist_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/nyquist_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include \"./transfer_function.hpp\"\n#ifdef CR_USE_MATPLOTLIB\n#include \"../third_party/matplotlib-cpp/matplotlibcpp.h\"\n#endif\n#include \"../utility/space.hpp\"\n#include \"../vector/vector2.hpp\"\n#include \"../utility/math_utils.hpp\"\n#include \"./bode.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; nyquist(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500))\n{\nsize_t n = omegas.size();\nstd::vector&lt;double&gt; Re(n), Im(n);\nauto [g, ph] = bode(tf, omegas, false, false);\n\nVector2d tmp;\nfor(size_t i = 0; i &lt; n; i++)\n{\ntmp.x = g[i];\ntmp.y = 0;\ntmp.rotate(ph[i]);\nRe[i] = tmp.x;\nIm[i] = tmp.y;\n}\n\nreturn {Re, Im};\n}\n\n#ifdef CR_USE_MATPLOTLIB\nstatic void nyquist_plot(TransferFunction &amp;tf, const std::vector&lt;double&gt; &amp;omegas = logspace(-2, 2, 500))\n{\nnamespace plt = matplotlibcpp;\nauto [Re, Im] = nyquist(tf, omegas);\n\nplt::plot(Re, Im);\nplt::set_aspect(1.0);\nplt::xlabel(\"Re\");\nplt::ylabel(\"Im\");\nplt::xlim(-1.3*Re[0], 1.3*Re[0]);\nplt::ylim(-1.3*Re[0], 1.3*Re[0]);\nplt::grid(true, \"both\");\n\nplt::show();\n}\n#endif\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/omni__ik_8hpp/","title":"include/cpp_robotics/chassis/omni_ik.hpp","text":""},{"location":"doxybook/Files/omni__ik_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/omni__ik_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni3Ik::Config class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni4Ik::Config"},{"location":"doxybook/Files/omni__ik_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/vector/transform.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass Omni3Ik\n{\npublic:\nstruct Config\n{\ndouble radius;\ndouble first_wheel_angle = M_PI/6;\n};\n\nOmni3Ik(double radius, double first_wheel_angle = M_PI/6):\nOmni3Ik(Config{radius, first_wheel_angle}) {}\n\nOmni3Ik(Config config):\nconfig_(config)\n{\nfor(size_t i = 0; i &lt; 3; i++)\n{\nconst double wheel_angle = config_.first_wheel_angle + (i* 2*M_PI/3);\nconv_mat_(i, 0) = -std::sin(wheel_angle);\nconv_mat_(i, 1) =  std::cos(wheel_angle);\nconv_mat_(i, 2) = config_.radius;\n\n}\n}\n\nstd::array&lt;double, 3&gt; calculate(Transformd velocity)\n{\nstd::array&lt;double, 3&gt; wv;\nEigen::Map&lt;Eigen::Vector3d&gt; wv_vec(wv.data());\nEigen::Vector3d v(velocity.x, velocity.y, velocity.theta);\nwv_vec = conv_mat_ * v;\nreturn wv;\n}\n\nConfig config() const { return config_; }\n\nprivate:\nConfig config_;\nEigen::Matrix&lt;double, 3, 3&gt; conv_mat_;\n};\n\nclass Omni4Ik\n{\npublic:\nstruct Config\n{\ndouble radius;\ndouble first_wheel_angle = M_PI/4;\n};\n\nOmni4Ik(double radius, double first_wheel_angle = M_PI/4):\nOmni4Ik(Config{radius, first_wheel_angle}) {}\n\nOmni4Ik(Config config):\nconfig_(config)\n{\nfor(size_t i = 0; i &lt; 4; i++)\n{\nconst double wheel_angle = config_.first_wheel_angle + (i* M_PI/2);\nconv_mat_(i, 0) = -std::sin(wheel_angle);\nconv_mat_(i, 1) =  std::cos(wheel_angle);\nconv_mat_(i, 2) = config_.radius;\n\n}\n}\n\nstd::array&lt;double, 4&gt; calculate(Transformd velocity)\n{\nstd::array&lt;double, 4&gt; wv;\nEigen::Map&lt;Eigen::Vector4d&gt; wv_vec(wv.data());\nEigen::Vector3d v(velocity.x, velocity.y, velocity.theta);\nwv_vec = conv_mat_ * v;\nreturn wv;\n}\n\nConfig config() const { return config_; }\n\nprivate:\nConfig config_;\nEigen::Matrix&lt;double, 4, 3&gt; conv_mat_;\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/optimize_8hpp/","title":"include/cpp_robotics/optimize.hpp","text":""},{"location":"doxybook/Files/optimize_8hpp/#source-code","title":"Source code","text":"<pre><code>#include \"optimize/constraint.hpp\"\n#include \"optimize/derivative.hpp\"\n#include \"optimize/bracketing_serach.hpp\"\n#include \"optimize/golden_serach.hpp\"\n#include \"optimize/steepest_descent_method.hpp\"\n#include \"optimize/newton_method.hpp\"\n#include \"optimize/quasi_newton_method.hpp\"\n#include \"optimize/penalty_method.hpp\"\n#include \"optimize/barrier_method.hpp\"\n#include \"optimize/linprog.hpp\"\n#include \"optimize/quadprog.hpp\"\n#include \"optimize/sqp.hpp\"\n#include \"optimize/interior_point_method.hpp\"\n#include \"optimize/active_set_method.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/path__planning_8hpp/","title":"include/cpp_robotics/path_planning.hpp","text":""},{"location":"doxybook/Files/path__planning_8hpp/#source-code","title":"Source code","text":"<pre><code>#include \"path_planning/grid_path_planning_utils.hpp\"\n#include \"path_planning/a_star.hpp\"\n#include \"path_planning/wave_propagation.hpp\"\n#include \"path_planning/dubins_path.hpp\"\n#include \"path_planning/frenet_frame.hpp\"\n#include \"path_planning/dwa.hpp\"\n#include \"path_planning/spline.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/penalty__method_8hpp/","title":"include/cpp_robotics/optimize/penalty_method.hpp","text":""},{"location":"doxybook/Files/penalty__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/penalty__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"constraint.hpp\"\n#include \"derivative.hpp\"\n#include \"quasi_newton_method.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; penalty_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init = 1.0, const double tol = 1e-3, const size_t max_iter = 1000)\n{\nEigen::VectorXd x = x_init;\ndouble r = r_init;\nstd::function&lt;double(const Eigen::VectorXd &amp;)&gt; ext_f = [&amp;](const Eigen::VectorXd &amp; x)\n{\ndouble y = f(x);\n\nfor(auto &amp; con : constraint)\n{\nswitch(con.type)\n{\ncase Constraint::Type::Eq:\ny += r*std::pow(con.con_f(x), 2);\nbreak;\ncase Constraint::Type::Ineq:\ny += r*std::pow(std::max(0.0, con.con_f(x)), 2);\nbreak;\n}\n}\n\nreturn y;\n};\n\nauto ext_grad = [&amp;](Eigen::VectorXd x)\n{\nreturn derivative(ext_f, x);\n};\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\nauto [step_result, new_x, sub_itr_cnt] = quasi_newton_method(ext_f, ext_grad, x, tol, 1);\nif(std::abs(r * constraint.eval_sum(new_x)) &lt; tol)\nreturn {true, new_x, i};\n\nx = new_x;\nr += 1;\n}\nreturn {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/pfc_8hpp/","title":"include/cpp_robotics/controller/pfc.hpp","text":""},{"location":"doxybook/Files/pfc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pfc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SISOPFC"},{"location":"doxybook/Files/pfc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n// https://hamachannel.hatenablog.com/entry/2018/01/13/233521\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;cmath&gt;\n#include &lt;functional&gt;\n\nnamespace cpp_robotics\n{\n\nclass SISOPFC\n{\npublic:\n\nSISOPFC(const Eigen::MatrixXd&amp; Ad, const Eigen::VectorXd&amp; Bd, const Eigen::VectorXd&amp; Cd, const double delay, const double target_responce_time, const double dt):\nA(Ad), B(Bd), C(Cd), delay_(delay), target_responce_time_(target_responce_time), dt_(dt), prev_input_(0)\n{\nh1 = std::ceil(target_responce_time_ / (dt_ * 3));\nh2 = std::ceil(target_responce_time_ / (dt_ * 2));\nh3 = std::ceil(target_responce_time_ / (dt_ * 1));\n\nlh &lt;&lt;\n(1.0 - std::exp(-3.0 * (double)(h1) * dt_ / target_responce_time_)),\n(1.0 - std::exp(-3.0 * (double)(h2) * dt_ / target_responce_time_)),\n(1.0 - std::exp(-3.0 * (double)(h3) * dt_ / target_responce_time_));\n\nCAh1 = CAh2 = CAh3 = C.transpose().eval();\nfor(size_t i = 0; i &lt; h1; i++)\nCAh1 *= A;\nfor (size_t i = 0; i &lt; h2; i++)\nCAh2 *= A;\nfor (size_t i = 0; i &lt; h3; i++)\nCAh3 *= A;\n\nG_inv.setZero();\nEigen::RowVectorXd tmp = C.transpose();\nfor (size_t i = 0; i &lt; h1; i++)\n{\nif(i &gt; 0)\ntmp *= A;\ndouble ele = tmp.dot(B);\ndouble t1 = dt_ * (h1-1-i);\ndouble t2 = t1 * t1;\nG_inv(0, 0) += ele;\nG_inv(0, 1) += ele * t1;\nG_inv(0, 2) += ele * t2;\n}\n\ntmp = C.transpose();\nfor (size_t i = 0; i &lt; h2; i++)\n{\nif (i &gt; 0)\ntmp *= A;\ndouble ele = tmp.dot(B);\ndouble t1 = dt_ * (h2-1-i);\ndouble t2 = t1 * t1;\nG_inv(1, 0) += ele;\nG_inv(1, 1) += ele * t1;\nG_inv(1, 2) += ele * t2;\n}\ntmp = C.transpose();\nfor (size_t i = 0; i &lt; h3; i++)\n{\nif (i &gt; 0)\ntmp *= A;\ndouble ele = tmp.dot(B);\ndouble t1 = dt_ * (h3-1 - i);\ndouble t2 = t1 * t1;\nG_inv(2, 0) += ele;\nG_inv(2, 1) += ele * t1;\nG_inv(2, 2) += ele * t2;\n}\n\nG_inv = G_inv.inverse().eval();\nxm = Eigen::VectorXd::Zero(A.cols());\n}\n\ndouble calculate(std::function&lt;double(double)&gt; ref_target, double now_state)\n{\nreturn calculate(ref_target, now_state, prev_input_);\n}\n\ndouble calculate(std::function&lt;double(double)&gt; ref_target, double now_state, double prev_input)\n{\nEigen::Vector3d SV_future;\nEigen::Vector3d SF;\n\nxm = A * xm + B * prev_input;\ndouble y = C.dot(xm);\n\ndouble now_tsarget = ref_target(delay_);\n\nSV_future &lt;&lt;\nref_target(delay_ + h1 * dt_) - now_tsarget,\nref_target(delay_ + h2 * dt_) - now_tsarget,\nref_target(delay_ + h3 * dt_) - now_tsarget;\n\nSF &lt;&lt;\nCAh1.dot(xm),\nCAh2.dot(xm),\nCAh3.dot(xm);\n\nauto buf = G_inv * (SV_future + (now_tsarget - now_state) * lh - SF + Eigen::Vector3d::Constant(y));\nprev_input_ = std::clamp&lt;double&gt;(buf(0), -12, 12);\n\nreturn prev_input_;\n}\n\ndouble prev_input() const { return prev_input_; }\nprivate:\nEigen::Matrix3d G_inv;\nEigen::MatrixXd A;\nEigen::VectorXd B, xm, MV_pre;\nEigen::VectorXd C;\nEigen::RowVectorXd CAh1, CAh2, CAh3;\nEigen::Vector3d lh;\nsize_t h1, h2, h3;\ndouble delay_;\ndouble target_responce_time_, dt_;\ndouble prev_input_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/pid2_8hpp/","title":"include/cpp_robotics/controller/pid2.hpp","text":""},{"location":"doxybook/Files/pid2_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pid2_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PID2 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 struct cpp_robotics::PID2::pid_param_t"},{"location":"doxybook/Files/pid2_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\nclass PID2\n{\npublic:\nstruct pid_param_t\n{\ndouble Ts;\ndouble gpd;\ndouble Kp, Ki, Kd;\ndouble b, c;\nstd::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit;\n};\n\nstatic PID2 create_PI_D(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit = std::nullopt)\n{\npid_param_t param = {\n.Ts = Ts,\n.gpd = gpd,\n.Kp = Kp,\n.Ki = Ki,\n.Kd = Kd,\n.b = 1,\n.c = 0,\n.output_limit = output_limit\n};\n\nreturn PID2(param);\n}\n\nstatic PID2 create_I_PD(double Ts, double gpd, double Kp, double Ki, double Kd, std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit = std::nullopt)\n{\npid_param_t param = {\n.Ts = Ts,\n.gpd = gpd,\n.Kp = Kp,\n.Ki = Ki,\n.Kd = Kd,\n.b = 0,\n.c = 0,\n.output_limit = output_limit\n};\n\nreturn PID2(param);\n}\n\nstatic PID2 create_feed_foward_pid2(double Ts, double gpd, double Kpff, double Kdff, double Kpfb, double Kifb, double Kdfb, std::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit = std::nullopt)\n{\npid_param_t param = {\n.Ts = Ts,\n.gpd = gpd,\n.Kp = Kpfb,\n.Ki = Kifb,\n.Kd = Kdfb,\n.b = (Kpff+Kpfb)/Kpfb,\n.c = (Kdff+Kdfb)/Kdfb,\n.output_limit = output_limit\n};\n\nreturn PID2(param);\n}\n\nPID2(pid_param_t param)\n{\nset_param(param);\nreset();\n}\n\nvoid set_param(pid_param_t param)\n{\nparam_ = param;\n}\n\nvoid reset()\n{\nu1_ = 0;\nu2_ = 0;\nr1_ = 0;\nr2_ = 0;\ny1_ = 0;\ny2_ = 0;\n}\n\ndouble calculate(double target, double present)\n{\ndouble &amp;r = target;\ndouble &amp;y = present;\nauto &amp;[Ts, gpd, Kp, Ki, Kd, b, c, output_limit] = param_;\n\ndouble u = ( Kp*( (4.0+2.0*gpd*Ts)*(b*r-y) - 8.0*(b*r1_-y1_) + (4.0-2.0*gpd*Ts)*(b*r2_-y2_) )\n+Ki*Ts*( (2.0+gpd*Ts)*(r-y) +2.0*gpd*Ts*(r1_-y1_) - (2.0-gpd*Ts)*(r2_-y2_) ) +4.0*Kd*gpd*( (c*r-y) - 2.0*(c*r1_-y1_) + (c*r2_-y2_) ) + 8.0*u1_ -(4.0-2.0*gpd*Ts)*u2_) / (4.0+2.0*gpd*Ts);\n\nif(output_limit)\n{\nu = std::clamp(u, output_limit.value().first, output_limit.value().second);\n}\n\nr2_ = r1_;\nr1_ = r;\ny2_ = y1_;\ny1_ = y;\n\nu2_ = u1_;\nu1_ = u;\n\nreturn u;\n}\n\nprivate:\npid_param_t param_;\ndouble u1_, u2_;\ndouble r1_, r2_;\ndouble y1_, y2_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/pid_8hpp/","title":"include/cpp_robotics/controller/pid.hpp","text":""},{"location":"doxybook/Files/pid_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pid_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PID PID\u5236\u5fa1\u5668 struct cpp_robotics::PID::pid_param_t"},{"location":"doxybook/Files/pid_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n#include &lt;algorithm&gt;\n\nnamespace cpp_robotics\n{\n\nclass PID\n{\npublic:\nstruct pid_param_t\n{\ndouble Ts;\ndouble gpd;\ndouble Kp, Ki, Kd;\nstd::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit;\n};\n\nPID(pid_param_t param)\n{\nset_param(param);\nreset();\n}\n\nvoid set_param(pid_param_t param)\n{\nparam_ = param;\n}\n\nvoid reset()\n{\nu1_ = 0;\nu2_ = 0;\ne1_ = 0;\ne2_ = 0;\n}\n\ndouble calculate(double error)\n{\nauto &amp;[Ts, gpd, Kp, Ki, Kd, output_limit] = param_;\n\ndouble u = ( 2.0*Ts*(Ki+Kp*gpd)*(error-e2_) + Ki*gpd*Ts*Ts*(error+2.0*e1_+e2_) +\n4.0*(Kd*gpd+Kp)*(error-2.0*e1_+e2_) - (4.0-2.0*gpd*Ts)*u2_ + 8.0*u1_) / (4.0+2.0*gpd*Ts);\n\ne2_ = e1_;\ne1_ = error;\n\nu2_ = u1_;\nu1_ = u;\n\nif(output_limit)\n{\nu = std::clamp(u, output_limit.value().first, output_limit.value().second);\n}\n\nreturn u;\n}\n\nprivate:\npid_param_t param_;\ndouble u1_, u2_;\ndouble e1_, e2_;\n};\n\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/poly__regression_8hpp/","title":"include/cpp_robotics/algorithm/poly_regression.hpp","text":""},{"location":"doxybook/Files/poly__regression_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/poly__regression_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;vector&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/system/polynomial.hpp\"\n\nnamespace cpp_robotics\n{\n\nPolynomial poly_regression(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y, const size_t degree)\n{\nEigen::MatrixXd XT, Y;\n\nassert(x.size() == y.size());\nconst size_t data_num = x.size();\nXT.resize(degree + 1, data_num);\nY.resize(data_num, 1);\n\nfor (size_t j = 0; j &lt; x.size(); j++)\n{\nXT(0, j) = 1;\nfor (size_t i = 0; i &lt; degree; i++)\n{\nXT(i + 1, j) = XT(i, j) * x[j];\n}\n}\n\nfor (size_t i = 0; i &lt; y.size(); i++)\n{\nY(i) = y[i];\n}\n\nstd::vector&lt;double&gt; coeff(degree + 1);\nEigen::Map&lt;Eigen::VectorXd&gt; coeff_vec(coeff.data(), degree + 1);\ncoeff_vec = (XT * XT.transpose()).inverse() * (XT * Y);\nreturn Polynomial(coeff);\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/polynomial_8hpp/","title":"include/cpp_robotics/system/polynomial.hpp","text":""},{"location":"doxybook/Files/polynomial_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/polynomial_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Polynomial \u591a\u9805\u5f0f"},{"location":"doxybook/Files/polynomial_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n// #include &lt;initializer_list&gt;\n#include &lt;cassert&gt;\n#include \"../utility/cpp_support.hpp\"\n\nnamespace cpp_robotics\n{\n\n// _coeff.front()\u304c\u6700\u9ad8\u6b21\u6570\n// _coeff.back()\u304c\u6b21\u65700\nstruct Polynomial\n{\nPolynomial() = default;\n\nPolynomial(std::initializer_list&lt;double&gt; coeff):\n_coeff(coeff.begin(), coeff.end()) {}\n\nPolynomial(const std::vector&lt;double&gt; &amp;coeff):\n_coeff(coeff) {}\n\ntemplate&lt;class IteratorType&gt;\nPolynomial(IteratorType begin, IteratorType end):\n_coeff(begin, end) {}\n\n// (x-a1)(x-a2)...(x-aN)\u306e{a...aN}\u3092\u5f15\u6570\u306b\u3068\u308a\u5c55\u958b\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059\nstatic Polynomial expand(std::vector&lt;double&gt; roots)\n{\nstd::vector&lt;double&gt; coeff, buf;\ncoeff.reserve(roots.size()+1);\nbuf.reserve(roots.size());\ncoeff.resize(1);\n\ncoeff[0] = 1;\nfor(auto &amp;c : roots)\n{\n\n// (x^m+a*x^m-1 ... c) * x\u3092\u8a08\u7b97\u3059\u308b\nbuf = coeff;\ncoeff.push_back(0);\n\n// (x^m+a*x^m-1 ... c) * d\u3092\u8a08\u7b97\u3059\u308b\nfor(auto &amp;bval : buf)\nbval *= -c;\n\n// (x^m+a*x^m-1 ... c) * d\u3092\u52a0\u7b97\u3059\u308b\nfor(size_t i = 0; i &lt; buf.size(); i++)\n{\ncoeff[i+1] += buf[i];\n}\n}\n\nreturn Polynomial{coeff};\n}\n\nvoid set_degree(size_t deg) { _coeff.resize(deg + 1); }\nsize_t size() const { return _coeff.size(); }\nsize_t degree() const { return size() ? (size() - 1) : 0; }\n//size_t degree_at(size_t i) const { return size() ? (degree() - i) : 0; }\n\nstd::vector&lt;double&gt; coeff() const { return _coeff; }\n\ndouble &amp;at(size_t i) { return _coeff[i]; }\ndouble  at(size_t i) const { return _coeff[i]; }\n\ndouble &amp;at_degree(size_t i) { return _coeff[degree()-i]; }\ndouble  at_degree(size_t i) const { return _coeff[degree()-i]; }\n\ndouble &amp;operator [](size_t i) { return at(i); }\ndouble operator [](size_t i) const { return at(i); }\n\nvoid check_degree()\n{\nwhile(size())\n{\nif(at(degree()) != 0)\nreturn;\n_coeff.erase(_coeff.begin() + _coeff.size()-1);\n}\n}\n\ndouble evalute(double x) const\n{\nassert(_coeff.size() != 0);\n\ndouble xn = 1;\ndouble y = _coeff.back();\nfor(auto it = _coeff.rbegin()+1; it != _coeff.rend(); it++)\n{\ny = y*x + (*it);\n}\n\nreturn y;\n}\n\n// /**\n//  * @brief \u591a\u9805\u5f0f\u3092n\u968e\u5fae\u5206\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059\n//  * \n//  * @param i \n//  * @return Polynomial \n//  */\n// Polynomial polyder(size_t i) const\n// {\n//     assert(degree() &gt; 0);\n\n//     if(i == 0)\n//         return *this;\n//     if(i &gt; degree())\n//         return {0};\n\n//     Polynomial dpol = *this;\n\n//     for(size_t c = 0; c &lt; dpol.size(); c++)\n//     {\n//         if(c &gt;= i)\n//         {\n//             size_t nc = 1;\n//             for(size_t r = 0; r &lt; i; r++)\n//             {\n//                 nc *= (c - r);\n//             }\n//             dpol[c] *= static_cast&lt;double&gt;(nc);\n//         }\n\n//     }\n//     dpol._coeff.erase(dpol._coeff.begin(), dpol._coeff.begin()+i);\n\n\n//     // size_t deg = dpol.degree();\n//     // dpol._coeff.resize(dpol.size() - i);\n\n//     // for(size_t c = 0; c &lt; dpol.size(); c++)\n//     // {\n//     //     size_t nc = 1;\n//     //     for(size_t r = 0; r &lt; i; r++)\n//     //     {\n//     //         nc *= (deg - c - r);\n//     //     }\n//     //     dpol[c] *= static_cast&lt;double&gt;(nc);\n//     // }\n\n//     return dpol;\n// }\n\n// Polynomial polyint(double C = 0) const\n// {\n//     Polynomial ipol = *this;\n\n//     for(size_t i = 0; i &lt; ipol.size(); i++)\n//     {\n//         double ndeg = static_cast&lt;double&gt;(i + 1);\n//         ipol[i] /= ndeg;\n//     }\n\n//     ipol._coeff.insert(ipol._coeff.begin(), C);\n\n//     return ipol;\n// }\n\nvoid swap(Polynomial &amp;poly)\n{\nPolynomial tmp = *this;\n*this = poly;\npoly = tmp;\n}\n\ndouble operator()(double x) const\n{\nreturn evalute(x);\n}\n\nPolynomial operator +() const\n{\nreturn *this;\n}\n\nPolynomial operator -() const\n{\nPolynomial ret = *this;\nfor(auto &amp;c : ret._coeff)\nc *= -1;\nreturn ret;\n}\n\nPolynomial operator +(double s) const\n{\nPolynomial ret = *this;\nret[ret.degree()] += s;\nret.check_degree();\nreturn ret;\n}\n\nPolynomial operator -(double s) const\n{\nPolynomial ret = *this;\nret[ret.degree()] -= s;\nret.check_degree();\nreturn ret;\n}\n\nPolynomial&amp; operator +=(double s)\n{\nthis-&gt;at(this-&gt;degree()) += s;\nthis-&gt;check_degree();\nreturn *this;\n}\n\nPolynomial&amp; operator -=(double s)\n{\nthis-&gt;at(this-&gt;degree()) -= s;\nthis-&gt;check_degree();\nreturn *this;\n}\n\nPolynomial operator *(double s) const\n{\nPolynomial ret = *this;\nfor(auto &amp;c : ret._coeff)\nc *= s;\nret.check_degree();\nreturn ret;\n}\n\nfriend Polynomial operator *(double s, const Polynomial &amp;poly)\n{\nreturn poly * s;\n}\n\nPolynomial&amp; operator *=(double s)\n{\n*this = *this * s;\nreturn *this;\n}\n\nPolynomial operator /(double s) const\n{\nPolynomial ret = *this;\nfor(auto &amp;c : ret._coeff)\nc /= s;\nret.check_degree();\nreturn ret;\n}\n\nPolynomial&amp; operator /=(double s)\n{\n*this = *this / s;\nreturn *this;\n}\n\nPolynomial operator *(const Polynomial &amp;p) const\n{\nstd::vector&lt;double&gt; new_coeff(this-&gt;degree() + p.degree() + 1);\nsize_t new_deg = new_coeff.size()-1;\n\nstd::vector&lt;double&gt; c0 = this-&gt;coeff();\nstd::vector&lt;double&gt; c1 = p.coeff();\n\nfor(size_t i0 = 0; i0 &lt; c0.size(); i0++)\n{\nfor(size_t i1 = 0; i1 &lt; c1.size(); i1++)\n{\nsize_t deg0 = this-&gt;degree() - i0;\nsize_t deg1 = p.degree() - i1;\n\nsize_t deg = new_deg - (deg0 + deg1);\n\nnew_coeff[deg] += c0[i0] * c1[i1];\n}\n}\nPolynomial new_p(new_coeff);\nreturn new_p;\n}\n\nPolynomial&amp; operator *=(const Polynomial &amp;p)\n{\n*this = *this * p;\nreturn *this;\n}\n\nPolynomial operator +(Polynomial poly) const\n{\nPolynomial ret = *this;\nif(ret.degree() &lt; poly.degree())\n{\nret.swap(poly);\n}\n\nfor (auto [it, rit] =\nstd::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()};\nit != poly._coeff.rend(); it++, rit++)\n{\n*rit += *it;\n}\nret.check_degree();\nreturn ret;\n}\n\nPolynomial&amp; operator +=(Polynomial poly)\n{\n*this = *this + poly;\nreturn *this;\n}\n\nPolynomial operator -(Polynomial poly) const\n{\nPolynomial ret = *this;\nint pm = 1;\nif(ret.degree() &lt; poly.degree())\n{\nret.swap(poly);\npm = -1;\n}\n\nfor (auto [it, rit] =\nstd::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()};\nit != poly._coeff.rend(); it++, rit++)\n{\n*rit -= *it;\n}\nret.check_degree();\nreturn pm*ret;\n}\n\nPolynomial&amp; operator -=(Polynomial poly)\n{\n*this = *this - poly;\nreturn *this;\n}\n\nfriend bool operator==(const Polynomial&amp; lhs, const Polynomial&amp; rhs)\n{\nreturn lhs._coeff == rhs._coeff;\n}\n\nfriend bool operator!=(const Polynomial&amp; lhs, const Polynomial&amp; rhs)\n{\nreturn lhs._coeff != rhs._coeff;\n}\n\nprivate:\nstd::vector&lt;double&gt; _coeff;\n};\n\nstd::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Polynomial&amp; v)\n{\nos &lt;&lt; \"( \";\n\nbool is_outputed = false;\nfor(size_t i = 0; i &lt; v.size(); i++)\n{\ndouble coeff = v.coeff()[i];\nsize_t deg = v.degree() - i;\nif(coeff != 0)\n{\nif(is_outputed)\n{\nif(coeff &gt;= 0)\nos &lt;&lt; \" + \";\nelse\nos &lt;&lt; \" - \";\n}\n\nos &lt;&lt; std::abs(coeff);\nif(deg &gt; 0)\nos &lt;&lt; \"x^\" + std::to_string(deg);\n\nis_outputed = true;\n}\n}\n\nos &lt;&lt; \" )\";\nreturn os;\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/psmc_8hpp/","title":"include/cpp_robotics/controller/psmc.hpp","text":""},{"location":"doxybook/Files/psmc_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/psmc_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PSMC struct cpp_robotics::PSMC::param_t"},{"location":"doxybook/Files/psmc_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;array&gt;\n#include &lt;utility&gt;\n#include &lt;cpp_robotics/utility/cpp_support.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass PSMC\n{\npublic:\nstruct param_t\n{\ndouble Ts;\ndouble Kp, Kd;\ndouble Hs;\nstd::optional&lt;std::pair&lt;double, double&gt;&gt; output_limit;\n};\n\nPSMC()\n{\nreset();\n}\n\nPSMC(param_t param):\nparam_(param)\n{\nreset();\n}\n\nPSMC(double p, double d, double Hs, double dt)\n{\nparam_.Kp = p;\nparam_.Kd = d;\nparam_.Hs = Hs;\nparam_.Ts = dt;\nreset();\n}\n\nPSMC(double p, double d, double Hs, double min_output, double max_output, double dt)\n{\nparam_.Kp = p;\nparam_.Kd = d;\nparam_.Hs = Hs;\nparam_.output_limit = std::pair(min_output, max_output);\nparam_.Ts = dt;\nreset();\n}\n\nvoid reset()\n{\nfor(size_t i = 0; i &lt; 2; i++)\n{\ntarget_val_[i] = now_val_[i] = error_[i] = 0.0;\n}\n}\n\nvoid set_param(param_t param)\n{\nparam_ = param;\n}\n\ndouble calculate(double target_val, double now_val)\n{\ndouble target_velocity, now_velocity;\n\ntarget_velocity = (target_val - target_val_[0])/param_.Ts;\nnow_velocity =  (now_val - now_val_[0])/param_.Ts;\n\nreturn calculate(target_val, now_val, target_velocity, now_velocity);\n}\n\ndouble calculate(double target_val, double now_val, double target_velocity, double now_velocity)\n{\ndouble s, u, f, e;\n\n// coeff\ndouble ua, ub;\ndouble ea;\n\nshift_right(target_val_.begin(), target_val_.begin(), 1);\ntarget_val_[0] = target_val;\nshift_right(now_val_.begin(), now_val_.begin(), 1);\nnow_val_[0] = now_val;\n\ns = (target_val_[0] - now_val_[0]) + param_.Hs*(target_velocity - now_velocity);\n\nua = (param_.Kd + param_.Kp*param_.Ts)/(param_.Hs + param_.Ts);\nub = (param_.Kp*param_.Hs - param_.Kd)/(param_.Hs + param_.Ts);\nu = ua*s + ub*error_[0];\n\nif(param_.output_limit)\nf = std::clamp(u, param_.output_limit.value().first, param_.output_limit.value().second);\nelse\nf = u;\n\nea = param_.Kd + param_.Kp*param_.Ts;\ne = (param_.Kd * error_[0] + param_.Ts*f) / ea;\n\nshift_right(error_.begin(), error_.begin(), 1);\nerror_[0] = e;\n\nreturn f;\n}\n\ndouble &amp;Kp() { return param_.Kp; }\ndouble &amp;Kd() { return param_.Kd; }\ndouble &amp;Hs() { return param_.Hs; }\n\nprivate:\nparam_t param_;\n\nstd::array&lt;double, 2&gt; target_val_;\nstd::array&lt;double, 2&gt; now_val_;\nstd::array&lt;double, 2&gt; error_;\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/pure__pursuit_8hpp/","title":"include/cpp_robotics/controller/pure_pursuit.hpp","text":""},{"location":"doxybook/Files/pure__pursuit_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/pure__pursuit_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668"},{"location":"doxybook/Files/pure__pursuit_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include \"../vector/vector2.hpp\"\n\nnamespace cpp_robotics\n{\n\n// https://myenigma.hatenablog.com/entry/2017/06/05/111007\n// https://sd08419ttic.hatenablog.com/entry/2020/03/22/152044\n// https://www.youtube.com/watch?v=zMdoLO4kRKg\n// https://www.coursera.org/lecture/intro-self-driving-cars/lesson-2-geometric-lateral-control-pure-pursuit-44N7x\n// https://www.youtube.com/watch?v=34CSRIlHMNk\n\nclass PurePursuit\n{\npublic:\n// K\u306f\u6b63\u306e\u5b9f\u6570\u30010\u306b\u8fd1\u3044\u307b\u3069\u30ed\u30d0\u30b9\u30c8\u6027\u304c\u843d\u3061\u308b\nPurePursuit(double K):\nK_(K) {}\n\nvoid set_K(double K)\n{\nK_ = K;\n}\n\nstd::tuple&lt;bool, double&gt; control(std::function&lt;Vector2d(double)&gt; traj_ref, double traj_progress, Vector2d pos_present, double vel, double angle_present)\n{\nvel = std::abs(vel);\n\n// lookahead\ndouble L = K_ * vel;\n\n// lookahead\u5ea7\u6a19\nVector2d pos_ref = traj_ref(traj_progress + L);\n\ndouble omega = 0.0f;\nconst double pos_diff = (pos_ref-pos_present).norm();\nif(std::abs(vel) &gt; 1e-2 &amp;&amp; pos_diff &gt; 0.001f)\n{\n// Yaw\u65b9\u5411\u30a8\u30e9\u30fc\ndouble raw_dir_err = ((pos_ref - pos_present).angle()) - angle_present;\ndouble dir_err = raw_dir_err;\n\n// Yaw\u65b9\u5411\u5236\u5fa1\u91cf\nomega = (2.0f * vel * std::sin(dir_err)) / L;\nreturn {true, omega};\n}\n\nreturn {false, 0.0f};\n}\n\nprivate:\ndouble K_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/quadprog_8hpp/","title":"include/cpp_robotics/optimize/quadprog.hpp","text":""},{"location":"doxybook/Files/quadprog_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/quadprog_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 struct cpp_robotics::QuadProg::Param struct cpp_robotics::QuadProg::Result"},{"location":"doxybook/Files/quadprog_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;tuple&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n// #include &lt;unsupported/Eigen/IterativeSolvers&gt;\n#include &lt;cassert&gt;\n#include \"constraint.hpp\"\n#include \"derivative.hpp\"\n#include \"bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\n// min 1/2 x^T Q x + c^T x\n// s.t. Aeq x = b, Ax &lt;= b\n\nclass QuadProg\n{\npublic:\nEigen::MatrixXd Q;\nEigen::VectorXd c;\nEigen::MatrixXd Aeq;\nEigen::VectorXd beq;\nEigen::MatrixXd A;\nEigen::VectorXd b;\n\nstruct Param\n{\n// \u30b9\u30c6\u30c3\u30d7\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6\ndouble tol_step = 1e-6;\n\n// \u5236\u7d04\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6\ndouble tol_con = 1e-6;\n\n// \u30b2\u30a4\u30f3\ndouble t = 0.5;\n\n// \u6700\u5927\u53cd\u5fa9\u56de\u6570\nsize_t max_iter = 100;\n\nbool print_variable = false;\n};\nParam param;\n\nstruct Result\n{\nbool is_solved = false;\nEigen::VectorXd x;\nEigen::VectorXd lambda_ineq;\nEigen::VectorXd lambda_eq;\nsize_t iter_cnt = 0;\n};\n\nvoid set_problem_size(const size_t valiable_size, const size_t ineq_constraint_size, const size_t eq_constraint_size)\n{\nQ.conservativeResize(valiable_size, valiable_size);\nc.conservativeResize(valiable_size);\nAeq.conservativeResize(eq_constraint_size, valiable_size);\nbeq.conservativeResize(eq_constraint_size);\nA.conservativeResize(ineq_constraint_size, valiable_size);\nb.conservativeResize(ineq_constraint_size);\n}\n\nvoid debug_prog()\n{\nstd::cout &lt;&lt; \"///// debug /////\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Q\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; Q &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"c\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; c &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Aeq\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; Aeq &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"beq\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; beq &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; A &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"b\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; b &lt;&lt; std::endl;\n\n}\n\nResult solve(Eigen::VectorXd x_init)\n{\nconst auto [tol_step, tol_con, t, max_iter, print_variable] = param;\nResult result;\n// Size check\nassert(Q.rows() == Q.cols());\nassert(c.rows() == Q.rows());\nassert(x_init.size() == Q.rows());\n\n// \u5909\u6570\u306e\u30b5\u30a4\u30ba\nconst size_t n = Q.rows(); if(Aeq.rows() != 0)\n{\nassert(Aeq.cols() == (int)n);\nassert(Aeq.rows() == beq.rows());\n}\nconst size_t m = Aeq.rows();\n\nif(A.rows() != 0)\n{\nassert(A.cols() == (int)n);\nassert(A.rows() == b.rows());\n}\nconst size_t l = A.rows();\n\nauto preprossesing = [&amp;]()\n{\nfor(int i = 0; i &lt; Aeq.rows(); i++)\n{\nif(not Aeq.row(i).allFinite() || not std::isfinite(beq(i)))\n{\nAeq.row(i).setZero();\nbeq(i) = 0;\n}\n}\nfor(int i = 0; i &lt; A.rows(); i++)\n{\nif(not A.row(i).allFinite() || not std::isfinite(b(i)))\n{\nA.row(i).setZero();\nb(i) = 0;\n}\n}\n};\npreprossesing();\n\nEigen::VectorXd x(n);\n\ndouble rho = l; // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u5e73\u5747\u76f8\u88dc\u6027\u6b8b\u5dee\nEigen::VectorXd s = Eigen::VectorXd::Ones(l); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30b9\u30e9\u30c3\u30af\u5909\u6570\nEigen::VectorXd u = Eigen::VectorXd::Ones(l); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570\nEigen::VectorXd v = Eigen::VectorXd::Zero(m); // \u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570\nEigen::VectorXd foom = grad_lagrange(x, u, v); // KKT\u6761\u4ef61\u6b21\u306e\u6700\u9069\u6027\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\nEigen::MatrixXd P = Eigen::MatrixXd::Zero(n + 2*l + m, n + 2*l + m);\nEigen::VectorXd r = Eigen::VectorXd::Zero(n + 2*l + m);\n\nP.block(0,0,n,n) = Q;\nr.segment(0,n) = Q*x + c;\n\n// \u4e0d\u7b49\u5f0f\u5236\u7d04\nif(l&gt;0)\n{\nP.block(0, n+l, n, l) = A.transpose();\nP.block(n,0,l,n) = A;\nP.block(n,n,l,l) = Eigen::MatrixXd::Identity(l,l);\nP.block(n+l, n, l,l) = u.asDiagonal();\nP.block(n+l, n+l, l,l) = s.asDiagonal();\n\nr.segment(0,n) += A.transpose() * u;\nr.segment(n,l) = A*x - b + s;\nr.segment(n+l,l) = -rho*Eigen::VectorXd::Ones(l) + Eigen::VectorXd(u.array()*s.array());\n}\n\n// \u7b49\u5f0f\u5236\u7d04\nif(m&gt;0)\n{\nP.block(n + 2*l, 0, m, n) = Aeq;\nP.block(0, n + 2*l, n, m) = Aeq.transpose();\n\nr.segment(0,n) += Aeq.transpose() * v;\nr.segment(n+2*l,m) = Aeq*x - beq;\n}\n\n// \u9023\u7acb\u4e00\u6b21\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f\nEigen::VectorXd delta = P.fullPivLu().solve(-r);\n\nEigen::VectorXd dx = delta.segment(0,n);\nEigen::VectorXd ds = delta.segment(n,l);\nEigen::VectorXd du = delta.segment(n+l,l);\nEigen::VectorXd dv = delta.segment(n+2*l,m);\n\nif(print_variable)\n{\nstd::cout &lt;&lt; \"//////////////// \" &lt;&lt; i &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"x\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; x &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"dx\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; dx &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"s\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; s &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"ds\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; ds &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"u\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; u &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"du\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; du &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"v\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; v &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"dv\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; dv &lt;&lt; std::endl;\n}\n\n// \u66f4\u65b0\nx += dx;\nif(l&gt;0)\n{\ns += ds;\nu += du;\nrho = t * (u.dot(s)) / l;\n}\nif(m&gt;0)\n{\nv += dv;\n}\n\n// Todo \u6700\u9069\u6027\u3068\u5236\u7d04\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\nEigen::VectorXd new_foom = grad_lagrange(x, u, v);\nif(dx.norm() &lt;= tol_step*(1.0+x.norm()) &amp;&amp; (new_foom - foom).norm() &lt;= tol_con*(1.0+foom.norm()))\n{\nresult.is_solved = true;\nresult.x = x;\nresult.lambda_ineq = u;\nresult.lambda_eq = v;\nresult.iter_cnt = i;\nreturn result;\n}\nfoom = new_foom;\n}\n\nresult.is_solved = false;\nresult.x = x;\nresult.lambda_ineq = u;\nresult.lambda_eq = v;\nresult.iter_cnt = max_iter;\nreturn result;\n}\n\ndouble evaluate(const Eigen::VectorXd &amp;x)\n{\nreturn 0.5*(x.transpose()*Q).dot(x) + c.dot(x);\n}\n\nEigen::VectorXd grad_lagrange(const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;u, const Eigen::VectorXd &amp;v)\n{\nEigen::VectorXd gl;\ngl = Q*x + c;\n\nif(u.size() &gt; 0)\ngl += A.transpose()*u;\n\nif(v.size() &gt; 0)\ngl += Aeq.transpose()*v;\nreturn gl;\n}\n\nbool satisfy(const Eigen::MatrixXd &amp;x, double eps = 1e-5)\n{\nbool satisfy = true;\n\nif(Aeq.rows())\n{\nEigen::VectorXd d = Aeq*x - beq;\nfor(Eigen::MatrixXd::Index i = 0; i &lt; d.size(); i++)\n{\nif(eps &lt; std::abs(d(i)))\nsatisfy = false;\n}\n}\n\nif(A.rows())\n{\nEigen::VectorXd d = A*x - b;\nfor(Eigen::MatrixXd::Index i = 0; i &lt; d.size(); i++)\n{\nif(eps &lt; d(i))\nsatisfy = false;\n}\n}\n\nreturn satisfy;\n}\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/quasi__newton__method_8hpp/","title":"include/cpp_robotics/optimize/quasi_newton_method.hpp","text":""},{"location":"doxybook/Files/quasi__newton__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/quasi__newton__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"./bfgs.hpp\"\n#include \"./bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; quasi_newton_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000)\n{\nsize_t n = x_init.rows();\nEigen::VectorXd x = x_init;\nEigen::VectorXd dx, gx, y;\nEigen::MatrixXd B = Eigen::MatrixXd::Identity(n, n);\n\ngx = grad(x);\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\ndx = - B.inverse() * grad(x);\n\nif(dx.norm() &lt; tol)\n{\nreturn {true, x, i};\n}\n\n// \u7591\u4f3c\u30d8\u30c3\u30bb\u884c\u5217\u306e\u66f4\u65b0\n// BFGS\u6cd5\ndouble a = bracketing_serach([&amp;](double v){ return f(x + v*dx); }); // \u76f4\u7dda\u63a2\u7d22\nx += a * dx;\ny = -gx;\ngx = grad(x);\ny += gx;\npowells_modified_bfgs_step(B, a*dx, y);\n}\n\nreturn {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/quaternion_8hpp/","title":"include/cpp_robotics/vector/quaternion.hpp","text":"<p>More...</p>"},{"location":"doxybook/Files/quaternion_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/quaternion_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9"},{"location":"doxybook/Files/quaternion_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author: Takumi Odashima (Kotakkucu@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-10-10</p> <p>Copyright: Copyright (c) 2021 </p>"},{"location":"doxybook/Files/quaternion_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./vector3.hpp\"\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Quaternion;\nusing Quaternionf = Quaternion&lt;float&gt;;\nusing Quaterniond = Quaternion&lt;double&gt;;\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nclass Quaternion\n{\npublic:\nusing value_type = FLOATING_TYPE;\nvalue_type x;\nvalue_type y;\nvalue_type z;\nvalue_type w;\n\nconstexpr Quaternion():\nx(0.0f), y(0.0f), z(0.0f), w(1.0f)\n{\n}\n\nconstexpr Quaternion(value_type nx, value_type ny, value_type nz, value_type nw):\nx(nx), y(ny), z(nz), w(nw)\n{\n}\n\nQuaternion get_product(Quaternion q)\n{\nreturn Quaternion(w * q.w - x * q.x - y * q.y - z * q.z,   // new w\nw * q.x + x * q.w + y * q.z - z * q.y,   // new x\nw * q.y - x * q.z + y * q.w + z * q.x,   // new y\nw * q.z + x * q.y - y * q.x + z * q.w);  // new z\n}\n\nconstexpr Quaternion conjugate() const { return Quaternion(w, -x, -y, -z); }\n\nconstexpr value_type norm() const { return sqrt(w * w + x * x + y * y + z * z); }\n\nconstexpr void normalize()\n{\nvalue_type m = norm();\nw /= m;\nx /= m;\ny /= m;\nz /= m;\n}\n\nconstexpr Quaternion get_normalized() const\n{\nQuaternion r(w, x, y, z);\nr.normalize();\nreturn r;\n}\n\nconstexpr void set_rpy(value_type roll, value_type pitch, value_type yaw)\n{\ndouble cos_roll = cos(roll / 2.0);\ndouble sin_roll = sin(roll / 2.0);\ndouble cos_pitch = cos(pitch / 2.0);\ndouble sin_pitch = sin(pitch / 2.0);\ndouble cos_yaw = cos(yaw / 2.0);\ndouble sin_yaw = sin(yaw / 2.0);\n\nw = cos_roll * cos_pitch * cos_yaw + sin_roll * sin_pitch * sin_yaw;\nx = sin_roll * cos_pitch * cos_yaw - cos_roll * sin_pitch * sin_yaw;\ny = cos_roll * sin_pitch * cos_yaw + sin_roll * cos_pitch * sin_yaw;\nz = cos_roll * cos_pitch * sin_yaw - sin_roll * sin_pitch * cos_yaw;\n}\n\nconstexpr Vector3d get_rpy() const\n{\nvalue_type xx = x * x;\nvalue_type xy = x * y;\nvalue_type xz = x * z;\nvalue_type xw = x * w;\nvalue_type yy = y * y;\nvalue_type yz = y * z;\nvalue_type yw = y * w;\nvalue_type zz = z * z;\nvalue_type zw = z * w;\nvalue_type ww = w * w;\nreturn Vector3d{std::atan2(2.0f * (zw + xy), xx - yy - zz + ww),\nstd::asin(2.0f * (xz - yw)),\nstd::atan2(2.0f * (yz + xw), xx + yy - zz - ww)};\n}\n\nconstexpr value_type operator [](const int index) const\n{\nassert(0 &lt;= index &amp;&amp; index &lt; 4);\nif (index == 0) return x;\nif (index == 1) return y;\nif (index == 2) return z;\nreturn w;\n}\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/random_8hpp/","title":"include/cpp_robotics/algorithm/random.hpp","text":""},{"location":"doxybook/Files/random_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/random_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668"},{"location":"doxybook/Files/random_8hpp/#source-code","title":"Source code","text":"<pre><code># pragma once\n\n#include &lt;cmath&gt;\n#include &lt;random&gt;\n#include \"../utility/singleton.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace internal\n{\ntemplate&lt;class Method&gt;\nclass RandomEngineWrapper\n{\npublic:\nusing engine_method_t = Method;\n\nRandomEngineWrapper():\nengine_((*Singleton&lt;std::random_device&gt;::get_shared_instance())()){}\n\nengine_method_t&amp; get_engine()\n{\nreturn engine_;\n}\n\nprivate:\nengine_method_t engine_;\n};\n}\n\ntemplate&lt;class Distribution, class EngineMethod = std::mt19937&gt;\nclass RandomGenerator : public Distribution\n{\npublic:\nusing distribution_t = Distribution;\nusing engine_method_t = EngineMethod;\n\ntemplate&lt;typename ...Arg&gt;\nRandomGenerator(Arg ...arg):\ndistribution_t(arg...)\n{\nengine_wrapper_ = Singleton&lt;engine_t&gt;::get_shared_instance();\n}\n\ntypename distribution_t::result_type value()\n{\nauto &amp;dist = *(distribution_t*)(this);\nreturn dist(engine_wrapper_-&gt;get_engine());\n}\n\nprivate:\nusing engine_t = internal::RandomEngineWrapper&lt;engine_method_t&gt;;\ntypename Singleton&lt;engine_t&gt;::shared_t engine_wrapper_;\n};\n\nusing UniformIntRandomEngine = RandomGenerator&lt;std::uniform_int_distribution&lt;&gt;&gt;;\nusing UniformRealRandomEngine = RandomGenerator&lt;std::uniform_real_distribution&lt;&gt;&gt;;\n\nusing BernoulliRandomEngine = RandomGenerator&lt;std::bernoulli_distribution&gt;;\nusing BinomialRandomEngine = RandomGenerator&lt;std::binomial_distribution&lt;&gt;&gt;;\nusing GeometricRandomEngine = RandomGenerator&lt;std::geometric_distribution&lt;&gt;&gt;;\nusing NegativeBinomialRandomEngine = RandomGenerator&lt;std::negative_binomial_distribution&lt;&gt;&gt;;\n\n\nusing PoissonRandomEngine = RandomGenerator&lt;std::poisson_distribution&lt;&gt;&gt;;\nusing ExponentialRandomEngine = RandomGenerator&lt;std::exponential_distribution&lt;&gt;&gt;;\nusing GammaRandomEngine = RandomGenerator&lt;std::gamma_distribution&lt;&gt;&gt;;\nusing WeibullRandomEngine = RandomGenerator&lt;std::weibull_distribution&lt;&gt;&gt;;\nusing ExtremeValueRandomEngine = RandomGenerator&lt;std::extreme_value_distribution&lt;&gt;&gt;;\n\n\n\nusing NormalRandomEngine = RandomGenerator&lt;std::normal_distribution&lt;&gt;&gt;;\n\nusing LognormalRandomEngine = RandomGenerator&lt;std::lognormal_distribution&lt;&gt;&gt;;\nusing ChiSquaredRandomEngine = RandomGenerator&lt;std::chi_squared_distribution&lt;&gt;&gt;;\nusing CauchyRandomEngine = RandomGenerator&lt;std::cauchy_distribution&lt;&gt;&gt;;\nusing FisherFRandomEngine = RandomGenerator&lt;std::fisher_f_distribution&lt;&gt;&gt;;\nusing StudentTRandomEngine = RandomGenerator&lt;std::student_t_distribution&lt;&gt;&gt;;\n\nusing DiscreteRandomEngine = RandomGenerator&lt;std::discrete_distribution&lt;&gt;&gt;;\nusing PiecewiseConstantRandomEngine = RandomGenerator&lt;std::piecewise_constant_distribution&lt;&gt;&gt;;\nusing PiecewiseLinearRandomEngine = RandomGenerator&lt;std::piecewise_linear_distribution&lt;&gt;&gt;;\n\ntemplate&lt;typename Real = double&gt;\nstatic Real gererate_random()\n{\nusing engine_t = internal::RandomEngineWrapper&lt;std::mt19937&gt;;\nauto engine_wrapper = Singleton&lt;engine_t&gt;::get_shared_instance();\nconstexpr std::size_t bits = std::numeric_limits&lt;Real&gt;::digits;\nreturn std::generate_canonical&lt;Real, bits&gt;(engine_wrapper-&gt;get_engine());\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/shape_8hpp/","title":"include/cpp_robotics/geometry/shape.hpp","text":""},{"location":"doxybook/Files/shape_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/shape_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9"},{"location":"doxybook/Files/shape_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include \"../vector/vector2.hpp\"\n\nnamespace cpp_robotics\n{\n\nstruct Line\n{\nVector2d p0, p1;\n\nLine() = default;\nconstexpr Line(const Vector2d&amp; p0, const Vector2d&amp; p1): p0(p0), p1(p1) {}\n\nvoid set(const Vector2d&amp; p0_, const Vector2d&amp; p1_) {p0 = p0_; p1 = p1_;}\n\nconstexpr double length() const { return (p1-p0).norm(); }\n\nconstexpr double angle() const { return (p1-p0).angle(); }\n\nconstexpr Vector2d lerp(const double t) const { return Vector2d::lerp(p0, p1, t); }\n};\n\nstruct Quad\n{\nVector2d p0, p1, p2, p3;\n\nQuad() = default;\nconstexpr Quad(const std::array&lt;Vector2d, 4&gt; &amp;points): p0(points[0]), p1(points[1]), p2(points[2]), p3(points[3]) {}\nconstexpr Quad(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2, const Vector2d &amp;p3): p0(p0), p1(p1), p2(p2), p3(p3) {} void set(const Vector2d &amp;p0_, const Vector2d &amp;p1_, const Vector2d &amp;p2_, const Vector2d &amp;p3_)\n{\np0 = p0_;\np1 = p1_;\np2 = p2_;\np3 = p3_;\n}\n\nconstexpr bool has_area() const\n{\nreturn !approx_zero(area());\n}\n\nconstexpr double area() const\n{\n// \u4e09\u89d2\u5f62\u306e\u9762\u7a4d2\u500b\n// 01 02\nconst double a1 = std::abs((p2.x - p0.x) * (p1.y - p0.y) - (p1.x - p0.x) * (p2.y - p0.y));\n\n// 31 32\nconst double a2 = std::abs((p2.x - p3.x) * (p1.y - p3.y) - (p1.x - p3.x) * (p2.y - p3.y));\nreturn 0.5*(a1 + a2);\n}\n\nconstexpr std::array&lt;Vector2d, 4&gt; vertex() const\n{\nreturn {p0, p1, p2, p3};\n}\n\nconstexpr std::array&lt;Line, 4&gt; outline() const\n{\nconst auto vtx = vertex();\nreturn {\nLine{vtx[0], vtx[1]},\nLine{vtx[1], vtx[2]},\nLine{vtx[2], vtx[3]},\nLine{vtx[3], vtx[0]}\n};\n}\n};\n\nstruct Rect\n{\nVector2d center;\nVector2d size;\n\nRect() = default;\nconstexpr Rect(const Vector2d&amp; center, const Vector2d&amp; size): center(center), size(size) {}\n\nvoid set(const Vector2d&amp; center_, const Vector2d&amp; size_) { center = center_; size = size_; }\n\nconstexpr bool has_area() const\n{\nreturn !approx_zero(area());\n}\n\nconstexpr double area() const\n{\nreturn size.x*size.y;\n}\n\nconstexpr std::array&lt;Vector2d, 4&gt; vertex() const\n{\nVector2d tv(size.x/2, size.y/2);\nreturn {\ncenter + tv,\ncenter + tv.nxy(),\ncenter - tv,\ncenter + tv.xny()\n};\n}\n\nconstexpr std::array&lt;Line, 4&gt; outline() const\n{\nconst auto vtx = vertex();\nreturn {\nLine{vtx[0], vtx[1]},\nLine{vtx[1], vtx[2]},\nLine{vtx[2], vtx[3]},\nLine{vtx[3], vtx[0]}\n};\n}\n\nconstexpr Quad as_quad() const\n{\nreturn Quad{vertex()};\n}\n\nconstexpr Quad get_rotated(double angle) const\n{\nconst Vector2d tv(size.x / 2, size.y / 2);\nreturn Quad\n{\ncenter + tv.get_rotated(angle),  center + tv.nxy().get_rotated(angle),\ncenter + -tv.get_rotated(angle), center + tv.xny().get_rotated(angle)\n};\n}\n};\n\nstruct Triangle\n{\nVector2d p0, p1, p2;\n\nTriangle() = default;\n// constexpr Triangle(const std::array&lt;Vector2d, 3&gt; &amp;points): points(points) {}\nconstexpr Triangle(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2): p0(p0), p1(p1), p2(p2) {} void set(const Vector2d &amp;p0_, const Vector2d &amp;p1_, const Vector2d &amp;p2_)\n{\np0 = p0_;\np1 = p1_;\np2 = p2_;\n}\n\nconstexpr bool has_area() const\n{\nreturn !approx_zero(area());\n}\n\nconstexpr double area() const\n{\nreturn std::abs((p2.x - p0.x) * (p1.y - p0.y) - (p1.x - p0.x) * (p2.y - p0.y)) * 0.5;\n}\n\nconstexpr std::array&lt;Vector2d, 3&gt; vertex() const\n{\nreturn {p0, p1, p2};\n}\n\nconstexpr std::array&lt;Line, 3&gt; outline() const\n{\nconst auto vtx = vertex();\nreturn {\nLine{vtx[0], vtx[1]},\nLine{vtx[1], vtx[2]},\nLine{vtx[2], vtx[0]}\n};\n}\n};\n\nstruct Circle\n{\nVector2d center;\ndouble r;\n\nCircle() = default;\nconstexpr Circle(const Vector2d&amp; center, const double r): center(center), r(r) {}\n\nconstexpr bool has_area() const\n{\nreturn !approx_zero(area());\n}\n\nconstexpr double area() const\n{\nreturn square(r)*PI;\n}\n\nconstexpr Vector2d angle_pos(const double theta) const {\nreturn center + Vector2d(r*std::cos(theta), r*std::sin(theta));\n}\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/si__unit_8hpp/","title":"include/cpp_robotics/unit/si_unit.hpp","text":""},{"location":"doxybook/Files/si__unit_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit_dimention unit_dim_assem"},{"location":"doxybook/Files/si__unit_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./unit_core.hpp\"\n\nnamespace cpp_robotics\n{\n\ninline namespace unit\n{\nnamespace unit_dimention\n{\nusing no_dimention = UnitType&lt;0, 0, 0, 0, 0, 0, 0&gt;;\n\n// \u57fa\u672c\u5358\u4f4d\nusing metere   = UnitType&lt;1, 0, 0, 0, 0, 0, 0&gt;;\nusing kilogram = UnitType&lt;0, 1, 0, 0, 0, 0, 0&gt;;\nusing second   = UnitType&lt;0, 0, 1, 0, 0, 0, 0&gt;;\nusing ampere   = UnitType&lt;0, 0, 0, 1, 0, 0, 0&gt;;\nusing kelvin   = UnitType&lt;0, 0, 0, 0, 1, 0, 0&gt;;\nusing mole     = UnitType&lt;0, 0, 0, 0, 0, 1, 0&gt;;\nusing candela  = UnitType&lt;0, 0, 0, 0, 0, 0, 1&gt;;\n\nusing namespace unit_dim_assem;\n// \u7d44\u7acb\u5358\u4f4d\nusing area          = udim_pow&lt;metere, 2&gt;::unit;\nusing volume        = udim_pow&lt;metere, 3&gt;::unit;\nusing velocity      = udim_div&lt;metere, second&gt;::unit;\nusing acceleration  = udim_div&lt;velocity, second&gt;::unit;\nusing dencity       = udim_div&lt;kilogram, volume&gt;::unit;\nusing angle         = udim_div&lt;metere, metere&gt;::unit;\nusing hertz         = udim_inv&lt;second&gt;::unit;\nusing newton        = udim_div&lt;udim_mul&lt;metere, kilogram&gt;::unit, udim_pow&lt;second, 2&gt;::unit&gt;::unit;\nusing pascal        = udim_div&lt;newton, area&gt;::unit;\nusing viscosity     = udim_mul&lt;pascal, second&gt;::unit;\nusing joule         = udim_mul&lt;newton, metere&gt;::unit;\nusing watt          = udim_div&lt;joule, second&gt;::unit;\nusing volt          = udim_div&lt;watt, ampere&gt;::unit;\nusing coulomb       = udim_mul&lt;second, ampere&gt;::unit;\nusing farad         = udim_div&lt;coulomb, volt&gt;::unit;\nusing ohm           = udim_div&lt;volt, ampere&gt;::unit;\nusing weber         = udim_mul&lt;volt, second&gt;::unit;\nusing henry         = udim_div&lt;weber, ampere&gt;::unit;\nusing torque        = udim_mul&lt;newton, metere&gt;::unit;\nusing inertia       = udim_mul&lt;kilogram, area&gt;::unit;\nusing angular_velocity = udim_div&lt;angle, second&gt;::unit;\nusing angular_acceleration = udim_div&lt;angular_velocity, second&gt;::unit;\n\n}\n\nusing Second = Unit&lt;double, unit_dimention::second, prefix::none&gt;;\nusing MilliSecond = Unit&lt;double, unit_dimention::second, prefix::milli&gt;;\nusing MicroSecond = Unit&lt;double, unit_dimention::second, prefix::micro&gt;;\nusing Meter = Unit&lt;double, unit_dimention::metere, prefix::none&gt;;\nusing MilliMeter = Unit&lt;double, unit_dimention::metere, prefix::milli&gt;;\nusing MicroMeter = Unit&lt;double, unit_dimention::metere, prefix::micro&gt;;\nusing CentiMeter = Unit&lt;double, unit_dimention::metere, prefix::centi&gt;;\nusing KiloGram = Unit&lt;double, unit_dimention::kilogram, prefix::none&gt;;\nusing Gram = Unit&lt;double, unit_dimention::kilogram, prefix::milli&gt;;\n\nusing Watt = Unit&lt;double, unit_dimention::watt, prefix::none&gt;;\nusing KiloWatt = Unit&lt;double, unit_dimention::watt, prefix::kilo&gt;;\nusing Newton = Unit&lt;double, unit_dimention::newton, prefix::none&gt;;\nusing KiloNewton = Unit&lt;double, unit_dimention::newton, prefix::kilo&gt;;\nusing Pascal = Unit&lt;double, unit_dimention::pascal, prefix::none&gt;;\nusing KiloPascal = Unit&lt;double, unit_dimention::pascal, prefix::kilo&gt;;\nusing Hertz = Unit&lt;double, unit_dimention::hertz, prefix::none&gt;;\n\n// \nusing Area = Unit&lt;double, unit_dimention::area, prefix::none&gt;;\nusing Volume = Unit&lt;double, unit_dimention::volume, prefix::none&gt;;\nusing Velocity = Unit&lt;double, unit_dimention::velocity, prefix::none&gt;;\nusing Acceleration = Unit&lt;double, unit_dimention::acceleration, prefix::none&gt;;\nusing Dencity = Unit&lt;double, unit_dimention::dencity, prefix::none&gt;;\nusing Torque = Unit&lt;double, unit_dimention::torque, prefix::none&gt;;\nusing Inertia = Unit&lt;double, unit_dimention::inertia, prefix::none&gt;;\n\n// \u96fb\u6c17\u7cfb\nusing Ampere = Unit&lt;double, unit_dimention::ampere, prefix::none&gt;;\nusing MilliAmpere = Unit&lt;double, unit_dimention::ampere, prefix::milli&gt;;\nusing Volt = Unit&lt;double, unit_dimention::volt, prefix::none&gt;;\nusing MilliVolt = Unit&lt;double, unit_dimention::volt, prefix::milli&gt;;\nusing Ohm = Unit&lt;double, unit_dimention::ohm, prefix::none&gt;;\nusing MilliOhm = Unit&lt;double, unit_dimention::ohm, prefix::milli&gt;;\nusing Henry = Unit&lt;double, unit_dimention::henry, prefix::none&gt;;\nusing MilliHenry = Unit&lt;double, unit_dimention::henry, prefix::milli&gt;;\nusing Farad = Unit&lt;double, unit_dimention::farad, prefix::none&gt;;\nusing MilliFarad = Unit&lt;double, unit_dimention::farad, prefix::milli&gt;;\nusing MicroFarad = Unit&lt;double, unit_dimention::farad, prefix::micro&gt;;\nusing NanoFarad = Unit&lt;double, unit_dimention::farad, prefix::nano&gt;;\n\n// \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6\nusing Radian = Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::radian&gt;;\nusing Degree = Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::degree&gt;;\nusing AngularVelocity = Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec&gt;;\nusing Rps = Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps&gt;;\nusing Rpm = Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm&gt;;\n\nusing AngularAcceleration = Unit&lt;double, unit_dimention::angular_acceleration, prefix::none&gt;;\n\nGENERATE_CONV_FACTOR(unit_dimention::angle, tag::angle::radian, tag::angle::degree, 180.0f/M_PI)\nGENERATE_CONV_FACTOR(unit_dimention::angle, tag::angle::degree, tag::angle::radian, M_PI/180.0f)\n\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rad_per_sec, tag::angular_vel::rps, 1.0f/(2*M_PI))\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rad_per_sec, tag::angular_vel::rpm, 30.0f/M_PI)\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rps, tag::angular_vel::rad_per_sec, (2*M_PI))\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rps, tag::angular_vel::rpm, 60.0f)\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rpm, tag::angular_vel::rps, 1/60.0f)\nGENERATE_CONV_FACTOR(unit_dimention::angular_velocity, tag::angular_vel::rpm, tag::angular_vel::rad_per_sec, M_PI/30.0f)\n}\n}\n\n// suffix\n\nGENERATE_UNIT_SUFFIX(cpp_robotics::Second, s)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliSecond, ms)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MicroSecond, us)\nGENERATE_UNIT_PFX_SUFFIX(cpp_robotics::Meter, prefix::kilo, km)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Meter, m)\nGENERATE_UNIT_SUFFIX(cpp_robotics::CentiMeter, cm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliMeter, mm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloGram, kg)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Gram, g)\n\n//\nGENERATE_UNIT_SUFFIX(cpp_robotics::Watt, W)\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloWatt, kW)\n\n#ifdef UNIT_NEWTON_ENABLE \n// \"_N\"\u3063\u3066\u540d\u524d\u306e\u30de\u30af\u30ed\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u308b\u306e\u3067\u305d\u306e\u307e\u307e\u3060\u3068\u4f7f\u3048\u306a\u3044\n#undef _N\nGENERATE_UNIT_SUFFIX(cpp_robotics::Newton, N) #endif // UNIT_NEWTON_ENABLE\n\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloNewton, kN)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Pascal, Pa)\nGENERATE_UNIT_SUFFIX(cpp_robotics::KiloPascal, kPa)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Torque, Nm)\nGENERATE_UNIT_PFX_SUFFIX(cpp_robotics::Torque, prefix::milli, mmNm)\n\n// \u56de\u8def\nGENERATE_UNIT_SUFFIX(cpp_robotics::Ampere, A)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliAmpere, mA)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Volt, V)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliVolt, mV)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Ohm, ohm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliOhm, mohm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Henry, H)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliHenry, mH)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Farad, F)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MilliFarad, mF)\nGENERATE_UNIT_SUFFIX(cpp_robotics::MicroFarad, uF)\nGENERATE_UNIT_SUFFIX(cpp_robotics::NanoFarad, nF)\n\n// \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6\nGENERATE_UNIT_SUFFIX(cpp_robotics::Radian, rad)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Degree, deg)\nGENERATE_UNIT_SUFFIX(cpp_robotics::AngularVelocity, rad_per_sec)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Rpm, rpm)\nGENERATE_UNIT_SUFFIX(cpp_robotics::Rps, rps)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/singleton_8hpp/","title":"include/cpp_robotics/utility/singleton.hpp","text":""},{"location":"doxybook/Files/singleton_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/singleton_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b"},{"location":"doxybook/Files/singleton_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;memory&gt;\n\nnamespace cpp_robotics\n{\n\ntemplate&lt;class T&gt;\nclass Singleton\n{\nprivate:\nSingleton() = default;\n\npublic:\nusing class_t = T;\nusing shared_t = std::shared_ptr&lt;class_t&gt;;\n\nstatic shared_t get_shared_instance()\n{\nstatic shared_t instance = std::make_shared&lt;class_t&gt;();\nreturn instance;\n}\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/siso__system_8hpp/","title":"include/cpp_robotics/system/siso_system.hpp","text":""},{"location":"doxybook/Files/siso__system_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/siso__system_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 struct cpp_robotics::SisoFeedbackSystem::func_list_t"},{"location":"doxybook/Files/siso__system_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;any&gt;\n#include \"../controller/pid.hpp\"\n#include \"../controller/nctf.hpp\"\n#include \"./transfer_function.hpp\"\n\n/*\n\nx_r  +                        x\n-----&gt;*--&gt;| C |--&gt;| G |---*---&gt;\n     -|                   |\n      ---------&lt;-----------\n\nx_r: \u76ee\u6a19\u5024\nx: \u72b6\u614b\nC: \u5236\u5fa1\u5668\nG: \u30d7\u30e9\u30f3\u30c8\n\n*/\n\nnamespace cpp_robotics\n{\n\nclass SisoFeedbackSystem\n{\npublic:\nstruct func_list_t\n{\n// C\nstd::function&lt;void(void)&gt; controller_reset;\nstd::function&lt;double(double)&gt; controller;\n// std::any controller_obj;\n\n// G\nstd::function&lt;void(void)&gt; system_reset;\nstd::function&lt;double(double)&gt; system;\n// std::any system_obj;\n};\n\nSisoFeedbackSystem() = default;\nSisoFeedbackSystem(func_list_t fn, double dt): func_list_(fn), dt_(dt) {}\n\nvoid reset()\n{\nu_ = 0;\ny_ = 0;\nfunc_list_.controller_reset();\nfunc_list_.system_reset();\n}\n\ndouble responce(double target)\n{\nu_ = func_list_.controller(target - y_);\ny_ = func_list_.system(u_);\nreturn y_;\n}\n\ndouble Ts() const { return dt_; }\n\ndouble u() const { return u_; }\ndouble y() const { return y_; }\n\nstd::function&lt;double(double)&gt; make_control_function()\n{\nreturn [this](double target){ return responce(target); };\n}\n\noperator std::function&lt;double(double)&gt;()\n{\nreturn make_control_function();\n}\n\nprivate:\ndouble u_ = 0;\ndouble y_ = 0;\n\nfunc_list_t func_list_;\nconst double dt_;\n};\n\ntemplate&lt;class CONTROLLER_T, class SYSTEM_T&gt;\nstatic SisoFeedbackSystem make_feedback_system(CONTROLLER_T &amp;controller, SYSTEM_T &amp;system)\n{\nSisoFeedbackSystem::func_list_t fn;\nset_controller(fn, controller);\nset_system(fn, system);\n\nreturn SisoFeedbackSystem(fn, system.Ts());\n}\n\nstatic void set_controller(SisoFeedbackSystem::func_list_t &amp;fn, PID &amp;controller)\n{\n// fn.controller_obj = controller;\nfn.controller_reset = [&amp;](){ controller.reset(); };\nfn.controller = [&amp;](double e){ return controller.calculate(e); };\n}\n\nstatic void set_controller(SisoFeedbackSystem::func_list_t &amp;fn, NctfController &amp;controller)\n{\n// fn.controller_obj = controller;\nfn.controller_reset = [&amp;](){ controller.reset(); };\nfn.controller = [&amp;](double e){ return controller.control(e); };\n}\n\nstatic void set_system(SisoFeedbackSystem::func_list_t &amp;fn, TransferFunction &amp;system)\n{\n// fn.system_obj = system;\nfn.system_reset = [&amp;](){ return system.reset(); };\nfn.system = [&amp;](double u){ return system.responce(u); };\n}\n\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/space_8hpp/","title":"include/cpp_robotics/utility/space.hpp","text":""},{"location":"doxybook/Files/space_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/space_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::vector&lt;double&gt; arrange(double start, double end, double step = 1.0)\n{\nstd::vector&lt;double&gt; vec(std::floor( (end-start) / step ));\nfor(size_t i = 0; i &lt; vec.size(); i++)\n{\nvec[i] = start + step * i;\n}\nreturn vec;\n}\n\nstatic std::vector&lt;double&gt; linspace(double start, double end, size_t n = 100)\n{\nstd::vector&lt;double&gt; vec(n);\nfor(size_t i = 0; i &lt; n; i++)\n{\nvec[i] = lerp(start, end, static_cast&lt;double&gt;(i) / (n-1));\n}\nreturn vec;\n}\n\nstatic std::vector&lt;double&gt; logspace(double start, double end, size_t n = 100)\n{\nstd::vector&lt;double&gt; vec(n);\nfor(size_t i = 0; i &lt; n; i++)\n{\nvec[i] = std::pow(10.0, lerp(start, end, static_cast&lt;double&gt;(i) / (n-1)));\n}\nreturn vec;\n}\n\nstatic std::vector&lt;double&gt; funcspace(std::function&lt;double(size_t, size_t)&gt; f, size_t n = 100)\n{\nstd::vector&lt;double&gt; vec(n);\nfor(size_t i = 0; i &lt; n; i++)\n{\nvec[i] = f(i, n);\n}\nreturn vec;\n}\n\n// \u4ed5\u69d8\u304c\u66d6\u6627\u3059\u304e\u308b\nstatic std::vector&lt;double&gt; sinspace(double a, double b, size_t n = 100)\n{\nreturn funcspace([a, b](size_t i, size_t n_){ (void) n_; return a * std::sin(b * i); }, n );\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/spline_8hpp/","title":"include/cpp_robotics/path_planning/spline.hpp","text":""},{"location":"doxybook/Files/spline_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1"},{"location":"doxybook/Files/spline_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::spline::spline_c class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda"},{"location":"doxybook/Files/spline_8hpp/#source-code","title":"Source code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cassert&gt;\n#include &lt;string&gt;\n\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n\n#include \"../utility/math_utils.hpp\"\n#include \"../vector/vector2.hpp\"\n#include \"../vector/vector4.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace spline\n{\nstruct spline_c\n{\nVector4d xb, yb;\n};\n\nspline_c bezier_spline(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2, const Vector2d &amp;p3)\n{\nreturn {\nVector4d{p0.x, p1.x, p2.x, p3.x},\nVector4d{p0.y, p1.y, p2.y, p3.y}};\n}\n\nspline_c hermite_spline(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;v0, const Vector2d &amp;v1)\n{\nVector2d bp1 = p0 + (1.0 / 3.0) * v0;\nVector2d bp2 = p1 - (1.0 / 3.0) * v1;\n\nreturn bezier_spline(p0, bp1, bp2, p1);\n}\n\nspline_c catumull_spline(const Vector2d &amp;p0, const Vector2d &amp;p1, const Vector2d &amp;p2, const Vector2d &amp;p3)\n{\nVector2d bp1 = p1 + (1.0 / 6.0) * (p2 - p0);\nVector2d bp2 = p2 - (1.0 / 6.0) * (p3 - p1);\n\nreturn bezier_spline(p1, bp1, bp2, p2);\n}\n\n// f(t) = a t^3 + b t^2 + c t + d -&gt; bezier\nspline_c cubic_function_to_bezier(const Vector2d &amp;a, const Vector2d &amp;b, const Vector2d &amp;c, const Vector2d &amp;d)\n{\nVector2d bp1 = d + (1.0 / 3.0) * c;\nVector2d bp2 = (1.0 / 3.0) * b + (2.0 / 3.0) * c + d;\nVector2d bp3 = a + b + c + d;\n\nreturn bezier_spline(d, bp1, bp2, bp3);\n}\n\nVector4d bezier_weight(const double t)\n{\ndouble s = 1.0 - t;\n\ndouble t2 = t * t;\ndouble t3 = t2 * t;\n\ndouble s2 = s * s;\ndouble s3 = s2 * s;\n\nreturn Vector4d(s3, 3.0 * s2 * t, 3.0 * s * t2, t3);\n}\n\nVector4d bezier_weight(const Vector4d t)\n{\nreturn Vector4d(\nt.x - 3.0 * t.y + 3.0 * t.z - t.w,\n3.0 * t.y - 6.0 * t.z + 3.0 * t.w,\n3.0 * t.z - 3.0 * t.w,\nt.w);\n}\n\ninline Vector2d evaluate(const spline_c &amp;spline, const Vector4d &amp;w)\n{\nreturn {\nVector4d::dot(spline.xb, w),\nVector4d::dot(spline.yb, w)};\n}\n\nVector2d position(const spline_c &amp;spline, double t)\n{\nreturn evaluate(spline, bezier_weight(t));\n}\n\nVector2d velocity(const spline_c &amp;spline, double t)\n{\nVector4d dt(0.0, 1.0, 2.0 * t, 3.0 * t * t);\nreturn evaluate(spline, bezier_weight(dt));\n}\n\nVector2d acceleration(const spline_c &amp;spline, double t)\n{\nVector4d dt(0.0, 0.0, 2.0, 6.0 * t);\nreturn evaluate(spline, bezier_weight(t));\n}\n\ninline void split(const Vector4d &amp;spline, Vector4d &amp;spline0, Vector4d &amp;spline1, double t)\n{\n// assumption: seg = (P0, P1, P2, P3)\ndouble q0 = lerp(spline.x, spline.y, t);\ndouble q1 = lerp(spline.y, spline.z, t);\ndouble q2 = lerp(spline.z, spline.w, t);\n\ndouble r0 = lerp(q0, q1, t);\ndouble r1 = lerp(q1, q2, t);\n\ndouble s0 = lerp(r0, r1, t);\n\ndouble sx = spline.x; // support aliasing\ndouble sw = spline.w;\n\nspline0 = Vector4d(sx, q0, r0, s0);\nspline1 = Vector4d(s0, r1, q2, sw);\n}\n\n// Optimised for t=0.5\ninline void split(const Vector4d &amp;spline, Vector4d &amp;spline0, Vector4d &amp;spline1)\n{\ndouble q0 = (spline.x + spline.y) * 0.5; // x + y / 2\ndouble q1 = (spline.y + spline.z) * 0.5; // y + z / 2\ndouble q2 = (spline.z + spline.w) * 0.5; // z + w / 2\n\ndouble r0 = (q0 + q1) * 0.5; // x + 2y + z / 4\ndouble r1 = (q1 + q2) * 0.5; // y + 2z + w / 4\n\ndouble s0 = (r0 + r1) * 0.5; // q0 + 2q1 + q2 / 4 = x+y + 2(y+z) + z+w / 8 = x + 3y + 3z + w\n\ndouble sx = spline.x; // support aliasing\ndouble sw = spline.w;\n\nspline0 = Vector4d(sx, q0, r0, s0);\nspline1 = Vector4d(s0, r1, q2, sw);\n}\n\nvoid split(const spline_c&amp; spline, spline_c&amp; spline0, spline_c&amp; spline1)\n{\nsplit(spline.xb, spline0.xb, spline1.xb);\nsplit(spline.yb, spline0.yb, spline1.yb);\n}\n\nvoid split(const spline_c&amp; spline, spline_c&amp; spline0, spline_c&amp; spline1, double t)\n{\nsplit(spline.xb, spline0.xb, spline1.xb, t);\nsplit(spline.yb, spline0.yb, spline1.yb, t);\n}\n\ndouble length_estimate(const spline_c &amp;s, double *error)\n{\n// Our convex hull is p0, p1, p2, p3, so p0_p3 is our minimum possible length, and p0_p1 + p1_p2 + p2_p3 our maximum.\ndouble d03 = square(s.xb.x - s.xb.w) + square(s.yb.x - s.yb.w);\n\ndouble d01 = square(s.xb.x - s.xb.y) + square(s.yb.x - s.yb.y);\ndouble d12 = square(s.xb.y - s.xb.z) + square(s.yb.y - s.yb.z);\ndouble d23 = square(s.xb.z - s.xb.w) + square(s.yb.z - s.yb.w);\n\ndouble minLength = std::sqrt(d03);\ndouble maxLength = std::sqrt(d01) + std::sqrt(d12) + std::sqrt(d23);\n\nminLength *= 0.5;\nmaxLength *= 0.5;\n\n*error = maxLength - minLength;\nreturn minLength + maxLength;\n}\n\ndouble length(const spline_c &amp;s, double maxError)\n{\ndouble error;\ndouble len = length_estimate(s, &amp;error);\n\nif (error &gt; maxError)\n{\nspline_c s0;\nspline_c s1;\n\nsplit(s, s0, s1);\n\nreturn length(s0, maxError) + length(s1, maxError);\n}\n\nreturn len;\n}\n\ndouble length(const spline_c &amp;s, double t0, double t1, double maxError)\n{\nassert(t0 &gt;= 0.0 &amp;&amp; t0 &lt; 1.0);\nassert(t1 &gt;= 0.0 &amp;&amp; t1 &lt;= 1.0);\nassert(t0 &lt;= t1);\n\nspline_c s0, s1;\n\nif (t0 == 0.0)\n{\nif (t1 == 1.0)\nreturn length(s, maxError);\n\nsplit(s, s0, s1, t1);\nreturn length(s0, maxError);\n}\nelse\n{\nsplit(s, s0, s1, t0);\n\nif (t1 == 1.0)\nreturn length(s1, maxError);\n\nsplit(s1, s0, s1, (t1 - t0) / (1.0 - t0));\nreturn length(s0, maxError);\n}\n}\n\ndouble curvature(const spline_c &amp;spline, double t)\n{\nVector2d v = velocity(spline, t);\nVector2d a = acceleration(spline, t);\n\ndouble avCrossLen = std::abs(v.x * a.y - v.y * a.x);\ndouble vLen = v.norm();\n\nif (vLen == 0.0)\nreturn 1e10;\n\nreturn avCrossLen / (vLen * vLen * vLen);\n}\n} // namespace spline\n\nclass Spline2D\n{\npublic:\nSpline2D() = default;\n\nbool is_empty()\n{\nreturn _is_empty;\n}\n\nsize_t size()\n{\nreturn _size;\n}\n\nsize_t point_num()\n{\nreturn size()+1;\n}\n\ndouble length()\n{\nreturn _all_length;\n}\n\ndouble length(size_t i)\n{\nif(i &gt;= size())\nreturn 0;\n\nreturn _spline[i].length;\n}\n\nVector2d position(double t)\n{\nassert(_is_empty == false);\nassert(t &gt;= 0);\nassert(t &lt;= static_cast&lt;double&gt;(size()));\n\nsegment_info_t segment = get_segmet_idx(t);\nreturn spline::position(_spline[segment.i].coeff, segment.t);\n}\n\nVector2d velocity(double t)\n{\nassert(_is_empty == false);\nassert(t &gt;= 0);\nassert(t &lt;= static_cast&lt;double&gt;(size()));\n\nsize_t i = std::floor(t);\nt -= static_cast&lt;double&gt;(i);\nreturn spline::velocity(_spline[i].coeff, t);\n}\n\nVector2d acceleration(double t)\n{\nassert(_is_empty == false);\nassert(t &gt;= 0);\nassert(t &lt;= static_cast&lt;double&gt;(size()));\n\nsize_t i = std::floor(t);\nt -= static_cast&lt;double&gt;(i);\nreturn spline::acceleration(_spline[i].coeff, t);\n}\n\nprotected:\nstruct segment_t\n{\nspline::spline_c coeff;\ndouble length;\n};\n\nstruct segment_info_t\n{\nsize_t i;\ndouble t;\n};\n\nsegment_info_t get_segmet_idx(const double t)\n{\nsegment_info_t result;\nresult.i = std::min(static_cast&lt;size_t&gt;(std::floor(t)), size()-1);\nresult.t = t - static_cast&lt;double&gt;(result.i);\nreturn result;\n}\n\nstd::vector&lt;segment_t&gt; _spline;\nbool _is_empty;\nsize_t _size;\ndouble _all_length;\n};\n\nclass CatumullRom2D : public Spline2D\n{\npublic:\nCatumullRom2D(std::vector&lt;Vector2d&gt;&amp; points, const double error = 0.1)\n{\nconst size_t p_size = points.size();\n\n_is_empty = false;\nswitch (p_size)\n{\ncase 0:\n_is_empty = true;\nreturn;\ncase 1:\n{\nVector2d&amp; p0 = points[0];\n_spline.push_back({spline::catumull_spline(p0, p0, p0, p0), 0});\nreturn;\n}\ncase 2:\n_size = 1;\n_spline.resize(_size);\ncalcu_segment(_spline[0], points, error, 0, 0, 0, 1, 1);\n_all_length = _spline[0].length;\nreturn;\n}\n\n_size = p_size - 1;\n_spline.resize(_size);\n\ncalcu_segment(_spline[0], points, error, 0, 0, 0, 1, 2);\nfor (size_t i = 0; i &lt; p_size - 3; i++)\n{\ncalcu_segment(_spline[i+1], points, error, i, 0, 1, 2, 3);\n}\n\ncalcu_segment(_spline[_size-1], points, error, p_size-3, 0, 1, 2, 2);\n\n_all_length = 0;\nfor(auto&amp; seg : _spline)\n{\n_all_length += seg.length;\n}\n}\n\nprivate:\nvoid calcu_segment(segment_t&amp; seg, std::vector&lt;Vector2d&gt;&amp; points, const double error, const size_t start, const size_t i0 = 0, const size_t i1 = 1, const size_t i2 = 2, const size_t i3 = 3)\n{\nVector2d &amp;p0 = points[start + i0];\nVector2d &amp;p1 = points[start + i1];\nVector2d &amp;p2 = points[start + i2];\nVector2d &amp;p3 = points[start + i3];\n\nseg.coeff = spline::catumull_spline(p0, p1, p2, p3);\nseg.length = spline::length(seg.coeff, error);\n}\n};\n\nclass CubicSpline : public Spline2D\n{\npublic:\nCubicSpline(std::vector&lt;Vector2d&gt;&amp; points, const double error = 0.1)\n{\nconst size_t p_size = points.size();\nstd::vector&lt;double&gt; w;\n\n_is_empty = false;\nif(p_size &lt; 2)\n{\n_is_empty = true;\nreturn;\n}\n\n_size = p_size - 1;\n_spline.resize(p_size);\nw.resize(p_size);\n\nfor(size_t xy = 0; xy &lt; 2; xy++)\n{            // 0\u6b21\u306e\u4fc2\u6570\nfor(size_t i = 0; i &lt;= _size; i++)\n{\nspline(i, xy).x = p(points, i, xy);\n}\n\n// 2\u6b21\u306e\u4fc2\u6570\nspline(0, xy).z = spline(_size, xy).z = 0.0;\nfor(size_t i = 1; i &lt; _size; i++)\n{\nspline(i, xy).z = 3.0 * (spline(i-1, xy).x - 2.0 * spline(i, xy).x + spline(i+1, xy).x);\n}\n// \u5de6\u4e0b\u6d88\u53bb\nw[0] = 0.0;\nfor(size_t i = 1; i &lt; _size; i++)\n{\ndouble temp = 4.0 - w[i-1];\nspline(i, xy).z = (spline(i, xy).z - spline(i-1, xy).z)/temp;\nw[i] = 1.0 / temp;\n}\n\n// \u53f3\u4e0b\u6d88\u53bb\nfor(size_t i = _size-1; i &gt; 0; i--) {\nspline(i, xy).z = spline(i, xy).z - spline(i+1, xy).z * w[i];\n}\n\n// 1\u6b21\u30683\u6b21\u306e\u4fc2\u6570\nspline(_size, xy).y = spline(_size, xy).w = 0.0;\nfor(size_t i = 0; i &lt; _size; i++)\n{\nspline(i, xy).w = ( spline(i+1, xy).z - spline(i, xy).z) / 3.0;\nspline(i, xy).y = spline(i+1, xy).x - spline(i, xy).x - spline(i, xy).z - spline(i, xy).w;\n}\n}\n// \u6700\u5f8c\u306e\u30bb\u30b0\u30e1\u30f3\u30c8\u306f\u6700\u5f8c\u306e\u5236\u5fa1\u70b9\u4e00\u70b9\u3088\u3046\u306a\u306e\u3067\u6d88\u3057\u3066\u304a\u304f\n_spline.erase(_spline.begin()+_spline.size()-1);\n\n_all_length = 0;\nfor(auto&amp; seg : _spline)\n{\nauto c = seg.coeff;\nseg.coeff = spline::cubic_function_to_bezier(\nVector2d(c.xb.w, c.yb.w),\nVector2d(c.xb.z, c.yb.z),\nVector2d(c.xb.y, c.yb.y),\nVector2d(c.xb.x, c.yb.x)\n);\nseg.length = spline::length(seg.coeff, error);\n_all_length += seg.length;\n}\n}\n\nprivate:\nVector4d&amp; spline(size_t i, size_t xy)\n{\nif (xy == 0)\nreturn _spline[i].coeff.xb;\nelse\nreturn _spline[i].coeff.yb;\n}\n\ndouble&amp; p(std::vector&lt;Vector2d&gt;&amp; points, size_t i, size_t xy)\n{\nif (xy == 0)\nreturn points[i].x;\nelse\nreturn points[i].y;\n}\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/sqp_8hpp/","title":"include/cpp_robotics/optimize/sqp.hpp","text":""},{"location":"doxybook/Files/sqp_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/sqp_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SQP SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) struct cpp_robotics::SQP::Problem struct cpp_robotics::SQP::Result"},{"location":"doxybook/Files/sqp_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;functional&gt;\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"./constraint.hpp\"\n#include \"./bracketing_serach.hpp\"\n#include \"./bfgs.hpp\"\n#include \"./quasi_newton_method.hpp\"\n// #include \"./quadprog.hpp\"\n#include &lt;cpp_robotics/optimize/quadprog.hpp&gt;\n#include \"./lsei_transition.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass SQP\n{\npublic:\nusing func_type = std::function&lt;double(Eigen::VectorXd)&gt;;\nusing grad_func_type = std::function&lt;Eigen::VectorXd(Eigen::VectorXd)&gt;;\n\nstruct Problem\n{\nfunc_type func;\nstd::optional&lt;grad_func_type&gt; grad;\nConstraintArray con;\n\nbool use_slsqp = false;\ndouble tol_step = 1e-6;\ndouble tol_con = 1e-6;\nsize_t max_iter = 100;\nbool print_variable = false;\n};\n\nstruct Result\n{\nbool is_solved = false;\nEigen::VectorXd x;\n// Eigen::VectorXd lambda_opt;\nsize_t iter_cnt = 0;\n};\n\nResult solve(Problem prob, const Eigen::VectorXd &amp;x0, std::optional&lt;std::function&lt;void(Eigen::VectorXd)&gt;&gt; callback = std::nullopt)\n{\nResult result;\n\ngrad_func_type grad_f = prob.grad.value_or([&amp;](const Eigen::VectorXd &amp;x){ return derivative(prob.func, x); });\n\n// \u5236\u7d04\u304c\u306a\u3044\u6642, \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f\nif(prob.con.size() == 0)\n{\nstd::tie(result.is_solved, result.x, result.iter_cnt) = quasi_newton_method(prob.func, grad_f, x0, 1e-6, prob.max_iter);\nreturn result;\n}\n\nEigen::VectorXd x = x0;\nEigen::VectorXd grad_f0 = grad_f(x0);\nEigen::MatrixXd B = Eigen::MatrixXd::Identity(x.rows(), x.rows());\nEigen::VectorXd grad_fx = grad_f0;\nEigen::VectorXd step = grad_f0;\nEigen::VectorXd dgg = Eigen::VectorXd::Zero(x.size());\n\n// Todo: x0\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u306a\u5834\u5408\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u307e\u3067\u79fb\u52d5\u3055\u305b\u308b\n\n// \u5236\u7d04\nauto eq_con = prob.con.gen_eq_constraint_list();\nauto ineq_con = prob.con.gen_ineq_constraint_list();\n\n// \u30b5\u30d6\u554f\u984c\u306e2\u6b21\u8a08\u753b\u554f\u984c\u306e\u30bd\u30eb\u30d0\u30fc\nQuadProg qp_solver;\nqp_solver.param.tol_con = 1e-3;\nqp_solver.param.tol_step = 1e-3;\nqp_solver.set_problem_size(x.size(), ineq_con.size(), eq_con.size());\n\n// \u76f4\u7dda\u63a2\u7d22\u7528\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5236\u7d04\u91cd\u307f\nconst double df0_norm = grad_f(x).norm();\nEigen::VectorXd eq_mw   = df0_norm * Eigen::VectorXd::Ones(eq_con.size());\nEigen::VectorXd ineq_mw = df0_norm * Eigen::VectorXd::Ones(ineq_con.size());\nfor(size_t i = 0; i &lt; eq_con.size(); i++)\n{\neq_mw(i) /= std::max(eq_con[i].grad(x).norm(), 1.0);\n}\nfor(size_t i = 0; i &lt; ineq_con.size(); i++)\n{\nineq_mw(i) /= std::max(ineq_con[i].grad(x).norm(), 1.0);\n}\n\n// \u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\nfor(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n{\nqp_solver.Aeq.row(con_i) = eq_con[con_i].grad(x).transpose();\nqp_solver.beq(con_i) = -eq_con[con_i].eval(x);\n}\n\n// \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\nfor(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n{\nqp_solver.A.row(con_i) = ineq_con[con_i].grad(x).transpose();\nqp_solver.b(con_i) = -ineq_con[con_i].eval(x);\n}\n\nEigen::MatrixXd new_Aeq(qp_solver.Aeq.rows(), qp_solver.Aeq.cols());\nEigen::VectorXd new_beq(qp_solver.beq.size());\nEigen::MatrixXd new_A(qp_solver.A.rows(), qp_solver.A.cols());\nEigen::VectorXd new_b(qp_solver.b.size());\n\n// Todo: \u3053\u306e\u524d\u51e6\u7406\u304c\u6709\u52b9\u306b\u306a\u3063\u305f\u6642\u306bdelta_grad_L\uff1f\u304c\u304a\u304b\u3057\u304f\u306a\u3063\u3066\u30d8\u30c3\u30b7\u30a2\u30f3\u304c\u767a\u6563\u3059\u308b\uff1f\nauto preprossesing = [&amp;](Eigen::MatrixXd &amp;Aeq, Eigen::VectorXd &amp;beq, Eigen::MatrixXd &amp;A, Eigen::VectorXd &amp;b)\n{\nfor(int i = 0; i &lt; Aeq.rows(); i++)\n{\nif(not Aeq.row(i).allFinite() || not std::isfinite(beq(i)))\n{\nAeq.row(i).setZero();\nbeq(i) = 0;\n}\n}\nfor(int i = 0; i &lt; A.rows(); i++)\n{\nif(not A.row(i).allFinite() || not std::isfinite(b(i)))\n{       A.row(i).setZero();\nb(i) = 0;\n}\n}\n};\npreprossesing(qp_solver.Aeq, qp_solver.beq, qp_solver.A, qp_solver.b);\n\nfor(size_t i = 1; i &lt; prob.max_iter+1; i++)\n{\nif(prob.print_variable)\n{\nstd::cout &lt;&lt; \"\\n////////////////////////////////\" &lt;&lt; std::endl;\n}\n\n// \u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\n// \u30b5\u30d6\u306e\u554f\u984c\u8a2d\u5b9a\nif (prob.use_slsqp)\n{\nauto ldlt_obj = B.ldlt();\nEigen::MatrixXd L = ldlt_obj.transpositionsP().transpose()*(Eigen::MatrixXd)ldlt_obj.matrixL();\nEigen::MatrixXd LT = L.transpose();\nEigen::MatrixXd Linv = L.inverse();\nEigen::VectorXd D = ldlt_obj.vectorD();\nEigen::VectorXd Dsq = D.array().sqrt();\nEigen::VectorXd Dinvsq = (D.array()).inverse();\n\n// std::cout &lt;&lt; \"D\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; D &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"Dsq\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; Dsq &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"Dinvsq\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; Dinvsq &lt;&lt; std::endl;\n\n\nEigen::MatrixXd C = Dsq.asDiagonal()*LT;\nEigen::VectorXd d = Dinvsq.asDiagonal()*Linv*grad_f(x);\nstd::tie(qp_solver.Q, qp_solver.c) = lsi2qp(C, d);\n\n// std::cout &lt;&lt; \"qp_solver.Q\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; qp_solver.Q &lt;&lt; std::endl;\n// std::cout &lt;&lt; \"qp_solver.c\" &lt;&lt; std::endl;\n// std::cout &lt;&lt; qp_solver.c &lt;&lt; std::endl;\n}\nelse\n{\nqp_solver.Q = B;\nqp_solver.c = grad_f(x).transpose();\n}\n\n// Todo QP\u306e\u5236\u7d04\u3067\u77db\u76fe\u3057\u305f\u3082\u306e\u3001\u6e80\u305f\u305b\u306a\u3044\u3082\u306e\u3092\u53d6\u308a\u9664\u304f\n\n// \u30b5\u30d6\u306e2\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\nauto sub_result = qp_solver.solve(Eigen::VectorXd::Zero(x.size()));\nif(not sub_result.is_solved)\n{\nresult.is_solved = false;\nresult.iter_cnt = i;\nresult.x = x;\n// result.lambda_opt = sub_result.lambda_opt;\nstd::cout &lt;&lt; \"cant solve sub qp: \" &lt;&lt; sub_result.iter_cnt &lt;&lt; std::endl;\nqp_solver.debug_prog();\nreturn result;\n}\nauto d = sub_result.x;\n\n// \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u6c7a\u5b9a\n// \u76f4\u7dda\u63a2\u7d22\nauto merit_func = [&amp;](const Eigen::VectorXd &amp;x)\n{\ndouble val = prob.func(x);\n\n// \u7b49\u5f0f\u5236\u7d04\nfor(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n{\nconst double eval = eq_con[con_i].eval(x);\nif(std::isfinite(eval))\nval += eq_mw(con_i) * std::abs(eval);\n}\n\n// \u4e0d\u7b49\u5f0f\u5236\u7d04\nfor(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n{\nconst double eval = ineq_con[con_i].eval(x);\nif(std::isfinite(eval))\nval += ineq_mw(con_i) * std::max(eval, 0.0);\n}\n\nreturn val;\n};\ndouble alpha = bracketing_serach(merit_func, [&amp;](const Eigen::VectorXd &amp;x){ return derivative(merit_func, x); }, x, d);\n\nif(prob.print_variable)\n{\nstd::cout &lt;&lt; \"d\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; d &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"alpha\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; alpha &lt;&lt; std::endl;\n}\n\nif(callback)\ncallback.value()(x);\nstep = alpha * d;\nx += step;\n\n// \u53ce\u675f\u5224\u5b9a\n// Todo: KKT\u6761\u4ef6\u306e1\u6b21\u306e\u6700\u9069\u6027\u30c1\u30a7\u30c3\u30af\u5165\u308c\u308b\nif(step.norm() &lt; prob.tol_step*(1.0+x.norm())) // &amp;&amp; prob.con.all_satisfy(x, prob.tol_con))\n{\nresult.is_solved = true;\nresult.iter_cnt = i;\nresult.x = x;\nreturn result;\n}\n\n// \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u91cd\u307f\u66f4\u65b0\nfor(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n{\neq_mw(con_i) = std::max(eq_mw(con_i), 0.5*(eq_mw(con_i) + sub_result.lambda_eq(con_i)));\n}\nfor(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n{\nineq_mw(con_i) = std::max(ineq_mw(con_i), 0.5*(ineq_mw(con_i) + sub_result.lambda_ineq(con_i)));\n}\n\n// \u89e3\u306e\u4fdd\u5b58\nresult.x = x;\nresult.iter_cnt = i;\n\n// \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u95a2\u6570\u306e\u52fe\u914d\u306e\u5909\u5316\u91cf\n/*\n            B\u306e\u5024\u304ce10\u4ee5\u4e0a\u306e\u30aa\u30fc\u30c0\u30fc\u3067\u5927\u304d\u304f\u306a\u308b\n            \u5236\u7d04\u306b\u639b\u304b\u308bgrad_L\u306e\u5024\u304c\u6b63\u3057\u3044\u306e\u304b\u78ba\u8a8d\u3059\u308b\n            */\n// https://jp.mathworks.com/help/optim/ug/constrained-nonlinear-optimization-algorithms.html#bsgppl4\nEigen::VectorXd delta_grad_L = -grad_fx;\ngrad_fx = grad_f(x);\ndelta_grad_L += grad_fx;\n// \u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\nfor(size_t con_i = 0; con_i &lt; eq_con.size(); con_i++)\n{\nnew_Aeq.row(con_i) = eq_con[con_i].grad(x).transpose();\nnew_beq(con_i) = -eq_con[con_i].eval(x);\n}\n\n// \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c\nfor(size_t con_i = 0; con_i &lt; ineq_con.size(); con_i++)\n{\nnew_A.row(con_i) = ineq_con[con_i].grad(x).transpose();\nnew_b(con_i) = -ineq_con[con_i].eval(x);\n}\n\npreprossesing(new_Aeq, new_beq, new_A, new_b);\n\ndelta_grad_L += (new_Aeq - qp_solver.Aeq).transpose() * sub_result.lambda_eq;\ndelta_grad_L += (new_A   - qp_solver.A  ).transpose() * sub_result.lambda_ineq;\n\nqp_solver.Aeq = new_Aeq;\nqp_solver.beq = new_beq;\nqp_solver.A = new_A;\nqp_solver.b = new_b;\n\n// \\grad_g(x) * g(x) = [n]*[1]\nEigen::VectorXd new_dgg = -new_Aeq.transpose()*new_beq -new_A.transpose()*new_b - x;\n\n// \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u95a2\u6570\u306e\u7591\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u66f4\u65b0\npowells_modified_bfgs_step(B, step, delta_grad_L, new_dgg - dgg);\ndgg = new_dgg;\n\nif(prob.print_variable)\n{\nstd::cout &lt;&lt; \"B=\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; B &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"x=\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n\nif(B.array().isNaN().any())\n{\nstd::cout &lt;&lt; \"NaN\u304c\u5b58\u5728\u3057\u307e\u3059\" &lt;&lt; std::endl;\nbreak;\n}\n}\n\nreturn result;\n}\n\nprivate:\ntemplate &lt;typename Mat&gt;\nbool is_posdef(Mat H)\n{\nEigen::EigenSolver&lt;Mat&gt; eigensolver(H);\nfor (int i = 0; i &lt; eigensolver.eigenvalues().rows(); i++) {\ndouble v = eigensolver.eigenvalues()(i).real();\nif (v &lt;= 0) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/state__machine_8hpp/","title":"include/cpp_robotics/algorithm/state_machine.hpp","text":""},{"location":"doxybook/Files/state__machine_8hpp/#source-code","title":"Source code","text":"<pre><code>// #pragma once\n\n// #include &lt;memory&gt;\n\n// namespace cpp_robotics\n// {\n\n// template&lt;class T&gt;\n// class State\n// {\n// public:\n//     State() = delete;\n\n//     State(const T &amp;id):\n//         id_(id) {}\n\n//     virtual void entry() {}\n\n//     virtual void update() {}\n\n//     virtual void exit() {}\n\n// private:\n//     const T id_;\n// };\n\n// template&lt;class T&gt;\n// class StateMachine\n// {\n// public:\n\n//     StateMachine()\n//     {\n\n//     }\n\n//     void update()\n//     {\n//         state_list_-&gt;update();\n//     }\n\n// private:\n//     std::map&lt;T, std::shared_ptr&lt;State&lt;T&gt;&gt;&gt; state_list_;\n// };\n\n// }\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/state__space__system_8hpp/","title":"include/cpp_robotics/system/state_space_system.hpp","text":""},{"location":"doxybook/Files/state__space__system_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/state__space__system_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb"},{"location":"doxybook/Files/state__space__system_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/../unsupported/Eigen/MatrixFunctions&gt;\n#include &lt;optional&gt;\n#include \"discret.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass StateSpaceSystem\n{\npublic:\nStateSpaceSystem() = default;\n\ntemplate&lt;typename DerivedA, typename DerivedB, typename DerivedC&gt;\nStateSpaceSystem(const Eigen::MatrixBase&lt;DerivedA&gt; &amp;A, const Eigen::MatrixBase&lt;DerivedB&gt; &amp;B, const Eigen::MatrixBase&lt;DerivedC&gt; &amp;C, const double Ts)\n{\nset_continuous(A, B, C, Ts);\n}\n\ntemplate&lt;typename DerivedA, typename DerivedB, typename DerivedC&gt;\nvoid set_continuous(const Eigen::MatrixBase&lt;DerivedA&gt; &amp;A, const Eigen::MatrixBase&lt;DerivedB&gt; &amp;B, const Eigen::MatrixBase&lt;DerivedC&gt; &amp;C, const double Ts, const bool skip_state_reset = false)\n{\nassert(A.rows() == A.cols());\nassert(A.rows() == B.rows());\nassert(A.cols() == C.cols());\n\nstate_size_ = A.rows();\ninput_size_ = B.cols();\noutput_size_ = C.rows();\n\nA_ = A;\nB_ = B;\nTs_ = Ts;\nstd::tie(Ad_, Bd_) = Discret::discritize(A, B, Ts);\nCd_ = C;\n\nif(not skip_state_reset)\nset_state_zero();\n}\n\ntemplate&lt;typename DerivedA, typename DerivedB, typename DerivedC&gt;\nvoid set_discrite(const Eigen::MatrixBase&lt;DerivedA&gt; &amp;Ad, const Eigen::MatrixBase&lt;DerivedB&gt; &amp;Bd, const Eigen::MatrixBase&lt;DerivedC&gt; &amp;Cd, const double Ts, const bool skip_state_reset = false)\n{\nassert(Ad.rows() == Ad.cols());\nassert(Ad.rows() == Bd.rows());\nassert(Ad.cols() == Cd.cols());\n\nstate_size_ = Ad.rows();\ninput_size_ = Bd.cols();\noutput_size_ = Cd.rows();\n\nA_ = std::nullopt;\nB_ = std::nullopt;\nTs_ = Ts;\n\nAd_ = Ad;\nBd_ = Bd;\nCd_ = Cd;\n\nif(not skip_state_reset)\nset_state_zero();\n}\n\nsize_t state_size() const { return state_size_; }\nsize_t input_size() const { return input_size_; }\nsize_t output_size() const { return output_size_; }\n\nbool is_siso_model() const { return (input_size() == 1 &amp;&amp; output_size() == 1); }\n\ninline void set_state_zero()\n{\nset_state(Eigen::VectorXd::Zero(state_size()));\n}\n\nvoid set_state(const Eigen::VectorXd &amp;x)\n{\nx_ = x;\n}\n\nvoid set_state(const double &amp;x)\n{\nassert(input_size() == 1 &amp;&amp; output_size() == 1);\nEigen::VectorXd x_vec(1);\nx_vec(0) = x;\nset_state(x_vec);\n}\n\nauto responce(const Eigen::VectorXd &amp;u)\n{\nx_ = Ad_*x_ + Bd_*u;\nreturn Cd_*x_;\n}\n\ndouble responce(double u)\n{\nassert(input_size() == 1 &amp;&amp; output_size() == 1);\nEigen::VectorXd u_vec(1);\nu_vec(0) = u;\nreturn responce(u_vec)(0);\n}\n\nstd::optional&lt;Eigen::MatrixXd&gt; A() const { return A_; }\nstd::optional&lt;Eigen::MatrixXd&gt; B() const { return B_; }\ndouble Ts() const { return Ts_; }\n\nEigen::MatrixXd Ad() const { return Ad_; }\nEigen::MatrixXd Bd() const { return Bd_; }\n\nEigen::MatrixXd C()  const { return Cd_; }\nEigen::MatrixXd Cd() const { return Cd_; }\n\nEigen::VectorXd x() const { return x_; }\nEigen::VectorXd y() const { return Cd_*x_; }\n\nprivate:\nEigen::MatrixXd Ad_;\nEigen::MatrixXd Bd_;\nEigen::MatrixXd Cd_;\n\nstd::optional&lt;Eigen::MatrixXd&gt; A_;\nstd::optional&lt;Eigen::MatrixXd&gt; B_;\ndouble Ts_;\n\nsize_t state_size_;\nsize_t input_size_;\nsize_t output_size_;\n\nEigen::VectorXd x_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/steepest__descent__method_8hpp/","title":"include/cpp_robotics/optimize/steepest_descent_method.hpp","text":""},{"location":"doxybook/Files/steepest__descent__method_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/steepest__descent__method_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;functional&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"bracketing_serach.hpp\"\n\nnamespace cpp_robotics\n{\n\nstatic std::tuple&lt;bool, Eigen::VectorXd, size_t&gt; steepest_descent_method(std::function&lt;double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt;Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000)\n{\nEigen::VectorXd x = x_init;\nEigen::VectorXd s;\n\nfor(size_t i = 0; i &lt; max_iter; i++)\n{\ns = -grad(x);\n\nif(s.norm() &lt; tol)\n{\nreturn {true, x, i};\n}\n\n// \u76f4\u7dda\u63a2\u7d22\ndouble a = bracketing_serach(f, grad, x, s);\nx += a*s;\n}\n\nreturn {false, x, max_iter};\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/swerve__ik_8hpp/","title":"include/cpp_robotics/chassis/swerve_ik.hpp","text":""},{"location":"doxybook/Files/swerve__ik_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/swerve__ik_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb"},{"location":"doxybook/Files/swerve__ik_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/vector/transform.hpp\"\n#include \"cpp_robotics/vector/vector2.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass SwerveIk\n{\npublic:\nusing VecArray = std::array&lt;Vector2d, 4&gt;;\n\nSwerveIk(const double width, const double length)\n{\nconst double hw = width/2;\nconst double hl = length/2;\nwheel_place_ =\n{\nVector2d{ hw,  hl},\nVector2d{-hw,  hl},\nVector2d{-hw, -hl},\nVector2d{ hw, -hl}\n};\n}\n\nSwerveIk(VecArray wheel_place):\nwheel_place_(wheel_place)\n{\n\n}\n\nVecArray calculate(Transformd velocity)\n{\nVecArray wv;\nfor(size_t i = 0; i &lt; 4; i++)\n{\nconst double wangle = wheel_place_[i].angle();\nconst double wpnorm = wheel_place_[i].norm();\nwv[i].x = velocity.x - wpnorm * velocity.theta * std::sin(wangle);\nwv[i].y = velocity.y + wpnorm * velocity.theta * std::cos(wangle);\n}\nreturn wv;\n}\n\nVecArray wheel_place() const { return wheel_place_; }\n\nprivate:\nVecArray wheel_place_;\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/system_8hpp/","title":"include/cpp_robotics/system.hpp","text":""},{"location":"doxybook/Files/system_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"system/discret.hpp\"\n#include \"system/state_space_system.hpp\"\n#include \"system/transfer_function.hpp\"\n#include \"system/polynomial.hpp\"\n#include \"system/bode.hpp\"\n#include \"system/nyquist.hpp\"\n#include \"system/time_responce.hpp\"\n#include \"system/siso_system.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/system__transformation_8hpp/","title":"include/cpp_robotics/system/system_transformation.hpp","text":""},{"location":"doxybook/Files/system__transformation_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/system__transformation_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cpp_robotics/system/transfer_function.hpp&gt;\n#include &lt;cpp_robotics/system/state_space_system.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nStateSpaceSystem tf2ss(const TransferFunction &amp;tf)\n{\n// \u4f1d\u9054\u95a2\u6570\u3092\u53ef\u5236\u5fa1\u6b63\u6e96\u7cfb\u306b\u5909\u63db\u3057\u3066\u4fdd\u5b58\nauto num_array = tf.num_array();\nauto den_array = tf.den_array();\nconst size_t num_size = num_array.size();\nconst size_t den_size = den_array.size();\nconst size_t state_size = tf.den_deg();\n\nEigen::MatrixXd A = Eigen::MatrixXd::Zero(state_size, state_size);\n// \u5bfe\u89d2\u8981\u7d20\u306e1\u500b\u53f3\u96a3\u30921\u57cb\u3081\nfor(size_t i = 0; i &lt; state_size-1; i++)\n{\nA(i, i+1) = 1;\n}\n// \u4e00\u756a\u4e0b\u306e\u884c\u3092\u4f1d\u9054\u95a2\u6570\u306e\u8981\u7d20\u3067\u57cb\u3081\nfor(size_t i = 0; i &lt; state_size; i++)\n{\nA(state_size-1, i) = -den_array[state_size - i] / den_array[0];\n}\n\nEigen::MatrixXd B = Eigen::VectorXd::Zero(state_size);\nB(state_size-1) = 1;\n\nEigen::MatrixXd C = Eigen::RowVectorXd::Zero(state_size);\nfor(size_t i = 0; i &lt;= num_size; i++)\n{\nC(i) = num_array[i] / den_array[0];\n}\n\nreturn StateSpaceSystem(A, B, C, tf.Ts());\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/time__responce_8hpp/","title":"include/cpp_robotics/system/time_responce.hpp","text":""},{"location":"doxybook/Files/time__responce_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/time__responce_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include \"../utility/space.hpp\"\n#include \"./transfer_function.hpp\"\n\nnamespace cpp_robotics\n{\n\nnamespace internal\n{\ntemplate &lt;class T&gt;\nclass is_system_class\n{\ntemplate &lt;class U&gt;\nstatic auto check(U&amp;&amp; x)-&gt;decltype(x.Ts(), x.responce(0.0), std::true_type{});\n\ntemplate &lt;class U&gt;\nstatic auto check(...)-&gt;std::false_type;\n\npublic:\nstatic constexpr bool value = decltype(check&lt;T&gt;(std::declval&lt;T&gt;()))::value;\n};\n\ntemplate &lt;class T&gt;\nclass is_filter_class\n{\ntemplate &lt;class U&gt;\nstatic auto check(U&amp;&amp; x)-&gt;decltype(x.Ts(), x.filtering(0.0), std::true_type{});\n\ntemplate &lt;class U&gt;\nstatic auto check(...)-&gt;std::false_type;\n\npublic:\nstatic constexpr bool value = decltype(check&lt;T&gt;(std::declval&lt;T&gt;()))::value;\n};\n\ntemplate &lt;class T&gt;\nstruct is_pure_filter_class\n{\nstatic constexpr bool value = not is_system_class&lt;T&gt;::value &amp;&amp; is_filter_class&lt;T&gt;::value;\n};\n\n}\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; impulse(const std::function&lt;double(double)&gt; &amp;sys, double dt, double time)\n{\nstd::vector&lt;double&gt; t = arrange(0, time, dt);\nstd::vector&lt;double&gt; res(t.size());\nfor(size_t i = 0; i &lt; res.size(); i++)\n{\nres[i] = sys( i == 0 ? 1.0/dt : 0.0);\n}\nreturn {t, res};\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_system_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; impulse(SysType &amp;sys, double time)\n{\nreturn impulse([&amp;](double u){ return sys.responce(u); }, sys.Ts(), time);\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_pure_filter_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; impulse(SysType &amp;sys, double time)\n{\nreturn impulse([&amp;](double u){ return sys.filtering(u); }, sys.Ts(), time);\n}\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step(const std::function&lt;double(double)&gt; &amp;sys, double dt, double time, const double gain = 1.0)\n{\nstd::vector&lt;double&gt; t = arrange(0, time, dt);\nstd::vector&lt;double&gt; res(t.size());\n\nfor(size_t i = 0; i &lt; res.size(); i++)\n{\nres[i] = sys(gain);\n}\n\nreturn {t, res};\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_system_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step(SysType &amp;sys, double time, const double gain = 1.0)\n{\nreturn step([&amp;](double u){ return sys.responce(u); }, sys.Ts(), time, gain);\n}\n\ntemplate&lt;class FilterType, typename std::enable_if&lt;internal::is_pure_filter_class&lt;FilterType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step(FilterType &amp;filter, double time, const double gain = 1.0)\n{\nreturn step([&amp;](double u){ return filter.filtering(u); }, filter.Ts(), time, gain);\n}\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; lsim(const std::function&lt;double(double)&gt; &amp;sys, double dt, const std::vector&lt;double&gt; &amp;input)\n{\nstd::vector&lt;double&gt; t = linspace(0, dt*input.size(), input.size());\nstd::vector&lt;double&gt; res(t.size());\nfor(size_t i = 0; i &lt; res.size(); i++)\n{\nres[i] = sys(input[i]);\n}\nreturn {t, res};\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_system_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; lsim(SysType &amp;sys, std::vector&lt;double&gt; input)\n{\nreturn lsim([&amp;](double u){ return sys.responce(u); }, sys.Ts(), input);\n}\n\ntemplate&lt;class SysType, typename std::enable_if&lt;internal::is_pure_filter_class&lt;SysType&gt;::value&gt;::type* = nullptr&gt;\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; lsim(SysType &amp;sys, std::vector&lt;double&gt; input)\n{\nreturn lsim([&amp;](double u){ return sys.filtering(u); }, sys.Ts(), input);\n}\n\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/timer_8hpp/","title":"include/cpp_robotics/utility/timer.hpp","text":""},{"location":"doxybook/Files/timer_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/timer_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::Timer"},{"location":"doxybook/Files/timer_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;chrono&gt;\n\nnamespace cpp_robotics\n{\n\nclass Timer\n{\npublic:\nvoid start()\n{\nstart_ = std::chrono::system_clock::now();\n}\n\nvoid stop()\n{\nend_ = std::chrono::system_clock::now();\n}\n\ndouble second()\n{\nreturn std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_-start_).count() * 1e-3;\n}\n\ndouble millisecond()\n{\nreturn std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_-start_).count();\n}\n\nprivate:\nstd::chrono::system_clock::time_point start_, end_; };\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/transfer__function_8hpp/","title":"include/cpp_robotics/system/transfer_function.hpp","text":""},{"location":"doxybook/Files/transfer__function_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/transfer__function_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb"},{"location":"doxybook/Files/transfer__function_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/system/discret.hpp&gt;\n\nnamespace cpp_robotics\n{\n\nclass TransferFunction\n{\npublic:\nstatic TransferFunction make_first_order_system(const double T, const double Ts)\n{\nreturn TransferFunction({1}, {T, 1}, Ts);\n}\n\nstatic TransferFunction make_second_order_system(const double omega, const double zeta, const double Ts)\n{\nreturn TransferFunction({omega*omega}, {1.0, 2.0*zeta*omega, omega*omega}, Ts);\n}\n\nTransferFunction() = default;\n\nTransferFunction(std::vector&lt;double&gt; num, std::vector&lt;double&gt; den, const double Ts):\nnum_array_(num), den_array_(den)\n{\nset_continuous(num_array_, den_array_, Ts);\n}\n\nvoid set_continuous(std::vector&lt;double&gt; num, std::vector&lt;double&gt; den, const double dt)\n{\nauto [num_disc, den_disc] = DiscretTransferFunction::discritize(num, den, dt);\nset_discrite(num_disc, den_disc, dt);\n}\n\n// z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306e\u5206\u5b50\u3068\u5206\u6bcd\u3092\u964d\u3079\u304d\u306e\u6e96\u306b\u4e0e\u3048\u308b\nvoid set_discrite(std::vector&lt;double&gt; num_disc, std::vector&lt;double&gt; den_disc, const double dt)\n{\nassert(num_disc.size() &gt; 0);\nassert(den_disc.size() &gt; 0);\n\nnum_ = num_disc;\nden_ = den_disc;\n\nu_.resize(num_.size());\ny_.resize(den_.size()-1);\n\ndt_ = dt;\n\nreset();\n}\n\ndouble Ts() const { return dt_; }\n\nvirtual void reset(double state = 0)\n{\nfor(auto &amp;u : u_)\nu = 0;\nfor(auto &amp;y : y_)\ny = state;\nu_.reset_position();\ny_.reset_position();\n}\n\ndouble responce(double u)\n{\ndouble y = 0;\nu_.insert_front(u);\n\nfor(size_t i = 0; i &lt; num_.size(); i++)\n{\ny += num_[i]*u_.at_circular(i);\n}\n\nfor(size_t i = 0; i &lt; den_.size()-1; i++)\n{\ny -= den_[i+1]*y_.at_circular(i);\n}\ny /= den_[0];\n\ny_.insert_front(y);\nreturn y;\n}\n\nsize_t num_deg(size_t num_idx = 0) const\n{\nreturn num_array_.size()-1 - num_idx;\n}\n\nsize_t den_deg(size_t num_idx = 0) const\n{\nreturn den_array_.size()-1 - num_idx;\n}\n\nstd::vector&lt;double&gt; num_array() const { return num_array_; }\nstd::vector&lt;double&gt; den_array() const { return den_array_; }\n\nprivate:\nstd::vector&lt;double&gt; num_array_;\nstd::vector&lt;double&gt; den_array_;\n\ntemplate&lt;typename T&gt;\nclass CircularBuffer : public std::vector&lt;T&gt;\n{\npublic:\nvoid reset_position()\n{\ni = 0;\n}\n\nT&amp; at_circular(size_t idx)\n{\nidx += i;\nif(this-&gt;size() &lt;= idx)\nidx-=this-&gt;size();\nreturn this-&gt;at(idx);\n}\n\nvoid insert_front(T val)\n{\ni += this-&gt;size()-1;\nif(this-&gt;size() &lt;= i)\ni-=this-&gt;size();\nthis-&gt;at(i) = val;\n}\n\nprivate:\nsize_t i = 0;\n};\nstd::vector&lt;double&gt; num_;\nstd::vector&lt;double&gt; den_;\nCircularBuffer&lt;double&gt; u_;\nCircularBuffer&lt;double&gt; y_;\ndouble dt_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/transform_8hpp/","title":"include/cpp_robotics/vector/transform.hpp","text":"<p>More...</p>"},{"location":"doxybook/Files/transform_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/transform_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9"},{"location":"doxybook/Files/transform_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author: Takumi Odashima (Kotakkucu@gmail.com) </p> <p>Date: 2021-01-25</p> <p>Copyright: Copyright (c) 2021 </p>"},{"location":"doxybook/Files/transform_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"./vector2.hpp\"\n\nnamespace cpp_robotics\n{\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Transform;\nusing Transformf = Transform&lt;float&gt;;\nusing Transformd = Transform&lt;double&gt;;\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Transform //\n{\nusing value_type = FLOATING_TYPE;\nusing vector_type = Vector2&lt;value_type&gt;;\nvalue_type x, y, theta;\n\n// \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\nTransform() = default;\n\nconstexpr Transform(const value_type _x, const value_type _y, const value_type _theta) : x(_x), y(_y), theta(_theta) {}\n\nconstexpr Transform(const vector_type&amp; _xy, const value_type _theta) : x(_xy.x), y(_xy.y), theta(_theta) {}\n\nconstexpr Transform(const Transform &amp;) = default;\n\nconstexpr vector_type make_vector2() const\n{\nreturn vector_type(x, y);\n}\n\nconstexpr void set(value_type vx, value_type vy, value_type vtheta) {\nx = vx;\ny = vy;\ntheta = vtheta;\n}\n\n// origin-xy\u8ddd\u96e2\nvalue_type distance() const\n{\nreturn vector_type(x, y).norm();\n}\n\n// \u56de\u8ee2\nvoid rotate(const value_type theta)\n{\nrotate(vector_type::zero(), theta);\n}\n\nvoid rotate(const value_type rotX, const value_type rotY, const value_type theta)\n{\nrotate(vector_type(rotX, rotY), theta); }\n\nvoid rotate(vector_type rotPos, const value_type theta) { vector_type p = make_vector2() - rotPos;\np.rotate(theta);\nx = p.x + rotPos.x;\ny = p.y + rotPos.y;\n}\n\n// \u6975\u5ea7\u6a19\u6307\u5b9a\nvoid set_polar(const value_type radius, const value_type angle, const value_type robotTheta)\n{\nx = radius * std::cos(angle);\ny = radius * std::sin(angle);\ntheta = robotTheta;\n}\n\nbool is_zero() const\n{\nreturn approx_zero(x) &amp;&amp; approx_zero(y) &amp;&amp; approx_zero(theta);\n}\n\nbool is_zero_pos() const\n{\nreturn x == 0.0 &amp;&amp; y == 0.0;\n}\n\nbool is_zero_angle() const\n{\nreturn theta == 0.0;\n}\n\nbool has_nan() const\n{\nreturn std::isnan(x) || std::isnan(y) || std::isnan(theta);\n}\n\nstatic constexpr value_type get_angle(Transform &amp;a, Transform &amp;b) { return b.theta - a.theta; };\n\nstatic value_type get_distance(Transform &amp;a, Transform &amp;b)\n{\nreturn (b-a).distance();\n}\n\nstatic Transform get_lerp(Transform &amp;a, Transform &amp;b, const value_type t)\n{\nreturn {lerp(a.x, b.x, t), lerp(a.y, b.y, t), lerp(a.theta, b.theta, t)};\n}\n\n// constatnt vector\nstatic constexpr Transform origin() {\nreturn {0.0, 0.0, 0.0};\n}\n\nconstexpr bool operator == (const Transform v) const\n{\nreturn (x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (theta == v.theta);\n}\n\nconstexpr bool operator != (const Transform&amp; v) const\n{\nreturn !((x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (theta == v.theta));\n}\n\nconstexpr Transform operator + (const Transform&amp; v) const {\nreturn {x + v.x, y + v.y, theta + v.theta};\n}\n\nconstexpr Transform operator - (const Transform&amp; v) const\n{\nreturn {x - v.x, y - v.y, theta - v.theta};\n}\n\nconstexpr Transform&amp; operator += (const Transform&amp; v)\n{\nx += v.x;\ny += v.y;\ntheta += v.theta;\n\nreturn *this;\n}\n\nconstexpr Transform&amp; operator -= (const Transform&amp; v)\n{\nx -= v.x;\ny -= v.y;\ntheta -= v.theta;\n\nreturn *this;\n}\n\n// xy\nconstexpr Transform operator + (const vector_type&amp; v) const\n{\nreturn {x + v.x, y + v.y, theta};\n}\n\nconstexpr Transform operator - (const vector_type&amp; v) const\n{\nreturn {x - v.x, y - v.y, theta};\n}\n\n// theta\n\nconstexpr Transform operator + (const value_type angle) const\n{\nreturn {x, y, theta + angle};\n}\n\nconstexpr Transform operator - (const value_type angle) const\n{\nreturn {x, y, theta - angle};\n}\n\n// xy\nconstexpr Transform&amp; operator += (const vector_type&amp; v)\n{\nx += v.x;\ny += v.y;\n\nreturn *this;\n}\n\nconstexpr Transform&amp; operator -= (const vector_type&amp; v)\n{\nx -= v.x;\ny -= v.y;\n\nreturn *this;\n}\n\n// theta\nconstexpr Transform&amp; operator += (const value_type angle)\n{\ntheta += angle;\n\nreturn *this;\n}\n\nconstexpr Transform&amp; operator -= (const value_type angle)\n{\ntheta -= angle;\n\nreturn *this;\n}\n\nconstexpr Transform operator * (const value_type value) const\n{\nreturn {x * value, y * value, theta * value};\n}\n\nconstexpr Transform operator / (const value_type value) const\n{\nreturn {x / value, y / value, theta / value};\n}\n\nconstexpr Transform&amp; operator *= (const value_type value)\n{\nx *= value;\ny *= value;\ntheta *= value;\n\nreturn *this;\n}\n\nconstexpr Transform&amp; operator /= (const value_type value)\n{\nx /= value;\ny /= value;\ntheta /= value;\n\nreturn *this;\n}\n\n// index\nvalue_type &amp;operator [] (const int index)\n{\nassert(0 &lt;= index &amp;&amp; index &lt; 3);\nif (index == 0) return x;\nif (index == 1) return y;\nreturn theta;\n}\n\nconstexpr value_type operator [] (const int index) const\n{\nassert(0 &lt;= index &amp;&amp; index &lt; 3);\nif (index == 0) return x;\nif (index == 1) return y;\nreturn theta;\n}\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/transformation_8hpp/","title":"include/cpp_robotics/algorithm/transformation.hpp","text":""},{"location":"doxybook/Files/transformation_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/transformation_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n\nnamespace cpp_robotics\n{\n\nstatic Eigen::MatrixXd homogeneous(const Eigen::MatrixXd &amp;R, const Eigen::VectorXd &amp;T)\n{\nassert(R.rows() == R.cols());\nassert(R.cols() == T.rows());\nconst int dim = T.rows();\nEigen::MatrixXd H(dim+1, dim+1);\nH.block(0,0, dim, dim) = R;\nH.block(0, dim, dim, 1) = T;\nH(dim, dim) = 1;\nreturn H;\n}\n\nstatic Eigen::VectorXd transform_by_homogeneous(const Eigen::MatrixXd &amp;H, const Eigen::VectorXd &amp;x)\n{\nassert(H.rows() == H.cols());\nassert(H.cols() == x.rows()+1);\nconst int dim = x.rows();\n\nEigen::VectorXd xt = H.block(0,0, dim, dim)*x + H.block(0, dim, dim, 1);\nreturn xt;\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/unit_8hpp/","title":"include/cpp_robotics/unit.hpp","text":""},{"location":"doxybook/Files/unit_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"unit/unit_core.hpp\"\n#include \"unit/si_unit.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/unit__core_8hpp/","title":"include/cpp_robotics/unit/unit_core.hpp","text":""},{"location":"doxybook/Files/unit__core_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::prefix cpp_robotics::unit::tag"},{"location":"doxybook/Files/unit__core_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 struct cpp_robotics::unit::prefix::pfx_mul struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag&lt;-1 &gt; struct cpp_robotics::unit::tag::is_normal_tag&lt; 0 &gt; class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9"},{"location":"doxybook/Files/unit__core_8hpp/#defines","title":"Defines","text":"Name GENERATE_CONV_FACTOR(unit_dim, from_tag, to_tag, factor) GENERATE_UNIT_SUFFIX(unit, suffix) GENERATE_UNIT_PFX_SUFFIX(unit_type, prefix, suffix)"},{"location":"doxybook/Files/unit__core_8hpp/#macros-documentation","title":"Macros Documentation","text":""},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_conv_factor","title":"define GENERATE_CONV_FACTOR","text":"<pre><code>#define GENERATE_CONV_FACTOR(\nunit_dim,\nfrom_tag,\nto_tag,\nfactor\n)\ntemplate&lt;&gt;\\\nconstexpr double conv_factor&lt;unit_dim, from_tag, to_tag&gt;()\\\n{\\\n    return (factor);\\\n}\n</code></pre>"},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_unit_suffix","title":"define GENERATE_UNIT_SUFFIX","text":"<pre><code>#define GENERATE_UNIT_SUFFIX(\nunit,\nsuffix\n)\nconstexpr unit operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr unit operator\"\" _## suffix(long double val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\n</code></pre>"},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_unit_pfx_suffix","title":"define GENERATE_UNIT_PFX_SUFFIX","text":"<pre><code>#define GENERATE_UNIT_PFX_SUFFIX(\nunit_type,\nprefix,\nsuffix\n)\nconstexpr auto operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr auto operator\"\" _## suffix(long double val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\n</code></pre>"},{"location":"doxybook/Files/unit__core_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;cstdlib&gt;\n#include &lt;type_traits&gt;\n#include &lt;numeric&gt;\n#include &lt;cmath&gt;\n\nnamespace cpp_robotics\n{\n\ninline namespace unit\n{\nenum UnitIndex\n{\nMetereIdx,\nKiloGramIdx,\nSecondIdx,\nAmpereIdx,\nKelvinIdx,\nMoleIdx,\nCandelaIdx\n};\n\ntemplate&lt;int DIM1, int DIM2, int DIM3, int DIM4, int DIM5, int DIM6, int DIM7&gt;\nstruct UnitType{\nstatic constexpr int dim1 = DIM1;\n\nstatic constexpr int dim2 = DIM2;\n\nstatic constexpr int dim3 = DIM3;\n\nstatic constexpr int dim4 = DIM4;\n\nstatic constexpr int dim5 = DIM5;\n\nstatic constexpr int dim6 = DIM6;\n\nstatic constexpr int dim7 = DIM7;\n};\n\nnamespace unit_dim_assem\n{\ntemplate&lt;class U1, class U2&gt;\nstruct udim_mul\n{\nusing unit = UnitType&lt;\nU1::dim1 + U2::dim1,\nU1::dim2 + U2::dim2,\nU1::dim3 + U2::dim3,\nU1::dim4 + U2::dim4,\nU1::dim5 + U2::dim5,\nU1::dim6 + U2::dim6,\nU1::dim7 + U2::dim7&gt;;\n};\n\ntemplate&lt;class U1, class U2&gt;\nstruct udim_div\n{\nusing unit = UnitType&lt;\nU1::dim1 - U2::dim1,\nU1::dim2 - U2::dim2,\nU1::dim3 - U2::dim3,\nU1::dim4 - U2::dim4,\nU1::dim5 - U2::dim5,\nU1::dim6 - U2::dim6,\nU1::dim7 - U2::dim7&gt;;\n};\n\ntemplate&lt;class U1, int N&gt;\nstruct udim_pow\n{\nusing unit = UnitType&lt;\nU1::dim1 * N,\nU1::dim2 * N,\nU1::dim3 * N,\nU1::dim4 * N,\nU1::dim5 * N,\nU1::dim6 * N,\nU1::dim7 * N&gt;;\n};\n\ntemplate&lt;class U1&gt;\nstruct udim_inv\n{\nusing unit = UnitType&lt;\n-U1::dim1,\n-U1::dim2,\n-U1::dim3,\n-U1::dim4,\n-U1::dim5,\n-U1::dim6,\n-U1::dim7&gt;;\n};\n}\n\nstruct PrefixBase {\nPrefixBase() = delete;\n};\n\ntemplate&lt;uint32_t N, uint32_t D&gt;\nstruct Prefix : public PrefixBase\n{\nusing type = Prefix&lt;N, D&gt;;\nstatic constexpr uint32_t num = N / std::gcd(N, D);\nstatic constexpr uint32_t den = D / std::gcd(N, D);\n};\n\nnamespace prefix\n{\nusing nano  = Prefix&lt;1, 1000000000&gt;;\nusing micro = Prefix&lt;1,    1000000&gt;;\nusing milli = Prefix&lt;1,       1000&gt;;\nusing centi = Prefix&lt;1,        100&gt;;\nusing deci  = Prefix&lt;1,         10&gt;;\nusing none  = Prefix&lt;1,          1&gt;;\nusing deca  = Prefix&lt;        10, 1&gt;;\nusing hecto = Prefix&lt;       100, 1&gt;;\nusing kilo  = Prefix&lt;      1000, 1&gt;;\nusing mega  = Prefix&lt;   1000000, 1&gt;;\nusing giga  = Prefix&lt;1000000000, 1&gt;;\n\ntemplate&lt;class P1, class P2&gt;\nstruct pfx_mul\n{\nstatic constexpr uint32_t raw_num = P2::num * P1::num;\nstatic constexpr uint32_t raw_den = P2::den * P1::den;\nusing prefix = Prefix&lt;raw_num, raw_den&gt;;\n};\n\ntemplate&lt;class P1, class P2&gt;\nstruct pfx_div\n{\nstatic constexpr uint32_t raw_num = P1::num * P2::den;\nstatic constexpr uint32_t raw_den = P1::den * P2::num;\nusing prefix = Prefix&lt;raw_num, raw_den&gt;;\n};\n\ntemplate&lt;class P&gt;\nstruct pfx_inv\n{\nusing prefix = Prefix&lt;P::den, P::num&gt;;\n};\n\ntemplate&lt;class P1, class P2&gt;\nstruct pfx_min\n{\nstatic constexpr uint32_t raw_num = std::min(P1::num * P2::den, P2::num * P1::den);\nstatic constexpr uint32_t raw_den = P1::den * P2::den;\nusing prefix = Prefix&lt;raw_num, raw_den&gt;;\n};\n}\n\nnamespace tag\n{\nenum angle\n{\nradian = 0,\ndegree\n};\n\nenum angular_vel\n{\nrad_per_sec = 0,\nrps,\nrpm\n};\n\ntemplate &lt;int Tag&gt;\nstruct is_normal_tag : std::false_type{};\n\ntemplate&lt;&gt;\nstruct is_normal_tag&lt;-1&gt; : std::true_type{};\ntemplate&lt;&gt;\nstruct is_normal_tag&lt;0&gt; : std::true_type{};\n}\n\ntemplate&lt;class UnitDimType, int FromTag, int ToTag, bool IsNormalTag = tag::is_normal_tag&lt;FromTag&gt;::value &amp;&amp; tag::is_normal_tag&lt;ToTag&gt;::value&gt;\nconstexpr double conv_factor()\n{\nstatic_assert(IsNormalTag == true, \"conv_factor is not defined\");\nreturn 1;\n}\n\ntemplate&lt;class T, class UnitDimType, class P, int Tag = -1&gt;\nclass Unit\n{\nstatic_assert(std::is_arithmetic_v&lt;T&gt;, \"T is not arithmetic.\");\nstatic_assert(std::is_base_of_v&lt;PrefixBase, P&gt; &amp;&amp; !std::is_same_v&lt;PrefixBase, P&gt;, \"\");\n\npublic:\nusing value_type = T;\nusing unit_dimention_type = UnitDimType;\nusing prefix_type = P;\nusing unit_type = Unit&lt;T, UnitDimType, P&gt;;\nstatic constexpr int tag = Tag;\n\nUnit() = default;\nconstexpr Unit(T val): val_(val){}\nconstexpr T value() const { return val_; }\nconstexpr T raw_value() const { return val_ * P::num / P::den; }\n\nconstexpr unit_type operator +() const\n{\nreturn val_;\n}\n\nconstexpr unit_type operator -() const\n{\nreturn -val_;\n}\n\nconstexpr unit_type operator +(const unit_type&amp; rhl) const\n{\nreturn {val_ + rhl.value()};\n}\n\nconstexpr unit_type operator -(const unit_type&amp; rhl) const\n{\nreturn {val_ - rhl.value()};\n}\n\nconstexpr auto operator *(const unit_type&amp; rhl) const\n{\nusing ret_dim_type = typename unit_dim_assem::udim_mul&lt;unit_dimention_type, unit_dimention_type&gt;::unit;\nusing ret_type = Unit&lt;value_type, ret_dim_type, prefix::none&gt;;\n\nreturn ret_type{raw_value() * rhl.raw_value()};\n}\n\nconstexpr unit_type&amp; operator +=(const unit_type&amp; rhl)\n{\nval_ += rhl.value();\nreturn *this;\n}\n\nconstexpr unit_type&amp; operator -=(const unit_type&amp; rhl)\n{\nval_ -= rhl.value();\nreturn *this;\n}\n\n// \u30bf\u30b0\u306e\u5909\u63db\ntemplate&lt;int R_Tag&gt;\nconstexpr operator Unit&lt;value_type, unit_dimention_type, prefix_type, R_Tag&gt;() const\n{\n\nusing ret_type = Unit&lt;T, UnitDimType, prefix_type, R_Tag&gt;;\nif constexpr (tag == -1 &amp;&amp; R_Tag == 0)\n{\nret_type{value()};\n}\nreturn ret_type{value() * conv_factor&lt;unit_dimention_type, tag, R_Tag&gt;()};\n}\n\n// \u63a5\u982d\u8a9e\u306e\u5909\u63db\ntemplate&lt;class R_P&gt;\nconstexpr operator Unit&lt;value_type, unit_dimention_type, R_P, tag&gt;() const\n{\nusing ret_type = Unit&lt;T, UnitDimType, R_P&gt;;\nusing scale_prefix = typename prefix::pfx_div&lt;R_P, prefix_type&gt;::prefix;\nreturn ret_type{value() * scale_prefix::den / scale_prefix::num};\n}\n\n// \u6570\u5024\u578b\u306b\u5909\u63db\nconstexpr operator value_type() const\n{\nreturn static_cast&lt;value_type&gt;(val_);\n}\n\nconstexpr bool operator ==(const unit_type &amp;r_value)\n{\nreturn val_ == r_value.value();\n}\n\nconstexpr bool operator !=(const unit_type &amp;r_value)\n{\nreturn !(val_ == r_value);\n}\n\nprivate:\nT val_;\n};\n\nnamespace unit_assem\n{\ntemplate&lt;class Unit1, class Unit2&gt;\nstruct unit_mul\n{\nstatic_assert(std::is_same_v&lt;typename Unit1::value_type, typename Unit2::value_type&gt;, \"\");\n// static_assert(Unit1::tag == 0 &amp;&amp; Unit2::tag == 0, \"\");\nusing dim = typename unit_dim_assem::udim_mul&lt;typename Unit1::unit_dimention_type, typename Unit2::unit_dimention_type&gt;::unit;\nusing pfx = typename prefix::pfx_mul&lt;typename Unit1::prefix_type, typename Unit2::prefix_type&gt;::prefix;\nusing unit = Unit&lt;typename Unit1::value_type, dim, pfx&gt;;\n};\n\ntemplate&lt;class Unit1, class Unit2&gt;\nstruct unit_div\n{\nstatic_assert(std::is_same_v&lt;typename Unit1::value_type, typename Unit2::value_type&gt;, \"\");\n// static_assert(Unit1::tag == 0 &amp;&amp; Unit2::tag == 0, \"\");\nusing dim = typename unit_dim_assem::udim_div&lt;typename Unit1::unit_dimention_type, typename Unit2::unit_dimention_type&gt;::unit;\nusing pfx = typename prefix::pfx_div&lt;typename Unit1::prefix_type, typename Unit2::prefix_type&gt;::prefix;\nusing unit = Unit&lt;typename Unit1::value_type, dim, pfx&gt;;\n};\n\ntemplate&lt;class UnitType&gt;\nstruct unit_inv\n{\nusing dim = typename unit_dim_assem::udim_inv&lt;typename UnitType::unit_dimention_type&gt;::unit;\nusing pfx = typename prefix::pfx_inv&lt;typename UnitType::prefix_type&gt;::prefix;\nusing unit = Unit&lt;typename UnitType::value_type, dim, pfx, 0&gt;;\n};\n\ntemplate&lt;class UnitType, class PrefixType&gt;\nstruct unit_pfx_scaled\n{\nusing unit = Unit&lt;typename UnitType::value_type, typename UnitType::unit_dimention_type, typename prefix::pfx_mul&lt;typename UnitType::prefix_type, PrefixType&gt;::prefix,\nUnitType::tag&gt;;\n};\n}\n\n// template &lt;class UnitType, typename T&gt;\n// constexpr auto operator &lt;=&gt;(const UnitType &amp;l_value, const T &amp;r_value)\n// {\n//     return static_cast&lt;typename UnitType::value_type&gt;(l_value) &lt;=&gt; r_value;\n// }\n\n// \u5358\u4f4d*\u6570\u5024\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator *(const Unit&lt;T1, UnitDim, Prefix, Tag&gt; &amp;l_value, const T2 &amp;r_value)\n{\nstatic_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\nusing unit_type = Unit&lt;T1, UnitDim, Prefix, Tag&gt;;\nreturn unit_type(static_cast&lt;T1&gt;(l_value) * r_value);\n}\n\n// \u6570\u5024*\u5358\u4f4d\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator *(const T1 &amp;l_value, const Unit&lt;T2, UnitDim, Prefix, Tag&gt; &amp;r_value)\n{\nstatic_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\nusing unit_type = Unit&lt;T2, UnitDim, Prefix, Tag&gt;;\nreturn unit_type(l_value * static_cast&lt;T1&gt;(r_value));\n}\n\n// \u6570\u5024/\u5358\u4f4d\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator /(const T1 &amp;l_value, const Unit&lt;T2, UnitDim, Prefix, Tag&gt; &amp;r_value)\n{\nstatic_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\nusing unit_type = Unit&lt;T2, UnitDim, Prefix, Tag&gt;;\nreturn typename unit_assem::unit_inv&lt;unit_type&gt;::unit(l_value / static_cast&lt;T2&gt;(r_value));\n}\n\n// \u5358\u4f4d/\u6570\u5024\ntemplate &lt;typename T1, typename T2, class UnitDim, class Prefix, int Tag&gt;\nconstexpr auto operator /(const Unit&lt;T1, UnitDim, Prefix, Tag&gt; &amp;l_value, const T2 &amp;r_value)\n{\nstatic_assert(std::is_arithmetic_v&lt;T1&gt; &amp;&amp; std::is_arithmetic_v&lt;T2&gt;, \"Type is not arithmetic\");\nusing unit_type = Unit&lt;T1, UnitDim, Prefix, Tag&gt;;\nreturn unit_type(static_cast&lt;T1&gt;(l_value) / r_value);\n}\n\n// \u5358\u4f4d*\u5358\u4f4d\ntemplate&lt;typename T1, class UnitDim1, class Prefix1, int Tag1, typename T2, class UnitDim2, class Prefix2, int Tag2&gt;\nconstexpr auto operator *(const Unit&lt;T1, UnitDim1, Prefix1, Tag1&gt;&amp; lhl, const Unit&lt;T2, UnitDim2, Prefix2, Tag2&gt; &amp;rhl)\n{\n// static_assert(std::is_base_of_v&lt;Unit, R_UnitDimType&gt; &amp;&amp; std::is_base_of_v&lt;Unit, L_UnityDimType&gt;, \"test\");\nstatic_assert(tag::is_normal_tag&lt;Tag1&gt;::value &amp;&amp; tag::is_normal_tag&lt;Tag2&gt;::value, \"Type has not normal tag\");\n// static_assert(R_UnitDimType)\n// static_assert(R_P)\nusing ret_dim_type = typename unit_dim_assem::udim_mul&lt;UnitDim1, UnitDim2&gt;::unit;\nusing ret_type = Unit&lt;T1, ret_dim_type, prefix::none&gt;;\nreturn ret_type{lhl.raw_value() * rhl.raw_value()};\n}\n\n// \u5358\u4f4d/\u5358\u4f4d\ntemplate&lt;typename T1, class UnitDim1, class Prefix1, int Tag1, typename T2, class UnitDim2, class Prefix2, int Tag2&gt;\nconstexpr auto operator /(const Unit&lt;T1, UnitDim1, Prefix1, Tag1&gt;&amp; lhl, const Unit&lt;T2, UnitDim2, Prefix2, Tag2&gt; &amp;rhl)\n{\nstatic_assert(tag::is_normal_tag&lt;Tag1&gt;::value &amp;&amp; tag::is_normal_tag&lt;Tag2&gt;::value, \"Type has not normal tag\");\n// static_assert(R_UnitDimType)\n// static_assert(R_P)\nstatic_assert(tag::is_normal_tag&lt;Tag2&gt;::value, \"R_Tag is imcorrect\");\nusing ret_dim_type = typename unit_dim_assem::udim_div&lt;UnitDim1, UnitDim2&gt;::unit;\nusing ret_type = Unit&lt;T1, ret_dim_type, prefix::none&gt;;\nreturn ret_type{lhl.raw_value() / rhl.raw_value()};\n}\n\n// \u5358\u4f4d+\u5358\u4f4d(prefix\u9055\u3044)\n// prefix\u304c\u5c0f\u3055\u3044\u65b9\u3067\u8fd4\u3059\ntemplate&lt;typename T, class UnitDim, class Prefix1, class Prefix2, int Tag&gt;\nconstexpr auto operator +(const Unit&lt;T, UnitDim, Prefix1, Tag&gt;&amp; lhl, const Unit&lt;T, UnitDim, Prefix2, Tag&gt; &amp;rhl)\n{\nusing min_prefix = typename prefix::pfx_min&lt;Prefix1, Prefix2&gt;::prefix;\n\n\nusing lpfx = typename prefix::pfx_div&lt;Prefix1, min_prefix&gt;::prefix;\nT lhl_scaled_val = lhl.value() * lpfx::num / lpfx::den;\n\nusing rpfx = typename prefix::pfx_div&lt;Prefix2, min_prefix&gt;::prefix;\nT rhl_scaled_val = rhl.value() * rpfx::num / rpfx::den;\n\nusing ret_type = Unit&lt;T, UnitDim, min_prefix, Tag&gt;;\nreturn ret_type{lhl_scaled_val + rhl_scaled_val};\n}\n\ntemplate&lt;typename T, class UnitDim, class Prefix1, class Prefix2, int Tag&gt;\nconstexpr auto operator -(const Unit&lt;T, UnitDim, Prefix1, Tag&gt;&amp; lhl, const Unit&lt;T, UnitDim, Prefix2, Tag&gt; &amp;rhl)\n{\nusing min_prefix = typename prefix::pfx_min&lt;Prefix1, Prefix2&gt;::prefix;\n\nusing lpfx = typename prefix::pfx_div&lt;Prefix1, min_prefix&gt;::prefix;\nT lhl_scaled_val = lhl.value() * lpfx::num / lpfx::den;\n\nusing rpfx = typename prefix::pfx_div&lt;Prefix2, min_prefix&gt;::prefix;\nT rhl_scaled_val = rhl.value() * rpfx::num / rpfx::den;\n\nusing ret_type = Unit&lt;T, UnitDim, min_prefix, Tag&gt;;\nreturn ret_type{lhl_scaled_val - rhl_scaled_val};\n}\n\n#define GENERATE_CONV_FACTOR(unit_dim, from_tag, to_tag, factor)\\\ntemplate&lt;&gt;\\\nconstexpr double conv_factor&lt;unit_dim, from_tag, to_tag&gt;()\\\n{\\\n    return (factor);\\\n}\n\n#define GENERATE_UNIT_SUFFIX(unit, suffix)\\\nconstexpr unit operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr unit operator\"\" _## suffix(long double val)\\\n{\\\n    return unit{static_cast&lt;double&gt;(val)};\\\n}\n\n#define GENERATE_UNIT_PFX_SUFFIX(unit_type, prefix, suffix)\\\nconstexpr auto operator\"\" _## suffix(unsigned long long val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\\\nconstexpr auto operator\"\" _## suffix(long double val)\\\n{\\\n    using namespace cpp_robotics::unit;\\\n    return unit_assem::unit_pfx_scaled&lt;unit_type, prefix&gt;::unit{static_cast&lt;double&gt;(val)};\\\n}\n\n}\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/utility_8hpp/","title":"include/cpp_robotics/utility.hpp","text":""},{"location":"doxybook/Files/utility_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"utility/math_utils.hpp\"\n#include \"utility/angle_range.hpp\"\n#include \"utility/space.hpp\"\n#include \"utility/singleton.hpp\"\n#include \"utility/cpp_support.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/vector2_8hpp/","title":"include/cpp_robotics/vector/vector2.hpp","text":"<p>More...</p>"},{"location":"doxybook/Files/vector2_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/vector2_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb"},{"location":"doxybook/Files/vector2_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author: Takumi Odashima (Kotakkucu@gmail.com) </p> <p>Date: 2021-01-25</p> <p>Copyright: Copyright (c) 2021 </p>"},{"location":"doxybook/Files/vector2_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Vector2;\nusing Vector2f = Vector2&lt;float&gt;;\nusing Vector2d = Vector2&lt;double&gt;;\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Vector2\n{\nusing value_type = FLOATING_TYPE;\nvalue_type x, y;\n\nVector2() = default;\n\nconstexpr Vector2(value_type vx, value_type vy) : x(vx), y(vy) {}\n\nconstexpr Vector2(const Vector2&amp;) = default;\n\nconstexpr void set(const value_type vx, const value_type vy)\n{\nx = vx;\ny = vy;\n}\n\nvoid set_polar(const value_type radius, const value_type theta)\n{\nx = radius * std::cos(theta);\ny = radius * std::sin(theta);\n}\n\nconstexpr value_type dot(const Vector2 &amp;v) const\n{\nreturn (x * v.x + y * v.y);\n}\n\nconstexpr value_type cross(const Vector2 &amp;v) const\n{\nreturn (x * v.y - y * v.x);\n}\n\nconstexpr value_type norm_sq() const\n{\nreturn dot(*this);\n}\n\nconstexpr value_type norm() const { return std::sqrt(norm_sq()); }\n\nvoid normalize() { *this /= norm(); }\n\n\n\nconstexpr value_type angle() const { return std::atan2(y, x); }\n\nconstexpr Vector2 get_normalized()\n{\nVector2 v = *this;\nv /= v.norm();\nreturn v;\n}\n\nvoid rotate(const value_type theta)\n{\nVector2 v = *this;\nx = v.x * std::cos(theta) - v.y * std::sin(theta);\ny = v.x * std::sin(theta) + v.y * std::cos(theta);\n}\n\nconstexpr Vector2 get_rotated(const value_type theta) const\n{\nVector2 v = {\nx * std::cos(theta) - y * std::sin(theta),\nx * std::sin(theta) + y * std::cos(theta)\n};\n\nreturn v;\n}\n\nconstexpr bool is_zero() const\n{\nreturn approx_zero(x) &amp;&amp; approx_zero(y);\n}\n\nconstexpr bool has_nan() const\n{\nreturn std::isnan(x) || std::isnan(y);\n}\n\nconstexpr Vector2 yx() const\n{\nreturn {y, x};\n}\n\nconstexpr Vector2 nyx() const\n{\nreturn {-y, x};\n}\n\nconstexpr Vector2 ynx() const\n{\nreturn {y, -x};\n}\n\nconstexpr Vector2 nxy() const\n{\nreturn {-x, y};\n}\n\nconstexpr Vector2 xny() const\n{\nreturn {x, -y};\n}\n\nstatic constexpr value_type dot(const Vector2 &amp;a, const Vector2 &amp;b)\n{\nreturn a.dot(b);\n}\n\nstatic constexpr value_type angle(const Vector2 &amp;a, const Vector2 &amp;b)\n{\nvalue_type value = a.dot(b) / (a.norm() * b.norm());\nreturn std::acos(value);\n}\n\nstatic constexpr value_type distance(const Vector2 &amp;a, const Vector2 &amp;b)\n{\nreturn (b-a).norm();\n}\n\nstatic constexpr Vector2 lerp(const Vector2 &amp;a, const Vector2 &amp;b, const value_type t)\n{\nreturn {cpp_robotics::lerp(a.x, b.x, t),\ncpp_robotics::lerp(a.y, b.y, t)};\n}\n\nconstexpr Vector2 lerp(const Vector2 &amp;b, const value_type t) const\n{\nreturn lerp(*this, b, t);\n}\n\n// constatnt vector\nstatic constexpr Vector2 zero()\n{\nreturn {0, 0};\n}\n\nstatic constexpr Vector2 up()\n{\nreturn {0, 1};\n}\n\nstatic constexpr Vector2 down()\n{\nreturn {0, -1};\n}\n\nstatic constexpr Vector2 right()\n{\nreturn {1, 0};\n}\n\nstatic constexpr Vector2 left()\n{\nreturn {-1, 0};\n}\n\nconstexpr Vector2 operator + () const\n{\nreturn *this;\n}\n\nconstexpr Vector2 operator - () const\n{\nreturn {-x, -y};\n}\n\nconstexpr bool operator == (const Vector2&amp; v) const\n{\nreturn (x == v.x) &amp;&amp; (y == v.y);\n}\n\nconstexpr bool operator != (const Vector2&amp; v) const\n{\nreturn !((x == v.x) &amp;&amp; (y == v.y));\n}\n\nconstexpr Vector2 operator + (const Vector2&amp; v) const\n{\nreturn {x + v.x, y + v.y};\n}\n\nconstexpr Vector2 operator - (const Vector2&amp; v) const\n{\nreturn {x - v.x, y - v.y};\n}\n\nfriend constexpr Vector2 operator / (const Vector2&amp; v, const value_type value)\n{\nreturn {v.x / value, v.y / value};\n}\n\nconstexpr Vector2&amp; operator += (const Vector2&amp; v)\n{\nx += v.x;\ny += v.y;\n\nreturn *this;\n}\n\nconstexpr Vector2&amp; operator -= (const Vector2&amp; v)\n{\nx -= v.x;\ny -= v.y;\n\nreturn *this;\n}\n\nconstexpr Vector2&amp; operator *= (const value_type value)\n{\nx *= value;\ny *= value;\n\nreturn *this;\n}\n\nconstexpr Vector2&amp; operator /= (const value_type value)\n{\nx /= value;\ny /= value;\n\nreturn *this;\n}\n\nvalue_type &amp;operator [] (const size_t index)\n{\nassert(index &lt; 2);\nif(index == 0) return x;\nreturn y;\n}\n\nconstexpr value_type operator [] (const size_t index) const\n{\nassert(index &lt; 2);\nif(index == 0) return x;\nreturn y;\n}\n\ntemplate&lt;typename Scaler&gt;\nfriend constexpr Vector2 operator *(const Vector2&amp; v, const Scaler s) noexcept\n{\nreturn {v.x * static_cast&lt;value_type&gt;(s), v.y * static_cast&lt;value_type&gt;(s)};\n}\n\ntemplate&lt;typename Scaler&gt;\nfriend constexpr Vector2 operator *(const Scaler s, const Vector2&amp; v) noexcept\n{\nreturn (v * static_cast&lt;value_type&gt;(s));\n}\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/vector3_8hpp/","title":"include/cpp_robotics/vector/vector3.hpp","text":""},{"location":"doxybook/Files/vector3_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/vector3_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb"},{"location":"doxybook/Files/vector3_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{   template&lt;typename FLOATING_TYPE&gt;\nstruct Vector3;\nusing Vector3f = Vector3&lt;float&gt;;\nusing Vector3d = Vector3&lt;double&gt;;\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Vector3\n{\nusing value_type = FLOATING_TYPE;\nvalue_type x, y, z;\n\nVector3() = default;\n\nconstexpr Vector3(value_type vx, value_type vy, value_type vz) : x(vx), y(vy), z(vz) {}\n\nVector3(const Vector3 &amp;v) = default;\n\n// function\nvoid set(value_type vx, value_type vy, value_type vz)\n{\nx = vx;\ny = vy;\nz = vz;\n}\n\nconstexpr value_type dot(const Vector3 &amp;v) const\n{\nreturn (x * v.x + y * v.y + z * v.z);\n}\n\nconstexpr Vector3 cross(const Vector3 &amp;v) const\n{\nreturn {(y * v.z) - (z * v.y), z * v.x - x * v.z, x * v.y - y * v.x};\n}\n\nconstexpr value_type norm_sq() const\n{\nreturn dot(*this);\n}\n\nvalue_type norm() { return std::sqrt(norm_sq()); }\n\nvoid normalize() { *this /= norm(); }\n\nVector3 get_normalized()\n{\nVector3 v = *this;\nv /= v.norm();\nreturn v;\n}\n\nconstexpr bool is_zero() const\n{\nreturn approx_zero(x) &amp;&amp; approx_zero(y) &amp;&amp; approx_zero(z);\n}\n\nconstexpr bool has_nan() const\n{\nreturn std::isnan(x) || std::isnan(y) || std::isnan(z);\n}\n\nstatic constexpr value_type dot(const Vector3 &amp;a, const Vector3 &amp;b)\n{\nreturn a.dot(b);\n}\n\nstatic value_type distance(const Vector3 &amp;a, const Vector3 &amp;b)\n{\nreturn (b-a).norm();\n}\n\nstatic constexpr Vector3 lerp(const Vector3 &amp;a, const Vector3 &amp;b, const value_type t)\n{\nreturn {cpp_robotics::lerp(a.x, b.x, t), cpp_robotics::lerp(a.y, b.y, t),\ncpp_robotics::lerp(a.z, b.z, t)};\n}\n\nconstexpr Vector3 lerp(const Vector3 &amp;b, const value_type t) const\n{\nreturn lerp(*this, b, t);\n}\n\n// constant vector\nstatic constexpr Vector3 zero()\n{\nreturn {0, 0, 0};\n}\n\nstatic constexpr Vector3 forward()\n{\nreturn {0, 0, 1};\n}\n\nstatic constexpr Vector3 back()\n{\nreturn {0, 0, -1};\n}\n\nstatic constexpr Vector3 up()\n{\nreturn {0, 1, 0};\n}\n\nstatic constexpr Vector3 down()\n{\nreturn {0, -1, 0};\n}\n\nstatic constexpr Vector3 right()\n{\nreturn {1, 0, 0};\n}\n\nstatic constexpr Vector3 left()\n{\nreturn {-1, 0, 0};\n}\n\nconstexpr Vector3 operator + () const\n{\nreturn *this;\n}\n\nconstexpr Vector3 operator - () const\n{\nreturn {-x, -y, -z};\n}\n\nbool operator == (const Vector3&amp; v) const\n{\nreturn (x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z);\n}\n\nbool operator != (const Vector3&amp; v) const\n{\nreturn !((x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z));\n}\n\nconstexpr Vector3 operator + (const Vector3&amp; v) const\n{\nreturn {x + v.x, y + v.y, z + v.z};\n}\n\nconstexpr Vector3 operator - (const Vector3&amp; v) const\n{\nreturn {x - v.x, y - v.y, z - v.z};\n}\n\nfriend constexpr Vector3 operator / (const Vector3&amp; v, const value_type value)\n{\nreturn {v.x / value, v.y / value, v.z / value};\n}\n\nconstexpr Vector3&amp; operator += (const Vector3&amp; v)\n{\nx += v.x;\ny += v.y;\nz += v.z;\n\nreturn *this;\n}\n\nconstexpr Vector3&amp; operator -= (const Vector3&amp; v)\n{\nx -= v.x;\ny -= v.y;\nz -= v.z;\n\nreturn *this;\n}\n\nconstexpr Vector3&amp; operator *= (const value_type value)\n{\nx *= value;\ny *= value;\nz *= value;\n\nreturn *this;\n}\n\nconstexpr Vector3&amp; operator /= (const value_type value)\n{\nx /= value;\ny /= value;\nz /= value;\n\nreturn *this;\n}\n\nvalue_type &amp;operator [](const int index)\n{\nassert(0 &lt;= index &amp;&amp; index &lt; 3);\nif (index == 0) return x;\nif (index == 1) return y;\nreturn z;\n}\n\nconstexpr value_type operator [](const int index) const\n{\nassert(0 &lt;= index &amp;&amp; index &lt; 3);\nif (index == 0) return x;\nif (index == 1) return y;\nreturn z;\n}\n\ntemplate&lt;typename Scaler&gt;\nfriend constexpr Vector3 operator *(const Vector3&amp; v, const Scaler s) noexcept\n{\nreturn {v.x * static_cast&lt;value_type&gt;(s), v.y * static_cast&lt;value_type&gt;(s),\nv.z * static_cast&lt;value_type&gt;(s)};\n}\n\ntemplate&lt;typename Scaler&gt;\nfriend constexpr Vector3 operator *(const Scaler s, const Vector3&amp; v) noexcept\n{\nreturn (v * static_cast&lt;value_type&gt;(s));\n}\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/vector4_8hpp/","title":"include/cpp_robotics/vector/vector4.hpp","text":""},{"location":"doxybook/Files/vector4_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/vector4_8hpp/#classes","title":"Classes","text":"Name struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb"},{"location":"doxybook/Files/vector4_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;cassert&gt;\n#include \"../utility/math_utils.hpp\"\n\nnamespace cpp_robotics\n{   template&lt;typename FLOATING_TYPE&gt;\nstruct Vector4;\nusing Vector4f = Vector4&lt;float&gt;;\nusing Vector4d = Vector4&lt;double&gt;;\n\ntemplate&lt;typename FLOATING_TYPE&gt;\nstruct Vector4\n{\nusing value_type = FLOATING_TYPE;\nvalue_type x, y, z, w;\n\nVector4() = default;\n\nconstexpr Vector4(value_type vx, value_type vy, value_type vz, value_type vw) : x(vx), y(vy), z(vz), w(vw) {}\n\nVector4(const Vector4 &amp;v) = default;\n\n// function\nvoid set(value_type vx, value_type vy, value_type vz, value_type vw)\n{\nx = vx;\ny = vy;\nz = vz;\nw = vw;\n}\n\nconstexpr value_type dot(const Vector4 &amp;v) const\n{\nreturn (x * v.x + y * v.y + z * v.z + w * v.w);\n}\n\nconstexpr value_type norm_sq() const\n{\nreturn dot(*this);\n}\n\nvalue_type norm() { return std::sqrt(norm_sq()); }\n\nvoid normalize() { *this /= norm(); }\n\nVector4 get_normalized()\n{\nVector4 v = *this;\nv /= v.norm();\nreturn v;\n}\n\nconstexpr bool is_zero() const\n{\nreturn approx_zero(x) &amp;&amp; approx_zero(y) &amp;&amp; approx_zero(z) &amp;&amp; approx_zero(w);\n}\n\nconstexpr bool has_nan() const\n{\nreturn std::isnan(x) || std::isnan(y) || std::isnan(z) || std::isnan(w);\n}\n\nstatic constexpr value_type dot(const Vector4 &amp;a, const Vector4 &amp;b)\n{\nreturn a.dot(b);\n}\n\nstatic value_type distance(const Vector4 &amp;a, const Vector4 &amp;b)\n{\nreturn (b-a).norm();\n}\n\nstatic constexpr Vector4 lerp(const Vector4 &amp;a, const Vector4 &amp;b, const value_type t)\n{\nreturn {cpp_robotics::lerp(a.x, b.x, t), cpp_robotics::lerp(a.y, b.y, t),\ncpp_robotics::lerp(a.z, b.z, t),\ncpp_robotics::lerp(a.w, b.w, t)};\n}\n\nconstexpr Vector4 lerp(const Vector4 &amp;b, const value_type t) const\n{\nreturn lerp(*this, b, t);\n}\n\n// constant vector\n\nstatic constexpr Vector4 zero()\n{\nreturn {0, 0, 0, 0};\n}\n\nconstexpr Vector4 operator + () const\n{\nreturn *this;\n}\n\nconstexpr Vector4 operator - () const\n{\nreturn {-x, -y, -z, -w};\n}\n\nbool operator == (const Vector4&amp; v) const\n{\nreturn (x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z) &amp;&amp; (w == v.w);\n}\n\nbool operator != (const Vector4&amp; v) const\n{\nreturn !((x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z) &amp;&amp; (w == v.w));\n}\n\nconstexpr Vector4 operator + (const Vector4&amp; v) const\n{\nreturn {x + v.x, y + v.y, z + v.z, w + v.w};\n}\n\nconstexpr Vector4 operator - (const Vector4&amp; v) const\n{\nreturn {x - v.x, y - v.y, z - v.z, w - v.w};\n}\n\nconstexpr Vector4 operator * (const value_type value) const\n{\nreturn {x * value, y * value, z * value, w * value};\n}\n\nconstexpr Vector4 operator / (const value_type value) const\n{\nreturn {x / value, y / value, z / value, w / value};\n}\n\nconstexpr Vector4&amp; operator += (const Vector4&amp; v)\n{\nx += v.x;\ny += v.y;\nz += v.z;\nw += v.w;\n\nreturn *this;\n}\n\nconstexpr Vector4&amp; operator -= (const Vector4&amp; v)\n{\nx -= v.x;\ny -= v.y;\nz -= v.z;\nw -= v.w;\n\nreturn *this;\n}\n\nconstexpr Vector4&amp; operator *= (const value_type value)\n{\nx *= value;\ny *= value;\nz *= value;\nw *= value;\n\nreturn *this;\n}\n\nconstexpr Vector4&amp; operator /= (const value_type value)\n{\nx /= value;\ny /= value;\nz /= value;\nw /= value;\n\nreturn *this;\n}\n\nvalue_type &amp;operator [](const int index)\n{\nassert(0 &lt;= index &amp;&amp; index &lt; 4);\nif (index == 0) return x;\nif (index == 1) return y;\nif (index == 2) return z;\nreturn w;\n}\n\nconstexpr value_type operator [](const int index) const\n{\nassert(0 &lt;= index &amp;&amp; index &lt; 4);\nif (index == 0) return x;\nif (index == 1) return y;\nif (index == 2) return z;\nreturn w;\n}\n\ntemplate&lt;typename Scaler&gt;\nfriend constexpr Vector4 operator *(Scaler s, Vector4 v) noexcept\n{\nreturn (v * static_cast&lt;value_type&gt;(s));\n}\n};\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/vector_8hpp/","title":"include/cpp_robotics/vector.hpp","text":""},{"location":"doxybook/Files/vector_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include \"vector/vector2.hpp\"\n#include \"vector/vector3.hpp\"\n#include \"vector/vector4.hpp\"\n#include \"vector/transform.hpp\"\n#include \"vector/quaternion.hpp\"\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/","title":"include/cpp_robotics/filter/velocity_limit_filter.hpp","text":""},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;optional&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n#include \"integrator.hpp\"\n\nnamespace cpp_robotics\n{\n\n// \u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f\nclass VelocityLimitFilter\n{\npublic:\nVelocityLimitFilter(double v_max, double dt):\nVelocityLimitFilter(v_max, dt, 0.5/dt, 0.5/dt){}\n\nVelocityLimitFilter(double v_max, double dt, std::pair&lt;double, double&gt; limit):\nVelocityLimitFilter(v_max, dt, 0.5/dt, 0.5/dt, limit){}\n\nVelocityLimitFilter(double v_max, double dt, double gpd, double fb_gain, std::optional&lt;std::pair&lt;double, double&gt;&gt; limit = std::nullopt): Ts_(dt), v_max_(v_max), gpd_(gpd), cfb_(fb_gain), dp_(gpd, dt), intr_(dt), limit_(limit)\n{\nreset();\n}\n\nvirtual void reset() {\nreset(0);\n}\nvoid reset(double u)\n{\nu1_ = u;\ny1_ = u;\ndp_.reset(u);\nintr_.reset(u);\n}\n\nvirtual double filtering(double u) {\nif(limit_)\n{\nu = std::clamp(u, limit_.value().first, limit_.value().second);\n}\nauto[diff, pass] = dp_.filtering(u);\ndouble v = diff - (cfb_*(y1_-pass));\nv = std::clamp(v, -v_max_, v_max_);\ndouble y = intr_.filtering(v);\nif(limit_)\n{\ny = std::clamp(y, limit_.value().first, limit_.value().second);\n}\n\nu1_ = u;\ny1_ = y;\nreturn y;\n}\n\ndouble Ts() const { return Ts_; }\n\nprivate:\n// diff = s / (gpd*s + 1)\n// pass = 1 / (gpd*s + 1)\nclass DiffPair\n{\npublic:\nDiffPair(double gpd, double Ts): Ts_(Ts), gpd_(gpd) {}\n\nvoid reset()\n{\nreset(0.0);\n}\n\nvoid reset(double u)\n{\nu1_ = u;\ny1diff_ = 0;\ny1pass_ = 0;\n}\n\nstd::tuple&lt;double, double&gt; filtering(double u)\n{\ndouble diff = ( 2.0*gpd_*(u-u1_) + (2.0-Ts_*gpd_)*y1diff_ )/(2.0+Ts_*gpd_);\ndouble pass = ( gpd_*Ts_*(u+u1_) + (2.0-gpd_*Ts_)*y1pass_ )/(2.0+Ts_*gpd_);\n\nu1_ = u;\ny1diff_ = diff;\ny1pass_ = pass;\n\nreturn {diff, pass};\n}\n\nprivate:    double Ts_, gpd_;\ndouble u1_ = 0, y1diff_ = 0, y1pass_ = 0;\n};\n\ndouble Ts_, v_max_, gpd_, cfb_;\nDiffPair dp_;\nIntegrator intr_;\ndouble u1_ = 0, y1_ = 0;\n\nstd::optional&lt;std::pair&lt;double, double&gt;&gt; limit_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/wave__propagation_8hpp/","title":"include/cpp_robotics/path_planning/wave_propagation.hpp","text":""},{"location":"doxybook/Files/wave__propagation_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/wave__propagation_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"grid_path_planning_utils.hpp\"\n\nnamespace cpp_robotics\n{\n\nstd::vector&lt;Eigen::Vector2i&gt; wave_propagation(const Eigen::Vector2i&amp; start, const Eigen::Vector2i&amp; end, const Eigen::MatrixXi&amp; map)\n{\nusing namespace grid_path_planning_utils;\n\nif(not contain_in_map(map, start) || not contain_in_map(map, end))\nreturn {start};\n\nif(start == end)\nreturn {start};\nif(!is_correct_step(start, map) || !is_correct_step(end, map))\nreturn {}; // not exist path\n\nconst static std::array&lt;Eigen::Vector2i,8&gt; nb = {Eigen::Vector2i{1,0}, {0,1}, {-1,0}, {0,-1},\n{1,1}, {-1,1}, {-1,-1}, {1,-1}};\n\nstd::vector&lt;std::vector&lt;int&gt;&gt; costs_mat;\ncosts_mat.resize(map.rows());\nfor(auto &amp;r : costs_mat)\n{\nr.resize(map.cols());\n}\n\nauto costs = [&amp;](int x, int y) -&gt; int&amp;\n{\nreturn costs_mat.at(y).at(x);\n};\n\nstd::list&lt;GridNode&gt; nodes = {}, new_nodes = {};\n\nGridNode enode;\nenode.pos = end;\nenode.cost = 1;\nnodes.push_back(enode);\ncosts(end(0), end(1)) = enode.cost;\n\n// propagate a wave\nauto exist_wp = [&amp;costs](const Eigen::Vector2i&amp; p) { return costs(p(0), p(1)) != 0; };\nwhile(not nodes.empty())\n{\n\nfor(auto &amp;n : nodes)\n{\nfor(size_t i = 0; i &lt; 4; i++)\n{\nauto pos = n.pos + nb[i];\nif(is_correct_step(pos, map)) // \u30b3\u30b9\u30c8\u304c0\u306e\u3068\u304d\n{\nif(!exist_wp(pos))\n{\nint new_cost = n.cost + 1;\ncosts(pos(0), pos(1)) = new_cost;\nGridNode nnode;\nnnode.pos = pos;\nnnode.cost = new_cost;\nnew_nodes.push_back(nnode);\n}\n}\n}\n}\nnodes.clear();\nnodes.insert(nodes.begin(), new_nodes.begin(), new_nodes.end());\nnew_nodes.clear();            }\n\n// create path\nstd::vector&lt;Eigen::Vector2i&gt; path;\nEigen::Vector2i look = start;\npath.push_back(start);\nstd::array&lt;int, 8&gt; nb_costs;\n\n// \u58c1\u306e\u90e8\u5206\u306f\u30b3\u30b9\u30c80&amp;nb_costs\u306e\u66f8\u304d\u63db\u3048\u3092\u884c\u308f\u306a\u3044\u305f\u3081\u58c1\u5074\u306b\u9032\u3080\u306e\u3092\u9632\u3050\nfor(auto &amp;c : nb_costs)\nc = costs(look(0), look(1));\n\nwhile(look != end)\n{\nsize_t correct_step_count = 0;\nfor(size_t i = 0; i &lt; 8; i++)\n{\nauto neighbor = look + nb[i];\nif(is_correct_step(neighbor, map))\n{\nint cost = costs(neighbor(0), neighbor(1));\nif(cost != 0)\n{\ncorrect_step_count++;\nnb_costs[i] = cost;\n}\n}\n}\nif(correct_step_count == 0)\n{\n// no exist path\n// std::cout &lt;&lt; \"------------------- no exist path\" &lt;&lt; std::endl;\nreturn {};\n}\n\nauto min_it = std::min_element(nb_costs.begin(), nb_costs.end());\nlook += nb[std::distance(nb_costs.begin(), min_it)];\n// std::cout &lt;&lt; \"------------------- push\" &lt;&lt; look(0) &lt;&lt; \", \" &lt;&lt; look(1) &lt;&lt; std::endl;\npath.push_back(look);\n}\n\nreturn path;\n}\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Files/xy__2deg__robot_8hpp/","title":"include/cpp_robotics/arm_ik/xy_2deg_robot.hpp","text":""},{"location":"doxybook/Files/xy__2deg__robot_8hpp/#namespaces","title":"Namespaces","text":"Name cpp_robotics"},{"location":"doxybook/Files/xy__2deg__robot_8hpp/#classes","title":"Classes","text":"Name class cpp_robotics::XY2degRobot"},{"location":"doxybook/Files/xy__2deg__robot_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n\n#include &lt;Eigen/Dense&gt;\n#include \"cpp_robotics/optimize/derivative.hpp\"\n#include \"cpp_robotics/optimize/quasi_newton_method.hpp\"\n#include \"cpp_robotics/algorithm/auto_diff.hpp\"\n\nnamespace cpp_robotics\n{\n\nclass XY2degRobot\n{\npublic:\nenum IkSolveMethod : uint8_t\n{\nAnalytical,\nNumerical\n};\nXY2degRobot(double l1, double l2, IkSolveMethod method = IkSolveMethod::Analytical):\nmethod_(method), kinematics_functor_(l1, l2), ad_(kinematics_functor_) {}\n\nEigen::Vector2d solve_fk(double joint_angle1, double joint_angle2)\n{\nreturn solve_fk(Eigen::Vector2d(joint_angle1, joint_angle2));\n}\n\nEigen::Vector2d solve_fk(Eigen::Vector2d joint_angles)\n{\nreturn kinematics_functor_.solve_fk(joint_angles);;\n}\n\nEigen::Vector2d solve_ik(Eigen::Vector2d pos, Eigen::Vector2d joint_angles0 = Eigen::Vector2d::Zero())\n{\nif(method_ == IkSolveMethod::Analytical)\n{\n// \u89e3\u6790\u7684\u306b\u9006\u904b\u52d5\u5b66\u3092\u89e3\u304f\nreturn kinematics_functor_.solve_ik_analytical(pos);\n}\n\n// \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u4f7f\u7528\u3057\u3066\u6570\u5024\u7684\u306b\u89e3\u304f\nkinematics_functor_.target_pos = pos;\nauto [ret, rx, rcnt] = quasi_newton_method(ad_.evalute_func_scalar(), ad_.jacobian_func_row_vector(), joint_angles0);\nreturn rx;\n}\n\nprivate:\nstruct Kinematics\n{\nKinematics(double l1, double l2):\nl1(l1), l2(l2) {}\n\n// \u9806\u904b\u52d5\u5b66\ntemplate&lt;typename T&gt;\nEigen::Matrix&lt;T,2,1&gt; solve_fk(const Eigen::Matrix&lt;T,2,1&gt;&amp; x)\n{\nEigen::Matrix&lt;T,2,1&gt; pos;\npos[0] = l1*cos(x[0]) + l2*cos(x[0]+x[1]);\npos[1] = l1*sin(x[0]) + l2*sin(x[0]+x[1]);\nreturn pos;\n} // \u9006\u904b\u52d5\u5b66\nEigen::Vector2d solve_ik_analytical(Eigen::Vector2d pos)\n{\nEigen::Vector2d angles;\nif (l1 + l2 &lt; pos.norm())\npos *= (l1 + l2) / pos.norm();\n\nconst double xxyyllll = pos.squaredNorm() + l1 * l1 - l2 * l2;\nconst double pos_norm = pos.norm();\nangles[0] = std::acos(xxyyllll / (2 * l1 * pos_norm)) + std::atan(pos[1] / pos[0]);\nangles[1] = std::atan((pos[1] - l1 * std::sin(angles[0])) / (pos[0] - l1 * std::cos(angles[0]))) - angles[0];\n\nreturn angles;\n}\n\n// \u9006\u904b\u52d5\u5b66\u3092\u6570\u5024\u7684\u306b\u6c42\u3081\u308b\u6642\u306e\u8a55\u4fa1\u95a2\u6570\ntemplate&lt;typename T&gt;\nvoid eval_func(const Eigen::Matrix&lt;T,2,1&gt;&amp; x, Eigen::Matrix&lt;T,1,1&gt;&amp; y)\n{\nEigen::Matrix&lt;T,2,1&gt; diff = target_pos - solve_fk(x);\ny[0] = diff.dot(diff);\n}\n\nEigen::Vector2d target_pos;\n\nconst double l1;\nconst double l2;\n};\n\nIkSolveMethod method_;\nKinematics kinematics_functor_;\nAutoDiffAdaptor&lt;Kinematics, Eigen::VectorXd, double, 2, 1&gt; ad_;\n};\n\n}\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/","title":"cpp_robotics","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#namespaces","title":"Namespaces","text":"Name cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 cpp_robotics::unit::prefix cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 cpp_robotics::unit::tag cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit_dimention"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#classes","title":"Classes","text":"Name class cpp_robotics::AutoDiffAdaptor \u81ea\u52d5\u5fae\u5206\u3067\u30e4\u30b3\u30d3\u30a2\u30f3\u3092\u6c42\u3081\u308b\u30af\u30e9\u30b9 class cpp_robotics::KMeansMethod K-means\u6cd5 class cpp_robotics::KDTree k-d\u6728 class cpp_robotics::NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 class cpp_robotics::DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 class cpp_robotics::XY2degRobot class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::LinearMPC \u7dda\u5f62\u6642\u4e0d\u5909\u30e2\u30c7\u30eb\u306e\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1\u30af\u30e9\u30b9 class cpp_robotics::LinearRegulatorMPC class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668 class cpp_robotics::SISOPFC class cpp_robotics::PID PID\u5236\u5fa1\u5668 class cpp_robotics::PID2 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 class cpp_robotics::PSMC class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668 class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::ButterworthFilter \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668 class cpp_robotics::ExtendedKalmanFilter class cpp_robotics::FilterConnector class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Integrator \u7a4d\u5206\u5668 class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9 struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 class cpp_robotics::SQP SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) class cpp_robotics::DubinsPath Dubins\u30d1\u30b9 class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class cpp_robotics::DiscretTransferFunction struct cpp_robotics::LinkConfig class cpp_robotics::LinkRobot struct cpp_robotics::Polynomial \u591a\u9805\u5f0f class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b class cpp_robotics::Timer class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#types","title":"Types","text":"Name enum class CanonicalizeMode enum UnitIndex template &lt;class DerType &gt; using Eigen::AutoDiffScalar&lt; DerType &gt; AutoDiffScalar template &lt;class DerType ,int NX =Eigen::Dynamic&gt; using Eigen::Matrix&lt; AutoDiffScalar&lt; DerType &gt;, NX, 1 &gt; AutoDiffVector using RandomGenerator&lt; std::uniform_int_distribution&lt;&gt; &gt; UniformIntRandomEngine \u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::uniform_real_distribution&lt;&gt; &gt; UniformRealRandomEngine \u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::bernoulli_distribution &gt; BernoulliRandomEngine \u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::binomial_distribution&lt;&gt; &gt; BinomialRandomEngine \u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::geometric_distribution&lt;&gt; &gt; GeometricRandomEngine \u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::negative_binomial_distribution&lt;&gt; &gt; NegativeBinomialRandomEngine \u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::poisson_distribution&lt;&gt; &gt; PoissonRandomEngine \u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::exponential_distribution&lt;&gt; &gt; ExponentialRandomEngine \u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::gamma_distribution&lt;&gt; &gt; GammaRandomEngine \u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::weibull_distribution&lt;&gt; &gt; WeibullRandomEngine \u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::extreme_value_distribution&lt;&gt; &gt; ExtremeValueRandomEngine \u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::normal_distribution&lt;&gt; &gt; NormalRandomEngine \u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::lognormal_distribution&lt;&gt; &gt; LognormalRandomEngine \u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::chi_squared_distribution&lt;&gt; &gt; ChiSquaredRandomEngine \u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::cauchy_distribution&lt;&gt; &gt; CauchyRandomEngine \u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::fisher_f_distribution&lt;&gt; &gt; FisherFRandomEngine \u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::student_t_distribution&lt;&gt; &gt; StudentTRandomEngine \u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::discrete_distribution&lt;&gt; &gt; DiscreteRandomEngine \u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::piecewise_constant_distribution&lt;&gt; &gt; PiecewiseConstantRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator&lt; std::piecewise_linear_distribution&lt;&gt; &gt; PiecewiseLinearRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using unit_assem::unit_div&lt; Torque, Ampere &gt;::unit TorqueConstant using unit_assem::unit_div&lt; Volt, AngularVelocity &gt;::unit BackEmfConstant using unit_assem::unit_mul&lt; Torque, Second &gt;::unit FrictionConstant using Unit&lt; double, unit_dimention::second, prefix::none &gt; Second using Unit&lt; double, unit_dimention::second, prefix::milli &gt; MilliSecond using Unit&lt; double, unit_dimention::second, prefix::micro &gt; MicroSecond using Unit&lt; double, unit_dimention::metere, prefix::none &gt; Meter using Unit&lt; double, unit_dimention::metere, prefix::milli &gt; MilliMeter using Unit&lt; double, unit_dimention::metere, prefix::micro &gt; MicroMeter using Unit&lt; double, unit_dimention::metere, prefix::centi &gt; CentiMeter using Unit&lt; double, unit_dimention::kilogram, prefix::none &gt; KiloGram using Unit&lt; double, unit_dimention::kilogram, prefix::milli &gt; Gram using Unit&lt; double, unit_dimention::watt, prefix::none &gt; Watt using Unit&lt; double, unit_dimention::watt, prefix::kilo &gt; KiloWatt using Unit&lt; double, unit_dimention::newton, prefix::none &gt; Newton using Unit&lt; double, unit_dimention::newton, prefix::kilo &gt; KiloNewton using Unit&lt; double, unit_dimention::pascal, prefix::none &gt; Pascal using Unit&lt; double, unit_dimention::pascal, prefix::kilo &gt; KiloPascal using Unit&lt; double, unit_dimention::hertz, prefix::none &gt; Hertz using Unit&lt; double, unit_dimention::area, prefix::none &gt; Area using Unit&lt; double, unit_dimention::volume, prefix::none &gt; Volume using Unit&lt; double, unit_dimention::velocity, prefix::none &gt; Velocity using Unit&lt; double, unit_dimention::acceleration, prefix::none &gt; Acceleration using Unit&lt; double, unit_dimention::dencity, prefix::none &gt; Dencity using Unit&lt; double, unit_dimention::torque, prefix::none &gt; Torque using Unit&lt; double, unit_dimention::inertia, prefix::none &gt; Inertia using Unit&lt; double, unit_dimention::ampere, prefix::none &gt; Ampere using Unit&lt; double, unit_dimention::ampere, prefix::milli &gt; MilliAmpere using Unit&lt; double, unit_dimention::volt, prefix::none &gt; Volt using Unit&lt; double, unit_dimention::volt, prefix::milli &gt; MilliVolt using Unit&lt; double, unit_dimention::ohm, prefix::none &gt; Ohm using Unit&lt; double, unit_dimention::ohm, prefix::milli &gt; MilliOhm using Unit&lt; double, unit_dimention::henry, prefix::none &gt; Henry using Unit&lt; double, unit_dimention::henry, prefix::milli &gt; MilliHenry using Unit&lt; double, unit_dimention::farad, prefix::none &gt; Farad using Unit&lt; double, unit_dimention::farad, prefix::milli &gt; MilliFarad using Unit&lt; double, unit_dimention::farad, prefix::micro &gt; MicroFarad using Unit&lt; double, unit_dimention::farad, prefix::nano &gt; NanoFarad using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::radian &gt; Radian using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::degree &gt; Degree using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec &gt; AngularVelocity using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps &gt; Rps using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm &gt; Rpm using Unit&lt; double, unit_dimention::angular_acceleration, prefix::none &gt; AngularAcceleration using Quaternion&lt; float &gt; Quaternionf using Quaternion&lt; double &gt; Quaterniond using Transform&lt; float &gt; Transformf using Transform&lt; double &gt; Transformd using Vector2&lt; float &gt; Vector2f using Vector2&lt; double &gt; Vector2d using Vector3&lt; float &gt; Vector3f using Vector3&lt; double &gt; Vector3d using Vector4&lt; float &gt; Vector4f using Vector4&lt; double &gt; Vector4d"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#functions","title":"Functions","text":"Name template &lt;class DerType &gt; auto make_auto_diff_vector(const size_t &amp; dim, const std::optional&lt; DerType &gt; &amp; x =std::nullopt) template &lt;int DIM&gt; std::pair&lt; Eigen::Matrix&lt; double, DIM, DIM &gt;, Eigen::Matrix&lt; double, DIM, 1 &gt; &gt; calcu_transformatoin(std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest, std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; fixed) template &lt;int DIM&gt; std::tuple&lt; std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt; &gt;, Eigen::MatrixXd, size_t &gt; icp(std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest, const std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; &amp; fixed, double eps =1e-4, size_t max_iter =100) double mahalanobis(const Eigen::VectorXd &amp; a, const Eigen::VectorXd &amp; b, const Eigen::MatrixXd cov_inv)\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 Polynomial poly_regression(const std::vector&lt; double &gt; &amp; x, const std::vector&lt; double &gt; &amp; y, const size_t degree)\u56de\u5e30\u66f2\u7dda template &lt;typename Real  =double&gt; Real gererate_random()0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b Eigen::MatrixXd homogeneous(const Eigen::MatrixXd &amp; R, const Eigen::VectorXd &amp; T) Eigen::VectorXd transform_by_homogeneous(const Eigen::MatrixXd &amp; H, const Eigen::VectorXd &amp; x) std::optional&lt; Eigen::MatrixXd &gt; solve_riccati_arimoto_potter(const Eigen::MatrixXd &amp; A, const Eigen::MatrixXd &amp; B, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R)\u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 Eigen::MatrixXd lqr(const Eigen::MatrixXd &amp; A, const Eigen::MatrixXd &amp; B, const Eigen::MatrixXd &amp; Q, const Eigen::MatrixXd &amp; R) Eigen::MatrixXd controllability_matrix(const Eigen::MatrixXd &amp; A, const Eigen::VectorXd &amp; B)\u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 bool is_controllable(const Eigen::MatrixXd &amp; A, const Eigen::VectorXd &amp; B)\u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 bool is_controllable(const StateSpaceSystem &amp; sys) Eigen::MatrixXd observability_matrix(const Eigen::MatrixXd &amp; A, const Eigen::RowVectorXd &amp; C)\u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b bool is_observable(const Eigen::MatrixXd &amp; A, const Eigen::RowVectorXd &amp; C)\u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 bool is_observable(const StateSpaceSystem &amp; sys) std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(const Eigen::MatrixXd &amp; A, const Eigen::MatrixXd &amp; B, const Eigen::MatrixXd &amp; C, CanonicalizeMode mode =CanonicalizeMode::COMPANION)\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(const StateSpaceSystem &amp; sys, CanonicalizeMode mode =CanonicalizeMode::COMPANION)\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Eigen::VectorXd place(const StateSpaceSystem &amp; sys, std::vector&lt; double &gt; poles)\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector2d &amp; v) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector3d &amp; v) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Vector4d &amp; v) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Transformd &amp; v) bool intersect(const Vector2d &amp; a, const Vector2d &amp; b) bool intersect(const Vector2d &amp; a, const Line &amp; b) bool intersect(const Vector2d &amp; a, const Rect &amp; b) bool intersect(const Vector2d &amp; a, const Circle &amp; b) bool intersect(const Line &amp; a, const Vector2d &amp; b) bool intersect(const Line &amp; a, const Circle &amp; b) bool intersect(const Rect &amp; a, const Vector2d &amp; b) bool intersect(const Circle &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Line &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Rect &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Vector2d &amp; a, const Circle &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Line &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Line &amp; a, const Line &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Rect &amp; a, const Vector2d &amp; b) std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(const Circle &amp; a, const Vector2d &amp; b) constexpr DCMotorParam generate_mabuchi_motor_param(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Torque stall_torque, Ampere stall_current, Henry inductance, Inertia rotor_inertia) constexpr DCMotorParam generate_maxon_brush_motor_param(Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm resistance, Henry inductance, TorqueConstant Kt, Inertia rotor_inertia) TransferFunction make_motor_vel_tf(const DCMotorParam &amp; motor, const double dt)DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_motor_pos_tf(const DCMotorParam &amp; motor, const double dt)DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_vel_tf(const DCGearedMotorParam &amp; geared_motor, const double dt)\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_pos_tf(const DCGearedMotorParam &amp; geared_motor, const double dt)\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; barrier_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =10.0, const double tol =1e-3, const size_t max_iter =1000)\u30d0\u30ea\u30a2\u6cd5 void bfgs_step(Eigen::MatrixXd &amp; hess, Eigen::VectorXd s, Eigen::VectorXd y)BFGS\u6cd5 void powells_modified_bfgs_step(Eigen::MatrixXd &amp; hess, Eigen::VectorXd s, Eigen::VectorXd y, Eigen::VectorXd dgg, double gamma =0.2)\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 void powells_modified_bfgs_step(Eigen::MatrixXd &amp; hess, Eigen::VectorXd s, Eigen::VectorXd y, double gamma =0.2) double bracketing_serach(std::function&lt; double(Eigen::VectorXd)&gt; func, std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad, const Eigen::VectorXd &amp; x, const Eigen::VectorXd &amp; d, double gamma =0.3, double tau =0.9, const size_t max_iter =1000)\u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 double bracketing_serach(std::function&lt; double(double)&gt; func, const double init =1.0, const double beta =0.9, const size_t max_iter =1000)\u56f2\u3044\u8fbc\u307f\u6cd5 double derivative(std::function&lt; double(double)&gt; f, double x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R -&gt; R\u306e\u6570\u5024\u5fae\u5206 Eigen::VectorXd derivative(std::function&lt; double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R^n -&gt; R\u306e\u6570\u5024\u5fae\u5206 Eigen::MatrixXd derivative(std::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R^n -&gt; R^m\u306e\u6570\u5024\u5fae\u5206 double second_derivative(std::function&lt; double(double)&gt; f, double x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5))R -&gt; R\u306e2\u56de\u6570\u5024\u5fae\u5206 Eigen::MatrixXd approx_hessian(std::function&lt; double(Eigen::VectorXd)&gt; f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)) double golden_search(std::function&lt; double(double)&gt; f, double low, double high, const double tol =1e-6, const size_t max_iter =100)\u9ec4\u91d1\u63a2\u7d22 std::tuple&lt; Eigen::MatrixXd, Eigen::VectorXd &gt; lsi2qp(const Eigen::MatrixXd &amp; C, const Eigen::VectorXd &amp; d) std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; newton_method(std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, std::function&lt; Eigen::MatrixXd(const Eigen::VectorXd &amp;)&gt; hesse, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000)\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; penalty_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =1.0, const double tol =1e-3, const size_t max_iter =1000)\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; quasi_newton_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000)\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; steepest_descent_method(std::function&lt; double(const Eigen::VectorXd &amp;)&gt; f, std::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000)\u6700\u6025\u964d\u4e0b\u6cd5 std::vector&lt; Eigen::Vector2i &gt; a_star(const Eigen::Vector2i &amp; start, const Eigen::Vector2i &amp; end, const Eigen::MatrixXi &amp; map)A*\u6cd5 double normalized_mjm_position(double t) double normalized_mjm_velocity(double t) double normalized_mjm_acceleration(double t) double normalized_mjm_jerk(double t) std::vector&lt; Eigen::Vector2i &gt; wave_propagation(const Eigen::Vector2i &amp; start, const Eigen::Vector2i &amp; end, const Eigen::MatrixXi &amp; map)Wave propagation\u6cd5 std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; bode(TransferFunction &amp; tf, const std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500), bool gain_db_mode =true, bool phase_deg_mode =true)\u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; nyquist(TransferFunction &amp; tf, const std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500))\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const Polynomial &amp; v) template &lt;class CONTROLLER_T ,class SYSTEM_T &gt; SisoFeedbackSystem make_feedback_system(CONTROLLER_T &amp; controller, SYSTEM_T &amp; system) void set_controller(SisoFeedbackSystem::func_list_t &amp; fn, PID &amp; controller) void set_controller(SisoFeedbackSystem::func_list_t &amp; fn, NctfController &amp; controller) void set_system(SisoFeedbackSystem::func_list_t &amp; fn, TransferFunction &amp; system) StateSpaceSystem tf2ss(const TransferFunction &amp; tf) std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(const std::function&lt; double(double)&gt; &amp; sys, double dt, double time)\u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b template &lt;class SysType ,typename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(SysType &amp; sys, double time) std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(const std::function&lt; double(double)&gt; &amp; sys, double dt, double time, const double gain =1.0)\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b template &lt;class SysType ,typename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(SysType &amp; sys, double time, const double gain =1.0) template &lt;class FilterType ,typename std::enable_if&lt; internal::is_pure_filter_class&lt; FilterType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(FilterType &amp; filter, double time, const double gain =1.0) std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; lsim(const std::function&lt; double(double)&gt; &amp; sys, double dt, const std::vector&lt; double &gt; &amp; input)\u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b template &lt;class SysType ,typename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt; std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; lsim(SysType &amp; sys, std::vector&lt; double &gt; input) template &lt;class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag::value &amp;&amp; tag::is_normal_tag::value&gt; constexpr double conv_factor() template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator+(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator-(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl) template &lt;class ForwardIterator &gt; constexpr ForwardIterator shift_left(ForwardIterator first, ForwardIterator last, typename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n)Substitute shift_left function in C++20 alogorithm. template &lt;class ForwardIterator &gt; constexpr ForwardIterator shift_right(ForwardIterator first, ForwardIterator last, typename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n)Substitute shift_right function in C++20 alogorithm. template &lt;typename... Args&gt; std::string c_format(const std::string &amp; format, Args const &amp;... args)printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b template &lt;typename... Args&gt; void print(const std::string &amp; format, Args const &amp;... args)std::cout\u306bprintf\u306e\u5f62\u5f0f\u3067\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3055\u308c\u305f\u6587\u5b57\u5217\u3092\u51fa\u529b\u3059\u308b template &lt;typename MatrixType &gt; MatrixType pseudo_inverse(const MatrixType &amp; a, double epsilon =std::numeric_limits&lt; double &gt;::epsilon()) template &lt;typename MatrixType &gt; MatrixType sr_inverse(const MatrixType &amp; a, double w0 =1e-2, Eigen::MatrixXd W =Eigen::MatrixXd()) template &lt;int ROWS,int COLS&gt; void cout_exmat(const Eigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat, std::string name =\"\") template &lt;int ROWS,int COLS&gt; void simplify_indexed(Eigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat) template &lt;int ROWS,int COLS&gt; void expand(Eigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat) template &lt;int ROWS,int COLS&gt; void subs(Eigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat, const GiNaC::lst exlst) template &lt;int IN_ROWS,int IN_COLS,int OUT_ROWS,int OUT_COLS&gt; void to_double_matrix(Eigen::Matrix&lt; GiNaC::ex, IN_ROWS, IN_COLS &gt; &amp; in_mat, Eigen::Matrix&lt; double, OUT_ROWS, OUT_COLS &gt; &amp; out_mat) template &lt;typename T &gt; constexpr bool in_range_open(T x, T min, T max) template &lt;typename T &gt; constexpr bool in_range(T x, T min, T max) template &lt;typename T &gt; constexpr int sgn(T x) template &lt;typename T &gt; constexpr double radians(T deg) template &lt;typename T &gt; constexpr double degrees(T rad) double normalize_angle_positive(double angle) double normalize_angle(double angle) double shortest_angular_distance(double from, double to) double nearest_angle(double from, double to) constexpr double square(const double x) constexpr double cubic(const double x) constexpr double lerp(const double a, const double b, const double t) constexpr double approx_eq(const double a, const double b) constexpr double approx_zero(const double a) std::vector&lt; double &gt; arrange(double start, double end, double step =1.0)start\u304b\u3089end\u307e\u3067step\u305a\u3064\u5897\u3048\u308b\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 std::vector&lt; double &gt; linspace(double start, double end, size_t n =100)start\u304b\u3089end\u307e\u3067\u3092n\u5206\u5272\u3057\u305f\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 std::vector&lt; double &gt; logspace(double start, double end, size_t n =100)10^start\u304b\u308910^end\u307e\u3067\u5bfe\u6570\u7684\u306b\u7b49\u9593\u9694\u306an\u500b\u306e\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 std::vector&lt; double &gt; funcspace(std::function&lt; double(size_t, size_t)&gt; f, size_t n =100) std::vector&lt; double &gt; sinspace(double a, double b, size_t n =100)"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#attributes","title":"Attributes","text":"Name constexpr DCMotorParam RZ_735VA_9517 constexpr DCMotorParam RS_775_8513 constexpr DCMotorParam RS_555VC_5524 constexpr DCMotorParam RS_380PH_4045 constexpr DCMotorParam RS_385PH_2465 constexpr DCMotorParam RE_65_250_18 constexpr GearHeadParam IG42C_4 constexpr GearHeadParam IG42C_14 constexpr GearHeadParam IG42C_17 constexpr GearHeadParam IG32_27 constexpr GearHeadParam IG32_71 constexpr GearHeadParam IG32_100 constexpr double PI \u5186\u5468\u7387 constexpr double HALF_PI \u5186\u5468\u7387 / 2 constexpr double TWO_PI \u5186\u5468\u7387 * 2 constexpr double DEG_TO_RAD degree -&gt; radians constexpr double RAD_TO_DEG radian -&gt; degree constexpr double EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr double GRAVITY \u91cd\u529b constexpr double Nm2gfm constexpr double gfm2Nm constexpr double mNm2gfcm constexpr double gfcm2mNm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-canonicalizemode","title":"enum CanonicalizeMode","text":"Enumerator Value Description COMPANION OBSERBAVLE CONTROLLABLE"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-unitindex","title":"enum UnitIndex","text":"Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-autodiffscalar","title":"using AutoDiffScalar","text":"<pre><code>template &lt;class DerType &gt;\nusing cpp_robotics::AutoDiffScalar = typedef Eigen::AutoDiffScalar&lt;DerType&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-autodiffvector","title":"using AutoDiffVector","text":"<pre><code>template &lt;class DerType ,\nint NX =Eigen::Dynamic&gt;\nusing cpp_robotics::AutoDiffVector = typedef Eigen::Matrix&lt;AutoDiffScalar&lt;DerType&gt;, NX, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-uniformintrandomengine","title":"using UniformIntRandomEngine","text":"<pre><code>using cpp_robotics::UniformIntRandomEngine = typedef RandomGenerator&lt;std::uniform_int_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-uniformrealrandomengine","title":"using UniformRealRandomEngine","text":"<pre><code>using cpp_robotics::UniformRealRandomEngine = typedef RandomGenerator&lt;std::uniform_real_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-bernoullirandomengine","title":"using BernoulliRandomEngine","text":"<pre><code>using cpp_robotics::BernoulliRandomEngine = typedef RandomGenerator&lt;std::bernoulli_distribution&gt;;\n</code></pre> <p>\u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-binomialrandomengine","title":"using BinomialRandomEngine","text":"<pre><code>using cpp_robotics::BinomialRandomEngine = typedef RandomGenerator&lt;std::binomial_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-geometricrandomengine","title":"using GeometricRandomEngine","text":"<pre><code>using cpp_robotics::GeometricRandomEngine = typedef RandomGenerator&lt;std::geometric_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-negativebinomialrandomengine","title":"using NegativeBinomialRandomEngine","text":"<pre><code>using cpp_robotics::NegativeBinomialRandomEngine = typedef RandomGenerator&lt;std::negative_binomial_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-poissonrandomengine","title":"using PoissonRandomEngine","text":"<pre><code>using cpp_robotics::PoissonRandomEngine = typedef RandomGenerator&lt;std::poisson_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-exponentialrandomengine","title":"using ExponentialRandomEngine","text":"<pre><code>using cpp_robotics::ExponentialRandomEngine = typedef RandomGenerator&lt;std::exponential_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-gammarandomengine","title":"using GammaRandomEngine","text":"<pre><code>using cpp_robotics::GammaRandomEngine = typedef RandomGenerator&lt;std::gamma_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-weibullrandomengine","title":"using WeibullRandomEngine","text":"<pre><code>using cpp_robotics::WeibullRandomEngine = typedef RandomGenerator&lt;std::weibull_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-extremevaluerandomengine","title":"using ExtremeValueRandomEngine","text":"<pre><code>using cpp_robotics::ExtremeValueRandomEngine = typedef RandomGenerator&lt;std::extreme_value_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-normalrandomengine","title":"using NormalRandomEngine","text":"<pre><code>using cpp_robotics::NormalRandomEngine = typedef RandomGenerator&lt;std::normal_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-lognormalrandomengine","title":"using LognormalRandomEngine","text":"<pre><code>using cpp_robotics::LognormalRandomEngine = typedef RandomGenerator&lt;std::lognormal_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-chisquaredrandomengine","title":"using ChiSquaredRandomEngine","text":"<pre><code>using cpp_robotics::ChiSquaredRandomEngine = typedef RandomGenerator&lt;std::chi_squared_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-cauchyrandomengine","title":"using CauchyRandomEngine","text":"<pre><code>using cpp_robotics::CauchyRandomEngine = typedef RandomGenerator&lt;std::cauchy_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-fisherfrandomengine","title":"using FisherFRandomEngine","text":"<pre><code>using cpp_robotics::FisherFRandomEngine = typedef RandomGenerator&lt;std::fisher_f_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-studenttrandomengine","title":"using StudentTRandomEngine","text":"<pre><code>using cpp_robotics::StudentTRandomEngine = typedef RandomGenerator&lt;std::student_t_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-discreterandomengine","title":"using DiscreteRandomEngine","text":"<pre><code>using cpp_robotics::DiscreteRandomEngine = typedef RandomGenerator&lt;std::discrete_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-piecewiseconstantrandomengine","title":"using PiecewiseConstantRandomEngine","text":"<pre><code>using cpp_robotics::PiecewiseConstantRandomEngine = typedef RandomGenerator&lt;std::piecewise_constant_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-piecewiselinearrandomengine","title":"using PiecewiseLinearRandomEngine","text":"<pre><code>using cpp_robotics::PiecewiseLinearRandomEngine = typedef RandomGenerator&lt;std::piecewise_linear_distribution&lt;&gt; &gt;;\n</code></pre> <p>\u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-torqueconstant","title":"using TorqueConstant","text":"<pre><code>using cpp_robotics::unit::TorqueConstant = typedef unit_assem::unit_div&lt;Torque, Ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-backemfconstant","title":"using BackEmfConstant","text":"<pre><code>using cpp_robotics::unit::BackEmfConstant = typedef unit_assem::unit_div&lt;Volt, AngularVelocity&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-frictionconstant","title":"using FrictionConstant","text":"<pre><code>using cpp_robotics::unit::FrictionConstant = typedef unit_assem::unit_mul&lt;Torque, Second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-second","title":"using Second","text":"<pre><code>using cpp_robotics::unit::Second = typedef Unit&lt;double, unit_dimention::second, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millisecond","title":"using MilliSecond","text":"<pre><code>using cpp_robotics::unit::MilliSecond = typedef Unit&lt;double, unit_dimention::second, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-microsecond","title":"using MicroSecond","text":"<pre><code>using cpp_robotics::unit::MicroSecond = typedef Unit&lt;double, unit_dimention::second, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-meter","title":"using Meter","text":"<pre><code>using cpp_robotics::unit::Meter = typedef Unit&lt;double, unit_dimention::metere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millimeter","title":"using MilliMeter","text":"<pre><code>using cpp_robotics::unit::MilliMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-micrometer","title":"using MicroMeter","text":"<pre><code>using cpp_robotics::unit::MicroMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-centimeter","title":"using CentiMeter","text":"<pre><code>using cpp_robotics::unit::CentiMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::centi&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilogram","title":"using KiloGram","text":"<pre><code>using cpp_robotics::unit::KiloGram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-gram","title":"using Gram","text":"<pre><code>using cpp_robotics::unit::Gram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-watt","title":"using Watt","text":"<pre><code>using cpp_robotics::unit::Watt = typedef Unit&lt;double, unit_dimention::watt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilowatt","title":"using KiloWatt","text":"<pre><code>using cpp_robotics::unit::KiloWatt = typedef Unit&lt;double, unit_dimention::watt, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-newton","title":"using Newton","text":"<pre><code>using cpp_robotics::unit::Newton = typedef Unit&lt;double, unit_dimention::newton, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilonewton","title":"using KiloNewton","text":"<pre><code>using cpp_robotics::unit::KiloNewton = typedef Unit&lt;double, unit_dimention::newton, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-pascal","title":"using Pascal","text":"<pre><code>using cpp_robotics::unit::Pascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilopascal","title":"using KiloPascal","text":"<pre><code>using cpp_robotics::unit::KiloPascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-hertz","title":"using Hertz","text":"<pre><code>using cpp_robotics::unit::Hertz = typedef Unit&lt;double, unit_dimention::hertz, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-area","title":"using Area","text":"<pre><code>using cpp_robotics::unit::Area = typedef Unit&lt;double, unit_dimention::area, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-volume","title":"using Volume","text":"<pre><code>using cpp_robotics::unit::Volume = typedef Unit&lt;double, unit_dimention::volume, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-velocity","title":"using Velocity","text":"<pre><code>using cpp_robotics::unit::Velocity = typedef Unit&lt;double, unit_dimention::velocity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-acceleration","title":"using Acceleration","text":"<pre><code>using cpp_robotics::unit::Acceleration = typedef Unit&lt;double, unit_dimention::acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-dencity","title":"using Dencity","text":"<pre><code>using cpp_robotics::unit::Dencity = typedef Unit&lt;double, unit_dimention::dencity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-torque","title":"using Torque","text":"<pre><code>using cpp_robotics::unit::Torque = typedef Unit&lt;double, unit_dimention::torque, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-inertia","title":"using Inertia","text":"<pre><code>using cpp_robotics::unit::Inertia = typedef Unit&lt;double, unit_dimention::inertia, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-ampere","title":"using Ampere","text":"<pre><code>using cpp_robotics::unit::Ampere = typedef Unit&lt;double, unit_dimention::ampere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-milliampere","title":"using MilliAmpere","text":"<pre><code>using cpp_robotics::unit::MilliAmpere = typedef Unit&lt;double, unit_dimention::ampere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-volt","title":"using Volt","text":"<pre><code>using cpp_robotics::unit::Volt = typedef Unit&lt;double, unit_dimention::volt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millivolt","title":"using MilliVolt","text":"<pre><code>using cpp_robotics::unit::MilliVolt = typedef Unit&lt;double, unit_dimention::volt, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-ohm","title":"using Ohm","text":"<pre><code>using cpp_robotics::unit::Ohm = typedef Unit&lt;double, unit_dimention::ohm, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-milliohm","title":"using MilliOhm","text":"<pre><code>using cpp_robotics::unit::MilliOhm = typedef Unit&lt;double, unit_dimention::ohm, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-henry","title":"using Henry","text":"<pre><code>using cpp_robotics::unit::Henry = typedef Unit&lt;double, unit_dimention::henry, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millihenry","title":"using MilliHenry","text":"<pre><code>using cpp_robotics::unit::MilliHenry = typedef Unit&lt;double, unit_dimention::henry, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-farad","title":"using Farad","text":"<pre><code>using cpp_robotics::unit::Farad = typedef Unit&lt;double, unit_dimention::farad, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millifarad","title":"using MilliFarad","text":"<pre><code>using cpp_robotics::unit::MilliFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-microfarad","title":"using MicroFarad","text":"<pre><code>using cpp_robotics::unit::MicroFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-nanofarad","title":"using NanoFarad","text":"<pre><code>using cpp_robotics::unit::NanoFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::nano&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-radian","title":"using Radian","text":"<pre><code>using cpp_robotics::unit::Radian = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::radian&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-degree","title":"using Degree","text":"<pre><code>using cpp_robotics::unit::Degree = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::degree&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-angularvelocity","title":"using AngularVelocity","text":"<pre><code>using cpp_robotics::unit::AngularVelocity = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-rps","title":"using Rps","text":"<pre><code>using cpp_robotics::unit::Rps = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-rpm","title":"using Rpm","text":"<pre><code>using cpp_robotics::unit::Rpm = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-angularacceleration","title":"using AngularAcceleration","text":"<pre><code>using cpp_robotics::unit::AngularAcceleration = typedef Unit&lt;double, unit_dimention::angular_acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-quaternionf","title":"using Quaternionf","text":"<pre><code>using cpp_robotics::Quaternionf = typedef Quaternion&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-quaterniond","title":"using Quaterniond","text":"<pre><code>using cpp_robotics::Quaterniond = typedef Quaternion&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-transformf","title":"using Transformf","text":"<pre><code>using cpp_robotics::Transformf = typedef Transform&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-transformd","title":"using Transformd","text":"<pre><code>using cpp_robotics::Transformd = typedef Transform&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector2f","title":"using Vector2f","text":"<pre><code>using cpp_robotics::Vector2f = typedef Vector2&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector2d","title":"using Vector2d","text":"<pre><code>using cpp_robotics::Vector2d = typedef Vector2&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector3f","title":"using Vector3f","text":"<pre><code>using cpp_robotics::Vector3f = typedef Vector3&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector3d","title":"using Vector3d","text":"<pre><code>using cpp_robotics::Vector3d = typedef Vector3&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector4f","title":"using Vector4f","text":"<pre><code>using cpp_robotics::Vector4f = typedef Vector4&lt;float&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector4d","title":"using Vector4d","text":"<pre><code>using cpp_robotics::Vector4d = typedef Vector4&lt;double&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_auto_diff_vector","title":"function make_auto_diff_vector","text":"<pre><code>template &lt;class DerType &gt;\nstatic auto make_auto_diff_vector(\nconst size_t &amp; dim,\nconst std::optional&lt; DerType &gt; &amp; x =std::nullopt\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-calcu_transformatoin","title":"function calcu_transformatoin","text":"<pre><code>template &lt;int DIM&gt;\nstatic std::pair&lt; Eigen::Matrix&lt; double, DIM, DIM &gt;, Eigen::Matrix&lt; double, DIM, 1 &gt; &gt; calcu_transformatoin(\nstd::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest,\nstd::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; fixed\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-icp","title":"function icp","text":"<pre><code>template &lt;int DIM&gt;\nstatic std::tuple&lt; std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt; &gt;, Eigen::MatrixXd, size_t &gt; icp(\nstd::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; dest,\nconst std::vector&lt; Eigen::Matrix&lt; double, DIM, 1 &gt;&gt; &amp; fixed,\ndouble eps =1e-4,\nsize_t max_iter =100\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-mahalanobis","title":"function mahalanobis","text":"<pre><code>double mahalanobis(\nconst Eigen::VectorXd &amp; a,\nconst Eigen::VectorXd &amp; b,\nconst Eigen::MatrixXd cov_inv\n)\n</code></pre> <p>\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>a </li> <li>b </li> <li>cov_inv \u5206\u6563\u306e\u9006\u884c\u5217 </li> </ul> <p>Return: double \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-poly_regression","title":"function poly_regression","text":"<pre><code>Polynomial poly_regression(\nconst std::vector&lt; double &gt; &amp; x,\nconst std::vector&lt; double &gt; &amp; y,\nconst size_t degree\n)\n</code></pre> <p>\u56de\u5e30\u66f2\u7dda </p> <p>Parameters: </p> <ul> <li>x </li> <li>y </li> <li>degree \u56de\u5e30\u66f2\u7dda\u306e\u6b21\u5143 </li> </ul> <p>Return: Polynomial</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-gererate_random","title":"function gererate_random","text":"<pre><code>template &lt;typename Real  =double&gt;\nstatic Real gererate_random()\n</code></pre> <p>0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Template Parameters: </p> <ul> <li>Real \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b </li> </ul> <p>Return: Real \u4e71\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-homogeneous","title":"function homogeneous","text":"<pre><code>static Eigen::MatrixXd homogeneous(\nconst Eigen::MatrixXd &amp; R,\nconst Eigen::VectorXd &amp; T\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-transform_by_homogeneous","title":"function transform_by_homogeneous","text":"<pre><code>static Eigen::VectorXd transform_by_homogeneous(\nconst Eigen::MatrixXd &amp; H,\nconst Eigen::VectorXd &amp; x\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-solve_riccati_arimoto_potter","title":"function solve_riccati_arimoto_potter","text":"<pre><code>static std::optional&lt; Eigen::MatrixXd &gt; solve_riccati_arimoto_potter(\nconst Eigen::MatrixXd &amp; A,\nconst Eigen::MatrixXd &amp; B,\nconst Eigen::MatrixXd &amp; Q,\nconst Eigen::MatrixXd &amp; R\n)\n</code></pre> <p>\u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> <li>Q </li> <li>R </li> </ul> <p>Return: std::optional"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lqr","title":"function lqr","text":"<pre><code>static Eigen::MatrixXd lqr(\nconst Eigen::MatrixXd &amp; A,\nconst Eigen::MatrixXd &amp; B,\nconst Eigen::MatrixXd &amp; Q,\nconst Eigen::MatrixXd &amp; R\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-controllability_matrix","title":"function controllability_matrix","text":"<pre><code>static Eigen::MatrixXd controllability_matrix(\nconst Eigen::MatrixXd &amp; A,\nconst Eigen::VectorXd &amp; B\n)\n</code></pre> <p>\u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_controllable","title":"function is_controllable","text":"<pre><code>static bool is_controllable(\nconst Eigen::MatrixXd &amp; A,\nconst Eigen::VectorXd &amp; B\n)\n</code></pre> <p>\u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> </ul> <p>Return: </p> <ul> <li>true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u3042\u308b </li> <li>false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u306a\u3044 </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_controllable_1","title":"function is_controllable","text":"<pre><code>static bool is_controllable(\nconst StateSpaceSystem &amp; sys\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-observability_matrix","title":"function observability_matrix","text":"<pre><code>static Eigen::MatrixXd observability_matrix(\nconst Eigen::MatrixXd &amp; A,\nconst Eigen::RowVectorXd &amp; C\n)\n</code></pre> <p>\u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>A </li> <li>C </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_observable","title":"function is_observable","text":"<pre><code>static bool is_observable(\nconst Eigen::MatrixXd &amp; A,\nconst Eigen::RowVectorXd &amp; C\n)\n</code></pre> <p>\u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 </p> <p>Parameters: </p> <ul> <li>A </li> <li>C </li> </ul> <p>Return: </p> <ul> <li>true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b </li> <li>false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044 </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_observable_1","title":"function is_observable","text":"<pre><code>static bool is_observable(\nconst StateSpaceSystem &amp; sys\n)\n</code></pre> <p>Parameters: </p> <ul> <li>sys \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 </li> </ul> <p>Return: </p> <ul> <li>true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b </li> <li>false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044 </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-canonicalize_system","title":"function canonicalize_system","text":"<pre><code>static std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(\nconst Eigen::MatrixXd &amp; A,\nconst Eigen::MatrixXd &amp; B,\nconst Eigen::MatrixXd &amp; C,\nCanonicalizeMode mode =CanonicalizeMode::COMPANION\n)\n</code></pre> <p>\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db </p> <p>Parameters: </p> <ul> <li>A </li> <li>B </li> <li>C </li> <li>mode </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-canonicalize_system_1","title":"function canonicalize_system","text":"<pre><code>static std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; canonicalize_system(\nconst StateSpaceSystem &amp; sys,\nCanonicalizeMode mode =CanonicalizeMode::COMPANION\n)\n</code></pre> <p>\u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db </p> <p>Parameters: </p> <ul> <li>sys </li> <li>mode </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-place","title":"function place","text":"<pre><code>static Eigen::VectorXd place(\nconst StateSpaceSystem &amp; sys,\nstd::vector&lt; double &gt; poles\n)\n</code></pre> <p>\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e </p> <p>Parameters: </p> <ul> <li>sys </li> <li>poles </li> </ul> <p>Return: Eigen::VectorXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; os,\nconst Vector2d &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; os,\nconst Vector3d &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; os,\nconst Vector4d &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; os,\nconst Transformd &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect","title":"function intersect","text":"<pre><code>bool intersect(\nconst Vector2d &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_1","title":"function intersect","text":"<pre><code>bool intersect(\nconst Vector2d &amp; a,\nconst Line &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_2","title":"function intersect","text":"<pre><code>bool intersect(\nconst Vector2d &amp; a,\nconst Rect &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_3","title":"function intersect","text":"<pre><code>bool intersect(\nconst Vector2d &amp; a,\nconst Circle &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_4","title":"function intersect","text":"<pre><code>bool intersect(\nconst Line &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_5","title":"function intersect","text":"<pre><code>bool intersect(\nconst Line &amp; a,\nconst Circle &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_6","title":"function intersect","text":"<pre><code>bool intersect(\nconst Rect &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_7","title":"function intersect","text":"<pre><code>bool intersect(\nconst Circle &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Vector2d &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_1","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Vector2d &amp; a,\nconst Line &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_2","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Vector2d &amp; a,\nconst Rect &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_3","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Vector2d &amp; a,\nconst Circle &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_4","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Line &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_5","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Line &amp; a,\nconst Line &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_6","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Rect &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_7","title":"function intersect_at","text":"<pre><code>std::optional&lt; std::vector&lt; Vector2d &gt; &gt; intersect_at(\nconst Circle &amp; a,\nconst Vector2d &amp; b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-generate_mabuchi_motor_param","title":"function generate_mabuchi_motor_param","text":"<pre><code>inline constexpr DCMotorParam generate_mabuchi_motor_param(\nVolt nominal_voltage,\nRpm free_speed,\nAmpere free_current,\nTorque stall_torque,\nAmpere stall_current,\nHenry inductance,\nInertia rotor_inertia\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-generate_maxon_brush_motor_param","title":"function generate_maxon_brush_motor_param","text":"<pre><code>inline constexpr DCMotorParam generate_maxon_brush_motor_param(\nVolt nominal_voltage,\nRpm free_speed,\nAmpere free_current,\nOhm resistance,\nHenry inductance,\nTorqueConstant Kt,\nInertia rotor_inertia\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_motor_vel_tf","title":"function make_motor_vel_tf","text":"<pre><code>static TransferFunction make_motor_vel_tf(\nconst DCMotorParam &amp; motor,\nconst double dt\n)\n</code></pre> <p>DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_motor_pos_tf","title":"function make_motor_pos_tf","text":"<pre><code>static TransferFunction make_motor_pos_tf(\nconst DCMotorParam &amp; motor,\nconst double dt\n)\n</code></pre> <p>DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_geared_motor_vel_tf","title":"function make_geared_motor_vel_tf","text":"<pre><code>static TransferFunction make_geared_motor_vel_tf(\nconst DCGearedMotorParam &amp; geared_motor,\nconst double dt\n)\n</code></pre> <p>\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>geared_motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_geared_motor_pos_tf","title":"function make_geared_motor_pos_tf","text":"<pre><code>static TransferFunction make_geared_motor_pos_tf(\nconst DCGearedMotorParam &amp; geared_motor,\nconst double dt\n)\n</code></pre> <p>\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b </p> <p>Parameters: </p> <ul> <li>geared_motor </li> <li>dt </li> </ul> <p>Return: TransferFunction</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-barrier_method","title":"function barrier_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; barrier_method(\nstd::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\nConstraintArray constraint,\nEigen::VectorXd x_init,\nconst double r_init =10.0,\nconst double tol =1e-3,\nconst size_t max_iter =1000\n)\n</code></pre> <p>\u30d0\u30ea\u30a2\u6cd5 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bfgs_step","title":"function bfgs_step","text":"<pre><code>static void bfgs_step(\nEigen::MatrixXd &amp; hess,\nEigen::VectorXd s,\nEigen::VectorXd y\n)\n</code></pre> <p>BFGS\u6cd5 </p> <p>Parameters: </p> <ul> <li>hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 </li> <li>s x_k+1 - x_k </li> <li>y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k) </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-powells_modified_bfgs_step","title":"function powells_modified_bfgs_step","text":"<pre><code>static void powells_modified_bfgs_step(\nEigen::MatrixXd &amp; hess,\nEigen::VectorXd s,\nEigen::VectorXd y,\nEigen::VectorXd dgg,\ndouble gamma =0.2\n)\n</code></pre> <p>\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 </p> <p>Parameters: </p> <ul> <li>hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 </li> <li>s x_k+1 - x_k </li> <li>y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k) </li> <li>w \\grad g(x+1)g(x+1) - \\grad g(x)g(x) </li> <li>gamma </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-powells_modified_bfgs_step_1","title":"function powells_modified_bfgs_step","text":"<pre><code>static void powells_modified_bfgs_step(\nEigen::MatrixXd &amp; hess,\nEigen::VectorXd s,\nEigen::VectorXd y,\ndouble gamma =0.2\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bracketing_serach","title":"function bracketing_serach","text":"<pre><code>static double bracketing_serach(\nstd::function&lt; double(Eigen::VectorXd)&gt; func,\nstd::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; grad,\nconst Eigen::VectorXd &amp; x,\nconst Eigen::VectorXd &amp; d,\ndouble gamma =0.3,\ndouble tau =0.9,\nconst size_t max_iter =1000\n)\n</code></pre> <p>\u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 </p> <p>Parameters: </p> <ul> <li>func </li> <li>grad </li> <li>x </li> <li>d </li> <li>gamma </li> <li>tau </li> <li>max_iter </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bracketing_serach_1","title":"function bracketing_serach","text":"<pre><code>static double bracketing_serach(\nstd::function&lt; double(double)&gt; func,\nconst double init =1.0,\nconst double beta =0.9,\nconst size_t max_iter =1000\n)\n</code></pre> <p>\u56f2\u3044\u8fbc\u307f\u6cd5 </p> <p>Parameters: </p> <ul> <li>func </li> <li>init </li> <li>beta </li> <li>max_iter </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative","title":"function derivative","text":"<pre><code>static double derivative(\nstd::function&lt; double(double)&gt; f,\ndouble x,\ndouble eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R -&gt; R\u306e\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative_1","title":"function derivative","text":"<pre><code>static Eigen::VectorXd derivative(\nstd::function&lt; double(Eigen::VectorXd)&gt; f,\nEigen::VectorXd x,\ndouble eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R^n -&gt; R\u306e\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::VectorXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative_2","title":"function derivative","text":"<pre><code>static Eigen::MatrixXd derivative(\nstd::function&lt; Eigen::VectorXd(Eigen::VectorXd)&gt; f,\nEigen::VectorXd x,\ndouble eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R^n -&gt; R^m\u306e\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-second_derivative","title":"function second_derivative","text":"<pre><code>static double second_derivative(\nstd::function&lt; double(double)&gt; f,\ndouble x,\ndouble eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>R -&gt; R\u306e2\u56de\u6570\u5024\u5fae\u5206 </p> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_hessian","title":"function approx_hessian","text":"<pre><code>static Eigen::MatrixXd approx_hessian(\nstd::function&lt; double(Eigen::VectorXd)&gt; f,\nEigen::VectorXd x,\ndouble eps =std::pow(std::numeric_limits&lt; double &gt;::epsilon(), 0.5)\n)\n</code></pre> <p>Parameters: </p> <ul> <li>f </li> <li>x </li> <li>eps </li> </ul> <p>Return: Eigen::MatrixXd </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-golden_search","title":"function golden_search","text":"<pre><code>static double golden_search(\nstd::function&lt; double(double)&gt; f,\ndouble low,\ndouble high,\nconst double tol =1e-6,\nconst size_t max_iter =100\n)\n</code></pre> <p>\u9ec4\u91d1\u63a2\u7d22 </p> <p>Parameters: </p> <ul> <li>f </li> <li>low </li> <li>high </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsi2qp","title":"function lsi2qp","text":"<pre><code>std::tuple&lt; Eigen::MatrixXd, Eigen::VectorXd &gt; lsi2qp(\nconst Eigen::MatrixXd &amp; C,\nconst Eigen::VectorXd &amp; d\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-newton_method","title":"function newton_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; newton_method(\nstd::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad,\nstd::function&lt; Eigen::MatrixXd(const Eigen::VectorXd &amp;)&gt; hesse,\nEigen::VectorXd x_init,\nconst double tol =1e-6,\nconst size_t max_iter =1000\n)\n</code></pre> <p>\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 </p> <p>Parameters: </p> <ul> <li>grad </li> <li>hesse </li> <li>x_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-penalty_method","title":"function penalty_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; penalty_method(\nstd::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\nConstraintArray constraint,\nEigen::VectorXd x_init,\nconst double r_init =1.0,\nconst double tol =1e-3,\nconst size_t max_iter =1000\n)\n</code></pre> <p>\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 </p> <p>Parameters: </p> <ul> <li>f </li> <li>constraint </li> <li>x_init </li> <li>r_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-quasi_newton_method","title":"function quasi_newton_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; quasi_newton_method(\nstd::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\nstd::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad,\nEigen::VectorXd x_init,\nconst double tol =1e-6,\nconst size_t max_iter =1000\n)\n</code></pre> <p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 </p> <p>Parameters: </p> <ul> <li>f </li> <li>grad </li> <li>x_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-steepest_descent_method","title":"function steepest_descent_method","text":"<pre><code>static std::tuple&lt; bool, Eigen::VectorXd, size_t &gt; steepest_descent_method(\nstd::function&lt; double(const Eigen::VectorXd &amp;)&gt; f,\nstd::function&lt; Eigen::VectorXd(const Eigen::VectorXd &amp;)&gt; grad,\nEigen::VectorXd x_init,\nconst double tol =1e-6,\nconst size_t max_iter =1000\n)\n</code></pre> <p>\u6700\u6025\u964d\u4e0b\u6cd5 </p> <p>Parameters: </p> <ul> <li>f </li> <li>grad </li> <li>x_init </li> <li>tol </li> <li>max_iter </li> </ul> <p>Return: std::tuple"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-a_star","title":"function a_star","text":"<pre><code>static std::vector&lt; Eigen::Vector2i &gt; a_star(\nconst Eigen::Vector2i &amp; start,\nconst Eigen::Vector2i &amp; end,\nconst Eigen::MatrixXi &amp; map\n)\n</code></pre> <p>A*\u6cd5 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>map </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_position","title":"function normalized_mjm_position","text":"<pre><code>static double normalized_mjm_position(\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_velocity","title":"function normalized_mjm_velocity","text":"<pre><code>static double normalized_mjm_velocity(\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_acceleration","title":"function normalized_mjm_acceleration","text":"<pre><code>static double normalized_mjm_acceleration(\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalized_mjm_jerk","title":"function normalized_mjm_jerk","text":"<pre><code>static double normalized_mjm_jerk(\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-wave_propagation","title":"function wave_propagation","text":"<pre><code>std::vector&lt; Eigen::Vector2i &gt; wave_propagation(\nconst Eigen::Vector2i &amp; start,\nconst Eigen::Vector2i &amp; end,\nconst Eigen::MatrixXi &amp; map\n)\n</code></pre> <p>Wave propagation\u6cd5 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>map </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bode","title":"function bode","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; bode(\nTransferFunction &amp; tf,\nconst std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500),\nbool gain_db_mode =true,\nbool phase_deg_mode =true\n)\n</code></pre> <p>\u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>tf </li> <li>omegas </li> <li>gain_db_mode </li> <li>phase_deg_mode </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-nyquist","title":"function nyquist","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; nyquist(\nTransferFunction &amp; tf,\nconst std::vector&lt; double &gt; &amp; omegas =logspace(-2, 2, 500)\n)\n</code></pre> <p>\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b </p> <p>Parameters: </p> <ul> <li>tf </li> <li>omegas </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; os,\nconst Polynomial &amp; v\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_feedback_system","title":"function make_feedback_system","text":"<pre><code>template &lt;class CONTROLLER_T ,\nclass SYSTEM_T &gt;\nstatic SisoFeedbackSystem make_feedback_system(\nCONTROLLER_T &amp; controller,\nSYSTEM_T &amp; system\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_controller","title":"function set_controller","text":"<pre><code>static void set_controller(\nSisoFeedbackSystem::func_list_t &amp; fn,\nPID &amp; controller\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_controller_1","title":"function set_controller","text":"<pre><code>static void set_controller(\nSisoFeedbackSystem::func_list_t &amp; fn,\nNctfController &amp; controller\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_system","title":"function set_system","text":"<pre><code>static void set_system(\nSisoFeedbackSystem::func_list_t &amp; fn,\nTransferFunction &amp; system\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-tf2ss","title":"function tf2ss","text":"<pre><code>StateSpaceSystem tf2ss(\nconst TransferFunction &amp; tf\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-impulse","title":"function impulse","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(\nconst std::function&lt; double(double)&gt; &amp; sys,\ndouble dt,\ndouble time\n)\n</code></pre> <p>\u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b </p> <p>Parameters: </p> <ul> <li>sys </li> <li>dt </li> <li>time </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-impulse_1","title":"function impulse","text":"<pre><code>template &lt;class SysType ,\ntypename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; impulse(\nSysType &amp; sys,\ndouble time\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step","title":"function step","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(\nconst std::function&lt; double(double)&gt; &amp; sys,\ndouble dt,\ndouble time,\nconst double gain =1.0\n)\n</code></pre> <p>\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b </p> <p>Parameters: </p> <ul> <li>sys </li> <li>dt </li> <li>time </li> <li>gain </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step_1","title":"function step","text":"<pre><code>template &lt;class SysType ,\ntypename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(\nSysType &amp; sys,\ndouble time,\nconst double gain =1.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step_2","title":"function step","text":"<pre><code>template &lt;class FilterType ,\ntypename std::enable_if&lt; internal::is_pure_filter_class&lt; FilterType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; step(\nFilterType &amp; filter,\ndouble time,\nconst double gain =1.0\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim","title":"function lsim","text":"<pre><code>static std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; lsim(\nconst std::function&lt; double(double)&gt; &amp; sys,\ndouble dt,\nconst std::vector&lt; double &gt; &amp; input\n)\n</code></pre> <p>\u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b </p> <p>Parameters: </p> <ul> <li>sys </li> <li>dt </li> <li>input </li> </ul> <p>Return: std::tuple, std::vector\\&gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim_1","title":"function lsim","text":"<pre><code>template &lt;class SysType ,\ntypename std::enable_if&lt; internal::is_system_class&lt; SysType &gt;::value &gt;::type *  =nullptr&gt;\nstatic std::tuple&lt; std::vector&lt; double &gt;, std::vector&lt; double &gt; &gt; lsim(\nSysType &amp; sys,\nstd::vector&lt; double &gt; input\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-conv_factor","title":"function conv_factor","text":"<pre><code>template &lt;class UnitDimType ,\nint FromTag,\nint ToTag,\nbool IsNormalTag =tag::is_normal_tag&lt;FromTag&gt;::value &amp;&amp; tag::is_normal_tag&lt;ToTag&gt;::value&gt;\nconstexpr double conv_factor()\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_5","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\nconst Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\nconst T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_6","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\nconst T1 &amp; l_value,\nconst Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_7","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\nconst T1 &amp; l_value,\nconst Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_8","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\nconst Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\nconst T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_9","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator*(\nconst Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\nconst Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_10","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator/(\nconst Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\nconst Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_11","title":"function operator+","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator+(\nconst Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\nconst Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator-","title":"function operator-","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator-(\nconst Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\nconst Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shift_left","title":"function shift_left","text":"<pre><code>template &lt;class ForwardIterator &gt;\nconstexpr ForwardIterator shift_left(\nForwardIterator first,\nForwardIterator last,\ntypename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n\n)\n</code></pre> <p>Substitute shift_left function in C++20 alogorithm. </p> <p>Parameters: </p> <ul> <li>first </li> <li>last </li> <li>n </li> </ul> <p>Template Parameters: </p> <ul> <li>ForwardIterator </li> </ul> <p>Return: constexpr ForwardIterator </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shift_right","title":"function shift_right","text":"<pre><code>template &lt;class ForwardIterator &gt;\nconstexpr ForwardIterator shift_right(\nForwardIterator first,\nForwardIterator last,\ntypename std::iterator_traits&lt; ForwardIterator &gt;::difference_type n\n)\n</code></pre> <p>Substitute shift_right function in C++20 alogorithm. </p> <p>Parameters: </p> <ul> <li>first </li> <li>last </li> <li>n </li> </ul> <p>Template Parameters: </p> <ul> <li>ForwardIterator </li> </ul> <p>Return: constexpr ForwardIterator </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-c_format","title":"function c_format","text":"<pre><code>template &lt;typename... Args&gt;\nstd::string c_format(\nconst std::string &amp; format,\nArgs const &amp;... args\n)\n</code></pre> <p>printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b </p> <p>Parameters: </p> <ul> <li>format </li> <li>args </li> </ul> <p>Template Parameters: </p> <ul> <li>Args </li> </ul> <p>Return: std::string </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-print","title":"function print","text":"<pre><code>template &lt;typename... Args&gt;\nvoid print(\nconst std::string &amp; format,\nArgs const &amp;... args\n)\n</code></pre> <p>std::cout\u306bprintf\u306e\u5f62\u5f0f\u3067\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u3055\u308c\u305f\u6587\u5b57\u5217\u3092\u51fa\u529b\u3059\u308b </p> <p>Parameters: </p> <ul> <li>format </li> <li>args </li> </ul> <p>Template Parameters: </p> <ul> <li>Args </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-pseudo_inverse","title":"function pseudo_inverse","text":"<pre><code>template &lt;typename MatrixType &gt;\nMatrixType pseudo_inverse(\nconst MatrixType &amp; a,\ndouble epsilon =std::numeric_limits&lt; double &gt;::epsilon()\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sr_inverse","title":"function sr_inverse","text":"<pre><code>template &lt;typename MatrixType &gt;\nMatrixType sr_inverse(\nconst MatrixType &amp; a,\ndouble w0 =1e-2,\nEigen::MatrixXd W =Eigen::MatrixXd()\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-cout_exmat","title":"function cout_exmat","text":"<pre><code>template &lt;int ROWS,\nint COLS&gt;\nvoid cout_exmat(\nconst Eigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat,\nstd::string name =\"\"\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-simplify_indexed","title":"function simplify_indexed","text":"<pre><code>template &lt;int ROWS,\nint COLS&gt;\nvoid simplify_indexed(\nEigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-expand","title":"function expand","text":"<pre><code>template &lt;int ROWS,\nint COLS&gt;\nvoid expand(\nEigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-subs","title":"function subs","text":"<pre><code>template &lt;int ROWS,\nint COLS&gt;\nvoid subs(\nEigen::Matrix&lt; GiNaC::ex, ROWS, COLS &gt; &amp; mat,\nconst GiNaC::lst exlst\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-to_double_matrix","title":"function to_double_matrix","text":"<pre><code>template &lt;int IN_ROWS,\nint IN_COLS,\nint OUT_ROWS,\nint OUT_COLS&gt;\nvoid to_double_matrix(\nEigen::Matrix&lt; GiNaC::ex, IN_ROWS, IN_COLS &gt; &amp; in_mat,\nEigen::Matrix&lt; double, OUT_ROWS, OUT_COLS &gt; &amp; out_mat\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-in_range_open","title":"function in_range_open","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr bool in_range_open(\nT x,\nT min,\nT max\n)\n</code></pre> <p>Parameters: </p> <ul> <li>x </li> <li>min </li> <li>max </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-in_range","title":"function in_range","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr bool in_range(\nT x,\nT min,\nT max\n)\n</code></pre> <p>Parameters: </p> <ul> <li>x </li> <li>min </li> <li>max </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: </p> <ul> <li>true </li> <li>false </li> </ul>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sgn","title":"function sgn","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr int sgn(\nT x\n)\n</code></pre> <p>Parameters: </p> <ul> <li>x </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: constexpr int </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-radians","title":"function radians","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr double radians(\nT deg\n)\n</code></pre> <p>Parameters: </p> <ul> <li>deg </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: constexpr double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-degrees","title":"function degrees","text":"<pre><code>template &lt;typename T &gt;\nstatic constexpr double degrees(\nT rad\n)\n</code></pre> <p>Parameters: </p> <ul> <li>rad </li> </ul> <p>Template Parameters: </p> <ul> <li>T </li> </ul> <p>Return: constexpr double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalize_angle_positive","title":"function normalize_angle_positive","text":"<pre><code>static inline double normalize_angle_positive(\ndouble angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalize_angle","title":"function normalize_angle","text":"<pre><code>static inline double normalize_angle(\ndouble angle\n)\n</code></pre> <p>Parameters: </p> <ul> <li>angle </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shortest_angular_distance","title":"function shortest_angular_distance","text":"<pre><code>static inline double shortest_angular_distance(\ndouble from,\ndouble to\n)\n</code></pre> <p>Parameters: </p> <ul> <li>from </li> <li>to </li> </ul> <p>Return: double </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-nearest_angle","title":"function nearest_angle","text":"<pre><code>static inline double nearest_angle(\ndouble from,\ndouble to\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-square","title":"function square","text":"<pre><code>inline constexpr double square(\nconst double x\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-cubic","title":"function cubic","text":"<pre><code>inline constexpr double cubic(\nconst double x\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lerp","title":"function lerp","text":"<pre><code>inline constexpr double lerp(\nconst double a,\nconst double b,\nconst double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_eq","title":"function approx_eq","text":"<pre><code>inline constexpr double approx_eq(\nconst double a,\nconst double b\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_zero","title":"function approx_zero","text":"<pre><code>inline constexpr double approx_zero(\nconst double a\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-arrange","title":"function arrange","text":"<pre><code>static std::vector&lt; double &gt; arrange(\ndouble start,\ndouble end,\ndouble step =1.0\n)\n</code></pre> <p>start\u304b\u3089end\u307e\u3067step\u305a\u3064\u5897\u3048\u308b\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>step </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-linspace","title":"function linspace","text":"<pre><code>static std::vector&lt; double &gt; linspace(\ndouble start,\ndouble end,\nsize_t n =100\n)\n</code></pre> <p>start\u304b\u3089end\u307e\u3067\u3092n\u5206\u5272\u3057\u305f\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>n </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-logspace","title":"function logspace","text":"<pre><code>static std::vector&lt; double &gt; logspace(\ndouble start,\ndouble end,\nsize_t n =100\n)\n</code></pre> <p>10^start\u304b\u308910^end\u307e\u3067\u5bfe\u6570\u7684\u306b\u7b49\u9593\u9694\u306an\u500b\u306e\u70b9\u306e\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 </p> <p>Parameters: </p> <ul> <li>start </li> <li>end </li> <li>n </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-funcspace","title":"function funcspace","text":"<pre><code>static std::vector&lt; double &gt; funcspace(\nstd::function&lt; double(size_t, size_t)&gt; f,\nsize_t n =100\n)\n</code></pre> <p>Parameters: </p> <ul> <li>f </li> <li>n </li> </ul> <p>Return: std::vector"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sinspace","title":"function sinspace","text":"<pre><code>static std::vector&lt; double &gt; sinspace(\ndouble a,\ndouble b,\nsize_t n =100\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rz_735va_9517","title":"variable RZ_735VA_9517","text":"<pre><code>constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param(\n18_V,\n20400_rpm,\n2.8_A,\n1265_mmNm,\n156_A,\n7.088e-5_H,\n2.46e-5 );\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_775_8513","title":"variable RS_775_8513","text":"<pre><code>constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param(\n18_V,\n18400_rpm,\n2.7_A,\n1216_mmNm, 130_A,\n5.872e-5_H,\n2.46e-5 );\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_555vc_5524","title":"variable RS_555VC_5524","text":"<pre><code>constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param(\n12_V,\n9100_rpm,\n0.8_A,\n450_mmNm, 36_A,\n1.820e-4_H,\n2.46e-5 );\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_380ph_4045","title":"variable RS_380PH_4045","text":"<pre><code>constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param(\n6_V,\n12500_rpm,\n0.56_A,\n77.5_mmNm, 18_A,\n1.521e-4_H,\n2.46e-5 );\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_385ph_2465","title":"variable RS_385PH_2465","text":"<pre><code>constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param(\n18_V,\n17500_rpm,\n0.23_A,\n76.9_mmNm, 7.91_A,\n1.521e-4_H,\n2.46e-5 );\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-re_65_250_18","title":"variable RE_65_250_18","text":"<pre><code>constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param(\n18_V,\n3520_rpm,\n755_mA,\n0.0609_ohm,\n0.0226_mH,\n46e-3_Nm_per_A,\n1.38\n);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_4","title":"variable IG42C_4","text":"<pre><code>constexpr GearHeadParam IG42C_4 = { 1/4.0f, 0.8f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_14","title":"variable IG42C_14","text":"<pre><code>constexpr GearHeadParam IG42C_14 = { 1/14.0f, 0.7f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_17","title":"variable IG42C_17","text":"<pre><code>constexpr GearHeadParam IG42C_17 = { 1/17.0f, 0.7f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_27","title":"variable IG32_27","text":"<pre><code>constexpr GearHeadParam IG32_27 = { 1/27.0f, 0.7f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_71","title":"variable IG32_71","text":"<pre><code>constexpr GearHeadParam IG32_71 = { 1/71.0f, 0.6f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_100","title":"variable IG32_100","text":"<pre><code>constexpr GearHeadParam IG32_100 = { 1/100.0f, 0.6f };\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-pi","title":"variable PI","text":"<pre><code>constexpr double PI = 3.1415926535897932384626433832795;\n</code></pre> <p>\u5186\u5468\u7387 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-half_pi","title":"variable HALF_PI","text":"<pre><code>constexpr double HALF_PI = PI / 2.0;\n</code></pre> <p>\u5186\u5468\u7387 / 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-two_pi","title":"variable TWO_PI","text":"<pre><code>constexpr double TWO_PI = PI * 2.0;\n</code></pre> <p>\u5186\u5468\u7387 * 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-deg_to_rad","title":"variable DEG_TO_RAD","text":"<pre><code>constexpr double DEG_TO_RAD = PI / 180.0;\n</code></pre> <p>degree -&gt; radians </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rad_to_deg","title":"variable RAD_TO_DEG","text":"<pre><code>constexpr double RAD_TO_DEG = 180.0 / PI;\n</code></pre> <p>radian -&gt; degree </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-euler","title":"variable EULER","text":"<pre><code>constexpr double EULER = 2.718281828459045235360287471352;\n</code></pre> <p>\u30cd\u30a4\u30d4\u30a2\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gravity","title":"variable GRAVITY","text":"<pre><code>constexpr double GRAVITY = 9.807;\n</code></pre> <p>\u91cd\u529b </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-nm2gfm","title":"variable Nm2gfm","text":"<pre><code>constexpr double Nm2gfm = (1/GRAVITY);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gfm2nm","title":"variable gfm2Nm","text":"<pre><code>constexpr double gfm2Nm = GRAVITY;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-mnm2gfcm","title":"variable mNm2gfcm","text":"<pre><code>constexpr double mNm2gfcm = (Nm2gfm * 100);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gfcm2mnm","title":"variable gfcm2mNm","text":"<pre><code>constexpr double gfcm2mNm = (gfm2Nm / 100);\n</code></pre> <p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/","title":"cpp_robotics::constants","text":"<p>\u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#attributes","title":"Attributes","text":"Name constexpr double PI \u5186\u5468\u7387 constexpr double HALF_PI \u5186\u5468\u7387 / 2 constexpr double TWO_PI \u5186\u5468\u7387 * 2 constexpr double DEG_TO_RAD degree -&gt; radians constexpr double RAD_TO_DEG radian -&gt; degree constexpr double EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr double GRAVITY \u91cd\u529b constexpr double Nm2gfm constexpr double gfm2Nm constexpr double mNm2gfcm constexpr double gfcm2mNm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-pi","title":"variable PI","text":"<pre><code>constexpr double PI = 3.1415926535897932384626433832795;\n</code></pre> <p>\u5186\u5468\u7387 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-half_pi","title":"variable HALF_PI","text":"<pre><code>constexpr double HALF_PI = PI / 2.0;\n</code></pre> <p>\u5186\u5468\u7387 / 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-two_pi","title":"variable TWO_PI","text":"<pre><code>constexpr double TWO_PI = PI * 2.0;\n</code></pre> <p>\u5186\u5468\u7387 * 2 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-deg_to_rad","title":"variable DEG_TO_RAD","text":"<pre><code>constexpr double DEG_TO_RAD = PI / 180.0;\n</code></pre> <p>degree -&gt; radians </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-rad_to_deg","title":"variable RAD_TO_DEG","text":"<pre><code>constexpr double RAD_TO_DEG = 180.0 / PI;\n</code></pre> <p>radian -&gt; degree </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-euler","title":"variable EULER","text":"<pre><code>constexpr double EULER = 2.718281828459045235360287471352;\n</code></pre> <p>\u30cd\u30a4\u30d4\u30a2\u6570 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gravity","title":"variable GRAVITY","text":"<pre><code>constexpr double GRAVITY = 9.807;\n</code></pre> <p>\u91cd\u529b </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-nm2gfm","title":"variable Nm2gfm","text":"<pre><code>constexpr double Nm2gfm = (1/GRAVITY);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gfm2nm","title":"variable gfm2Nm","text":"<pre><code>constexpr double gfm2Nm = GRAVITY;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-mnm2gfcm","title":"variable mNm2gfcm","text":"<pre><code>constexpr double mNm2gfcm = (Nm2gfm * 100);\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gfcm2mnm","title":"variable gfcm2mNm","text":"<pre><code>constexpr double gfcm2mNm = (gfm2Nm / 100);\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/","title":"cpp_robotics::grid_path_planning_utils","text":"<p>\u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#classes","title":"Classes","text":"Name struct cpp_robotics::grid_path_planning_utils::GridNode"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#functions","title":"Functions","text":"Name bool contain_in_map(const Eigen::MatrixXi &amp; map, const Eigen::Vector2i &amp; p) int dist(const Eigen::Vector2i &amp; pos, const Eigen::Vector2i &amp; end) template &lt;typename T &gt; bool in_range_open(T x, T min, T max) bool is_valid(const Eigen::Vector2i &amp; pos, size_t row, size_t col) bool is_wall(const Eigen::Vector2i &amp; pos, size_t row, size_t col) bool is_correct_step(const Eigen::Vector2i &amp; pos, const Eigen::MatrixXi &amp; map) bool exist(std::list&lt; GridNode &gt; &amp; open, std::list&lt; GridNode &gt; &amp; closed, const Eigen::Vector2i &amp; p, int cost)"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-contain_in_map","title":"function contain_in_map","text":"<pre><code>static bool contain_in_map(\nconst Eigen::MatrixXi &amp; map,\nconst Eigen::Vector2i &amp; p\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-dist","title":"function dist","text":"<pre><code>static int dist(\nconst Eigen::Vector2i &amp; pos,\nconst Eigen::Vector2i &amp; end\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-in_range_open","title":"function in_range_open","text":"<pre><code>template &lt;typename T &gt;\nbool in_range_open(\nT x,\nT min,\nT max\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_valid","title":"function is_valid","text":"<pre><code>bool is_valid(\nconst Eigen::Vector2i &amp; pos,\nsize_t row,\nsize_t col\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_wall","title":"function is_wall","text":"<pre><code>bool is_wall(\nconst Eigen::Vector2i &amp; pos,\nsize_t row,\nsize_t col\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_correct_step","title":"function is_correct_step","text":"<pre><code>bool is_correct_step(\nconst Eigen::Vector2i &amp; pos,\nconst Eigen::MatrixXi &amp; map\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-exist","title":"function exist","text":"<pre><code>bool exist(\nstd::list&lt; GridNode &gt; &amp; open,\nstd::list&lt; GridNode &gt; &amp; closed,\nconst Eigen::Vector2i &amp; p,\nint cost\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/","title":"cpp_robotics::spline","text":"<p>\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#classes","title":"Classes","text":"Name struct cpp_robotics::spline::spline_c"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#functions","title":"Functions","text":"Name spline_c bezier_spline(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2, const Vector2d &amp; p3) spline_c hermite_spline(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; v0, const Vector2d &amp; v1) spline_c catumull_spline(const Vector2d &amp; p0, const Vector2d &amp; p1, const Vector2d &amp; p2, const Vector2d &amp; p3) spline_c cubic_function_to_bezier(const Vector2d &amp; a, const Vector2d &amp; b, const Vector2d &amp; c, const Vector2d &amp; d) Vector4d bezier_weight(const double t) Vector4d bezier_weight(const Vector4d t) Vector2d evaluate(const spline_c &amp; spline, const Vector4d &amp; w) Vector2d position(const spline_c &amp; spline, double t) Vector2d velocity(const spline_c &amp; spline, double t) Vector2d acceleration(const spline_c &amp; spline, double t) void split(const Vector4d &amp; spline, Vector4d &amp; spline0, Vector4d &amp; spline1, double t) void split(const Vector4d &amp; spline, Vector4d &amp; spline0, Vector4d &amp; spline1) void split(const spline_c &amp; spline, spline_c &amp; spline0, spline_c &amp; spline1) void split(const spline_c &amp; spline, spline_c &amp; spline0, spline_c &amp; spline1, double t) double length_estimate(const spline_c &amp; s, double * error) double length(const spline_c &amp; s, double maxError) double length(const spline_c &amp; s, double t0, double t1, double maxError) double curvature(const spline_c &amp; spline, double t)"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_spline","title":"function bezier_spline","text":"<pre><code>spline_c bezier_spline(\nconst Vector2d &amp; p0,\nconst Vector2d &amp; p1,\nconst Vector2d &amp; p2,\nconst Vector2d &amp; p3\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-hermite_spline","title":"function hermite_spline","text":"<pre><code>spline_c hermite_spline(\nconst Vector2d &amp; p0,\nconst Vector2d &amp; p1,\nconst Vector2d &amp; v0,\nconst Vector2d &amp; v1\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-catumull_spline","title":"function catumull_spline","text":"<pre><code>spline_c catumull_spline(\nconst Vector2d &amp; p0,\nconst Vector2d &amp; p1,\nconst Vector2d &amp; p2,\nconst Vector2d &amp; p3\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-cubic_function_to_bezier","title":"function cubic_function_to_bezier","text":"<pre><code>spline_c cubic_function_to_bezier(\nconst Vector2d &amp; a,\nconst Vector2d &amp; b,\nconst Vector2d &amp; c,\nconst Vector2d &amp; d\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_weight","title":"function bezier_weight","text":"<pre><code>Vector4d bezier_weight(\nconst double t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_weight_1","title":"function bezier_weight","text":"<pre><code>Vector4d bezier_weight(\nconst Vector4d t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-evaluate","title":"function evaluate","text":"<pre><code>inline Vector2d evaluate(\nconst spline_c &amp; spline,\nconst Vector4d &amp; w\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-position","title":"function position","text":"<pre><code>Vector2d position(\nconst spline_c &amp; spline,\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-velocity","title":"function velocity","text":"<pre><code>Vector2d velocity(\nconst spline_c &amp; spline,\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-acceleration","title":"function acceleration","text":"<pre><code>Vector2d acceleration(\nconst spline_c &amp; spline,\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split","title":"function split","text":"<pre><code>inline void split(\nconst Vector4d &amp; spline,\nVector4d &amp; spline0,\nVector4d &amp; spline1,\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_1","title":"function split","text":"<pre><code>inline void split(\nconst Vector4d &amp; spline,\nVector4d &amp; spline0,\nVector4d &amp; spline1\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_2","title":"function split","text":"<pre><code>void split(\nconst spline_c &amp; spline,\nspline_c &amp; spline0,\nspline_c &amp; spline1\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_3","title":"function split","text":"<pre><code>void split(\nconst spline_c &amp; spline,\nspline_c &amp; spline0,\nspline_c &amp; spline1,\ndouble t\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length_estimate","title":"function length_estimate","text":"<pre><code>double length_estimate(\nconst spline_c &amp; s,\ndouble * error\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length","title":"function length","text":"<pre><code>double length(\nconst spline_c &amp; s,\ndouble maxError\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length_1","title":"function length","text":"<pre><code>double length(\nconst spline_c &amp; s,\ndouble t0,\ndouble t1,\ndouble maxError\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-curvature","title":"function curvature","text":"<pre><code>double curvature(\nconst spline_c &amp; spline,\ndouble t\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/","title":"cpp_robotics::unit","text":"<p>\u5358\u4f4d\u7cfb </p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#namespaces","title":"Namespaces","text":"Name cpp_robotics::unit::prefix cpp_robotics::unit::tag cpp_robotics::unit_dimention"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#classes","title":"Classes","text":"Name struct cpp_robotics::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#types","title":"Types","text":"Name enum UnitIndex using unit_assem::unit_div&lt; Torque, Ampere &gt;::unit TorqueConstant using unit_assem::unit_div&lt; Volt, AngularVelocity &gt;::unit BackEmfConstant using unit_assem::unit_mul&lt; Torque, Second &gt;::unit FrictionConstant using Unit&lt; double, unit_dimention::second, prefix::none &gt; Second using Unit&lt; double, unit_dimention::second, prefix::milli &gt; MilliSecond using Unit&lt; double, unit_dimention::second, prefix::micro &gt; MicroSecond using Unit&lt; double, unit_dimention::metere, prefix::none &gt; Meter using Unit&lt; double, unit_dimention::metere, prefix::milli &gt; MilliMeter using Unit&lt; double, unit_dimention::metere, prefix::micro &gt; MicroMeter using Unit&lt; double, unit_dimention::metere, prefix::centi &gt; CentiMeter using Unit&lt; double, unit_dimention::kilogram, prefix::none &gt; KiloGram using Unit&lt; double, unit_dimention::kilogram, prefix::milli &gt; Gram using Unit&lt; double, unit_dimention::watt, prefix::none &gt; Watt using Unit&lt; double, unit_dimention::watt, prefix::kilo &gt; KiloWatt using Unit&lt; double, unit_dimention::newton, prefix::none &gt; Newton using Unit&lt; double, unit_dimention::newton, prefix::kilo &gt; KiloNewton using Unit&lt; double, unit_dimention::pascal, prefix::none &gt; Pascal using Unit&lt; double, unit_dimention::pascal, prefix::kilo &gt; KiloPascal using Unit&lt; double, unit_dimention::hertz, prefix::none &gt; Hertz using Unit&lt; double, unit_dimention::area, prefix::none &gt; Area using Unit&lt; double, unit_dimention::volume, prefix::none &gt; Volume using Unit&lt; double, unit_dimention::velocity, prefix::none &gt; Velocity using Unit&lt; double, unit_dimention::acceleration, prefix::none &gt; Acceleration using Unit&lt; double, unit_dimention::dencity, prefix::none &gt; Dencity using Unit&lt; double, unit_dimention::torque, prefix::none &gt; Torque using Unit&lt; double, unit_dimention::inertia, prefix::none &gt; Inertia using Unit&lt; double, unit_dimention::ampere, prefix::none &gt; Ampere using Unit&lt; double, unit_dimention::ampere, prefix::milli &gt; MilliAmpere using Unit&lt; double, unit_dimention::volt, prefix::none &gt; Volt using Unit&lt; double, unit_dimention::volt, prefix::milli &gt; MilliVolt using Unit&lt; double, unit_dimention::ohm, prefix::none &gt; Ohm using Unit&lt; double, unit_dimention::ohm, prefix::milli &gt; MilliOhm using Unit&lt; double, unit_dimention::henry, prefix::none &gt; Henry using Unit&lt; double, unit_dimention::henry, prefix::milli &gt; MilliHenry using Unit&lt; double, unit_dimention::farad, prefix::none &gt; Farad using Unit&lt; double, unit_dimention::farad, prefix::milli &gt; MilliFarad using Unit&lt; double, unit_dimention::farad, prefix::micro &gt; MicroFarad using Unit&lt; double, unit_dimention::farad, prefix::nano &gt; NanoFarad using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::radian &gt; Radian using Unit&lt; double, unit_dimention::angle, prefix::none, tag::angle::degree &gt; Degree using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec &gt; AngularVelocity using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps &gt; Rps using Unit&lt; double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm &gt; Rpm using Unit&lt; double, unit_dimention::angular_acceleration, prefix::none &gt; AngularAcceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#functions","title":"Functions","text":"Name template &lt;class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag::value &amp;&amp; tag::is_normal_tag::value&gt; constexpr double conv_factor() template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator*(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const T1 &amp; l_value, const Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value) template &lt;typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value, const T2 &amp; r_value) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator*(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2&gt; constexpr auto operator/(const Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl, const Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator+(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl) template &lt;typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag&gt; constexpr auto operator-(const Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl, const Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl)"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#enum-unitindex","title":"enum UnitIndex","text":"Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-torqueconstant","title":"using TorqueConstant","text":"<pre><code>using cpp_robotics::unit::TorqueConstant = typedef unit_assem::unit_div&lt;Torque, Ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-backemfconstant","title":"using BackEmfConstant","text":"<pre><code>using cpp_robotics::unit::BackEmfConstant = typedef unit_assem::unit_div&lt;Volt, AngularVelocity&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-frictionconstant","title":"using FrictionConstant","text":"<pre><code>using cpp_robotics::unit::FrictionConstant = typedef unit_assem::unit_mul&lt;Torque, Second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-second","title":"using Second","text":"<pre><code>using cpp_robotics::unit::Second = typedef Unit&lt;double, unit_dimention::second, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millisecond","title":"using MilliSecond","text":"<pre><code>using cpp_robotics::unit::MilliSecond = typedef Unit&lt;double, unit_dimention::second, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-microsecond","title":"using MicroSecond","text":"<pre><code>using cpp_robotics::unit::MicroSecond = typedef Unit&lt;double, unit_dimention::second, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-meter","title":"using Meter","text":"<pre><code>using cpp_robotics::unit::Meter = typedef Unit&lt;double, unit_dimention::metere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millimeter","title":"using MilliMeter","text":"<pre><code>using cpp_robotics::unit::MilliMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-micrometer","title":"using MicroMeter","text":"<pre><code>using cpp_robotics::unit::MicroMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-centimeter","title":"using CentiMeter","text":"<pre><code>using cpp_robotics::unit::CentiMeter = typedef Unit&lt;double, unit_dimention::metere, prefix::centi&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilogram","title":"using KiloGram","text":"<pre><code>using cpp_robotics::unit::KiloGram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-gram","title":"using Gram","text":"<pre><code>using cpp_robotics::unit::Gram = typedef Unit&lt;double, unit_dimention::kilogram, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-watt","title":"using Watt","text":"<pre><code>using cpp_robotics::unit::Watt = typedef Unit&lt;double, unit_dimention::watt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilowatt","title":"using KiloWatt","text":"<pre><code>using cpp_robotics::unit::KiloWatt = typedef Unit&lt;double, unit_dimention::watt, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-newton","title":"using Newton","text":"<pre><code>using cpp_robotics::unit::Newton = typedef Unit&lt;double, unit_dimention::newton, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilonewton","title":"using KiloNewton","text":"<pre><code>using cpp_robotics::unit::KiloNewton = typedef Unit&lt;double, unit_dimention::newton, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-pascal","title":"using Pascal","text":"<pre><code>using cpp_robotics::unit::Pascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilopascal","title":"using KiloPascal","text":"<pre><code>using cpp_robotics::unit::KiloPascal = typedef Unit&lt;double, unit_dimention::pascal, prefix::kilo&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-hertz","title":"using Hertz","text":"<pre><code>using cpp_robotics::unit::Hertz = typedef Unit&lt;double, unit_dimention::hertz, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-area","title":"using Area","text":"<pre><code>using cpp_robotics::unit::Area = typedef Unit&lt;double, unit_dimention::area, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-volume","title":"using Volume","text":"<pre><code>using cpp_robotics::unit::Volume = typedef Unit&lt;double, unit_dimention::volume, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-velocity","title":"using Velocity","text":"<pre><code>using cpp_robotics::unit::Velocity = typedef Unit&lt;double, unit_dimention::velocity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-acceleration","title":"using Acceleration","text":"<pre><code>using cpp_robotics::unit::Acceleration = typedef Unit&lt;double, unit_dimention::acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-dencity","title":"using Dencity","text":"<pre><code>using cpp_robotics::unit::Dencity = typedef Unit&lt;double, unit_dimention::dencity, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-torque","title":"using Torque","text":"<pre><code>using cpp_robotics::unit::Torque = typedef Unit&lt;double, unit_dimention::torque, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-inertia","title":"using Inertia","text":"<pre><code>using cpp_robotics::unit::Inertia = typedef Unit&lt;double, unit_dimention::inertia, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-ampere","title":"using Ampere","text":"<pre><code>using cpp_robotics::unit::Ampere = typedef Unit&lt;double, unit_dimention::ampere, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-milliampere","title":"using MilliAmpere","text":"<pre><code>using cpp_robotics::unit::MilliAmpere = typedef Unit&lt;double, unit_dimention::ampere, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-volt","title":"using Volt","text":"<pre><code>using cpp_robotics::unit::Volt = typedef Unit&lt;double, unit_dimention::volt, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millivolt","title":"using MilliVolt","text":"<pre><code>using cpp_robotics::unit::MilliVolt = typedef Unit&lt;double, unit_dimention::volt, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-ohm","title":"using Ohm","text":"<pre><code>using cpp_robotics::unit::Ohm = typedef Unit&lt;double, unit_dimention::ohm, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-milliohm","title":"using MilliOhm","text":"<pre><code>using cpp_robotics::unit::MilliOhm = typedef Unit&lt;double, unit_dimention::ohm, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-henry","title":"using Henry","text":"<pre><code>using cpp_robotics::unit::Henry = typedef Unit&lt;double, unit_dimention::henry, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millihenry","title":"using MilliHenry","text":"<pre><code>using cpp_robotics::unit::MilliHenry = typedef Unit&lt;double, unit_dimention::henry, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-farad","title":"using Farad","text":"<pre><code>using cpp_robotics::unit::Farad = typedef Unit&lt;double, unit_dimention::farad, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millifarad","title":"using MilliFarad","text":"<pre><code>using cpp_robotics::unit::MilliFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::milli&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-microfarad","title":"using MicroFarad","text":"<pre><code>using cpp_robotics::unit::MicroFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::micro&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-nanofarad","title":"using NanoFarad","text":"<pre><code>using cpp_robotics::unit::NanoFarad = typedef Unit&lt;double, unit_dimention::farad, prefix::nano&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-radian","title":"using Radian","text":"<pre><code>using cpp_robotics::unit::Radian = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::radian&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-degree","title":"using Degree","text":"<pre><code>using cpp_robotics::unit::Degree = typedef Unit&lt;double, unit_dimention::angle, prefix::none, tag::angle::degree&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-angularvelocity","title":"using AngularVelocity","text":"<pre><code>using cpp_robotics::unit::AngularVelocity = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-rps","title":"using Rps","text":"<pre><code>using cpp_robotics::unit::Rps = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-rpm","title":"using Rpm","text":"<pre><code>using cpp_robotics::unit::Rpm = typedef Unit&lt;double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-angularacceleration","title":"using AngularAcceleration","text":"<pre><code>using cpp_robotics::unit::AngularAcceleration = typedef Unit&lt;double, unit_dimention::angular_acceleration, prefix::none&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-conv_factor","title":"function conv_factor","text":"<pre><code>template &lt;class UnitDimType ,\nint FromTag,\nint ToTag,\nbool IsNormalTag =tag::is_normal_tag&lt;FromTag&gt;::value &amp;&amp; tag::is_normal_tag&lt;ToTag&gt;::value&gt;\nconstexpr double conv_factor()\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\nconst Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\nconst T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_1","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator*(\nconst T1 &amp; l_value,\nconst Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_2","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\nconst T1 &amp; l_value,\nconst Unit&lt; T2, UnitDim, Prefix, Tag &gt; &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_3","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\ntypename T2 ,\nclass UnitDim ,\nclass Prefix ,\nint Tag&gt;\nconstexpr auto operator/(\nconst Unit&lt; T1, UnitDim, Prefix, Tag &gt; &amp; l_value,\nconst T2 &amp; r_value\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_4","title":"function operator*","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator*(\nconst Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\nconst Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_5","title":"function operator/","text":"<pre><code>template &lt;typename T1 ,\nclass UnitDim1 ,\nclass Prefix1 ,\nint Tag1,\ntypename T2 ,\nclass UnitDim2 ,\nclass Prefix2 ,\nint Tag2&gt;\nconstexpr auto operator/(\nconst Unit&lt; T1, UnitDim1, Prefix1, Tag1 &gt; &amp; lhl,\nconst Unit&lt; T2, UnitDim2, Prefix2, Tag2 &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_6","title":"function operator+","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator+(\nconst Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\nconst Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator-","title":"function operator-","text":"<pre><code>template &lt;typename T ,\nclass UnitDim ,\nclass Prefix1 ,\nclass Prefix2 ,\nint Tag&gt;\nconstexpr auto operator-(\nconst Unit&lt; T, UnitDim, Prefix1, Tag &gt; &amp; lhl,\nconst Unit&lt; T, UnitDim, Prefix2, Tag &gt; &amp; rhl\n)\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/","title":"cpp_robotics::unit::prefix","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#classes","title":"Classes","text":"Name struct cpp_robotics::unit::prefix::pfx_mul struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#types","title":"Types","text":"Name using Prefix&lt; 1, 1000000000 &gt; nano using Prefix&lt; 1, 1000000 &gt; micro using Prefix&lt; 1, 1000 &gt; milli using Prefix&lt; 1, 100 &gt; centi using Prefix&lt; 1, 10 &gt; deci using Prefix&lt; 1, 1 &gt; none using Prefix&lt; 10, 1 &gt; deca using Prefix&lt; 100, 1 &gt; hecto using Prefix&lt; 1000, 1 &gt; kilo using Prefix&lt; 1000000, 1 &gt; mega using Prefix&lt; 1000000000, 1 &gt; giga"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-nano","title":"using nano","text":"<pre><code>using cpp_robotics::unit::prefix::nano = typedef Prefix&lt;1, 1000000000&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-micro","title":"using micro","text":"<pre><code>using cpp_robotics::unit::prefix::micro = typedef Prefix&lt;1, 1000000&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-milli","title":"using milli","text":"<pre><code>using cpp_robotics::unit::prefix::milli = typedef Prefix&lt;1, 1000&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-centi","title":"using centi","text":"<pre><code>using cpp_robotics::unit::prefix::centi = typedef Prefix&lt;1, 100&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-deci","title":"using deci","text":"<pre><code>using cpp_robotics::unit::prefix::deci = typedef Prefix&lt;1, 10&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-none","title":"using none","text":"<pre><code>using cpp_robotics::unit::prefix::none = typedef Prefix&lt;1, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-deca","title":"using deca","text":"<pre><code>using cpp_robotics::unit::prefix::deca = typedef Prefix&lt; 10, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-hecto","title":"using hecto","text":"<pre><code>using cpp_robotics::unit::prefix::hecto = typedef Prefix&lt; 100, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-kilo","title":"using kilo","text":"<pre><code>using cpp_robotics::unit::prefix::kilo = typedef Prefix&lt; 1000, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-mega","title":"using mega","text":"<pre><code>using cpp_robotics::unit::prefix::mega = typedef Prefix&lt; 1000000, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-giga","title":"using giga","text":"<pre><code>using cpp_robotics::unit::prefix::giga = typedef Prefix&lt;1000000000, 1&gt;;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/","title":"cpp_robotics::unit::tag","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#classes","title":"Classes","text":"Name struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag&lt;-1 &gt; struct cpp_robotics::unit::tag::is_normal_tag&lt; 0 &gt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#types","title":"Types","text":"Name enum angle enum angular_vel"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#enum-angle","title":"enum angle","text":"Enumerator Value Description radian 0 degree"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#enum-angular_vel","title":"enum angular_vel","text":"Enumerator Value Description rad_per_sec 0 rps rpm <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/","title":"cpp_robotics::unit_dimention","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#types","title":"Types","text":"Name using UnitType&lt; 0, 0, 0, 0, 0, 0, 0 &gt; no_dimention using UnitType&lt; 1, 0, 0, 0, 0, 0, 0 &gt; metere using UnitType&lt; 0, 1, 0, 0, 0, 0, 0 &gt; kilogram using UnitType&lt; 0, 0, 1, 0, 0, 0, 0 &gt; second using UnitType&lt; 0, 0, 0, 1, 0, 0, 0 &gt; ampere using UnitType&lt; 0, 0, 0, 0, 1, 0, 0 &gt; kelvin using UnitType&lt; 0, 0, 0, 0, 0, 1, 0 &gt; mole using UnitType&lt; 0, 0, 0, 0, 0, 0, 1 &gt; candela using udim_pow&lt; metere, 2 &gt;::unit area using udim_pow&lt; metere, 3 &gt;::unit volume using udim_div&lt; metere, second &gt;::unit velocity using udim_div&lt; velocity, second &gt;::unit acceleration using udim_div&lt; kilogram, volume &gt;::unit dencity using udim_div&lt; metere, metere &gt;::unit angle using udim_inv&lt; second &gt;::unit hertz using udim_div&lt; udim_mul&lt; metere, kilogram &gt;::unit, udim_pow&lt; second, 2 &gt;::unit &gt;::unit newton using udim_div&lt; newton, area &gt;::unit pascal using udim_mul&lt; pascal, second &gt;::unit viscosity using udim_mul&lt; newton, metere &gt;::unit joule using udim_div&lt; joule, second &gt;::unit watt using udim_div&lt; watt, ampere &gt;::unit volt using udim_mul&lt; second, ampere &gt;::unit coulomb using udim_div&lt; coulomb, volt &gt;::unit farad using udim_div&lt; volt, ampere &gt;::unit ohm using udim_mul&lt; volt, second &gt;::unit weber using udim_div&lt; weber, ampere &gt;::unit henry using udim_mul&lt; newton, metere &gt;::unit torque using udim_mul&lt; kilogram, area &gt;::unit inertia using udim_div&lt; angle, second &gt;::unit angular_velocity using udim_div&lt; angular_velocity, second &gt;::unit angular_acceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#types-documentation","title":"Types Documentation","text":""},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-no_dimention","title":"using no_dimention","text":"<pre><code>using cpp_robotics::unit::unit_dimention::no_dimention = typedef UnitType&lt;0, 0, 0, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-metere","title":"using metere","text":"<pre><code>using cpp_robotics::unit::unit_dimention::metere = typedef UnitType&lt;1, 0, 0, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-kilogram","title":"using kilogram","text":"<pre><code>using cpp_robotics::unit::unit_dimention::kilogram = typedef UnitType&lt;0, 1, 0, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-second","title":"using second","text":"<pre><code>using cpp_robotics::unit::unit_dimention::second = typedef UnitType&lt;0, 0, 1, 0, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-ampere","title":"using ampere","text":"<pre><code>using cpp_robotics::unit::unit_dimention::ampere = typedef UnitType&lt;0, 0, 0, 1, 0, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-kelvin","title":"using kelvin","text":"<pre><code>using cpp_robotics::unit::unit_dimention::kelvin = typedef UnitType&lt;0, 0, 0, 0, 1, 0, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-mole","title":"using mole","text":"<pre><code>using cpp_robotics::unit::unit_dimention::mole = typedef UnitType&lt;0, 0, 0, 0, 0, 1, 0&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-candela","title":"using candela","text":"<pre><code>using cpp_robotics::unit::unit_dimention::candela = typedef UnitType&lt;0, 0, 0, 0, 0, 0, 1&gt;;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-area","title":"using area","text":"<pre><code>using cpp_robotics::unit::unit_dimention::area = typedef udim_pow&lt;metere, 2&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-volume","title":"using volume","text":"<pre><code>using cpp_robotics::unit::unit_dimention::volume = typedef udim_pow&lt;metere, 3&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-velocity","title":"using velocity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::velocity = typedef udim_div&lt;metere, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-acceleration","title":"using acceleration","text":"<pre><code>using cpp_robotics::unit::unit_dimention::acceleration = typedef udim_div&lt;velocity, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-dencity","title":"using dencity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::dencity = typedef udim_div&lt;kilogram, volume&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angle","title":"using angle","text":"<pre><code>using cpp_robotics::unit::unit_dimention::angle = typedef udim_div&lt;metere, metere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-hertz","title":"using hertz","text":"<pre><code>using cpp_robotics::unit::unit_dimention::hertz = typedef udim_inv&lt;second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-newton","title":"using newton","text":"<pre><code>using cpp_robotics::unit::unit_dimention::newton = typedef udim_div&lt;udim_mul&lt;metere, kilogram&gt;::unit, udim_pow&lt;second, 2&gt;::unit&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-pascal","title":"using pascal","text":"<pre><code>using cpp_robotics::unit::unit_dimention::pascal = typedef udim_div&lt;newton, area&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-viscosity","title":"using viscosity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::viscosity = typedef udim_mul&lt;pascal, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-joule","title":"using joule","text":"<pre><code>using cpp_robotics::unit::unit_dimention::joule = typedef udim_mul&lt;newton, metere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-watt","title":"using watt","text":"<pre><code>using cpp_robotics::unit::unit_dimention::watt = typedef udim_div&lt;joule, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-volt","title":"using volt","text":"<pre><code>using cpp_robotics::unit::unit_dimention::volt = typedef udim_div&lt;watt, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-coulomb","title":"using coulomb","text":"<pre><code>using cpp_robotics::unit::unit_dimention::coulomb = typedef udim_mul&lt;second, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-farad","title":"using farad","text":"<pre><code>using cpp_robotics::unit::unit_dimention::farad = typedef udim_div&lt;coulomb, volt&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-ohm","title":"using ohm","text":"<pre><code>using cpp_robotics::unit::unit_dimention::ohm = typedef udim_div&lt;volt, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-weber","title":"using weber","text":"<pre><code>using cpp_robotics::unit::unit_dimention::weber = typedef udim_mul&lt;volt, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-henry","title":"using henry","text":"<pre><code>using cpp_robotics::unit::unit_dimention::henry = typedef udim_div&lt;weber, ampere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-torque","title":"using torque","text":"<pre><code>using cpp_robotics::unit::unit_dimention::torque = typedef udim_mul&lt;newton, metere&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-inertia","title":"using inertia","text":"<pre><code>using cpp_robotics::unit::unit_dimention::inertia = typedef udim_mul&lt;kilogram, area&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angular_velocity","title":"using angular_velocity","text":"<pre><code>using cpp_robotics::unit::unit_dimention::angular_velocity = typedef udim_div&lt;angle, second&gt;::unit;\n</code></pre>"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angular_acceleration","title":"using angular_acceleration","text":"<pre><code>using cpp_robotics::unit::unit_dimention::angular_acceleration = typedef udim_div&lt;angular_velocity, second&gt;::unit;\n</code></pre> <p>Updated on 2023-06-27 at 12:43:10 +0000</p>"},{"location":"doxybook/Namespaces/namespacestd/","title":"std","text":"<p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"doxybook/Namespaces/namespaceunit__dim__assem/","title":"unit_dim_assem","text":"<p>Updated on 2023-06-27 at 12:43:09 +0000</p>"},{"location":"example/hello_world/","title":"Hello World","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/cpp_robotics.hpp&gt;\n\nint main(int argc, char *argv[])\n{\n(void) argc;\n(void) argv;\nnamespace cr = cpp_robotics;\n\nstd::cout &lt;&lt; \"test\" &lt;&lt; std::endl;\n\nconstexpr cr::Vector2d vec(3.0, 4.0);\nprintf(\"constexpr 2D vector: %f, %f\\n\", vec.x, vec.y);\n\nEigen::MatrixXd A(2,2), B(2,1), Q(2,2), R(1,1), P(2,2);\nA &lt;&lt; 0, 1, -10, -1;\nB &lt;&lt; 0, 1;\nQ &lt;&lt; 300, 0, 0, 60;\nR &lt;&lt; 1;\n\nEigen::MatrixXd K = cr::lqr(A, B, Q, R);\nstd::cout &lt;&lt; \"LQR feedback vector\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; K &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"polynomial\" &lt;&lt; std::endl;\ncr::Polynomial p0({1, 0, 3});\nstd::cout &lt;&lt; p0 &lt;&lt; std::endl;\ncr::Polynomial p1 = cr::Polynomial({1, -2}) * cr::Polynomial({1, 2});\nstd::cout &lt;&lt; p1 &lt;&lt; std::endl;\n\ncr::TransferFunction tf({1.0}, {1, 1.0}, 0.01);\n\nnamespace plt = matplotlibcpp;\nstd::cout &lt;&lt; \"transfer function step responce\" &lt;&lt; std::endl;\n{\nauto [t, y] = cr::step(tf, 30);\nplt::plot(t, y);\nplt::show();\n}\n\nstd::cout &lt;&lt; \"transfer function sin cruve input responce\" &lt;&lt; std::endl;\n{\nauto input = cr::sinspace(1, 0.1, 1000);\nauto [t, y] = cr::lsim(tf, input);\nplt::plot(t, y);\nplt::show();\n}\n\nstd::cout &lt;&lt; \"transfer function bode fig plot\" &lt;&lt; std::endl;\ncr::bode_plot(tf);\n\nstd::cout &lt;&lt; \"transfer function nyquist fig plot\" &lt;&lt; std::endl;\ncr::nyquist_plot(tf);\n}\n</code></pre>"},{"location":"example/algorithm/icp_sample/","title":"ICP","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm.hpp&gt;\n#include &lt;cpp_robotics/vector/vector2.hpp&gt;\n#include &lt;cpp_robotics/third_party/matplotlib-cpp/matplotlibcpp.h&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\n\n{\nstd::vector&lt;Eigen::Vector2d&gt; fixed = {\n{0,9},\n{0,7},\n{0,5},\n{0,3},\n{2,1},\n{4,1},\n{6,1},\n{8,3},\n{8,5},\n{8,9},\n};\n\nstd::vector&lt;Eigen::Vector2d&gt; p2 = fixed;\nfor(size_t i = 0; i &lt; fixed.size(); i++)\n{\n// p2[i][0] = fixed[i][1] + 1;\n// p2[i][1] = -fixed[i][0];\np2[i][0] += 3.0; //fixed[i][0];\np2[i][1] += 1.0; //fixed[i][1];\n}\nauto [R, T] = cr::calcu_transformatoin&lt;2&gt;(p2, fixed);\n\nstd::cout &lt;&lt; \"R = \" &lt;&lt; std::endl;\nstd::cout &lt;&lt; R &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"T = \" &lt;&lt; std::endl;\nstd::cout &lt;&lt; T &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"///// check /////\" &lt;&lt; std::endl;\n\nfor(size_t i = 0; i &lt; p2.size(); i++)\n{\nauto moved_p = R*p2[i] + T;\n\nstd::cout &lt;&lt; moved_p.transpose() &lt;&lt; \", err = \" &lt;&lt; (moved_p-fixed[i]).transpose() &lt;&lt; std::endl;\n}\n}\n\n{\nstd::vector&lt;Eigen::Vector2d&gt; p1 = {\n{0,8},\n{0,7},\n{0,5},\n{0,3},\n{2,1},\n{4,1},\n{6,1},\n{8,3},\n{8,5},\n{8,9},\n};\n\nstd::vector&lt;Eigen::Vector2d&gt; p2 = p1;\nfor(auto &amp;v : p2)\nv += Eigen::Vector2d(3, 0);\n\nauto [points, cnt] = cr::icp&lt;2&gt;(p2, p1, 50);\n\nauto gen = [](std::vector&lt;Eigen::Vector2d&gt; ps)\n{\nstd::vector&lt;double&gt; x_(ps.size()), y_(ps.size());\n\nfor(size_t i = 0; i &lt; (ps.size()); i++)\n{\nx_[i] = ps[i][0];\ny_[i] = ps[i][1];\n}\n\nreturn std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;(x_, y_);\n};\n\nauto [x, y] = gen(p1);\nmatplotlibcpp::plot(x, y);\nauto [x2, y2] = gen(points);\nmatplotlibcpp::plot(x2, y2);\nmatplotlibcpp::show();\n\n}\n}\n</code></pre>"},{"location":"example/algorithm/kdtree_sample/","title":"KDTree","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm/kdtree.hpp&gt;\n#include &lt;cpp_robotics/vector/vector2.hpp&gt;\n#include &lt;Eigen/Dense&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\n\n// for cpp_rototics::VectorXx\nstd::cout &lt;&lt; \"for cpp_rototics::VectorXx\" &lt;&lt; std::endl;\n{\ncr::KDTree&lt;cr::Vector2d, 2&gt; kdtree;\n\nstd::vector&lt;cr::Vector2d&gt; points = {\n{0,1},\n{2,3},\n{3,4},\n{4,5},\n{5,6},\n};\n\nkdtree.build(points);\n// kdtree.debug_node();\n\nauto ret = kdtree.knn_search_points(cr::Vector2d(0,1), 1);\n\nprintf(\"size %ld\\n\", ret.size());\nstd::for_each(ret.begin(), ret.end(), [&amp;](cr::Vector2d p)\n{\nprintf(\"%6.2f, %6.2f\\n\", p.x, p.y);\n});\n}\n\n// for Eigen::VectorXx\nstd::cout &lt;&lt; \"for Eigen::VectorXx\" &lt;&lt; std::endl;\n{\ncr::KDTree&lt;Eigen::Vector2d, 2&gt; kdtree;\n\nstd::vector&lt;Eigen::Vector2d&gt; points = {\n{0,1},\n{2,3},\n{3,4},\n{4,5},\n{5,6},\n};\n\nkdtree.build(points);\n// kdtree.debug_node();\n\nauto ret = kdtree.knn_search_points(Eigen::Vector2d(0,1), 1);\n\nprintf(\"size %ld\\n\", ret.size());\nstd::for_each(ret.begin(), ret.end(), [&amp;](Eigen::Vector2d p)\n{\nprintf(\"%6.2f, %6.2f\\n\", p[0], p[1]);\n});\n}\n\n}\n</code></pre>"},{"location":"example/control/canonicalize/","title":"\u6b63\u6e96\u5f62","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;cpp_robotics/system.hpp&gt;\n#include &lt;cpp_robotics/controller.hpp&gt;\n\n#define PRINT_MAT(MAT) \\\n    std::cout &lt;&lt; #MAT &lt;&lt; std::endl;\\\n    std::cout &lt;&lt; MAT &lt;&lt; std::endl &lt;&lt; std::endl;\n\nint main()\n{\nnamespace cr = cpp_robotics;\nnamespace plt = matplotlibcpp;\n\nEigen::MatrixXd A(3,3);\nEigen::MatrixXd B(3,1);\nEigen::MatrixXd C(1,3);\nEigen::MatrixXd D(1,1);\n\nA &lt;&lt; -0.313, 56.7, 0,\n-0.0139, -0.426, 0,\n0, 56.7, 0;\nB &lt;&lt; 0.232, 0.0203, 0;\nC &lt;&lt; 0, 0, 1;\nD &lt;&lt; 0;\n\nconst double dt = 0.01;\ncr::StateSpaceSystem sys(A, B, C, D, dt);\n\nstd::cout &lt;&lt; \"//////////////////////////////\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"controllability: \" &lt;&lt; (cr::is_controllable(sys) ? \"true\" : \"false\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"observability  : \" &lt;&lt; (cr::is_observable(sys) ? \"true\" : \"false\") &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"\\n//////////////////////////////\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"canonicalize\" &lt;&lt; std::endl;\nauto [A_tilde, B_tilde, C_tilde, D_tilde] = cr::canonicalize_system(sys, cr::CanonicalizeMode::CONTROLLABLE );\n\nstd::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);\nPRINT_MAT(A_tilde);\nPRINT_MAT(B_tilde);\nPRINT_MAT(C_tilde);\nPRINT_MAT(D_tilde);\n}\n</code></pre>"},{"location":"example/control/lqr/","title":"LQR","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/core.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\nnamespace plt = matplotlibcpp;\n\nconst double dt = 0.01;\n\n//////////////////// plant ////////////////////\nEigen::MatrixXd A(2,2), B(2,1), C(2,2);\nA &lt;&lt; 0, 1, -10, -1;\nB &lt;&lt; 0, 1;\nC.setIdentity();\n\ncr::StateSpaceSystem sys;\nsys.set_continuous(A, B, C, dt);\n\n//////////////////// controller ////////////////////\nEigen::MatrixXd Q(2,2), R(1,1);\nQ &lt;&lt; 3000, 0, 0, 60;\nR &lt;&lt; 0.01;\nEigen::MatrixXd K = cr::lqr(A, B, Q, R);\n\nstd::cout &lt;&lt; \"fb gain\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; K &lt;&lt; std::endl;\n\nEigen::Vector2d target_vec;\ntarget_vec &lt;&lt; 30, 0;\n\n\n{\n\nauto t = cr::arrange(0, 5.0, dt);\nstd::vector&lt;double&gt; x1(t.size()), x2(t.size()), x1_ref(t.size());\n\n//////////////////// simulation ////////////////////\nfor(size_t i = 0; i &lt; t.size(); i++)\n{\nEigen::VectorXd u = K*(target_vec-sys.x());\n\nauto x = sys.responce(u);\nx1[i] = x(0);\nx2[i] = x(1);\nx1_ref[i] = target_vec(0);\n}\n\nstd::cout &lt;&lt; \"plot\" &lt;&lt; std::endl;\n\nplt::named_plot(\"x1\", t, x1);\nplt::named_plot(\"x2\", t, x2);\nplt::named_plot(\"x1_ref\", t, x1_ref);\nplt::legend();\nplt::show();\n}\n\n}\n</code></pre>"},{"location":"example/control/pid_vs_nctf/","title":"PID vs NCTF","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/core.hpp&gt;\n#include &lt;cpp_robotics/motor/dc_motor_list.hpp&gt;\n#include &lt;cpp_robotics/motor/motor_tf.hpp&gt;\n\nstatic std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; step_test(cpp_robotics::SisoFeedbackSystem &amp;sys, double time, double dt)\n{\nstd::vector&lt;double&gt; t = cpp_robotics::arrange(0, time, dt);\nstd::vector&lt;double&gt; target(t.size());\nstd::vector&lt;double&gt; res(t.size());\nstd::vector&lt;double&gt; dres(t.size());\nstd::vector&lt;double&gt; input(t.size());\n\ncpp_robotics::Differentiator diff_(1/dt, dt);\n\n\nfor(size_t i = 0; i &lt; res.size(); i++)\n{\ntarget[i] = (res.size()/2 &lt; i ) ? ( (res.size()*3/4 &lt; i ) ? 0: 20 ) : 20*std::cos(i*0.03); // : 1.0;\nres[i] = sys.control(target[i]);\ndres[i] = diff_.filtering(res[i]);\ninput[i] = sys.u();\n}\n\nreturn {t, target, input, res, dres};\n}\n\nvoid make_nct_test(std::function&lt;double(double)&gt; f)\n{\nstd::vector&lt;double&gt; e = cpp_robotics::arrange(-10, 10, 0.05);\nstd::vector&lt;double&gt; e_dot(e.size());\n\nfor(size_t i = 0; i &lt; e.size(); i++)\n{\ne_dot[i] = f(e[i]);\n}\n\nnamespace plt = matplotlibcpp;\nplt::plot(e, e_dot);\nplt::ylim(-10, 10);\nplt::show();\n}\n\nint main()\n{\nusing namespace cpp_robotics;\n\nconst double dt = 0.01;\nconst double max_output = 24;\n\n//////////////////// PID ////////////////////\nPIDController::pid_param_t pid_param = {\n.Ts = dt,\n.gpd = 100,\n.Kp = 10.0,\n.Ki = 0.0,\n.Kd = 0.09,\n.output_limit = std::pair(-max_output, max_output)\n};\nPIDController pid(pid_param);\n\n//////////////////// NCTF ////////////////////\nPIDController::pid_param_t nctf_pid_param = {\n.Ts = dt,\n.gpd = 500,\n.Kp = 0.8,\n.Ki = 0.0,\n.Kd = 0.005,\n.output_limit = std::pair(-max_output, max_output)\n};\n\nconst double nct_max_velocity = 300.0;\nconst double nct_slope = 10;\nNctfController nctf(nct_max_velocity, nct_slope, nctf_pid_param, dt);\n\n//////////////////// Plant ////////////////////\nauto motor = DCGearedMotorParam(24_V, RZ_735VA_9517, IG42C_17);\nauto plant = make_geared_motor_pos_tf(motor, dt); // [rad]\n\n// make_nct_test(nctf.nct());\n// {\n//     auto vel_plant = make_geared_motor_vel_tf(motor, dt); // [rad]\n//     namespace plt = matplotlibcpp;\n//     auto [t, res] = step(vel_plant, 3.0, max_output);\n//     plt::named_plot(\"responce\", t, res);\n//     plt::legend();\n//     plt::show();\n// }\n\n{\nnamespace plt = matplotlibcpp;\n{\nSisoFeedbackSystem siso_sys = cpp_robotics::make_feedback_system(pid, plant);\nsiso_sys.reset();\nauto [t, target, input, ret, dres] = step_test(siso_sys, 5.0, dt);\n\nplt::named_plot(\"target\", t, target);\nplt::named_plot(\"PID responce\", t, ret);\n}\n\n{\nSisoFeedbackSystem siso_sys = cpp_robotics::make_feedback_system(nctf, plant);\nauto [t, target, input, ret, dres] = step_test(siso_sys, 5.0, dt);\nplant.set_state_zero();\nsiso_sys.reset();\n// plt::named_plot(\"target\", t, target);\nplt::named_plot(\"NCTF responce\", t, ret);\n// plt::named_plot(\"input\", t, input);\n}\n\n// plt::named_plot(\"input\", t, input);\n// plt::named_plot(\"d responce / dt\", t, dres);\n\nplt::ylim(-30.0, 30.0);\nplt::legend();\nplt::show();\n\n// // show NCT\n// plt::named_plot(\"actual NCT\", nctf.e_, nctf.e_dot_);\n// plt::named_plot(\"target NCT\", nctf.e_, nctf.target_e_dot_);\n// plt::show();\n}\n\n}\n</code></pre>"},{"location":"example/control/place/","title":"\u6975\u914d\u7f6e","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;cpp_robotics/system.hpp&gt;\n#include &lt;cpp_robotics/controller.hpp&gt;\n\n#define PRINT_MAT(MAT) \\\n    std::cout &lt;&lt; #MAT &lt;&lt; std::endl;\\\n    std::cout &lt;&lt; MAT &lt;&lt; std::endl &lt;&lt; std::endl;\n\nint main()\n{\nnamespace cr = cpp_robotics;\nnamespace plt = matplotlibcpp;\n\n// http://arduinopid.web.fc2.com/O7.html\nEigen::MatrixXd A(2,2);\nEigen::MatrixXd B(2,1);\nEigen::MatrixXd C(1,2);\nEigen::MatrixXd D(1,1);\n\nA &lt;&lt; -10, -10,\n5, 0;\nB &lt;&lt; 10, 0;\nC &lt;&lt; 0, 1;\nD &lt;&lt; 0;\n\nconst double dt = 0.01;\ncr::StateSpaceSystem sys(A, B, C, D, dt);\n\nstd::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);\nstd::cout &lt;&lt; \"pole place\" &lt;&lt; std::endl;\nstd::vector&lt;double&gt; pole = {-6, -6};\nauto K = cr::place(sys, pole);\n\nPRINT_MAT(K);\n}\n</code></pre>"},{"location":"example/control/pure_pursuit/","title":"Pure pursuit","text":""},{"location":"example/optimize/active_set_method_example/","title":"\u6709\u52b9\u5236\u7d04\u6cd5","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm.hpp&gt;\n#include &lt;cpp_robotics/optimize/active_set_method.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\n\ncr::ActiveSetMethod solver;\n\ncr::ActiveSetMethod::Problem prob(2);\n\nstd::cout &lt;&lt; \"prob setup\" &lt;&lt; std::endl;\nprob.Q &lt;&lt; 1,0,0,1;\nprob.c &lt;&lt; -6,-2;\n\nEigen::VectorXd A(2);\nA &lt;&lt; 0,0;\nEigen::VectorXd b(1);\nb &lt;&lt; 1;\n\n// prob.add_inequality_constraint(A.transpose(), b); // x2 = 1\u306e\u5236\u7d04\n// A &lt;&lt; -1, 0;\n// prob.add_equality_constraint(A.transpose(), b); // x1 = 1\u306e\u5236\u7d04\n\nEigen::Vector2d x0;\nx0 &lt;&lt; 3,2;\n\nstd::cout &lt;&lt; \"prob setup end\" &lt;&lt; std::endl;\n\nauto result = solver.solve(prob, x0);\n\nif(result.is_solved)\n{\nstd::cout &lt;&lt; \"\u89e3\u3051\u305f\" &lt;&lt; std::endl;\n}\nelse\n{\nstd::cout &lt;&lt; \"\u89e3\u7121\u3057\" &lt;&lt; std::endl;\n}\n\nstd::cout &lt;&lt; result.x_opt.transpose() &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"iter: \" &lt;&lt; result.iter_cnt &lt;&lt; std::endl;\n\n}\n</code></pre>"},{"location":"example/optimize/optimize_rosenbrock/","title":"Rosenbrock\u95a2\u6570\u306e\u6700\u9069\u5316","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\n\n// 2\u5909\u6570 Rosenbrock\u95a2\u6570\n// \u6700\u9069\u89e3\u306f x = (1, 1)\nauto f = [](Eigen::VectorXd x) -&gt; double\n{\nreturn 100*( std::pow( (x(0) - std::pow(x(1),2)), 2) ) + std::pow(1 - x(1), 2);\n};\n\nauto g = [&amp;](const Eigen::VectorXd &amp;x)\n{\nreturn cr::derivative(f, x);\n};\n\nEigen::VectorXd x_init = Eigen::VectorXd::Zero(2);\n{\nauto [ret, rx, rcnt] = cr::quasi_newton_method(f, g, x_init);\nstd::cout &lt;&lt; \"optimize Rosenbrock function with quasi newton method\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"ans: \" &lt;&lt; rx.transpose() &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"itr: \" &lt;&lt; rcnt &lt;&lt; std::endl;\n}\n}\n</code></pre>"},{"location":"example/optimize/optimize_scalar/","title":"\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u306e\u6700\u9069\u5316","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\n\nstd::cout &lt;&lt; \"optimize_scalar\" &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"min x =&gt; (x+1)^2 = \" &lt;&lt; cr::golden_search([](double x){ return std::pow(x+1, 2); }, -10, 10) &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"sin'(0) = cos(0) = \" &lt;&lt; cr::derivative([](double x){ return std::sin(x); }, 0) &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"example/optimize/optimize_with_constraint/","title":"\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize.hpp&gt;\n\nint main()\n{\nusing namespace cpp_robotics;\n\nstd::cout &lt;&lt; \"test\" &lt;&lt; std::endl;\n\nauto f = [](Eigen::VectorXd x)\n{\nreturn std::pow(x(0)-2,2) + std::pow(x(1),2);\n};\n\nEigen::VectorXd x_init = Eigen::VectorXd::Zero(2);\n\nConstraintArray con;\ncon.push_back({\nConstraint::Type::Ineq,\n[](Eigen::VectorXd x)\n{\nreturn (std::pow(x(0), 2) + std::pow(x(1), 2)) - 1;\n}\n});\n\n{\nx_init(0) = 0.4;\nx_init(1) = 0.5;\nauto [ret, rx, rcnt] = penalty_method(f, con, x_init);\nstd::cout &lt;&lt; rx.transpose() &lt;&lt; \"(norm: \" &lt;&lt; rx.norm() &lt;&lt; \"), \" &lt;&lt; rcnt &lt;&lt; std::endl;\n}\n\n{\nx_init(0) = 0.4;\nx_init(1) = 0.5;\nauto [ret, rx, rcnt] = barrier_method(f, con, x_init);\nstd::cout &lt;&lt; rx.transpose() &lt;&lt; \"(norm: \" &lt;&lt; rx.norm() &lt;&lt; \"), \" &lt;&lt; rcnt &lt;&lt; std::endl;\n}\n}\n</code></pre>"},{"location":"example/optimize/optimize_without_constraint/","title":"\u7121\u5236\u7d04\u6700\u9069\u5316","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/optimize.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\n\nstd::cout &lt;&lt; \"test\" &lt;&lt; std::endl;\n\nauto f1 = [](Eigen::VectorXd x)\n{\nreturn std::sin(x(0)) + std::cos(x(1)) + std::sin(x(1) + M_PI) + std::sin(x(2));\n};\nstd::cout &lt;&lt; \"f({0, 0, 0}) = \" &lt;&lt; f1(Eigen::VectorXd::Zero(3))&lt;&lt; std::endl;\nstd::cout &lt;&lt; \"f'({0, 0, 0}) = \" &lt;&lt; cr::derivative(f1, Eigen::VectorXd::Zero(3)).transpose() &lt;&lt; std::endl;\n\n\nauto f = [](Eigen::VectorXd x)\n{\n//return 4.5*(std::pow(std::cos(x(0)), 4) + std::pow(std::cos(x(1)), 4));\n// return std::sin(x(0)) + std::sin(x(1));\nreturn std::pow(x(0)-2,2) + std::pow(x(1)-3,2);\n};\n\nauto g = [&amp;](const Eigen::VectorXd &amp;x)\n{\nreturn cr::derivative(f, x);\n};\n\n// auto g = [](Eigen::VectorXd x)\n// {\n//     Eigen::VectorXd gval(2);\n\n//     gval(0) = 2*(x(0)-2);\n//     gval(1) = 2*(x(1)-3);\n\n//     return gval;\n// };\n\n// auto h = [](Eigen::VectorXd x)\n// {\n//     (void) x;\n//     Eigen::MatrixXd hval(2, 2);\n\n//     hval(0, 0) = 2;\n//     hval(1, 0) = 0;\n//     hval(0, 1) = 0;\n//     hval(1, 1) = 2;\n\n//     return hval;\n// };\n\nEigen::VectorXd x_init = Eigen::VectorXd::Zero(2);\nx_init(0) = 0;\nx_init(1) = 0;\n\n{\nauto [ret, rx, rcnt] = cr::steepest_descent_method(f, g, x_init);\nstd::cout &lt;&lt; \"steepest_descent_method\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; rx.transpose() &lt;&lt; \", \" &lt;&lt; rcnt &lt;&lt; std::endl;\n}\n\nx_init(0) = 0;\nx_init(1) = 0;\n{\nauto [ret, rx, rcnt] = cr::newton_method(g, h, x_init);\nstd::cout &lt;&lt; \"newton_method\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; rx.transpose() &lt;&lt; \", \" &lt;&lt; rcnt &lt;&lt; std::endl;\n}\n\nx_init(0) = 0;\nx_init(1) = 0;\n{\nauto [ret, rx, rcnt] = cr::quasi_newton_method(f, g, x_init);\nstd::cout &lt;&lt; \"quasi_newton_method\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; rx.transpose() &lt;&lt; \", \" &lt;&lt; rcnt &lt;&lt; std::endl;\n}\n}\n</code></pre>"},{"location":"example/optimize/sqp_example/","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cpp_robotics/algorithm.hpp&gt;\n#include &lt;cpp_robotics/optimize/sqp.hpp&gt;\n\nusing namespace cpp_robotics;\n\nint main()\n{\nSQP solver;\nSQP::Problem prob;\n\n//////////////////// \u554f\u984c\u8a2d\u5b9a ////////////////////\nprob.func = [](Eigen::VectorXd x)\n{\nreturn std::pow(x(0)-3, 2) + std::pow(x(1)-3,2);\n};\n\nprob.con.push_back({\nConstraint::Ineq,\n[](Eigen::VectorXd x)\n{\nreturn (x.squaredNorm() - 1);\n},\n});\n// prob.con.push_back({\n//     Constraint::Ineq,\n//     [](Eigen::VectorXd x)\n//     {\n//         x(0) -= 1.5;\n//         return x.squaredNorm() - 1;\n//     },\n// });\n\nprob.max_iter = 3;\n\nEigen::VectorXd x0(2);\nx0 &lt;&lt; 1.0, 0;\n\n//////////////////// \u89e3\u304f ////////////////////\nauto result = solver.solve(prob, x0);\n\nstd::cout &lt;&lt; \"min (x(0)-3)^2 + x(1)^2\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"s.t. x(0)^2 + x(1)^2 &lt;= 1\" &lt;&lt; std::endl;\n\nif(result.is_solved)\n{\nstd::cout &lt;&lt; \"\u89e3\u3051\u305f\" &lt;&lt; std::endl;\n}\nelse\n{\nstd::cout &lt;&lt; \"\u89e3\u3051\u306a\u304b\u3063\u305f\" &lt;&lt; std::endl;\n}\n\nstd::cout &lt;&lt; \"x_opt =\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; result.x_opt &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"lambda_opt =\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; result.lambda_opt &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; \"iter: \" &lt;&lt; result.iter_cnt &lt;&lt; std::endl;\n\n}\n</code></pre>"},{"location":"example/path_planning/dubins_path/","title":"Dubins\u66f2\u7dda","text":"<pre><code>#include &lt;iostream&gt;\n#include \"cpp_robotics/cpp_robotics.hpp\"\n\nint main()\n{\nusing namespace cpp_robotics;\nnamespace plt = matplotlibcpp;\n\nconst Transformd start(4.0, 3.0, radians(-45));\nconst Transformd end(1.0, 1.0, radians(45));\nconst double cavature = 1;\nDubinsPath dpath(start, end, cavature);\n\nstd::cout &lt;&lt; dpath.path_type() &lt;&lt; std::endl;\n\nfor(size_t i = 0; i &lt; 3; i++)\nstd::cout &lt;&lt; dpath.segment_length(i) &lt;&lt; std::endl;\n\nauto l = linspace(0, dpath.length());\n\nstd::vector&lt;double&gt; x(l.size()), y(l.size());\n\nfor(size_t i = 0; i &lt; l.size(); i++)\n{\nauto pos = dpath.position(l[i]);\nx[i] = pos.x;\ny[i] = pos.y;\n}\n\nplt::plot(x, y);\nplt::set_aspect(1.0);\nplt::show();\n}\n</code></pre>"},{"location":"example/system/bode_nyquist/","title":"\u30dc\u30fc\u30c9\u7dda\u56f3\u30fb\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;cpp_robotics/system.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\n\n// \u4f1d\u9054\u95a2\u6570\n// tf(s) = 1 / (s + 1)\ncr::TransferFunction tf({1.0}, {1.0, 1.0}, 0.01);\n\n// \u30dc\u30fc\u30c9\u7dda\u56f3\ncr::bode_plot(tf);\n\n// \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\ncr::nyquist_plot(tf);\n}\n</code></pre>"},{"location":"example/system/disc_tf/","title":"z\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54","text":"<pre><code>#include &lt;cpp_robotics/system.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\nnamespace plt = matplotlibcpp;\n\n// LPF\n//            K\n// G(s) = --------\n//         Ts + 1\n//\n// \u96e2\u6563\u5316\u3057\u3066\n//           K*dt*z^-1 + K*dt\n// G(z) = -----------------------\n//         (dt-2T)z^-1 + (dt+2T)\nconst double K = 1.5;\nconst double T = 0.6;\nconst double dt = 0.01;\ncr::DiscreteTransferFunction tf({K*dt, K*dt}, {dt-2*T, dt+2*T}, dt);\n\n// \u521d\u671f\u72b6\u614b\u304b\u30894\u79d2\u5206\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u8a08\u7b97\nauto [t, y] = cr::step(tf, 4.0);\nplt::plot(t, y);\nplt::show();\n}\n</code></pre>"},{"location":"example/system/state_space_system/","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe","text":"<pre><code>#include &lt;cpp_robotics/system.hpp&gt;\n#include &lt;cpp_robotics/controller.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\nnamespace plt = matplotlibcpp;\n\nEigen::Matrix2d A;\nEigen::Matrix&lt;double, 2, 1&gt; B;\nEigen::Matrix&lt;double, 1, 2&gt; C;\n\nA &lt;&lt; 0, 1, 1, 0.5;\nB &lt;&lt; 0, 0.5;\nC &lt;&lt; 1, 0;\nconst double dt = 0.01;\n\ncr::StateSpaceSystem sys(A, B, C, dt);\n\nstd::cout &lt;&lt; cr::is_controllable(A, B) &lt;&lt; std::endl;\nstd::cout &lt;&lt; cr::is_observable(A, C) &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"example/system/step_responce/","title":"\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54","text":"<pre><code>#include &lt;cpp_robotics/system.hpp&gt;\n\nint main()\n{\nnamespace cr = cpp_robotics;\nnamespace plt = matplotlibcpp;\n\n// 2\u6b21\u7cfb\u306e\u4f1d\u9054\u95a2\u6570\u30920.01\u79d2\u3067\u96e2\u6563\u5316\n//                  omega^2\n// G(s) = ------------------------------\n//         s^2 + 2*zeta*omega*s + omega^2\nconst double omega = 4.0;\nconst double zeta = 0.5;\ncr::TransferFunction tf({omega*omega}, {1.0, 2.0*zeta*omega, omega*omega}, 0.01);\n\n// \u521d\u671f\u72b6\u614b\u304b\u30894\u79d2\u5206\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u8a08\u7b97\nauto [t, y] = cr::step(tf, 4.0);\nplt::plot(t, y);\nplt::show();\n}\n</code></pre>"},{"location":"example/units/units/","title":"\u5358\u4f4d\u7cfb","text":"<pre><code>#include &lt;iostream&gt;\n// #include &lt;cpp_robotics/core.hpp&gt;\n\n#include \"cpp_robotics/utility.hpp\"\n#include \"cpp_robotics/vector.hpp\"\n#include \"cpp_robotics/unit.hpp\"\n\nint main()\n{\nusing namespace cpp_robotics;\n\nconstexpr Meter width = 1.5_m;\nconstexpr Meter height = 3000_mm;\n\nconstexpr Meter perimeter = 2*(width + height); // 8.0\n\nconstexpr Area rectangle_area = width*height; // 4.5\n\nconstexpr Volt voltage = 20_V;\nconstexpr Ohm res = 5_ohm;\n\nconstexpr Ampere current = voltage / res; // 4.0\n}\n</code></pre>"},{"location":"tech_note/algorithm/auto_diff/","title":"\u81ea\u52d5\u5fae\u5206","text":""},{"location":"tech_note/algorithm/auto_diff/#_2","title":"\u30d5\u30a9\u30ef\u30fc\u30c9\u30e2\u30fc\u30c9\u30fb\u30d0\u30c3\u30af\u30ef\u30fc\u30c9\u30e2\u30fc\u30c9","text":""},{"location":"tech_note/algorithm/auto_diff/#_3","title":"\u81ea\u52d5\u5fae\u5206\u30e9\u30a4\u30d6\u30e9\u30ea","text":""},{"location":"tech_note/algorithm/auto_diff/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/algorithm/icp/","title":"ICP (Iterative Closest Point)","text":""},{"location":"tech_note/algorithm/icp/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>ICP\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u5229\u7528\u3057\u305fSLAM\u7528Python\u3001MATLAB\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0</li> <li>ICP(Iterative Closest Point)\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/algorithm/jerk_minimum_model/","title":"\u8e8d\u5ea6\u6700\u5c0f\u5316\u30e2\u30c7\u30eb","text":""},{"location":"tech_note/algorithm/jerk_minimum_model/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/algorithm/k_means_method/","title":"K-means\u6cd5","text":""},{"location":"tech_note/algorithm/k_means_method/#k-means_1","title":"K-means++\u6cd5","text":""},{"location":"tech_note/algorithm/k_means_method/#_1","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/algorithm/kdtree/","title":"KDTree","text":""},{"location":"tech_note/algorithm/mahalanobis/","title":"\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2","text":"<p>\u7570\u5e38\u691c\u77e5\u306a\u3069\u306b\u3088\u304f\u4f7f\u308f\u308c\u308b\u591a\u5909\u6570\u306e\u7a7a\u9593\u306b\u5bfe\u3057\u3066\u305d\u308c\u305e\u308c\u306e\u5909\u6570\u306e\u5171\u5206\u6563\u884c\u5217\u3092\u4f7f\u3063\u3066\u8868\u73fe\u3055\u308c\u308b\u8ddd\u96e2</p> \\[ d = \\sqrt{(x-\\mu)^T\\Sigma^{-1}(x-\\mu)} \\]"},{"location":"tech_note/algorithm/mahalanobis/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2</li> </ul>"},{"location":"tech_note/algorithm/ndt/","title":"NDT scan matching","text":""},{"location":"tech_note/algorithm/ndt/#ndt","title":"NDT\u30de\u30c3\u30c1\u30f3\u30b0\u5927\u307e\u304b\u306a\u6d41\u308c","text":"<ul> <li>\u30de\u30c3\u30d7\u3092NDT\u5316\u3059\u308b</li> <li>\u30ec\u30fc\u30b6\u30fc\u306e\u89b3\u6e2c\u30c7\u30fc\u30bf\u3092\u3053\u308c\u307e\u3067\u306e\u81ea\u5df1\u4f4d\u7f6e\u3092\u30d9\u30fc\u30b9\u306b\u3057\u3066NDT\u5316\u3059\u308b?</li> <li></li> <li>\u30ec\u30fc\u30b6\u30fc\u3067\u306e</li> </ul>"},{"location":"tech_note/algorithm/ndt/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>NDT\u52c9\u5f37\u4f1a</li> <li>\u3010ROS\u3011\u30b9\u30ad\u30e3\u30f3\u30de\u30c3\u30c1\u30f3\u30b0SLAM\u306e\u5b9f\u88c5\uff08NDT\u5b9f\u88c5\u7de8\uff09</li> <li>Scan Matching \u81ea\u5df1\u4f4d\u7f6e\u63a8\u5b9a\u624b\u6cd5</li> <li>pcl_apps ROS2\u3067pcl\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8</li> </ul>"},{"location":"tech_note/algorithm/poly/","title":"\u591a\u9805\u5f0f","text":""},{"location":"tech_note/algorithm/poly/#_2","title":"\u52a0\u6e1b\u4e57\u9664","text":""},{"location":"tech_note/algorithm/poly/#_3","title":"\u5c55\u958b","text":""},{"location":"tech_note/algorithm/poly/#_4","title":"\u56e0\u6570\u5206\u89e3","text":""},{"location":"tech_note/algorithm/poly/#_5","title":"\u5fae\u5206\u30fb\u7a4d\u5206","text":""},{"location":"tech_note/algorithm/poly_lerp/","title":"\u591a\u9805\u5f0f\u88dc\u9593","text":"<p>\u30ed\u30dc\u30c3\u30c8\u30a2\u30fc\u30e0\u306a\u3069\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3057\u305f\u3044\u6642\u306b\u76ee\u6a19\u5024\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3059\u3053\u3068\u3067\u5b9f\u73fe\u3057\u3088\u3046\u3068\u3057\u305f\u6642\u306b\u306a\u308b\u3079\u304f\u7c21\u5358\u306b\u53c2\u7167\u8ecc\u9053\u3092\u4f5c\u308a\u305f\u3044\u3053\u3068\u304c\u3042\u308b\u3002\u7c21\u5358\u306b\u5b9f\u88c5\u3059\u308b\u306a\u3089\u591a\u9805\u5f0f\u3067\u8ecc\u9053\u3092\u4f5c\u308b\u306e\u304c\u7c21\u5358\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/algorithm/poly_lerp/#1","title":"1\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65702</p> <p>\u59cb\u70b9\u4f4d\u7f6e\\(P_0\\), \u7d42\u70b9\u4f4d\u7f6e\\(P_1\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; \\dfrac{P_1 - P_0}{T} \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#2","title":"2\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65703</p> <p>\u59cb\u70b9\\((P_0, v_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{T^2}\\left\\{ (P_1 - P_0) - v_0T \\right\\}\\\\ \\end{array} \\] <p>\u59cb\u70b9\\((P_0, v_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((v_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{2T}(v_1 - v_0)\\\\ \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#3","title":"3\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65704</p> <p>\u59cb\u70b9\\((P_0, v_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, v_1)\\), \u9593\u9694\\(T`x\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{T^2}\\left\\{ 3(P_1 - P_0) - (v_1 + 2v_0)T \\right\\}\\\\ a_3 &amp;=&amp; \\dfrac{1}{T^3}\\left\\{ -2(P_1 - P_0) - (v_1 + v_0)T \\right\\} \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#4","title":"4\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65705</p> <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((v_1, acc_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{2} acc_0\\\\ a_3 &amp;=&amp; \\dfrac{1}{3T^2}\\left\\{ 3(v_1 - v_0) - (acc_1 + 2acc_0)T \\right\\}\\\\ a_4 &amp;=&amp; \\dfrac{1}{4T^3}\\left\\{ -2(v_1 - v_0) + (acc_1 + acc_0)T \\right\\}\\\\ \\end{array} \\] <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, v_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, acc_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p>"},{"location":"tech_note/algorithm/poly_lerp/#5","title":"5\u6b21\u5f0f","text":"<p>\u5883\u754c\u6761\u4ef6\u65706</p> <p>\u59cb\u70b9\\((P_0, v_0, acc_0)\\), \u7d42\u70b9\u4f4d\u7f6e\\((P_1, v_1, acc_1)\\), \u9593\u9694\\(T\\)\u306e\u3068\u304d</p> \\[ f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5 \\] \\[ \\begin{array}{rcl} a_0 &amp;=&amp; P_0\\\\ a_1 &amp;=&amp; v_0\\\\ a_2 &amp;=&amp; \\dfrac{1}{2} acc_0\\\\ a_3 &amp;=&amp; \\dfrac{1}{2T^3}\\left\\{ 20(P_1 - P_0) - (8v_1 + 12v_0)T + (acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_4 &amp;=&amp; \\dfrac{1}{2T^4}\\left\\{ -30(P_1 - P_0) + (14v_1 + 16v_0)T -    (2acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_5 &amp;=&amp; \\dfrac{1}{2T^5}\\left\\{ 12(P_1 - P_0) - 6(v_1 + v_0)T +    (acc_1 - acc_0)T^2 \\right\\} \\end{array} \\]"},{"location":"tech_note/algorithm/poly_lerp/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30c3\u30c8\u5de5\u5b66\u306e\u57fa\u790e\uff08\u7b2c2\u7248\uff09</li> </ul>"},{"location":"tech_note/algorithm/poly_regression/","title":"\u56de\u5e30\u66f2\u7dda","text":""},{"location":"tech_note/algorithm/poly_regression/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/control/lqr/","title":"LQR","text":""},{"location":"tech_note/control/lqr/#_1","title":"\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f","text":""},{"location":"tech_note/control/lqr/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u7dda\u5f62\u4e8c\u6b21\u30ec\u30ae\u30e5\u30ec\u30fc\u30bf(Linear-Quadratic Regulator:LQR)\u306e\u6982\u8981\u3068Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9</li> <li>\u7dda\u5f62\u6700\u9069\u5236\u5fa1\uff08LQR\uff09\u3068Riccati\u30bd\u30eb\u30d0\u30fc\u306b\u3064\u3044\u3066</li> <li>LQR\u5236\u5fa1\u3068\u306f\u30fb\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u304d\u65b9</li> </ul>"},{"location":"tech_note/control/minphase/","title":"\u6700\u5c0f\u4f4d\u76f8\u7cfb\u30fb\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb","text":""},{"location":"tech_note/control/minphase/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3010\u5236\u5fa1\u5de5\u5b66\u3011\u4e0d\u5b89\u5b9a\u96f6\u70b9\u3068\u30a2\u30f3\u30c0\u30fc\u30b7\u30e5\u30fc\u30c8\uff08\u5236\u5fa1\u7406\u8ad6#7\uff09(YouTube)</li> <li>106\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb#\u3064\u3076\u3084\u304d\u5236\u5fa1\u5de5\u5b66 (YouTube)</li> </ul>"},{"location":"tech_note/control/nctf/","title":"NCTF","text":""},{"location":"tech_note/control/pfc/","title":"PFC","text":""},{"location":"tech_note/control/pfc/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>Predictive Functional Control\u306e\u5b9f\u88c5</li> </ul>"},{"location":"tech_note/control/pid/","title":"PID","text":"<p>\u53e4\u5178\u5236\u5fa1\u306e\u4ee3\u8868\u7684\u306a\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u5668\u3002\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3092\u3001\u72b6\u614b\u91cf\u3068\u76ee\u6a19\u5024\u306e\u5dee\u5206\u3001\u305d\u306e\u7a4d\u5206\u5024\u3001\u5fae\u5206\u5024\u306b\u3088\u3063\u3066\u6c7a\u5b9a\u3059\u308b\u30023\u3064\u306e\u5024\u306b\u5bfe\u3057\u3066\u30b2\u30a4\u30f3\u3092\u304b\u3051\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5fdc\u7b54\u3092\u8abf\u6574\u3059\u308b\u3002</p> \\[ u(t) = K_p e + K_i \\int_0^t e dt + K_d \\dot{e} \\] <p>PID\u5236\u5fa1\u5668\u306f\u4e0a\u8a18\u306e\u3088\u3046\u306b\u8868\u3055\u308c\u3001\\(K_p\\), \\(K_i\\), \\(K_d\\)\u3092\u305d\u308c\u305e\u308c\u6bd4\u4f8b\u30b2\u30a4\u30f3\u3001\u7a4d\u5206\u30b2\u30a4\u30f3\u3001\u5fae\u5206\u30b2\u30a4\u30f3\u3068\u547c\u3076\u3002</p> <p>\u7a4d\u5206\u9805\u3001\u5fae\u5206\u9805\u306e\u4fc2\u6570\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u8a18\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002</p> \\[ u(t) = K_p \\left( e + \\frac{1}{T_i} \\int_0^t e dt + T_d \\dot{e} \\right) \\text{ \u305f\u3060\u3057}K_i=K_p/T_i, Kd = K_pT_d \\] <p>\u3053\u3053\u3067\\(T_i\\)\u306f\u7a4d\u5206\u6642\u9593\u3068\u547c\u3070\u308c\\(T_d\\)\u306f\u5fae\u5206\u6642\u9593\u3068\u547c\u3070\u308c\u308b\u3002</p>"},{"location":"tech_note/control/pid/#_1","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u8abf\u6574\u6cd5","text":""},{"location":"tech_note/control/pid/#_2","title":"\u9650\u754c\u611f\u5ea6\u6cd5","text":""},{"location":"tech_note/control/pid/#_3","title":"\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u6cd5","text":""},{"location":"tech_note/control/pid/#chr","title":"CHR\u6cd5","text":""},{"location":"tech_note/control/pid/#_4","title":"\u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7","text":"<p>\u7a4d\u5206\u9805\u304c\u6709\u52b9\u306aPID\u5236\u5fa1\u5668\u306e\u5834\u5408\u3001\u504f\u5dee\u304c\u9577\u3044\u6642\u9593\u306b\u6e21\u3063\u3066\u5b58\u5728\u3059\u308b\u3068\u7a4d\u5206\u5024\u304c\u5927\u304d\u304f\u306a\u308a\u5165\u529b\u91cf\u304c\u98fd\u548c\u3059\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u3053\u308c\u3092\u9632\u3050\u305f\u3081\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b\u3002</p>"},{"location":"tech_note/control/pid/#_5","title":"\u7a4d\u5206\u306e\u505c\u6b62","text":"<p>\u4e00\u756a\u7c21\u5358\u306a\u624b\u6cd5\u3068\u3057\u3066\u7a4d\u5206\u3092\u505c\u6b62\u3055\u305b\u308b\u3053\u3068\u304c\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u308c\u306fPID\u5236\u5fa1\u306e\u51fa\u529b\u304c\u98fd\u548c\u3057\u305f\u3068\u304d\u306b\u306f\u7a4d\u5206\u9805\u3078\u306e\u5165\u529b\u3092\u305d\u308c\u4ee5\u4e0a\u7a4d\u5206\u9805\u304c\u5927\u304d\u304f\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u7c21\u5358\u3067\u3042\u308b\u304c\u4eba\u306b\u3088\u3063\u3066\u5b9f\u88c5\u65b9\u6cd5\u306b\u3086\u3089\u304e\u304c\u51fa\u3084\u3059\u3044</p>"},{"location":"tech_note/control/pid/#_6","title":"\u81ea\u52d5\u6574\u5408","text":"<p>\u81ea\u52d5\u6574\u5408\u3084\u9006\u89e3\u6790\u3068\u547c\u3070\u308c\u308b\u3053\u306e\u624b\u6cd5\u306f\u3001\u7d14\u7c8b\u306aPID\u306e\u51fa\u529b\u3068\u98fd\u548c\u3057\u3066\u5236\u9650\u304c\u304b\u304b\u3063\u305f\u51fa\u529b\u306e\u5dee\u5206\u3092PD\u5236\u5fa1\u5668\u306e\u9006\u30b7\u30b9\u30c6\u30e0\u3092\u901a\u3057\u3066\u7a4d\u5206\u9805\u3078\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b\u5f62\u3092\u53d6\u308b\u3002</p>"},{"location":"tech_note/control/pid/#pid_1","title":"\u901f\u5ea6\u578bPID","text":"<p>\u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3068\u3044\u3046\u308f\u3051\u3067\u306f\u306a\u3044\u304c\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3057\u306a\u3044\u5f62\u306ePID\u5236\u5fa1\u5668\u306e\u5f62\u3068\u3057\u3066\u901f\u5ea6\u578bPID\u304c\u3042\u308b\u3002\u6700\u521d\u306b\u7d39\u4ecb\u3057\u305fPID\u5236\u5fa1\u5668\u306f\u4f4d\u7f6e\u578bPID\u3068\u547c\u3070\u308c\u5bfe\u6bd4\u3055\u308c\u308b\u3002\u901f\u5ea6\u578bPID\u306f\u504f\u5dee\u3092\u4e00\u968e\u5fae\u5206\u3057\u3066PID\u306b\u5165\u529b\u3059\u308b\u3053\u3068\u3067PID\u306e\u4e2d\u304b\u3089\u7a4d\u5206\u8981\u7d20\u3092\u6392\u9664\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u3042\u308b\u3002</p>"},{"location":"tech_note/control/pid/#_7","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>PID\u5236\u5fa1</li> <li>PID\u5236\u5fa1\u3068\u306f\uff1f\u4ed5\u7d44\u307f\u3068\u52d5\u4f5c\u30a4\u30e1\u30fc\u30b8\u3092\u5206\u304b\u308a\u3084\u3059\u304f\u89e3\u8aac\uff01</li> <li>PID\u5236\u5fa1\u5668\u306eAnti-windup</li> </ul>"},{"location":"tech_note/control/pid2/","title":"2\u81ea\u7531\u5ea6PID","text":"<p>2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306bPID\u3092\u4f7f\u7528\u3057\u305f\u3082\u306e\u30922\u81ea\u7531\u5ea6PID\u3068\u547c\u3076\u3002 2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u3068\u306f\u76ee\u6a19\u5024\u3068\u72b6\u614b\u91cf\u306e2\u3064\u306e\u60c5\u5831\u3092\u6271\u3063\u3066\u5236\u5fa1\u3059\u308b\u5236\u5fa1\u7cfb\u3092\u6307\u3059\u3002 \u5358\u7d14\u306aPID\u5236\u5fa1\u7cfb\u306b\u3082\u76ee\u6a19\u5024\u306e\u5165\u529b\u3068\u72b6\u614b\u91cf\u306e\u51fa\u529b\u306f\u5b58\u5728\u3059\u308b\u304cPID\u5236\u5fa1\u5668\u3078\u306e\u5165\u529b\u306f\u305d\u308c\u3089\u306e\u5dee\u5206\u3067\u3042\u308b\u504f\u5dee\u306e\u307f\u3067\u3042\u308b\u305f\u3081\u81ea\u7531\u5ea6\u306f1\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/control/pid2/#2","title":"2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306e\u30d6\u30ed\u30c3\u30af\u56f3","text":"<p>2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306f\u30d6\u30ed\u30c3\u30af\u56f3\u3067\u8003\u3048\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u578b\u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"tech_note/control/pid2/#_1","title":"\u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u578b","text":"<p>\u5165\u529b\u306b\u76ee\u6a19\u5024\u3068\u504f\u5dee\u3092\u53d6\u308b 2\u3064\u306ePID\u306e\u51fa\u529b\u3092\u8db3\u3057\u5408\u308f\u305b\u3066\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3068\u3059\u308b</p> \\[ u_{ff} = K_{pff}r + K_{dff} s r \\\\ u_{fb} = K_{pfb}(r-y) + \\frac{K_i}{s}(r-y) + K_{dfb}s(r-y) \\\\ u = u_{ff} + u_{fb} \\]"},{"location":"tech_note/control/pid2/#_2","title":"\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u578b","text":"<p>\u5165\u529b\u306b\u504f\u5dee\u3068\u72b6\u614b\u91cf\u3092\u53d6\u308b 2\u3064\u306ePID\u306e\u51fa\u529b\u3092\u8db3\u3057\u5408\u308f\u305b\u3066\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3068\u3059\u308b</p>"},{"location":"tech_note/control/pid2/#_3","title":"\u30d5\u30a3\u30eb\u30bf\u30fc\u578b","text":"<p>\u5165\u529b\u306b\u76ee\u6a19\u5024\u3068\u504f\u5dee\u3092\u53d6\u308b \u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u578b\u3068\u9055\u3063\u3066\u76ee\u6a19\u5024\u3092\u5165\u529b\u306b\u53d6\u308b\u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u51fa\u529b\u3068\u72b6\u614b\u91cf\u306e\u5dee\u3092\u504f\u5dee\u3068\u3059\u308b \u504f\u5dee\u3092\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u5165\u529b\u3068\u3057\u3066\u305d\u306e\u51fa\u529b\u3092\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3068\u3059\u308b</p>"},{"location":"tech_note/control/pid2/#_4","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u5171\u901a\u5316","text":"<p>\u4e0a\u8a18\u306e\u3088\u3046\u306b2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u69cb\u9020\u304c\u3042\u308b (\u307e\u3068\u3081\u3066\u6271\u3048\u308b\u3088\u3046\u306b\u304b\u3069\u3046\u304b\u306f\u308f\u304b\u3089\u306a\u3044\u304c)\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u5f62\u306e\u3082\u306e\u304c\u3088\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b</p> \\[ u = K_p(br-y) + \\frac{K_i}{s}(r-y) + K_d s (cr-y) \\]"},{"location":"tech_note/control/pid2/#2pid_1","title":"\u30d5\u30a3\u30fc\u30c9\u30d5\u30a9\u30ef\u30fc\u30c9\u578b2\u81ea\u7531\u5ea6PID\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u5171\u901a\u5316","text":"\\[ b = \\frac{K_{pff} + K_{pfb}}{K_{pfb}} \\\\ c = \\frac{K_{dff} + K_{dfb}}{K_{dfb}} \\]"},{"location":"tech_note/control/pid2/#2pid_2","title":"\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u578b2\u81ea\u7531\u5ea6PID\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u5171\u901a\u5316","text":""},{"location":"tech_note/control/pid2/#2pid_3","title":"\u30d5\u30a3\u30eb\u30bf\u30fc2\u81ea\u7531\u5ea6PID\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u5171\u901a\u5316","text":""},{"location":"tech_note/control/pid2/#pidpi-d","title":"\u5fae\u5206\u5148\u884c\u578bPID(PI-D)","text":"<p>\u5fae\u5206\u9805\u3092\u504f\u5dee\u306e\u5fae\u5206\u3067\u306f\u306a\u304f\u72b6\u614b\u91cf\u306e\u5fae\u5206\u306b\u3059\u308b\u3053\u3068\u3067\u76ee\u6a19\u5024\u306e\u6025\u6fc0\u306a\u5909\u5316\u306b\u3088\u308b\u30ad\u30c3\u30af\u306e\u767a\u751f\u3092\u6291\u3048\u308b\u52b9\u679c\u304c\u3042\u308b $$ b = 1 \\ c = 0 $$</p>"},{"location":"tech_note/control/pid2/#pidi-pd","title":"\u6bd4\u4f8b\u5fae\u5206\u5148\u884c\u578bPID(I-PD)","text":"<p>\u6bd4\u4f8b\u9805\u3068\u5fae\u5206\u9805\u3092\u72b6\u614b\u91cf\u304b\u3089\u6c42\u3081\u308b\u3053\u3068\u3067\u30ad\u30c3\u30af\u306e\u767a\u751f\u3092\u6291\u3048\u308b\u52b9\u679c\u304c\u3042\u308b\u3002\u76ee\u6a19\u5024\u306e\u5909\u5316\u306b\u8ffd\u5f93\u3059\u308b\u6210\u5206\u304c\u7a4d\u5206\u9805\u306e\u307f\u306b\u306a\u308b\u305f\u3081\u4fdd\u5b88\u7684\u306a\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u306a\u308b</p> \\[ b = 0 \\\\ c = 0 \\]"},{"location":"tech_note/control/pid2/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>2 \u81ea\u7531\u5ea6 PID \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc</li> <li>2-DOF PID \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc\u306e SISO \u30b3\u30f3\u30dd\u30fc\u30cd\u30f3\u30c8\u3078\u306e\u5206\u89e3</li> <li>zpk</li> </ul>"},{"location":"tech_note/control/place/","title":"\u6975\u914d\u7f6e\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af","text":""},{"location":"tech_note/control/place/#_2","title":"\u7c21\u5358\u306a\u30b7\u30b9\u30c6\u30e0\u306e\u624b\u8a08\u7b97\u306b\u3088\u308b\u6975\u914d\u7f6e","text":""},{"location":"tech_note/control/place/#_3","title":"\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308b\u6975\u914d\u7f6e","text":"<p>\u6570\u5024\u8a08\u7b97\u3067\u6975\u914d\u7f6e\u3092\u884c\u3046\u306b\u306fSISO\u30e2\u30c7\u30eb\u306b\u5bfe\u3057\u3066\u306f\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u3068\u3044\u3046\u3082\u306e\u304c\u63d0\u5531\u3055\u308c\u3066\u304d\u305f\u3002</p> <p>\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u65b9\u3067\u306f\u4ee5\u4e0b\u306e\u624b\u9806\u3067\u6975\u914d\u7f6e\u3092\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u6c42\u3081\u308b\u3002</p> <ol> <li>\u914d\u7f6e\u3057\u305f\u3044\u6975\u306e\u5024\u304b\u3089\u7279\u6027\u65b9\u7a0b\u5f0f\u306b\u5c55\u958b\u3059\u308b</li> <li>\u30b7\u30b9\u30c6\u30e0\u306e\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092\u6c42\u3081\u308b</li> <li>\u53ef\u5236\u5fa1\u6027\u884c\u5217\\(U_c\\)\u3068\u30b7\u30b9\u30c6\u30e0\u306e\u9077\u79fb\u884c\u5217\\(A\\)\u3068\u7279\u6027\u65b9\u7a0b\u5f0f\u306e\u4fc2\u6570\\(d_n\\)\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a08\u7b97\u3059\u308b</li> </ol> \\[ \\begin{array}{l} K = [0 &amp; 0 &amp; 0 &amp; \\dots \\ &amp; 1]U_c^{-1}(A^n + d_{n-1}A^{n-1} + \\dots + d_{2}A^{2} + d_{1}A^{1} + d_{0}I) \\end{array} \\] <p>\u3053\u308c\u306b\u3088\u308a\u6c42\u3081\u305f\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\\(K\\)\u3067\\(u = -Kx\\)\u306e\u3088\u3046\u306b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3092\u884c\u3046\u3002</p>"},{"location":"tech_note/control/place/#_4","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6975\u914d\u7f6e\u306e\u5b9f\u88c5\uff1a\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\uff0cEigenvalueStructure\u6cd5\u306eMATLAB\u5b9f\u88c5</li> </ul>"},{"location":"tech_note/control/pole_and_zero/","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975\u30fb\u96f6\u70b9","text":""},{"location":"tech_note/control/pole_and_zero/#_2","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975","text":""},{"location":"tech_note/control/pole_and_zero/#_3","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u96f6\u70b9","text":""},{"location":"tech_note/control/pole_and_zero/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/control/pure_pursuit/","title":"Pure pursuit","text":""},{"location":"tech_note/control/stability/","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027\u3068\u306f</p>"},{"location":"tech_note/control/stability/#_2","title":"\u5b89\u5b9a\u5224\u5225","text":""},{"location":"tech_note/control/stability/#_3","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/filter/extend_kalman_filter/","title":"\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf","text":"<p>\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306f\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u3057\u304b\u6271\u3046\u3053\u3068\u304c\u51fa\u6765\u306a\u304b\u3063\u305f\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306e\u7406\u8ad6\u3092\u975e\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306b\u307e\u3067\u62e1\u5f35\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/filter/extend_kalman_filter/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/filter/kalman_filter/","title":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf","text":"<p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3068\u306f\u7dda\u5f62\u306e\u904b\u52d5\u30e2\u30c7\u30eb\u3068\u89b3\u6e2c\u30e2\u30c7\u30eb\u304b\u3089\u72b6\u614b\u3092\u63a8\u5b9a\u3059\u308b\u30d5\u30a3\u30eb\u30bf\u306e\u4e00\u7a2e\u3067\u3042\u308b</p>"},{"location":"tech_note/filter/kalman_filter/#_2","title":"\u96e2\u6563\u5316\u30e2\u30c7\u30eb","text":"<p>\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f\u3067\u96e2\u6563\u5316\u3057\u305f\u7dda\u5f62\u30e2\u30c7\u30eb\u304c\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3068\u3059\u308b\u3002</p> \\[ \\begin{array}{lll} x(t) = Fx(t-1) + Gu(t) + w(t) \\\\ z(t) = Hx(t) + v(t) \\end{array} \\] <p>\u3053\u3053\u3067\u5404\u5909\u6570\u306f\u4ee5\u4e0b\u306e\u901a\u308a \\(x \\in \\mathbb{R}^{n \\times 1}\\) : \u72b6\u614b\u91cf \\(u \\in \\mathbb{R}^{r \\times 1}\\) : \u5236\u5fa1\u91cf \\(z \\in \\mathbb{R}^{p \\times 1}\\) : \u89b3\u6e2c\u91cf \\(F \\in \\mathbb{R}^{n \\times n}\\) : \u72b6\u614b\u9077\u79fb\u884c\u5217 \\(G \\in \\mathbb{R}^{n \\times r}\\) : \u5236\u5fa1\u884c\u5217 \\(H \\in \\mathbb{R}^{p \\times n}\\) : \u89b3\u6e2c\u884c\u5217  </p> <p>\\(Q \\in \\mathbb{R}^{n \\times n}\\) : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 \\(w \\in \\mathbb{R}^{n \\times 1}\\) : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba \\(N[0, Q]\\)\u306b\u5f93\u3046 \\(R \\in \\mathbb{R}^{p \\times p}\\) : \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 \\(v \\in \\mathbb{R}^{p \\times 1}\\) : \u89b3\u6e2c\u30ce\u30a4\u30ba \\(N[0, R]\\)\u306b\u5f93\u3046</p>"},{"location":"tech_note/filter/kalman_filter/#_3","title":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306b\u4e0e\u3048\u305f\u5165\u529b\\(u\\)\u3068\u8aa4\u5dee\u304c\u3042\u308b\u89b3\u6e2c\u91cf\\(z\\)\u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf\\(\\bar{x}\\)\u3092\u63a8\u5b9a\u3059\u308b\u3002</p> <p>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306b\u306f\u5927\u304d\u304f\u5206\u3051\u3066\u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7\u3068\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7\u306b\u5206\u3051\u3089\u308c\u308b\u3002</p>"},{"location":"tech_note/filter/kalman_filter/#_4","title":"\u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7","text":""},{"location":"tech_note/filter/kalman_filter/#_5","title":"\u4e8b\u524d\u72b6\u614b\u63a8\u5b9a","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u3092\u4f7f\u3063\u3066\u3001\u524d\u30b9\u30c6\u30c3\u30d7\u306e\u72b6\u614b\u91cf\u3068\u5165\u529b\u91cf\u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf\u304c\u3069\u3046\u306a\u308b\u304b\u3092\u8a08\u7b97\u3059\u308b</p> \\[ \\bar{x} = F\\bar{x} + Gu \\]"},{"location":"tech_note/filter/kalman_filter/#_6","title":"\u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0","text":"<p>\u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\u3067\u72b6\u614b\u3092\u66f4\u65b0\u3057\u305f\u3053\u3068\u306b\u3088\u308b\u72b6\u614b\u306e\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b</p> \\[ P = FPF^T + Q \\]"},{"location":"tech_note/filter/kalman_filter/#_7","title":"\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7","text":""},{"location":"tech_note/filter/kalman_filter/#_8","title":"\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u306e\u8a08\u7b97","text":"<p>\u72b6\u614b\u306e\u4e0d\u78ba\u304b\u3055\u3068\u89b3\u6e2c\u306e\u4e0d\u78ba\u304b\u3055\u304b\u3089\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b</p> \\[ K = PH^T(HPH^T + R)^-1 \\]"},{"location":"tech_note/filter/kalman_filter/#_9","title":"\u72b6\u614b\u63a8\u5b9a","text":"<p>\u8aa4\u5dee\u4ed8\u304d\u306e\u89b3\u6e2c\u91cf\u3068\u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u304b\u3089\u4e88\u6e2c\u3055\u308c\u308b\u89b3\u6e2c\u91cf\u306e\u5dee\u5206\u3092\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3067\u8abf\u6574\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b</p> \\[ \\bar{x} = \\bar{x} + K(z - H\\bar{x}) \\]"},{"location":"tech_note/filter/kalman_filter/#_10","title":"\u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0","text":"<p>\u72b6\u614b\u63a8\u5b9a\u306e\u66f4\u65b0\u306e\u5206\u306e\u72b6\u614b\u91cf\u306e\u4e0d\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b</p> \\[ P = (I -KH)P \\]"},{"location":"tech_note/filter/kalman_filter/#_11","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3063\u3066\u306a\u306b\uff1f</li> <li>\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u30fc</li> <li>\u88cf\u53e3\u304b\u3089\u306e\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u5165\u9580 (YouTube)</li> </ul>"},{"location":"tech_note/filter/limitted_filter/","title":"\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u30fb\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf","text":"<p>\u3053\u3053\u3067\u306f\u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u308b\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3068\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u306b\u3064\u3044\u3066\u8aac\u660e\u3092\u3057\u3066\u3044\u304f\u3002</p>"},{"location":"tech_note/filter/limitted_filter/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/filter/tf_filter/","title":"\u4f1d\u9054\u95a2\u6570\u3067\u8868\u73fe\u3055\u308c\u308b\u30d5\u30a3\u30eb\u30bf","text":"\u8aac\u660e \u4f1d\u9054\u95a2\u6570 \u96e2\u6563\u4f1d\u9054\u95a2\u6570(\u53cc\u4e00\u6b21\u5909\u63db) \u7a4d\u5206\u8981\u7d20 \\(\\dfrac{1}{s}\\) \\(\\dfrac{T}{2} \\dfrac{z+1}{z-1}\\) \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{\\omega}{s + \\omega}\\) \\(\\dfrac{T\\omega z + T\\omega}{(T\\omega + 2)z + (T\\omega - 2)}\\) \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{s}{s + \\omega}\\) \\(\\dfrac{2z - 2}{(T\\omega + 2)z + (T\\omega - 2)}\\) \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{2\\zeta\\omega s}{s^2 + 2\\zeta\\omega s + \\omega^2}\\) \\(\\dfrac{(4T\\zeta\\omega)z^2 + (-4T\\zeta\\omega) }{(4+ 4T\\zeta \\omega +T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4-4T\\zeta \\omega + T^2\\omega^2)}\\) \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf \\(\\dfrac{s^2 + \\omega^2}{s^2 + 2\\zeta\\omega s + \\omega^2}\\) \\(\\dfrac{(4+T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4+T^2\\omega^2)}{(4+ 4T\\zeta \\omega +T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4-4T\\zeta \\omega + T^2\\omega^2)}\\) \u8aac\u660e \u4f1d\u9054\u95a2\u6570 \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(2\u6b21) \\(\\dfrac{1}{\\tau^2s^2 + \\sqrt{2} \\tau s + 1 }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(3\u6b21) \\(\\dfrac{1}{(\\tau s + 1)(\\tau^2s^2 + \\tau s + 1) }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(4\u6b21) \\(\\dfrac{1}{(\\tau^2s^2 + 0.7654 \\tau s + 1)(\\tau^2s^2 + 1.8478\\tau s + 1) }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(5\u6b21) \\(\\dfrac{1}{(\\tau s + 1)(\\tau^2s^2 + 0.6180\\tau s + 1)(\\tau^2s^2 + 1.6180\\tau s + 1) }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(n\u6b21: n\u304c\u5076\u6570) \\(\\dfrac{1}{ \\prod_{k=1}{\\frac{n}{2}} \\left[ \\tau^2 s^2 -2 \\tau s \\cos \\left( \\dfrac{2k+n-1}{2n}\\pi \\right) + 1 \\right] }\\) \u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf(n\u6b21: n\u304c\u5947\u6570) \\(\\dfrac{1}{ (\\tau s + 1) \\prod_{k=1}{\\frac{n-1}{2}} \\left[ \\tau^2s^2 - 2 \\tau s \\cos \\left( \\dfrac{2k+n-1}{2n}\\pi \\right) + 1 \\right] }\\)"},{"location":"tech_note/filter/tf_filter/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u53cc\u4e00\u6b21\u5909\u63db (Wikipedia)</li> <li>\u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u30d5\u30a3\u30eb\u30bf</li> <li>\u30d0\u30bf\u30fc\u30ef\u30fc\u30b9\u578b\u30ed\u30fc\u30d1\u30b9\u30fb\u30d5\u30a3\u30eb\u30bf</li> </ul>"},{"location":"tech_note/geometry/geometry/","title":"\u56f3\u5f62\u306e\u885d\u7a81\u5224\u5b9a","text":""},{"location":"tech_note/kinematics/delta_robot/","title":"\u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8","text":""},{"location":"tech_note/kinematics/delta_robot/#_2","title":"\u9806\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/delta_robot/#_3","title":"\u9006\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/delta_robot/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/kinematics/diff_robot/","title":"\u5dee\u52d5\u4e8c\u8f2a","text":""},{"location":"tech_note/kinematics/diff_robot/#_2","title":"\u9806\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/diff_robot/#_3","title":"\u9006\u904b\u52d5\u5b66","text":""},{"location":"tech_note/kinematics/diff_robot/#_4","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/kinematics/mecanum/","title":"\u30e1\u30ab\u30ca\u30e0\u79fb\u52d5\u6a5f\u69cb","text":"<p>\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u30e1\u30ab\u30ca\u30e0\u30db\u30a4\u30fc\u30eb\u306e\u6a3d\u306e\u8ef8\u65b9\u5411\u306e\u307f\u306b\u529b\u304c\u4f5c\u7528\u3059\u308b\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\u3068</p> \\[ v_1 \\cos \\frac{\\pi}{4} = - \\dot{x} \\cos \\frac{\\pi}{4} + \\dot{y} \\cos \\frac{\\pi}{4} + l \\dot{\\theta} \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right) \\] <p>\u5f0f\u6574\u7406\u3057\u3066</p> \\[ v_1 = - \\dot{x} + \\dot{y} + (a+b)\\dot{\\theta}  \\] <p>\u3053\u3053\u3067\u53f3\u8fba\u7b2c3\u9805\u306e\\(\\dot{\\theta}\\)\u306b\u3064\u3044\u3066\u306e\u5f0f\u5909\u5f62\u306b\u3064\u3044\u3066\u4e0b\u8a18\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[     \\frac{l \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right)}{\\cos \\frac{\\pi}{4} } \\dot{\\theta}\\\\ \\] <p>\u5206\u5b50\u306b\u52a0\u6cd5\u5b9a\u7406\u3092\u9069\u7528</p> \\[ \\begin{array}{cc}     \\frac{l \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right)}{\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\     \\Leftrightarrow      \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\sin \\frac{\\pi}{4} \\right\\}}     {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\     \\Leftrightarrow      \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\cos \\frac{\\pi}{4} \\right\\}}     {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\     \\Leftrightarrow      l \\left( \\cos \\alpha + \\sin \\alpha \\right) \\dot{\\theta}\\\\     \\Leftrightarrow      l \\left( \\frac{a}{l} + \\frac{b}{l} \\right) \\dot{\\theta}\\\\     \\Leftrightarrow      \\left(a +b \\right) \\dot{\\theta} \\end{array} \\] <p>4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -1 &amp;  1 &amp; (a+b) \\\\ -1 &amp; -1 &amp; (a+b) \\\\  1 &amp; -1 &amp; (a+b) \\\\  1 &amp;  1 &amp; (a+b) \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \\] <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/mecanum/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76     \u53c2\u8003\u6587\u732e\u3068\u306f\u30bf\u30a4\u30e4\u306e\u56de\u8ee2\u65b9\u5411\u306e\u5b9a\u7fa9\u304c\u7570\u306a\u308b\u305f\u3081\u9006\u904b\u52d5\u5b66\u304c\u7570\u306a\u308b\u3053\u3068\u306b\u6ce8\u610f</li> </ul>"},{"location":"tech_note/kinematics/omni/","title":"\u30aa\u30e0\u30cb\u79fb\u52d5\u6a5f\u69cb","text":""},{"location":"tech_note/kinematics/omni/#3","title":"3\u8f2a\u30aa\u30e0\u30cb","text":"<p>\u56f3\u306e\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066</p> \\[ v_1 = - \\dot{x} \\sin \\alpha + \\dot{y} \\cos \\alpha + L \\dot{\\theta} \\] <p>3\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha &amp; \\cos\\alpha &amp; L \\\\ -\\sin \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) &amp; \\cos \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) &amp; L \\\\ -\\sin \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) &amp; \\cos \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) &amp; L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \\] <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/omni/#4","title":"4\u8f2a\u30aa\u30e0\u30cb","text":"<p>\u5404\u8eca\u8f2a\u3054\u3068\u306b\u8003\u3048\u308b\u3053\u3068\u306f3\u8f2a\u30aa\u30e0\u30cb\u3068\u5909\u308f\u3089\u306a\u3044</p> \\[ \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha &amp; \\cos\\alpha &amp; L \\\\ -\\sin \\left( \\alpha + \\dfrac{\\pi}{2} \\right) &amp; \\cos \\left( \\alpha + \\dfrac{\\pi}{2} \\right) &amp; L \\\\ -\\sin \\left( \\alpha + \\pi \\right) &amp; \\cos \\left( \\alpha + \\pi \\right) &amp; L \\\\ -\\sin \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) &amp; \\cos \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) &amp; L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \\] <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/omni/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76</li> </ul>"},{"location":"tech_note/kinematics/swerve/","title":"\u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb","text":"<p>\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u8003\u3048\u308b\u3068</p> \\[ \\vec{v_1} = \\left(      \\dot{x} -r \\dot{\\theta}\\sin{\\theta},      \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right) \\] <p>\u3053\u306e\u6642\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306e\u64cd\u8235\u89d2\u5ea6\u306f</p> \\[ \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}} \\] <p>4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{array}{} \\vec{v_1} = \\left(      \\dot{x} -r \\dot{\\theta}\\sin{\\theta},      \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_2} = \\left(      \\dot{x} -r \\dot{\\theta}\\cos{\\theta},      \\dot{y} -r \\dot{\\theta}\\sin{\\theta} \\right)\\\\ \\vec{v_3} = \\left(      \\dot{x} +r \\dot{\\theta}\\sin{\\theta},      \\dot{y} -r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_4} = \\left(      \\dot{x} +r \\dot{\\theta}\\cos{\\theta},      \\dot{y} +r \\dot{\\theta}\\sin{\\theta} \\right) \\end{array} \\] \\[ \\begin{array}{} \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_2 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} -r \\dot{\\theta}\\cos{\\theta}}\\\\ \\theta_3 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} +r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_4 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} +r \\dot{\\theta}\\cos{\\theta}}\\\\ \\end{array} \\] <p>\u5236\u5fa1\u3059\u308b\u969b\u306b\u306f\u64cd\u8235\u89d2\u306e\u89d2\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b\\(\\theta_j\\)\u3092\u4e0e\u3048\u3001\u30db\u30a4\u30fc\u30eb\u306e\u901f\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b\\(|\\vec{v_j}|\\)\u3092\u4e0e\u3048\u308b\u3002</p> <p>Note</p> <p>Todo: \u56f3\u3092\u8f09\u305b\u308b</p>"},{"location":"tech_note/kinematics/swerve/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76     \u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb\u306e\u9006\u904b\u52d5\u5b66\u306b\u3064\u3044\u3066\u3053\u306e\u30da\u30fc\u30b8\u3068\u53c2\u8003\u6587\u732e\u3067\\(v_1\\)\u306b\u3064\u3044\u3066\u306e\\(\\cos, \\sin\\)\u304c\u7570\u306a\u3063\u3066\u3044\u308b\u7b87\u6240\u304c\u5b58\u5728\u3059\u308b\u304c\u5c0e\u51fa\u3092\u8003\u3048\u308b\u3068\u53c2\u8003\u6587\u732e\u306e\u65b9\u306b\u8aa4\u690d\u304c\u3042\u308b\u3068\u8003\u3048\u3089\u308c\u308b</li> </ul>"},{"location":"tech_note/motor/mabuchi/","title":"\u30de\u30d6\u30c1\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a","text":"<p>\u30de\u30d6\u30c1\u306e\u88fd\u54c1\u30da\u30fc\u30b8\u306b\u306f\u3053\u306e\u3088\u3046\u306b\u6027\u80fd\u8868\u304c\u8f09\u3063\u3066\u3044\u308b\u304c\u3053\u3053\u306e\u60c5\u5831\u304b\u3089\u8a08\u7b97\u3092\u3057\u3066\u9759\u7279\u6027\u3092\u89e3\u6790\u3059\u308b</p> <p></p> <p></p>"},{"location":"tech_note/motor/mabuchi/#_2","title":"\u9759\u7279\u6027","text":"<p>\u9759\u7279\u6027\u306f\u516c\u958b\u3057\u3066\u3042\u308b\u6027\u80fd\u8868\u304b\u3089\u8a08\u7b97\u304c\u51fa\u6765\u308b\u3002\u500b\u4f53\u5024\u3082\u3042\u308b\u306e\u3067\u53c2\u8003\u7a0b\u5ea6</p>"},{"location":"tech_note/motor/mabuchi/#v","title":"\u516c\u79f0\u96fb\u5727[V]","text":"<p>VOLTAGE - NOMINAL</p>"},{"location":"tech_note/motor/mabuchi/#rpm","title":"\u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm]","text":"<p>NO LOAD - SPEED</p>"},{"location":"tech_note/motor/mabuchi/#a","title":"\u7121\u8ca0\u8377\u6642\u96fb\u6d41[A]","text":"<p>NO LOAD - CURRENT</p>"},{"location":"tech_note/motor/mabuchi/#a_1","title":"\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41[A]","text":"<p>STALL - CURRENT</p>"},{"location":"tech_note/motor/mabuchi/#_3","title":"\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af","text":"<p>STALL - TORQUE</p>"},{"location":"tech_note/motor/mabuchi/#ohm","title":"\u96fb\u6a5f\u5b50\u62b5\u6297[ohm]","text":"<p>\u516c\u79f0\u96fb\u5727 / \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41</p>"},{"location":"tech_note/motor/mabuchi/#nma","title":"\u30c8\u30eb\u30af\u5b9a\u6570[Nm/A]","text":"<p>\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af / (\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41 - \u7121\u8ca0\u8377\u96fb\u6d41)</p>"},{"location":"tech_note/motor/mabuchi/#vrads","title":"\u9006\u6c17\u96fb\u529b\u5b9a\u6570[V/(rad/s)]","text":"<p>(\u516c\u79f0\u96fb\u5727 - \u96fb\u6a5f\u5b50\u62b5\u6297\u00d7\u7121\u8ca0\u8377\u96fb\u6d41)/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]</p>"},{"location":"tech_note/motor/mabuchi/#nm","title":"\u30c8\u30eb\u30af\u640d\u5931[Nm]","text":"<p>\u7121\u8ca0\u8377\u6642\u96fb\u6d41\u00d7\u30c8\u30eb\u30af\u5b9a\u6570</p>"},{"location":"tech_note/motor/mabuchi/#nms","title":"\u7c98\u6027\u4fc2\u6570[Nms]","text":"<p>\u30c8\u30eb\u30af\u640d\u5931/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]</p>"},{"location":"tech_note/motor/mabuchi/#_4","title":"\u52d5\u7279\u6027","text":"<p>\u52d5\u7279\u6027\u306f\u6027\u80fd\u8868\u304b\u3089\u306f\u308f\u304b\u3089\u306a\u3044\u306e\u3067\u8a08\u6e2c\u3059\u308b</p>"},{"location":"tech_note/motor/mabuchi/#h","title":"\u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H]","text":""},{"location":"tech_note/motor/mabuchi/#s","title":"\u96fb\u6c17\u7684\u6642\u5b9a\u6570[s]","text":"<p>\u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9/\u96fb\u6a5f\u5b50\u62b5\u6297</p>"},{"location":"tech_note/motor/mabuchi/#kgm2","title":"\u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2]","text":"<p>\u52d5\u7279\u6027\u306f\u6027\u80fd\u8868\u304b\u3089\u306f\u308f\u304b\u3089\u306a\u3044\u306e\u3067\u8a08\u6e2c\u3059\u308b</p>"},{"location":"tech_note/motor/mabuchi/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>RS-555VC-3754</li> </ul>"},{"location":"tech_note/motor/motor_model/","title":"\u30e2\u30fc\u30bf\u30fc\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe","text":"\\[ \\begin{array}{l} \\frac{\\rm{d}}{\\rm{dt}} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} = \\begin{bmatrix} -\\frac{R}{L} &amp; -\\frac{K_e}{L} \\\\ \\frac{K_t}{J} &amp; 0 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} +  \\begin{bmatrix} \\frac{1}{L}\\\\ 0 \\end{bmatrix} V(t) \\\\ y(t) = \\begin{bmatrix} 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} \\end{array} \\]"},{"location":"tech_note/motor/motor_model/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u73fe\u4ee3\u5236\u5fa1 2\u6b21\u30b7\u30b9\u30c6\u30e0(RL\u56de\u8def+\u30e2\u30fc\u30bf\u30fc)\u306e\u72b6\u614b\u65b9\u7a0b\u5f0f</li> </ul>"},{"location":"tech_note/optimal_control/linear_mpc/","title":"\u6642\u4e0d\u5909\u7dda\u5f62MPC","text":""},{"location":"tech_note/optimal_control/linear_mpc/#_1","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/optimal_control/mpc/","title":"\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1","text":""},{"location":"tech_note/optimal_control/mpc/#mpc","title":"\u7dda\u5f62\u30e2\u30c7\u30ebMPC","text":""},{"location":"tech_note/optimal_control/mpc/#mpcnmpc","title":"\u975e\u7dda\u5f62\u30e2\u30c7\u30ebMPC(NMPC)","text":""},{"location":"tech_note/optimal_control/mpc/#cgmres","title":"C/GMRES\u6cd5","text":""},{"location":"tech_note/optimal_control/mpc/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580</li> <li>Model Predictive Control:MPC (\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1)\u306e\u6280\u8853\u5206\u985e</li> <li>\u30b7\u30f3\u30d7\u30eb\u306aMPC\u6700\u9069\u5316\u30e2\u30c7\u30ea\u30f3\u30b0\u306e\u6570\u5f0f\u5c0e\u51fa\u3068Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9</li> </ul>"},{"location":"tech_note/optimal_control/optimal_control/","title":"\u6700\u9069\u5236\u5fa1","text":""},{"location":"tech_note/optimal_control/optimal_control/#_2","title":"\u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f","text":"<p>\u30b7\u30b9\u30c6\u30e0\u30fb\u521d\u671f\u72b6\u614b\u30fb\u8a55\u4fa1\u95a2\u6570\u304c\u4e0e\u3048\u3089\u308c\u305f\u6642\u306b\u8a55\u4fa1\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u6700\u9069\u306a\u5236\u5fa1\u5165\u529b\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6\u3002\u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308bKKT\u6761\u4ef6\u3068\u8003\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_3","title":"\u52d5\u7684\u8a08\u753b\u6cd5","text":"<p>\u52d5\u7684\u8a08\u753b\u6cd5\u3067\u306f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5206\u91ce\u3067\u306f\u5bfe\u8c61\u3068\u306a\u308b\u554f\u984c\u3092\u8907\u6570\u306e\u90e8\u5206\u554f\u984c\u306b\u5206\u5272\u3057\u3001\u90e8\u5206\u554f\u984c\u306e\u8a08\u7b97\u7d50\u679c\u3092\u8a18\u9332\u3057\u306a\u304c\u3089\u89e3\u3044\u3066\u3044\u304f\u624b\u6cd5\u306e\u7dcf\u79f0\u3092\u6307\u3059\u3002 \u6700\u9069\u5236\u5fa1\u306b\u304a\u3051\u308b\u52d5\u7684\u8a08\u753b\u6cd5\u3068\u306f\u8a55\u4fa1\u95a2\u6570\u306e\u6700\u5c0f\u5024\u3092\u518d\u5e30\u7684\u306b\u8868\u3059\u624b\u6cd5\u306e\u3053\u3068\u3092\u6307\u3059\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_4","title":"\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f","text":"<p>\u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u3063\u3066\u8868\u3055\u308c\u305f\u5024\u95a2\u6570\u306e\u518d\u5e30\u4e00\u56de\u5206\u3092\u53d6\u308a\u51fa\u3057\u305f\u6642\u523bk\u3068\u6642\u523bk+1\u306e\u5024\u95a2\u6570\u306e\u95a2\u4fc2\u5f0f\u3002\u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f\u306b\u3088\u3063\u3066\u6700\u9069\u5236\u5fa1\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6\u304c\u5c0e\u304b\u308c\u308b\u304c\u3001\u6700\u9069\u5236\u5fa1\u554f\u984c\u304c\u6301\u3064\u6642\u9593\u7684\u306a\u69cb\u9020\u3092\u4f7f\u3046\u3053\u3068\u3067\u5c0e\u304b\u308c\u308b\u5225\u306e\u5f62\u306e\u6700\u9069\u6027\u6761\u4ef6\u304c\u3053\u306e\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u3067\u8868\u3055\u308c\u308b\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_5","title":"\u6700\u9069\u5236\u5fa1\u306e\u5fc5\u8981\u6761\u4ef6","text":"<p>\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u306e\u7d42\u7aef\u6761\u4ef6\u306e\u3082\u3068\u3067\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u304c\u6210\u7acb\u3059\u308b</p>"},{"location":"tech_note/optimal_control/optimal_control/#_6","title":"\u6700\u9069\u5236\u5fa1\u306e\u5341\u5206\u6761\u4ef6","text":""},{"location":"tech_note/optimal_control/optimal_control/#_7","title":"\u5909\u5206\u6cd5","text":"<p>\u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u6700\u9069\u5236\u5fa1\u306b\u304a\u3044\u3066\u57fa\u790e\u3068\u306a\u308b\u3001\u95a2\u6570\u306e\u5fae\u5206\u3092\u6c4e\u95a2\u6570\u306b\u62e1\u5f35\u3057\u305f\u3082\u306e\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_8","title":"\u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5","text":"<p>\u4ee5\u4e0b\u306e\u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5\u306f\u30b7\u30b9\u30c6\u30e0\u304c\u9023\u7d9a\u6642\u9593\u3067\u3082\u96e2\u6563\u6642\u9593\u3067\u3082\u96e2\u6563\u7684\u306b\u6c42\u3081\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u96e2\u6563\u30b7\u30b9\u30c6\u30e0\u306e\u5834\u5408\u306f\u6570\u5024\u7684\u306b\u7a4d\u5206\u64cd\u4f5c\u3092\u884c\u3046\u306a\u3069\u306e\u64cd\u4f5c\u304c\u767a\u751f\u3059\u308b\u3002</p> \u6570\u5024\u89e3\u6cd5 \u9577\u6240 \u77ed\u6240 \u9069\u3059\u308b\u7528\u9014 \u52fe\u914d\u6cd5 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u4e0d\u8981 \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u9045\u3044 \u6700\u9069\u89e3\u306e\u304a\u304a\u3088\u305d\u306e\u69d8\u5b50\u3092\u624b\u8efd\u306b\u77e5\u308a\u305f\u3044\u6642 \u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5 \u672a\u77e5\u91cf\u304c\u6709\u9650\u6b21\u5143 \u8a08\u7b97\u304c\u767a\u6563\u3057\u3084\u3059\u3044 \u826f\u597d\u306a\u521d\u671f\u63a8\u5b9a\u89e3\u3092\u9078\u3079\u308b\u6642 \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(2\u6b21\u306e\u52fe\u914d\u6cd5) \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u901f\u3044 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u5fc5\u8981\u3067\u5404\u53cd\u5fa9\u306b\u304a\u3051\u308b\u8a08\u7b97\u91cf\u304c\u591a\u3044 \u6700\u9069\u89e3\u3092\u7cbe\u5ea6\u826f\u304f\u6c42\u3081\u305f\u3044\u6642 \u52d5\u7684\u8a08\u753b\u6cd5 \u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u304c\u5f97\u3089\u308c\u308b \u72b6\u614b\u306e\u6b21\u5143\u304c\u9ad8\u3044\u3068\u8a18\u61b6\u91cf\u304c\u81a8\u5927 \u72b6\u614b\u306e\u6b21\u5143\u304c\u4f4e\u3044\u304b\u3001\u72ed\u3044\u7bc4\u56f2\u3060\u3051\u8003\u616e\u3059\u308c\u3070\u826f\u3044\u6642"},{"location":"tech_note/optimal_control/optimal_control/#_9","title":"\u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5)","text":"<p>\u30cf\u30df\u30eb\u30c8\u30f3\u95a2\u6570\u306e\u5236\u5fa1\u5165\u529b\u504f\u5fae\u5206\\(\\frac{\\partial H}{\\partial u}\\)\u304c0\u306b\u306a\u308b\u307e\u3067\\(-\\frac{\\partial H}{\\partial u}\\)\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3001\u76f4\u7dda\u7dda\u63a2\u7d22\u3068\u7d44\u307f\u5408\u308f\u305b\u3066\\(u\\)\u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u3002\u968f\u4f34\u5909\u6570\u306f\u968f\u4f34\u65b9\u7a0b\u5f0f\u304b\u3089\\(\\frac{\\partial H}{\\partial x}\\)\u3092\u4f7f\u3063\u3066\u6c42\u3081\u308b\u3002\u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u5236\u5fa1\u91cf\\(u\\)\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_10","title":"\u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5","text":"<p>\u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u521d\u671f\u5024\u304b\u3089\u72b6\u614b\u91cf\u3092\u64cd\u4f5c\u3057\u3001\u7d42\u7aef\u6761\u4ef6\u3092\u5408\u308f\u305b\u306b\u3044\u304f\u69d8\u304c\u5c04\u6483\u306b\u4f3c\u3066\u3044\u308b\u3053\u3068\u304b\u3089\u3053\u306e\u540d\u304c\u3064\u3051\u3089\u308c\u305f\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_11","title":"\u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5","text":"<p>\u958b\u59cb\u6642\u9593\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u306e\u521d\u671f\u5024\u3092\u4e0e\u3048\u3001\u521d\u671f\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6761\u4ef6\u3068\u3057\u3066\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3092\u7d42\u7aef\u6642\u9593\u307e\u3067\u89e3\u304d\u3001\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6c42\u3081\u308b\u3002\u305d\u306e\u5f8c\u65b9\u7a0b\u5f0f\u304b\u3089\u5236\u5fa1\u91cf\u304c\u6c42\u307e\u308b\u3002\u7d42\u7aef\u6642\u523b\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u304c\\(\\frac{\\partial \\phi}{\\partial x}\\)\u306b\u5341\u5206\u306b\u8fd1\u3065\u304f\u307e\u3067\u968f\u4f34\u5909\u6570\u3092\u66f4\u65b0\u3059\u308b\u3002 \u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u968f\u4f34\u5909\u6570\\(\\lambda\\)\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#ddpdifferential-dynamic-programming","title":"DDP(Differential Dynamic Programming)","text":""},{"location":"tech_note/optimal_control/optimal_control/#ilqrinteractive-linear-quadratic-regulator","title":"iLQR(interactive Linear Quadratic Regulator)","text":""},{"location":"tech_note/optimal_control/optimal_control/#slqsequential-linear-quadratic-regulator","title":"SLQ(Sequential Linear Quadratic Regulator)","text":"\u6570\u5024\u89e3\u6cd5 \u53cd\u5fa9\u306b\u304a\u3051\u308b\u64cd\u4f5c\u91cf \u7279\u5fb4 \u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5 \u968f\u4f34\u5909\u6570 iLQR \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c\u30ac\u30a6\u30b9\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 DDP \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c2\u6b21\u8fd1\u4f3c\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 SLQ \u5236\u5fa1\u5165\u529b ???"},{"location":"tech_note/optimal_control/optimal_control/#_12","title":"\u5165\u529b\u91cf\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5)\u306b\u304a\u3044\u3066\u306ft\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\u306b\\(\\frac{\\partial H}{\\partial u}\\)\u3092\u4f7f\u7528\u3057\u305f\u304c\u3053\u308c\u306f\u6700\u9069\u5316\u554f\u984c\u30921\u6b21\u8fd1\u4f3c\u3057\u53cd\u5fa9\u306b\u3088\u3063\u3066\u6700\u9069\u89e3\u3092\u6c42\u3081\u3066\u3044\u308b\u3002\u306a\u3089\u3070\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3066\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u89e3\u304f\u3053\u3068\u3082\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u306e\u65b9\u6cd5\u3067\u306f\u7dda\u5f62\uff12\u70b9\u5883\u754c\u5024\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3067\\(\\delta x\\)\u3001\\(\\delta \\lambda\\)\u304c\u6c42\u3081\u3089\u308c\u305d\u3053\u304b\u3089\\(\\delta u\\)\u304c\u6c42\u3081\u3089\u308c\u308b\u305f\u3081\\(\\delta u\\)\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/optimal_control/optimal_control/#_13","title":"\u52d5\u7684\u8a08\u753b\u6cd5","text":""},{"location":"tech_note/optimal_control/optimal_control/#_14","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580</li> <li>Differential Dynamic Programming(DDP)/iterative LQR(iLQR)/Sequential LQR(SLQ)</li> </ul>"},{"location":"tech_note/optimize/active_set_method/","title":"\u6709\u52b9\u5236\u7d04\u6cd5","text":"<p>\u6709\u52b9\u5236\u7d04\u6cd5\u3068\u306f\u7dda\u5f62\u5236\u7d04\u3092\u6301\u3064\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b</p>"},{"location":"tech_note/optimize/algo_abst/","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u6982\u8981","text":"<p>\u3053\u3053\u3067\u306f\u5909\u6570\u30fb\u5236\u7d04\u306b\u53d6\u308b\u5024\u304c\u6574\u6570\u306b\u5236\u9650\u3055\u308c\u306a\u3044\u6700\u9069\u5316\u554f\u984c\u306b\u3064\u3044\u3066\u6982\u8981\u3092\u307e\u3068\u3081\u308b</p>"},{"location":"tech_note/optimize/algo_abst/#_2","title":"\u5358\u4f53\u6cd5(\u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5)","text":"<p>\u7dda\u5f62\u8a08\u753b\u554f\u984c\u3067\u4f7f\u7528\u3055\u308c\u308bDantzig\u306b\u3088\u3063\u3066\u63d0\u6848\u3055\u308c\u305f\u624b\u6cd5\u3002\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5883\u754c\u306b\u6cbf\u3063\u3066\u89e3\u3092\u66f4\u65b0\u3059\u308b\u3002\u5f8c\u306b\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u304c\u63d0\u6848\u3057\u305f\u591a\u9805\u5f0f\u6642\u9593\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u6955\u5186\u4f53\u6cd5\u306b\u3088\u3063\u3066\u666e\u53ca\u3057\u305f\u5185\u70b9\u6cd5\u3068\u4e26\u3093\u3067\u5e83\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b\u3002</p> <p>\u5358\u4f53\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u3001Dantzig\u304c\u63d0\u6848\u3057\u305f\u7279\u6b8a\u306a\u56f3\u89e3\u6cd5\u306b\u304a\u3044\u3066\u306f\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u9032\u884c\u306b\u5f93\u3063\u3066\u5358\u4f53\u304c\u4e0b\u306b\u843d\u3061\u3066\u3044\u304f\u3088\u3046\u306b\u898b\u3048\u308b\u3053\u3068\u306b\u7531\u6765\u3059\u308b\u3002</p> \\[ \\begin{array} \\text{max } \\space z = Cx \\\\ \\text{s.t.} \\space Ax &lt; b \\end{array} \\]"},{"location":"tech_note/optimize/algo_abst/#_3","title":"\u6709\u52b9\u5236\u7d04\u6cd5","text":"<p>\u6709\u52b9\u5236\u7d04\u6cd5\u306f\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\u7528\u3044\u3089\u308c\u308b\u3002</p> \\[ \\begin{array} \\text{min } \\space f(x) = \\frac{1}{2}x^TQx + cx \\\\ \\text{s.t.} \\space a_i^T x \\geq b_i \\end{array} \\]"},{"location":"tech_note/optimize/algo_abst/#_4","title":"\u5185\u70b9\u6cd5","text":"<p>\u30d0\u30ea\u30a2\u6cd5\u306e\u3088\u3046\u306a\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5185\u90e8\u3092\u9032\u3080\u3088\u3046\u306b\u89e3\u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u306e\u7dcf\u79f0 \u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u306a\u3044\u5834\u5408\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u89e3\u3092\u79fb\u52d5\u3055\u305b\u308b\u624b\u6bb5\u304c\u5fc5\u8981\u306b\u306a\u308b</p> <p>\u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u65b9\u6cd5\u306b\u3088\u3063\u3066\u3001\u30a2\u30d5\u30a3\u30f3\u5909\u63db\u6cd5\u3001\u30dd\u30c6\u30f3\u30b7\u30e3\u30eb\u6e1b\u5c11\u6cd5\u3001\u30d1\u30b9\u8ffd\u8de1\u6cd5\u306a\u3069\u306b\u5206\u985e\u3055\u308c\u308b</p> <p>\u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u3092\u76f4\u63a5\u6271\u3046\u65b9\u6cd5(\u4e3b\u5185\u70b9\u6cd5)\u3001\u305d\u306e\u53cc\u5bfe\u554f\u984c\u3092\u6271\u3046\u65b9\u6cd5(\u53cc\u5bfe\u5185\u70b9\u6cd5)\u3001\u4e3b\u554f\u984c\u3068\u53cc\u5bfe\u554f\u984c\u3092\u540c\u6642\u306b\u89e3\u304f\u65b9\u6cd5(\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5)\u306b\u5206\u3051\u3089\u308c\u308b</p>"},{"location":"tech_note/optimize/algo_abst/#_5","title":"\u4e3b\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#_6","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#_7","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#_8","title":"\u5916\u70b9\u6cd5","text":"<p>\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u306b\u4ee3\u8868\u3055\u308c\u308b\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u306e\u53cd\u5fa9\u3092\u8a31\u3059\u624b\u6cd5\u306e\u7dcf\u79f0 \u5185\u70b9\u6cd5\u3068\u7570\u306a\u308a\u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u3042\u3063\u3066\u3082\u53cd\u5fa9\u8a08\u7b97\u304c\u53ef\u80fd\u3067\u3042\u308b\u304c\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u306e\u30b9\u30b1\u30fc\u30eb\u8abf\u6574\u306b\u3088\u3063\u3066\u306f\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u53ce\u675f\u3059\u308b\u5834\u5408\u304c\u3042\u308b</p>"},{"location":"tech_note/optimize/algo_abst/#sqp","title":"\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(SQP\u6cd5)","text":"<p>NLP\u554f\u984c\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0</p> <ul> <li>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u89e3\u304f\u624b\u6cd5</li> <li>\u4fe1\u983c\u9818\u57df\u6cd5\u306b\u3088\u308a\u89e3\u304f\u624b\u6cd5</li> <li>\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP)</li> <li>\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP)</li> </ul> <p>\u306a\u3069\u304c\u3042\u308b \u57fa\u672c\u7684\u306b\u9055\u3044\u306f\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3059\u308b\u65b9\u6cd5\u3068\u3001\u8fd1\u4f3c\u3057\u305f\u4e8c\u6b21\u554f\u984c\u304b\u3089\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u5b9a\u3059\u308b\u65b9\u6cd5\u3078\u306e\u9055\u3044</p>"},{"location":"tech_note/optimize/algo_abst/#_9","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u4ee3\u308f\u308a\u306bBFGS\u6cd5\u3067\u8fd1\u4f3c\u3057\u305fB\u884c\u5217\u3092\u4f7f\u7528\u3057\u305fQP\u554f\u984c\u3092\u4f5c\u6210\u3057\u3001\u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f</p>"},{"location":"tech_note/optimize/algo_abst/#_10","title":"\u4fe1\u983c\u9818\u57df\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/algo_abst/#slp-sqp-slqp","title":"\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP, SLQP)","text":"<p>\u5236\u7d04\u5145\u8db3\u306e\u305f\u3081\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u76ee\u7684\u95a2\u6570\u5024\u6700\u5c0f\u5316\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u3044\u3046\u4e8c\u3064\u306e\u30d5\u30a7\u30fc\u30ba\u304b\u3089\u69cb\u6210\u3055\u308c\u308b\u4ed6\u306eSQP\u6cd5\u3068\u306f\u6bdb\u8272\u304c\u9055\u3046\u6700\u9069\u5316\u624b\u6cd5</p>"},{"location":"tech_note/optimize/algo_abst/#slsqp","title":"\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP)","text":"<p>\u300c\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5\u300d\u3068\u3044\u3046\u65e5\u672c\u8a9e\u8a33\u306f\u3042\u3063\u3066\u306a\u3044\u304b\u65e5\u672c\u8a9e\u8a33\u304c\u5f53\u3066\u3089\u308c\u3066\u3044\u306a\u3044\u53ef\u80fd\u6027\u304c\u3042\u308b MATLAB\u3084Scipy\u3067\u5c0e\u5165\u3055\u308c\u3066\u3044\u308bSLSQP\u306f1988\u5e74Kraft\u3089\u306e\u767a\u8868\u3057\u305f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u540c\u68b1\u3055\u308c\u8a00\u8a9e\u306fFortran \u8ad6\u6587\u30bf\u30a4\u30c8\u30eb\u306f\u4ee5\u4e0b</p> <p>Kraft, D. A software package for sequential quadratic    programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace    Center -- Institute for Flight Mechanics, Koln, Germany.</p>"},{"location":"tech_note/optimize/algo_abst/#_11","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6700\u9069\u5316\u554f\u984c</li> <li>\u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5</li> <li>B.2 \u5358\u4f53\u6cd5\u30fb\u6709\u52b9\u5236\u7d04\u6cd5</li> <li>\u5185\u70b9\u6cd5<ul> <li>\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> <li>B.1 \u5185\u70b9\u6cd5</li> </ul> </li> <li>B.7 \u5916\u70b9\u6cd5</li> <li>B.3 \u9010\u6b21\u4e8c\u6b21\u8a08\u753b\uff08SQP\uff09\u6cd5<ul> <li>SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066</li> </ul> </li> </ul>"},{"location":"tech_note/optimize/barrier_method/","title":"\u30d0\u30ea\u30a2\u6cd5","text":"<p>\u30d0\u30ea\u30a2\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u76ee\u7684\u95a2\u6570\u306b\u5236\u7d04\u306e\u8a55\u4fa1\u5024\u306b\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5024\u3092\u8db3\u3057\u3066\u5236\u7d04\u306a\u3057\u306e\u6700\u9069\u5316\u554f\u984c\u3068\u3057\u3066\u89e3\u304f\u5185\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b</p>"},{"location":"tech_note/optimize/benchmark_cont/","title":"\u9023\u7d9a\u95a2\u6570\u6700\u9069\u5316\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570","text":"<p>\u6700\u9069\u5316\u624b\u6cd5\u306e\u6bd4\u8f03\u306a\u3069\u306b\u4f7f\u7528\u3055\u308c\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u7528\u306e\u95a2\u6570\u306f\u4ee5\u4e0b\u3092\u8003\u616e\u3057\u3066\u4f5c\u3089\u308c\u305f\u3082\u306e\u304c\u591a\u3044\u3002</p> <ul> <li>\u5909\u6570\u306b\u3088\u3063\u3066\u53d6\u308b\u7bc4\u56f2\u304c\u9055\u3046(\u60aa\u30b9\u30b1\u30fc\u30eb\u6027)</li> <li>\u5909\u6570\u304c\u72ec\u7acb\u3067\u306a\u304f\u5909\u6570\u3054\u3068\u306e\u95a2\u6570\u306e\u548c\u3068\u3057\u3066\u8868\u73fe\u3067\u304d\u306a\u3044(\u5909\u6570\u9593\u4f9d\u5b58\u6027)</li> <li>\u5c40\u6240\u89e3\u304c\u6ca2\u5c71\u5b58\u5728\u3059\u308b\u3082\u306e(\u591a\u5cf0\u6027)</li> </ul> <p>\u4f8b\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u95a2\u6570\u304c\u6319\u3052\u3089\u308c\u308b\u3002</p> <ul> <li>Sphere\u95a2\u6570</li> <li>Ellipsoid\u95a2\u6570</li> <li>k-tablet\u95a2\u6570</li> <li>Rosenbrock\u95a2\u6570(star\u578b/chain\u578b)</li> <li>Bohachevsky\u95a2\u6570</li> <li>Ackley\u95a2\u6570</li> <li>Scaffer\u95a2\u6570</li> <li>Rastrign\u95a2\u6570</li> </ul>"},{"location":"tech_note/optimize/benchmark_cont/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6700\u9069\u5316\u624b\u6cd5\u8a55\u4fa1\u306e\u305f\u3081\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u3010Python\u30d7\u30ed\u30b0\u30e9\u30e0\u4ed8\u3011</li> <li>\u6700\u9069\u5316\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8a55\u4fa1\u3059\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u307e\u3068\u3081</li> </ul>"},{"location":"tech_note/optimize/conj_grad/","title":"\u6700\u6025\u964d\u4e0b\u6cd5","text":"<p>\u6700\u6025\u964d\u4e0b\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u306e\u9006\u65b9\u5411\u306b\u5909\u6570\u306e\u66f4\u65b0\u65b9\u5411\u3092\u53d6\u308a\u3001\u505c\u7559\u70b9\u306b\u53ce\u675f\u3059\u308b\u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u3002\u63a2\u7d22\u65b9\u5411\u306e\u53d6\u308a\u3046\u308b\u4e2d\u3067\u4e00\u756a\u52fe\u914d\u304c\u6025\u306a\u65b9\u5411\u306b\u66f4\u65b0\u3057\u7d9a\u3051\u308b\u305f\u3081\u3053\u306e\u540d\u304c\u3064\u3044\u305f</p> <p>\u6700\u9069\u5316\u306e\u53cd\u5fa9\u6cd5\u306b\u304a\u3051\u308b\u89e3\u306e\u66f4\u65b0\u5247\u306f</p> \\[ \\bf{x}^{(k+1)} = \\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)} \\] <p>\u6700\u6025\u964d\u4e0b\u6cd5\u3067\u306f\u63a2\u7d22\u65b9\u5411\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u53d6\u308b</p> \\[ \\bf{d}^{(k)} = -\\Delta f(\\bf{x}^{(k)}) \\] <p>\u63a2\u7d22\u65b9\u5411\u6c7a\u5b9a\u5f8c\u306f\u30b9\u30c6\u30c3\u30d7\u5e45\u30921\u306b\u56fa\u5b9a\u3059\u308b\u304b\u76f4\u7dda\u63a2\u7d22\u3092\u5225\u9014\u884c\u3044\u89e3\u3092\u66f4\u65b0\u3059\u308b</p>"},{"location":"tech_note/optimize/conj_grad/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/derivative/","title":"\u6570\u5024\u5fae\u5206\u6cd5","text":""},{"location":"tech_note/optimize/derivative/#1","title":"1\u968e\u5dee\u5206\u6cd5","text":"<p>\u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e1\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5</p> <p>\u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u65b9\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044</p> \\[ \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_{i+1} - f_{i-1}}{2\\Delta x}  \\] <p>\u3053\u306e\u4ed6\u7c21\u5358\u306a\u65b9\u6cd5\u3068\u3057\u3066\u306f\u5f8c\u9000\u5dee\u5206\u6cd5\u304c\u3042\u308b</p> \\[ \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_i - f_{i-1}}{\\Delta x}  \\]"},{"location":"tech_note/optimize/derivative/#2","title":"2\u968e\u5dee\u5206\u6cd5","text":"<p>\u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e2\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5</p> <p>\u3053\u308c\u3082\u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u6cd5\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044</p> \\[ \\left(\\frac{\\partial^2 f}{\\partial^2 x}\\right)_i = \\frac{f_{i+1} - 2f_{i} + f_{i-1}}{\\Delta x^2}  \\]"},{"location":"tech_note/optimize/interior_method/","title":"\u5185\u70b9\u6cd5","text":""},{"location":"tech_note/optimize/interior_method/#_2","title":"\u4e3b\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/interior_method/#_3","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/interior_method/#_4","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>Note</p> <p>Todo</p>"},{"location":"tech_note/optimize/interior_method/#hpipmhigh-performance-interior-point-method","title":"HPIPM(High Performance Interior Point Method)","text":""},{"location":"tech_note/optimize/interior_method/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u51f8\u6700\u9069\u5316\u306e\u6982\u8981\u3068\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac</li> <li>\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5</li> <li>\uff12\u6b21\u8a08\u753b\u554f\u984c\u3068\u5185\u70b9\u6cd5</li> <li>\u6570\u7406\u6700\u9069\u5316\u3092\u3057\u3063\u304b\u308a\u5b66\u3076\u305f\u3081\u306b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3068\u305d\u308c\u3092\u4f7f\u3063\u305fSVM\u3092\u5b9f\u88c5</li> </ul>"},{"location":"tech_note/optimize/kkt_condition/","title":"KKT\u6761\u4ef6","text":""},{"location":"tech_note/optimize/kkt_condition/#1","title":"\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027","text":"\\[ \\begin{array}{} \\text{min} \\space  f(x)\\\\ \\text{s.t.} \\space  g_i(x) = 0, \\space i = 0, \\dots , m\\\\ x \\in \\mathbb{R}^n \\end{array} \\] <p>\u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9\\(x^*\\)\u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\\(u^*\\)\u304c\u5b58\u5728\u3059\u308b</p> \\[ \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0 \\] <p>Note</p> <p>\u70b9\\(x\\)\u306b\u304a\u3044\u3066\\(\\nabla g_1(x), \\dots ,\\nabla g_m(x)\\)\u304c\u4e92\u3044\u306b1\u6b21\u72ec\u7acb\u306a\u3089\u3070\u70b9\\(x\\)\u306f\u6b63\u5247\u3067\u3042\u308b\u3068\u3044\u3046</p>"},{"location":"tech_note/optimize/kkt_condition/#1_1","title":"\u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027","text":"\\[ \\begin{array}{} \\text{\\rm min} \\space  f(x)\\\\ \\text{s.t.} \\space  g_i(x) \\leq 0, \\space i = 0, \\dots , m\\\\ x \\in \\mathbb{R}^n \\end{array} \\] <p>\u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9\\(x^*\\)\u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\\(u^*\\)\u304c\u5b58\u5728\u3059\u308b</p> \\[ \\begin{array}{} \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0\\\\ u_i^* g_i(x^*) = 0, \\space i = 0, \\dots , m\\\\ u_i^* \\geq 0, \\space i = 0, \\dots , m \\end{array} \\] <p>2\u5f0f\u76ee\u306f\u76f8\u88dc\u6027\u6761\u4ef6\u3068\u547c\u3070\u308c\u308b\u3002\\(g_i(x^*)\\)\u304c\u6709\u52b9\u306a\u6642\u306f\\(g_i(x^*)=0\\)\u3068\u306a\u308a, \u6709\u52b9\u3067\u306a\u3044\u5834\u5408\u306f\\(u_i^*=0\\)\u3068\u306a\u308b\u3002</p>"},{"location":"tech_note/optimize/kkt_condition/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/least_squares_method/","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5","text":""},{"location":"tech_note/optimize/least_squares_method/#_2","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u672c","text":""},{"location":"tech_note/optimize/least_squares_method/#_3","title":"\u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5","text":""},{"location":"tech_note/optimize/least_squares_method/#_4","title":"\u7dda\u5f62\u7b49\u5f0f\u30fb\u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5","text":""},{"location":"tech_note/optimize/least_squares_method/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b</li> <li>\u5236\u7d04\u4ed8\u304d\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b</li> <li>Conversion from least squares to quadratic programming</li> <li>lsqlin</li> <li>\u6700\u5c0f\u4e8c\u4e57 (\u30e2\u30c7\u30eb\u5f53\u3066\u306f\u3081) \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/optimize/line_search/","title":"\u76f4\u7dda\u63a2\u7d22","text":"<p>\u9023\u7d9a\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b\u9010\u6b21\u6700\u9069\u5316\u306b\u304a\u3044\u3066\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u3081\u305f\u5f8c\u306b\u3069\u308c\u3060\u3051\u305d\u306e\u65b9\u5411\u306b\u9032\u3080\u304b\u306e\u30b9\u30c6\u30c3\u30d7\u30b5\u30a4\u30ba\u3092\u6c7a\u5b9a\u3059\u308b\u624b\u6cd5</p> <p>\u76ee\u7684\u95a2\u6570\\(f\\)\u306b\u5bfe\u3057\u3066\\(g\\)\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3057\u3001\\(\\alpha\\)\u306b\u3064\u3044\u3066\u6700\u5c0f\u5316\u3059\u308b\u3053\u3068\u3092\u76ee\u7684\u3068\u3059\u308b</p> \\[ g(\\alpha) = f(\\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)}) \\]"},{"location":"tech_note/optimize/line_search/#_2","title":"\u56f2\u3044\u8fbc\u307f\u6cd5","text":"<p>\u30b9\u30c6\u30c3\u30d7\u5e45\u30921\u304b\u3089\u958b\u59cb\u3057\u53cd\u5fa9\u3054\u3068\u306b0\u3088\u308a\u5927\u304d\u304f1\u3088\u308a\u5c0f\u3055\u3044\u5b9a\u6570\u3092\u304b\u3051\u3066\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u5c0f\u3055\u304f\u3057\u3066\u3044\u304f\u3002\u95a2\u6570\u306e\u5024\u304c\u5c0f\u3055\u304f\u306a\u308b\u9650\u308a\u3053\u306e\u53cd\u5fa9\u3092\u7d9a\u3051\u308b</p>"},{"location":"tech_note/optimize/line_search/#_3","title":"\u30a2\u30eb\u30df\u30db\u6761\u4ef6","text":"<p>\u3042\u308b\u5b9a\u6570\\(0 &lt; \\tau &lt; 1\\)\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u3088\u3046\u306a\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u63a1\u7528\u3059\u308b</p> \\[ g(\\alpha) \\leq g(0) + \\tau g'(0) \\alpha \\] <p>\u3053\u3053\u3067\\(f\\)\u306f\u5fae\u5206\u53ef\u80fd\u3067\u3042\u308b\u3068\u3057</p> \\[ g'(\\alpha) = \\Delta f(\\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)})^T \\bf{d}^{(k)} \\]"},{"location":"tech_note/optimize/line_search/#_4","title":"\u30a6\u30eb\u30d5\u6761\u4ef6","text":"<p>\u3042\u308b\u5b9a\u6570\\(0 &lt; \\tau_1 &lt; \\tau_2 &lt; 1\\)\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u3088\u3046\u306a\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u63a1\u7528\u3059\u308b</p> \\[ \\begin{array} g(\\alpha) \\leq g(0) + \\tau_1 g'(0) \\alpha  \\\\ g'(\\alpha) \\geq \\tau_2 g'(\\alpha) \\end{array} \\]"},{"location":"tech_note/optimize/line_search/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> <li>\u76f4\u7dda\u63a2\u7d22\u306b\u304a\u3051\u308bArmijo\u6761\u4ef6\u3068Wolfe\u6761\u4ef6\u3092\u56f3\u304b\u3089\u7406\u89e3\u3059\u308b</li> </ul>"},{"location":"tech_note/optimize/newton/","title":"\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u3068\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u3044\u95a2\u6570\u3092\u5909\u6570\u306e\u5468\u308a\u30672\u6b21\u8fd1\u4f3c\u3057\u89e3\u304f\u3053\u3068\u3067\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u5b9a\u3057\u3001\u505c\u7559\u70b9\u306b\u53ce\u675f\u3059\u308b\u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u3002\u6700\u6025\u964d\u4e0b\u6cd5\u304c\u4e00\u6b21\u53ce\u675f\u3067\u3042\u308b\u3053\u3068\u306b\u5bfe\u3057\u3066\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f2\u6b21\u53ce\u675f\u3067\u3042\u308b\u305f\u3081\u505c\u7559\u70b9\u4ed8\u8fd1\u3067\u3082\u53ce\u675f\u304c\u901f\u3044\u304c\u76ee\u7684\u95a2\u6570\u306e2\u89e3\u5fae\u5206\u304c\u5fc5\u8981\u3067\u3042\u308b\u3002</p> <p>\u6700\u9069\u5316\u306e\u53cd\u5fa9\u6cd5\u306b\u304a\u3051\u308b\u89e3\u306e\u66f4\u65b0\u5247\u306f</p> \\[ \\bf{x}^{(k+1)} = \\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)} \\] <p>\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u306f\u63a2\u7d22\u65b9\u5411\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u53d6\u308b\u3002\u884c\u3063\u3066\u3044\u308b\u3053\u3068\u306f\u73fe\u5728\u306e\u89e3\u5468\u308a\u3067\u76ee\u7684\u95a2\u6570\u30922\u6b21\u8fd1\u4f3c\u3057\u3001\u6700\u5c0f\u5024\u3092\u65b9\u7a0b\u5f0f\u304b\u3089\u6c42\u3081\u3066\u3044\u308b\u3002</p> \\[ \\bf{d}^{(k)} = -\\Delta^2 f(\\bf{x}^{(k)})^{-1} \\Delta f(\\bf{x}^{(k)}) \\] <p>\u63a2\u7d22\u65b9\u5411\u6c7a\u5b9a\u5f8c\u306f\u76f4\u7dda\u63a2\u7d22\u3067\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u8a08\u7b97\u3057\u52b9\u7387\u7684\u306b\u89e3\u3092\u66f4\u65b0\u3059\u308b</p>"},{"location":"tech_note/optimize/newton/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/penalty_methond/","title":"\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5","text":"<p>\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u79fb\u52d5\u3057\u305f\u969b\u306b\u5024\u304c\u5897\u52a0\u3059\u308b\u3088\u3046\u306a\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u76ee\u7684\u95a2\u6570\u306b\u4ed8\u52a0\u3057\u305f\u5916\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/","title":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7","text":""},{"location":"tech_note/optimize/prob_and_algo/#_2","title":"\u6570\u7406\u8a08\u753b\u554f\u984c","text":""},{"location":"tech_note/optimize/prob_and_algo/#lp-linear-programming","title":"LP (Linear Programming : \u7dda\u5f62\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u554f\u984c\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u3082\u306e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#milp-mixed-integer-linear-programming","title":"MILP (Mixed Integer Linear Programming : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e   MIP(Mixed Integer Programming)\u3068\u547c\u3070\u308c\u308b\u3053\u3068\u3082\u591a\u3044</p>"},{"location":"tech_note/optimize/prob_and_algo/#miqp-mixed-integer-quadratic-programming","title":"MIQP (Mixed Integer Quadratic Programming : \u6df7\u5408\u6574\u6570\u4e8c\u6b21\u8a08\u753b\u554f\u984c)","text":"<p>\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3001\u76ee\u7684\u95a2\u6570\u304c\u4e8c\u6b21\u95a2\u6570\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e</p>"},{"location":"tech_note/optimize/prob_and_algo/#minlp-mixed-integer-nonlinear-programming","title":"MINLP (Mixed Integer Nonlinear Programming : \u6df7\u5408\u6574\u6570\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c)","text":"<p>\u5236\u7d04\u5f0f\u304a\u3088\u3073\u76ee\u7684\u95a2\u6570\u304c\u975e\u7dda\u5f62\u3067\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#cqp-convex-quadratic-programming","title":"CQP (Convex Quadratic Programming : \u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u304c\u51f8\u306a\u4e8c\u6b21\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u3082\u306e (\u305f\u3060\u3057\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u3082\u306e)  </p>"},{"location":"tech_note/optimize/prob_and_algo/#cp-convex-programming","title":"CP (Convex Programming : \u51f8\u8a08\u753b\u554f\u984c)","text":"<p>\u76ee\u7684\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u306a\u3082\u306e\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304c\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u304c\u51f8\u3067\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u554f\u984c\u3053\u3053\u3067\u306f\u6574\u6570\u5909\u6570\u306f\u542b\u307e\u306a\u3044\u3082\u306e\u3092\u6307\u3059  \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3082\u51f8\u8a08\u753b\u554f\u984c\u306e\u4e00\u90e8\u3067\u3059\u304c\u3001\u3053\u3053\u306b\u306f\u542b\u3081\u306a\u3044</p>"},{"location":"tech_note/optimize/prob_and_algo/#nlp-nonlinear-programming","title":"NLP (Nonlinear Programming : \u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c)","text":"<p>\u4e0a\u8a18\u4ee5\u5916\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c  </p>"},{"location":"tech_note/optimize/prob_and_algo/#sdp-semidefinite-programing","title":"SDP (SemiDefinite Programing : \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c)","text":"<p>\u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u3080\u7dda\u5f62\u8a08\u753b\u554f\u984c  </p>"},{"location":"tech_note/optimize/prob_and_algo/#nlsdp-nonlinear-semidefinite-programing","title":"NLSDP (NonLinear SemiDefinite Programing : \u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c)","text":"<p>\u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u307f\u3001\u306a\u304a\u304b\u3064\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u542b\u307e\u308c\u308b\u554f\u984c  </p>"},{"location":"tech_note/optimize/prob_and_algo/#wcsp-weighted-constraint-satisfaction-problem","title":"WCSP (Weighted Constraint Satisfaction Problem : \u91cd\u307f\u4ed8\u304d\u5236\u7d04\u5145\u8db3\u554f\u984c)","text":"<p>\u5404\u3005\u91cd\u307f\u306e\u4ed8\u3044\u305f\u5236\u7d04\u6761\u4ef6\u3092\u306a\u308b\u3079\u304f\u6e80\u8db3\u3059\u308b\u305f\u3081\u306b\u306f\u5024\u3092\u3069\u306e\u3088\u3046\u306b\u5272\u308a\u5f53\u3066\u308b\u3068\u826f\u3044\u304b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0wcsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/#rcpsp-resource-constrained-project-scheduling-problem","title":"RCPSP (Resource Constrained Project Scheduling Problem : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c)","text":"<p>\u4e00\u5b9a\u306e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\u3067\u3001\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u3000\u3000 \u4e00\u822c\u306e\u6574\u6570\u8a08\u753b\u554f\u984c(MILP)\u3068\u3057\u3066\u8a18\u8ff0\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3060\u304c\u3001\u7279\u6b8a\u306a\u8a18\u6cd5\u3092\u884c\u3046\u3068\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0rcpsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/#_3","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7","text":""},{"location":"tech_note/optimize/prob_and_algo/#simplex","title":"simplex : \u5358\u4f53\u6cd5()","text":"<p>\u7dda\u5f62\u8a08\u753b\u6cd5\u306e\u89e3\u6cd5\u3068\u3057\u3066\u53e4\u304f\u304b\u3089\u77e5\u3089\u308c\u3066\u3044\u308b\u65b9\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\u5185\u70b9\u6cd5\u306b\u901f\u5ea6\u7684\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u304c\u6c42\u307e\u308a\u539f\u7406\u7684\u306b\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e \u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u6307\u5b9a\u3059\u308b\u3068\uff0c\u5358\u4f53\u6cd5\u3092\u5206\u679d\u9650\u5b9a\u6cd5(Branch and bound method)\u3068\u3044\u3046\u67a0\u7d44\u306e\u306a\u304b\u3067\u7e70\u308a\u8fd4\u3057\u884c\u3063\u3066\uff0c\u6700\u9069\u6027\u306e\u4fdd\u8a3c\u306e\u3042\u308b\u6574\u6570\u89e3\u3092\u6c42\u3081\u307e\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u306b\u304a\u3044\u3066\u57fa\u5e95\u89e3\u304c\u5fc5\u8981\u306a\u5834\u5408\u306b\u306f\uff0c\"cross:on\"\u3068\u6307\u5b9a\u3057\u3066\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u306e\u304c\u6709\u5229\u3067\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#dual_simplex-dual_simplex","title":"dual_simplex : \u53cc\u5bfe\u5358\u4f53\u6cd5(DUAL_SIMPLEX)","text":"<p>(\u4e3b)\u5358\u4f53\u6cd5\u304c\u4e3b\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304f\u306e\u306b\u5bfe\u3057\uff0c\u53cc\u5bfe\u5358\u4f53\u6cd5\u306f\u53cc\u5bfe\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304d\u307e\u3059\uff0e \u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\uff0c(\u4e3b)\u5358\u4f53\u6cd5\u3068\u6bd4\u8f03\u3057\u3066\u6709\u5229\u3067\u3042\u308b\u3053\u3068\u304c\u3042\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#asqp-active_set_qp","title":"asqp : \u6709\u52b9\u5236\u7d04\u6cd5(ACTIVE_SET_QP)","text":"<p>\u5358\u4f53\u6cd5\u3068\u540c\u69d8\uff0c\u53e4\u5178\u7684\u306a\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u53b3\u5bc6\u89e3\u6cd5\u3067\u3059\uff0e1\u4e07\u5909\u6570\u4ee5\u4e0a\u306e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\uff0c\u4e00\u822c\u306b\u5185\u70b9\u6cd5(\u76f4\u7dda\u63a2\u7d22\u6cd5(Line Search Method))\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c \u5909\u6570\u306b\u6bd4\u3079\u3066\u5236\u7d04\u5f0f\u306e\u6570\u304c\u975e\u5e38\u306b\u5c11\u306a\u3044(1/10\u4ee5\u4e0b)\u5834\u5408 \u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30bb\u884c\u5217\u304c\u5bc6\u884c\u5217\u3067\u3042\u308b\u5834\u5408 \u306b\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u304b\u3064\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e\u307e\u305f\uff0c\u6574\u6570\u8a08\u753b\u6cd5\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u306e\u3067\uff0c\u6574\u6570\u5909\u6570\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\"cross:on\"\u3068\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\uff0c\u5927\u898f\u6a21\u554f\u984c\u306b\u5bfe\u3057\u3066\u9ad8\u7cbe\u5ea6\u306a\u89e3\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#higher-higher_order","title":"higher : \u7dda\u5f62\u8a08\u753b\u554f\u984c\u5c02\u7528\u5185\u70b9\u6cd5(HIGHER_ORDER)","text":"<p>\u7dda\u5f62\u8a08\u753b\u6cd5\u306b\u7279\u5316\u3057\u305f\u5185\u70b9\u6cd5\u3067\uff0c\u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306e\u89e3\u6cd5\u3068\u3057\u3066\u306f\u6700\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5358\u4f53\u6cd5\u3068\u9055\u3044\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u306f\u6c42\u307e\u308a\u307e\u305b\u3093\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lipm-line_search_ipm","title":"lipm : (\u65b0\u7248)\u76f4\u7dda\u63a2\u7d22\u6cd5(LINE_SEARCH_IPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#lepm-line_search_epm","title":"lepm : \u76f4\u7dda\u63a2\u7d22\u5916\u70b9\u6cd5(LINE_SEARCH_EPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#line-line_search","title":"line : (\u65e7\u7248)\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5(LINE_SEARCH)","text":"<p>\u4e00\u822c\u306e\u51f8\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u554f\u984c\u304c\u51f8\u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u5834\u5408\u306b\u306f\u4fe1\u983c\u9818\u57df\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(lipm)\uff0c\u5916\u70b9\u6cd5(lepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(line)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5line\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5lipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059)\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#bfgs-bfgs_line_search","title":"bfgs : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(BFGS_LINE_SEARCH)","text":"<p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u201cbfgs\u201d\u306f\u30d8\u30c3\u30bb\u884c\u5217\u306e\u8fd1\u4f3c\u884c\u5217\u3092\u5bc6\u884c\u5217\u3068\u3057\u3066\u4fdd\u6301\u3057\u307e\u3059\u306e\u3067\uff0c\u5c0f\u898f\u6a21(50\uff5e500\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#tipm-trust_region_ipm","title":"tipm : (\u65b0\u7248)\u4fe1\u983c\u9818\u57df\u5185\u70b9\u6cd5(TRUST_REGION_IPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#tepm-trust_region_epm","title":"tepm : \u4fe1\u983c\u9818\u57df\u5916\u70b9\u6cd5(TRUST_REGION_EPM)","text":""},{"location":"tech_note/optimize/prob_and_algo/#trust-trust_region","title":"trust : (\u65e7\u7248)\u4fe1\u983c\u9818\u57df\u6cd5\u5185\u70b9\u6cd5(TRUST_REGION)","text":"<p>\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(tipm)\uff0c\u5916\u70b9\u6cd5(tepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(trust)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5trust\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5tipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3054\u3056\u3044\u307e\u3059)\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lsqp-line_search_sqp","title":"lsqp : \u76f4\u7dda\u63a2\u7d22\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(LINE_SEARCH_SQP)","text":"<p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5c0f\u898f\u6a21(50\uff5e100\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e \u554f\u984c\u306b\u3088\u3063\u3066\u306f\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(lipm/lepm/line)\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#tsqp-trust_region_sqp","title":"tsqp : \u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(TRUST_REGION_SQP)","text":"<p>\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u305d\u306e\u307e\u307e\u7528\u3044\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u65b9\u6cd5\u3067\u3059\uff0e\u4e00\u822c\u306b\u5185\u70b9\u6cd5\u3088\u308a\u3082\u4f4e\u901f\u3067\u3059\u304c\uff0c\u554f\u984c\u306b\u3088\u3063\u3066\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\uff0c\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u5909\u6570\u306e\u6570\u3088\u308a\u3082\u5236\u7d04\u5f0f\u6570\u304c\u591a\u3044\u5834\u5408\u306b\u306f\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3088\u308a\u3082\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#slpsqp-slp-sqp","title":"slpsqp : \u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP)","text":"<p>\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u7528\u3044\u306a\u3044\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u3042\u308b\u7a0b\u5ea6\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u3067\u3059\uff0e\u5927\u57df\u7684\u53ce\u675f\u6027\u3092\u4fdd\u8a3c\u3059\u308b\u539f\u7406\u304c\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3084\u5f93\u6765\u306e\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(lsqp/tsqp)\u306e\u3082\u306e\u3068\u306f\u7570\u306a\u308b\u305f\u3081\uff0c\u4ed6\u306e\u65b9\u6cd5\u3067\u53ce\u675f\u3057\u306a\u3044\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e\u307e\u305f\uff0c\u5236\u7d04\u5f0f\u306e\u52fe\u914d\u304c\u5c0f\u3055\u3044\u53cd\u5fa9\u70b9\u306b\u3044\u308b\u6642\uff0c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u63a5\u8fd1\u3059\u308b\u3068\u3044\u3046\u4ed5\u7d44\u307f\u304c\u7d44\u307f\u8fbc\u307e\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u8907\u96d1\u306a\u5236\u7d04\u306b\u304a\u3044\u3066\u3082\u5b89\u5b9a\u7684\u306a\u52d5\u4f5c\u304c\u671f\u5f85\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lsdp","title":"lsdp : \u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u7dda\u5f62\u306e\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u51fa\u73fe\u3059\u308b\u9805\u306f\u7dda\u5f62\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3044\u307e\u305b\u3093\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#csdp","title":"csdp : \u51f8\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u76ee\u7684\u95a2\u6570\u304c\u51f8\u975e\u7dda\u5f62\u95a2\u6570\u3067\uff0c\u5236\u7d04\u304c\u7dda\u5f62\u306a\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u3053\u306e\u985e\u306e\u554f\u984c\u306f\uff0c\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3067\u8a18\u8ff0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u304c\uff0c\u305d\u306e\u307e\u307e\u6271\u3063\u305f\u65b9\u304c\u9ad8\u901f\u306b\u6c42\u89e3\u3067\u304d\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3046\u70b9\u304clsdp\u3068\u7570\u306a\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#qnsdp","title":"qnsdp : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#lmsdp-levenberg-marquardt","title":"lmsdp : Levenberg-Marquardt\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5","text":"<p>\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u70ba\u306b\uff0cLevenberg-Marquardt\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u306b\u6bd4\u3079\u3066\uff0c\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e\u5909\u6570\u304c\u5c11\u306a\u304f\uff0c\u884c\u5217\u6b21\u5143\u304c\u5927\u304d\u3044\u554f\u984c\u306e\u5834\u5408\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(trsdp)\u3088\u308a\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e trsdp : \u4fe1\u983c\u9818\u57df\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u3088\u308a\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#wcsp-wcsp","title":"wcsp : \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0(WCSP)","text":"<p>\u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u5236\u7d04\u5145\u8db3\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u5fc5\u305a\u3057\u3082\u53b3\u5bc6\u89e3\u304c\u6c42\u307e\u308b\u308f\u3051\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\uff0c\u5927\u898f\u6a21\u306a\u6574\u6570\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\uff0c\u975e\u5e38\u306b\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3(\u8fd1\u4f3c\u89e3)\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u6574\u6570\u5909\u6570\u306e\u307f\u3092\u542b\u307f\uff0c\u304b\u3064\u3059\u3079\u3066\u306e\u5909\u6570\u306b\u4e0a\u9650\u3068\u4e0b\u9650\u304c\u3042\u308b\u554f\u984c\u306b\u5bfe\u3057\u3066\u306e\u307f\u6709\u52b9\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\uff0c\u5236\u7d04\u5f0f\u306b\u91cd\u307f\u3092\u8a2d\u5b9a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u5236\u7d04\u306e\u91cd\u307f\u306b\u306f\uff0c\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bb\u30df\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bd\u30d5\u30c8\u5236\u7d04\u306e\u4e09\u7a2e\u985e\u304c\u3042\u308a\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#wcsplp","title":"wcsplp : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u5c02\u7528\u306e\u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0","text":"<p>\u7dda\u5f62\u306a\u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u3092\u5236\u7d04\u5145\u8db3\u554f\u984c\u306e\u67a0\u7d44\u307f\u3067\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u306f\uff0c\u9023\u7d9a\u5909\u6570\u306f\u9069\u5f53\u306a\u523b\u307f\u5e45\u3092\u3082\u3064DiscreteVariable\u3068\u89e3\u91c8\u3055\u308c\u307e\u3059\uff0ewcsplp\u3067\u306f\u5168\u3066\u306e\u5236\u7d04\u5f0f\u3092\u30cf\u30fc\u30c9\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\uff0c\u76ee\u7684\u95a2\u6570\u3092\u30bd\u30d5\u30c8\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#rcpsp-rcpsp","title":"rcpsp : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0(RCPSP)","text":"<p>\u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\uff0c\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u306e\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u9ad8\u901f\u306b\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0ercpsp\u306e\u8a18\u8ff0\u306b\u3042\u305f\u3063\u3066\u306f\u554f\u984c\u3092SIMPLE\u306e\u7279\u6b8a\u306a\u30af\u30e9\u30b9\u3092\u7528\u3044\u3066\u8a18\u8ff0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5b8c\u4e86\u6642\u523b\u306e\u6700\u5c0f\u5316\u554f\u984c\u3068\uff0c\u7d0d\u671f\u9045\u308c\u6700\u5c0f\u5316\u554f\u984c\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u524d\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30bd\u30d5\u30c8\u5236\u7d04\uff0c\u5f8c\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30cf\u30fc\u30c9\u5236\u7d04\u306e\u307f\u304c\u4f7f\u7528\u3067\u304d\u307e\u3059\uff0e  </p>"},{"location":"tech_note/optimize/prob_and_algo/#_4","title":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc","text":"LP MILP MIQP MINLP CQP CP NLP SDP NLSDP RCPSP simplex \u25cb \u25cb -- -- -- -- -- -- -- \u25b3 dual_simplex \u25cb -- -- -- -- -- -- -- -- -- asqp \u25cb -- \u25cb -- \u25cb -- -- -- -- -- higher \u25cb -- -- -- -- -- -- -- -- -- lipm/lepm/line \u25b3 -- -- -- \u25cb \u25cb -- -- -- -- bfgs \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- tipm/tepm/trust \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- lsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- tsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- slpsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- lsdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- csdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- qnsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- trsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- lmsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- wcsp -- \u25cb\u203b1 \u25cb\u203b1 \u25cb\u203b1 -- -- -- -- -- -- wcsplp \u25b3 \u25cb\u203b2 -- -- -- -- -- -- -- -- global \u25b3 \u25b3 \u25b3 \u25cb \u25b3 \u25b3 \u25cb \u25cb \u25cb \u25b3 DFO \u25b3 -- -- -- \u25b3 \u25b3 \u25cb -- -- -- rcpsp -- -- -- -- -- -- -- -- -- \u25cb <p>Info</p> <p>\u203b1: 0-1\u6574\u6570\u5909\u6570\u3068\u96e2\u6563\u5909\u6570\u306e\u307f\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u9069\u7528\u3067\u304d\u308b\u3053\u3068\u3092\u610f\u5473\u3059\u308b \u3000\u3000\u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u3042\u308b\u3044\u306f\u4e0a\u9650\u3068\u4e0b\u9650\u3092\u6301\u305f\u306a\u3044\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u306f\u9069\u7528\u3067\u304d\u306a\u3044 \u203b2: \u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u5834\u5408\u3082\u9069\u7528\u304c\u3067\u304d\u308b\u304c\u52b9\u7387\u304c\u843d\u3061\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b</p>"},{"location":"tech_note/optimize/prob_and_algo/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>14.1 \u6570\u7406\u8a08\u753b\u554f\u984c\u4e00\u89a7</li> <li>14.2 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7</li> <li>14.3 \u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc</li> </ul>"},{"location":"tech_note/optimize/quadprog/","title":"\u4e8c\u6b21\u8a08\u753b\u6cd5","text":"<p>\u4ee5\u4e0b\u306e\u6700\u9069\u5316\u554f\u984c\u3092\u8003\u3048\u308b</p> \\[ \\begin{array} \\text{min} \\space \\dfrac{1}{2}x^TQx + c^T x\\\\ \\text{s.t.} \\space Ax = b, A_{eq}x \\leq b_{eq}, l_x \\leq x \\leq u_x \\\\ x \\in \\mathbb{R}^n \\end{array} \\]"},{"location":"tech_note/optimize/quadprog/#kkt","title":"KKT\u6761\u4ef6","text":"<p>\u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u306b\u5bfe\u3059\u308bKKT\u6761\u4ef6\u306f\u4ee5\u4e0b</p> \\[ \\begin{array}{l} Qx+c + A^T\\lambda + A_{eq}\\lambda_{eq} = \\bf{0} \\\\ \\lambda_i s_i = \\rho\\\\ Ax-b+s = \\bf{0}\\\\ A_{eq}x-b_{eq} = \\bf{0}\\\\ s &gt; \\bf{0}\\\\ \\lambda &gt; \\bf{0}\\\\ \\end{array} \\] <p>KKT\u6761\u4ef6\u306b\u3064\u3044\u3066</p>"},{"location":"tech_note/optimize/quadprog/#_2","title":"\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a","text":"<p>KKT\u6761\u4ef6\u306b\u5bfe\u3057\u3066\u5404\u5909\u6570\u3092\u5fae\u5c0f\u5909\u5316\u3055\u305b\u305f\u5834\u5408\u3092\u8003\u3048\u308b</p> \\[ \\begin{array}{cc} x \\leftarrow x + \\Delta x\\\\ s \\leftarrow s + \\Delta s\\\\ \\lambda \\leftarrow \\lambda + \\Delta \\lambda\\\\ \\lambda_{eq} \\leftarrow \\lambda_{eq} + \\Delta \\lambda_{eq}\\\\ \\end{array} \\] <p>KKT\u6761\u4ef6\u306b\u4ee5\u4e0a\u3092\u4ee3\u5165\u3057\u5fae\u5c0f\u5909\u5316\u91cf\u306b\u5bfe\u3057\u3066\u9023\u7acb\u65b9\u7a0b\u5f0f\u306e\u5f62\u5f0f\u306b\u307e\u3068\u3081\u308b</p> \\[ \\begin{bmatrix} Q    &amp; \\bf{0}    &amp; A^T    &amp; A_{eq}^T \\\\ A    &amp; I         &amp; \\bf{0} &amp; \\bf{0} \\\\ 0    &amp; D_\\lambda &amp; D_s    &amp; \\bf{0} \\\\ A_eq &amp; \\bf{0}    &amp; 0      &amp; \\bf{0} \\\\ \\end{bmatrix} \\begin{bmatrix} \\Delta x \\\\ \\Delta s \\\\ \\Delta \\lambda \\\\ \\Delta \\lambda_{eq} \\\\ \\end{bmatrix} =  \\begin{bmatrix} Qx + c + A^T\\lambda + A_{eq}^T \\lambda_{eq}\\\\ Ax - b + s\\\\ -\\rho I + \\lambda \\bigodot s \\\\ A_{eq} x - b_{eq}\\\\ \\end{bmatrix}\\\\ \\space\\\\ D_\\lambda = \\text{diag}(\\lambda)\\\\ D_s = \\text{diag}(s)\\\\ \\lambda \\bigodot s = \\text{(\u8981\u7d20\u7a4d\u30fb\u30a2\u30c0\u30de\u30fc\u30eb\u7a4d)} \\] <p>\u3053\u306e\u65b9\u7a0b\u5f0f\u3092\u89e3\u3044\u3066\u5404\u5909\u6570\u3092\u66f4\u65b0\u3057\u3066\u3044\u304f</p>"},{"location":"tech_note/optimize/quadprog/#_3","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u4e8c\u6b21\u8a08\u753b\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/optimize/quasi_newton/","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u4f7f\u7528\u3057\u305f\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u7528\u305b\u305a\u8fd1\u4f3c\u3057\u305f\u3082\u306e\u3092\u4f7f\u7528\u3057\u3066\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u3053\u306e\u3068\u304d\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u306f\u6b63\u5247\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067BFGS\u516c\u5f0f\u3092\u4f7f\u7528\u3057\u3066\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u66f4\u65b0\u3059\u308b\u3002</p> <p>\u6700\u9069\u5316\u306e\u53cd\u5fa9\u6cd5\u306b\u304a\u3051\u308b\u89e3\u306e\u66f4\u65b0\u5247\u306f</p> \\[ \\bf{x}^{(k+1)} = \\bf{x}^{(k)} + \\alpha \\bf{d}^{(k)} \\] <p>\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u306f\u63a2\u7d22\u65b9\u5411\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u53d6\u308b\u3002\u73fe\u5728\u306e\u89e3\u5468\u308a\u3067\u306e\u76ee\u7684\u95a2\u6570\u306e2\u6b21\u8fd1\u4f3c\u3092\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\\(B\\)\u3092\u4f7f\u3063\u3066\u884c\u3063\u3066\u3044\u308b</p> \\[ \\bf{d}^{(k)} = - (\\bf{B}^{(k)})^{-1} \\Delta f(\\bf{x}^{(k)}) \\] <p>\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\\(B\\)\u306f\u521d\u671f\u5316\u306e\u3068\u304d\u306b\u306f\u5358\u4f4d\u884c\u5217\u306a\u3069\u3092\u9078\u3076</p> <p>\u63a2\u7d22\u65b9\u5411\u6c7a\u5b9a\u5f8c\u306f\u76f4\u7dda\u63a2\u7d22\u3067\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u8a08\u7b97\u3057\u3066\u89e3\u3092\u66f4\u65b0\u3059\u308b\u3002\u307e\u305f\u3001\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\\(B\\)\u3092BFGS\u516c\u5f0f\u306b\u3088\u308a\u66f4\u65b0\u3059\u308b</p>"},{"location":"tech_note/optimize/quasi_newton/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> </ul>"},{"location":"tech_note/optimize/sqp/","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)","text":"<p>NLP\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0 QP\u3078\u306e\u8fd1\u4f3c\u3068\u305d\u306e\u89e3\u6cd5\u306b\u3088\u3063\u3066\u3044\u304f\u3064\u304b\u306e\u7a2e\u985e\u306b\u5206\u304b\u308c\u308b  \u3053\u3053\u3067\u306f\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u3082\u306e\u3068SLSQP\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b  </p>"},{"location":"tech_note/optimize/sqp/#_1","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5","text":"<p>\u307e\u305a\u306f\u7d14\u7c8b\u306aSQP\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b\u3002\u4e0e\u3048\u3089\u308c\u308b\u554f\u984c\u306f\u4ee5\u4e0b\u306e\u5f62\u5f0f\u3067\u3042\u308b</p> \\[ \\begin{array}{} \\underset{x}{\\text{min}} \\space f(x)\\\\ \\text{s.t.} \\space  g_i(x) = 0, \\space i = 0, \\dots , m_e\\\\ \\text{\u3000\u3000\u3000} \\space  g_i(x) \\leq 0, \\space i = m_e+1, \\dots , l\\\\ x \\in \\mathbb{R}^n \\end{array} \\] <p>\u30b5\u30d6\u554f\u984c\u3068\u3057\u3066QP\u306b\u8fd1\u4f3c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u5f62\u3092\u53d6\u308b</p> \\[ f(x) \\approx \\dfrac{1}{2}x^TQx + c^Tx\\\\ \\] <p>\u3053\u3053\u3067\u4efb\u610f\u306e\u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30b7\u30a2\u30f3\\(Q\\)\u306b\u3064\u3044\u3066\u534a\u6b63\u5b9a\u5024\u6027\u304c\u4fdd\u8a3c\u3055\u308c\u306a\u3044\u305f\u3081\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5\u306b\u3088\u308a\u8fd1\u4f3c\u3057\u305f\u884c\u5217\u3092\u4f7f\u7528\u3059\u308b\u3002</p> <p>\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\u306e\u305f\u3081\u306b\u76ee\u7684\u5909\u6570\u3092\u63a2\u7d22\u65b9\u5411\u306b\u53d6\u308aQP\u554f\u984c\u3092\u5b9a\u5f0f\u5316\u3059\u308b\u3002</p> \\[ \\begin{array}{} \\underset{d}{\\text{min}} \\dfrac{1}{2}d^TQd + c^Td\\\\ \\text{s.t.} \\space \\nabla g_i(x)^Td + g_i(x) = 0, \\space i = 0, \\dots , m_e\\\\ \\text{\u3000\u3000\u3000} \\space \\nabla g_i(x)^Td + g_i(x) \\leq 0, \\space i = m_e+1, \\dots , l\\\\ \\end{array} \\] <p>\u63a2\u7d22\u65b9\u5411\u304c\u6c7a\u5b9a\u3057\u305f\u3089\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u76f4\u7dda\u63a2\u7d22\u306b\u3088\u308a\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c7a\u5b9a\u3057\u3001\u5909\u6570\u3092\u66f4\u65b0\u3059\u308b\u3002 \u305d\u306e\u5f8cBFGS\u306b\u3088\u308b\u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u66f4\u65b0\u3092\u884c\u3046\u3002</p> <p>\u4ee5\u4e0a\u306e\u64cd\u4f5c\u3092\u53ce\u675f\u3059\u308b\u307e\u3067\u884c\u3046\u3002</p>"},{"location":"tech_note/optimize/sqp/#slsqp","title":"SLSQP","text":"<p>SLSQP\u3067\u306f\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u8aac\u660e\u3057\u305f\u30b5\u30d6\u554f\u984c\u3067\u3042\u308bQP\u3092\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306b\u5909\u5f62\u3057\u3066\u89e3\u3044\u3066\u3044\u308b\u3002\u3053\u308c\u306b\u3042\u305f\u3063\u3066B\u884c\u5217\u3092\u4fee\u6b63\u30b3\u30ec\u30b9\u30ad\u30fc\u5206\u89e3\u3059\u308b</p> \\[ B = LDL^T \\] <p>\u5206\u89e3\u3057\u305f\u884c\u5217\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u3092\u89e3\u304f</p> \\[ \\begin{array}{} \\underset{d}{\\text{min}} || D^\\frac{1}{2}L^Td + D^{-\\frac{1}{2}}L^{-1}\\nabla f(x) ||\\\\ \\text{s.t.} \\space \\nabla g_i(x)^Td + g_i(x) = 0, \\space i = 0, \\dots , m_e\\\\ \\text{\u3000\u3000\u3000} \\space \\nabla g_i(x)^Td + g_i(x) \\leq 0, \\space i = m_e+1, \\dots , l\\\\ \\end{array} \\]"},{"location":"tech_note/optimize/sqp/#qp","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5\u554f\u984c\u304b\u3089QP\u554f\u984c\u3078\u306e\u5909\u63db","text":"<p>Kraft, D. A software package for sequential quadratic    programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace    Center -- Institute for Flight Mechanics, Koln, Germany.</p>"},{"location":"tech_note/optimize/sqp/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316</li> <li> <p>SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066</p> </li> <li> <p>fmincon SQP \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0     \u57fa\u672c\u7684\u306a\u5b9f\u88c5\u306f\u3053\u306e\u30da\u30fc\u30b8\u306efmincon \u30a2\u30af\u30c6\u30a3\u30d6 \u30bb\u30c3\u30c8 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u53c2\u7167</p> </li> </ul>"},{"location":"tech_note/optimize/tolerances_and_stopping/","title":"\u8a31\u5bb9\u8aa4\u5dee\u30fb\u505c\u6b62\u6761\u4ef6","text":"<p>\u6700\u9069\u5316\u3092\u884c\u3046\u4e0a\u3067\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u505c\u6b62\u6761\u4ef6\u3092\u5224\u65ad\u3059\u308b\u305f\u3081\u306b\u8a31\u5bb9\u8aa4\u5dee\u3092\u8a2d\u5b9a\u3059\u308b\u3002 \u3053\u306e\u8a31\u5bb9\u8aa4\u5dee\u306b\u306f\u6700\u9069\u6027\u30fb\u95a2\u6570\u5024\u30fb\u30b9\u30c6\u30c3\u30d7\u30fb\u5236\u7d04\u306b\u5bfe\u3057\u3066\u76e3\u8996\u3055\u308c\u3001\u307e\u305f\u3001\u305d\u308c\u305e\u308c\u306e\u8a31\u5bb9\u8aa4\u5dee\u306f\u554f\u984c\u8a2d\u5b9a\u306b\u3088\u3063\u3066\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u304b\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u5316\u304c\u7570\u306a\u308b\u3002</p>"},{"location":"tech_note/optimize/tolerances_and_stopping/#_2","title":"\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u3068\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee","text":""},{"location":"tech_note/optimize/tolerances_and_stopping/#_3","title":"\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee","text":"<p>\u5404\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3067\u8a55\u4fa1\u3055\u308c\u305f\u5024\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee  \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408  </p> \\[ (f(x_{i+1}) - f(x_i)) &lt; AbsTolerance  \\] <p>\u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408  </p> \\[ |x_{i+1} - x_{i}| &lt; AbsTolerance \\]"},{"location":"tech_note/optimize/tolerances_and_stopping/#_4","title":"\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee","text":"<p>\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308b\u5024\u306e\u5909\u5316\u91cf\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408</p> \\[ (f(x_{i+1}) - f(x_i)) &lt; RelTolerance \\times (1 + f(x_i)) \\] <p>\u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408  </p> \\[ |x_{i+1} - x_{i}| &lt; RelTolerance \\times (1 + |x_i|) \\] \u554f\u984c \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 \u6700\u9069\u6027\u306e\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u8a31\u5bb9\u8aa4\u5dee \u30b9\u30c6\u30c3\u30d7\u306e\u8a31\u5bb9\u8aa4\u5dee \u5236\u7d04\u306e\u8a31\u5bb9\u8aa4\u5dee \u5099\u8003 \u5236\u7d04\u306a\u3057\u975e\u7dda\u5f62\u6700\u9069\u5316 (fminsearch) - Abs Abs - \u540c\u6642\u306b\u6e80\u305f\u3057\u305f\u6642\u7d42\u4e86\u3068\u3059\u308b \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Rel - Rel - \u5236\u7d04\u4ed8\u304d\u975e\u7dda\u5f62\u6700\u9069\u5316 \u5185\u70b9\u6cd5 Rel - Rel Rel \u6709\u52b9\u5236\u7d04\u6cd5 Abs Abs Abs Abs \u9010\u6b21\u4e8c\u6b21\u6700\u9069\u5316(SQP) Rel - Rel Rel <p>Abs: \u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee Rel: \u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee  </p>"},{"location":"tech_note/optimize/tolerances_and_stopping/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u8a31\u5bb9\u8aa4\u5dee\u3068\u505c\u6b62\u6761\u4ef6</li> <li>\u8a31\u5bb9\u8aa4\u5dee\u306e\u8a73\u7d30</li> </ul>"},{"location":"tech_note/path_planning/a_star/","title":"A*","text":"<p>A*\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u30b0\u30e9\u30d5\u63a2\u7d22\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u4e00\u7a2e\u3067\u3001\u30b0\u30ea\u30c3\u30c9\u72b6\u306b\u533a\u5207\u3089\u308c\u305f\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u304a\u3051\u308b\u7d4c\u8def\u8a08\u753b\u3067\u3088\u304f\u7528\u3044\u3089\u308c\u3066\u3044\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/path_planning/a_star/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>A*</li> <li>\u3088\u304f\u308f\u304b\u308bA*(A-star)\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 (Unity2D\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3064\u304d)</li> </ul>"},{"location":"tech_note/path_planning/dubins_path/","title":"Dubins\u66f2\u7dda","text":"<p>Dubins\u30d1\u30b9\u306f2\u6b21\u5143\u7a7a\u9593\u4e0a\u3067\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u5411\u304d\u3092\u4e0e\u3048\u308b\u3068\u3001\u59cb\u70b9\u3068\u7d42\u70b9\u3092\u76f4\u9032\u304b\u4e00\u5b9a\u306e\u66f2\u7387\u306e\u30ab\u30fc\u30d6\u304b\u3067\u6700\u77ed\u3068\u306a\u308b\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002</p>"},{"location":"tech_note/path_planning/dubins_path/#_1","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","text":"<p>Dubins\u30d1\u30b9\u3067\u306f\u76f4\u9032\u3092S\u3001\u53f3\u56de\u308a\u306e\u7d4c\u8def\u3092R\u3001\u5de6\u56de\u308a\u306e\u7d4c\u8def\u3092L\u3068\u3057\u3066\u6587\u5b57\u306e\u7d44\u307f\u5408\u308f\u305b\u3067\u3069\u3046\u3044\u3046\u5f62\u3092\u7d4c\u8def\u5316\u3092\u8868\u3059\u3002\u4f8b\u3048\u3070\u76f4\u9032\u3057\u305f\u5f8c\u306b\u53f3\u56de\u308a\u3059\u308b\u3088\u3046\u306a\u7d4c\u8def\u306fSR\u3068\u306a\u308b\u3002</p> <p>Dubins\u30d1\u30b9\u3067\u306f\u4e8c\u70b9\u9593\u3092\u7d50\u3076\u7d4c\u8def\u306f3\u533a\u9593\u304b\u3089\u306a\u308b\u7d4c\u8def\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3057\u3066\u3044\u308b\u3002\u3055\u3089\u306b\u306f6\u7a2e\u985e\u306e\u7d4c\u8def\u306e\u3069\u308c\u304b\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u307e\u3067\u8a3c\u660e\u3057\u3066\u3044\u308b\u3002</p> <p>\u5177\u4f53\u7684\u306b\u306f</p> <ul> <li>RLR</li> <li>LRL</li> <li>LSR</li> <li>LSL</li> <li>RSL</li> <li>RSR</li> </ul> <p>\u306e6\u7a2e\u985e\u3092\u7dcf\u5f53\u308a\u3059\u308c\u3070\u305d\u306e\u3046\u3061\u3069\u308c\u304b\u304c\u6700\u77ed\u3067\u5230\u9054\u3067\u304d\u308b\u7d4c\u8def\u3068\u306a\u308b\u3002</p>"},{"location":"tech_note/path_planning/dubins_path/#_2","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>Python\u306b\u3088\u308bDubins\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0</li> </ul>"},{"location":"tech_note/path_planning/dwa/","title":"DWA(Dynamic Window Approach)","text":"<p>\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u306f\u591a\u304f\u306e\u6d3e\u751f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304c\u5b58\u5728\u3059\u308b</p>"},{"location":"tech_note/path_planning/dwa/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>DWA\uff08Dynamic Window Approach\uff09\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u3066\u307f\u305f</li> <li>Dynamic Window Approach\u3092\u5229\u7528\u3057\u305fMotion planning\u306eMATLAB, Python \u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0</li> </ul>"},{"location":"tech_note/path_planning/frenet_path/","title":"\u30d5\u30ec\u30cd\u5ea7\u6a19\u7cfb","text":""},{"location":"tech_note/path_planning/frenet_path/#_2","title":"\u53c2\u8003\u6587\u732e","text":""},{"location":"tech_note/path_planning/rvo/","title":"RVO","text":""},{"location":"tech_note/path_planning/rvo/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>RVO\u306b\u3088\u308b\u885d\u7a81\u56de\u907f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0</li> </ul>"},{"location":"tech_note/path_planning/spline/","title":"\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda","text":""},{"location":"tech_note/path_planning/spline/#_2","title":"\u88dc\u9593\u66f2\u7dda\u306e\u7a2e\u985e","text":"<p>\u30ed\u30dc\u30c3\u30c8\u306e\u79fb\u52d5\u3084\u30a2\u30af\u30c1\u30e5\u30a8\u30fc\u30bf\u306e\u8ecc\u9053\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u901a\u904e\u70b9\u3060\u3051\u3092\u6307\u5b9a\u3057\u3066\u66f2\u7dda\u7684\u306b\u88dc\u9593\u3055\u305b\u3066\u8ecc\u9053\u3092\u751f\u6210\u3059\u308b\u3002\u88dc\u9593\u66f2\u7dda\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3082\u306e\u304c\u3042\u308b </p> <ul> <li>Bezier\u66f2\u7dda(\u30d9\u30b8\u30a8\u66f2\u7dda)</li> <li>Hermite\u66f2\u7dda(\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda)</li> <li>Catmull-Rom\u66f2\u7dda(\u30ad\u30e3\u30c3\u30c8\u30e0\u30eb-\u30ed\u30e0\u66f2\u7dda?)</li> <li>Cubic-Spline\u66f2\u7dda(3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda)</li> </ul> <p>\u3053\u306e\u8a18\u4e8b\u3067\u306f\u4e8c\u6b21\u5143\u5e73\u9762\u4e0a\u3067\u306e\u66f2\u7dda\u306b\u3064\u3044\u3066\u8ff0\u3079\u3066\u3044\u304f</p>"},{"location":"tech_note/path_planning/spline/#bezier","title":"Bezier\u66f2\u7dda","text":"<p>N\u500b\u306e\u5236\u5fa1\u70b9\u3092\u4f7f\u3063\u3066\u66f2\u7dda\u3092\u4f5c\u308b\u7279\u5fb4\u3068\u3057\u3066 </p> <ul> <li>\u4e00\u822c\u306b0\u70b9\u76ee, N-1\u70b9\u76ee\u3057\u304b\u901a\u904e\u3057\u306a\u3044</li> </ul> <p>\u3088\u3063\u3066\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3068\u6349\u3048\u3066\u3082\u307b\u3068\u3093\u3069\u9593\u9055\u3044\u306a\u3044\u3060\u308d\u3046</p>"},{"location":"tech_note/path_planning/spline/#n","title":"N\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda","text":"<p>N\u500b\u306e\u5236\u5fa1\u70b9\u304b\u3089\u306a\u308b\u30d9\u30b8\u30a8\u66f2\u7dda\u3067\u3042\u308bN\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u6b21\u5f0f\u3067\u8868\u3055\u308c\u308b</p> \\[ P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) \\] <p>\u3053\u3053\u3067 \\(Bn\\): \u5236\u5fa1\u70b9\u306e\u4e8c\u6b21\u5143\u5ea7\u6a19(\\(n\\) = 0, 1\u22ef\\(N\\) \u2212 1) \\(JN\\) \u2212 1, \\(i\\)(\\(t\\)): \u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570</p>"},{"location":"tech_note/path_planning/spline/#_3","title":"\u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570","text":"\\[ J_{n, i}(t) = \\left(\\begin{array}{c}n\\\\i\\end{array} \\right)t^i(1-t)^{n-i} \\] <p>\u3053\u3053\u3067\u4e8c\u9805\u4fc2\u6570</p> \\[ \\left(\\begin{array}{c}n\\\\i\\end{array} \\right) = \\frac{n!}{i!(n-i)!} \\] <p>\u4e8c\u9805\u4fc2\u6570\u304c\u3071\u3063\u3068\u51fa\u3066\u3053\u306a\u3044\u3068\u304d\u306f\u30d1\u30b9\u30ab\u30eb\u306e\u4e09\u89d2\u5f62\u3092\u8003\u3048\u308b\u3068\u65e9\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\\(n\\)\u3068\\(i\\)\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u4e0a\u304b\u3089n+1\u6bb5\u76ee\u306e(\u5de6\u304b\u3089)i\u2005+\u20051\u500b\u76ee\u304c\u4fc2\u6570\u306b\u306a\u308b</p> <p>\u4ed6\u306e\u66f2\u7dda\u3068\u306e\u6bd4\u8f03\u306e\u305f\u3081\u306bN=4\u3068\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u306e\u3067N=4\u306b\u3064\u3044\u3066\u66f8\u304d\u4e0b\u3059\u3068\u4fc2\u6570\u306f</p> \\[ \\begin{array}{l} J_{3, 0}(t) = (1-t)^3\\\\ J_{3, 1}(t) = 3(1-t)^2t\\\\ J_{3, 2}(t) = 3(1-t)t^2\\\\ J_{3, 3}(t) = t^3 \\end{array} \\] <p>\u3088\u3063\u3066\u30d9\u30b8\u30a8\u66f2\u7dda</p> \\[ P(t)=(1-t)^3 B_0 +  3(1-t)^2t B_1 +  3(1-t)t^2 B_2 + t^3 B_3 \\quad \\quad t \\in [0, 1] \\]"},{"location":"tech_note/path_planning/spline/#hermite","title":"Hermite\u66f2\u7dda","text":"<p>\u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u540c\u69d8\u4e8c\u70b9\u9593\u306e\u66f2\u7dda\u88dc\u9593\u6cd5\u3067\u3042\u308b\u3002\u7279\u5fb4\u3068\u3057\u3066 </p> <ul> <li>\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u6307\u5b9a\u3059\u308b</li> </ul> <p>\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u3092\u305d\u308c\u305e\u308c\u6b21\u306e\u3088\u3046\u306b\u7f6e\u304f P0,\u2006P1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19 v0,\u2006v1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb (\u3044\u305a\u308c\u3082\u4e8c\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b)</p> <p>3\u6b21\u5f0f\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7f6e\u304f</p> \\[ \\begin{array}{l} f_x(t) = a_x t^3 + b_x t^2 + c_x t + d_x\\\\ f_y(t) = a_y t^3 + b_y t^2 + c_y t + d_y \\quad \\quad t \\in [0, 1] \\end{array} \\] <p>\u307e\u305fP0\u7b49\u306b\u3064\u3044\u3066\u3082P0x,\u2006P0y\u304c\u5b58\u5728\u3059\u308b</p> <p>\u4eca\u3001x\u3068y\u306b\u3064\u3044\u3066\u64cd\u4f5c\u306f\u540c\u3058\u306a\u306e\u3067\u3053\u3053\u304b\u3089\u306f\u5f0f\u3092\u898b\u3084\u3059\u304f\u3059\u308b\u305f\u3081\u306bxy\u306e\u6dfb\u5b57\u306f\u7701\u7565\u3059\u308b</p> <p>f(t)\u3092\u5fae\u5206\u3059\u308b\u3068</p> \\[ f(x) = at^3 + bt^2 + ct + d\\\\ f'(x) = 3at^2 + 2bt + c \\] <p>a\u304b\u3089d\u3092\u6c42\u3081\u3066\u3044\u304f\u3002 \u4e0e\u3048\u3089\u308c\u305f\u30d1\u30e9\u30e1\u30fc\u30bf\u3088\u308a  </p> \\[ \\begin{array}{l} f(0) = P_0\\\\ f(1) = P_1\\\\ f'(0) = v_0\\\\ f'(1) = v_1 \\end{array} \\] <p>\u3088\u3063\u3066t=0\u306b\u7740\u76ee\u3059\u308b\u3068</p> \\[ d = P_0\\\\ c = v_0 \\] <p>\u307e\u305ft=1\u306b\u304a\u3044\u3066</p> \\[ \\begin{array}{l} f(1) = a + b + c + d = P_1 \u3088\u308a\\\\ c = v_0, d=P_0\u3092\u4ee3\u5165\u3057\u3066\\\\ a + b = P_1 - P_0 - v_0\\\\ \\\\ f'(1) = 3a + 2b + c = v_1 \u3088\u308a\\\\ c = v_0\u3092\u4ee3\u5165\u3057\u3066\\\\ 3a + 2b = v_1 - v_0 \\end{array} \\] <p>\u305d\u308c\u305e\u308c\u306e\u5f0f\u3092\u2460,\u2461\u3068\u3057\u3066\u2461\u22122\u00d7\u2460\u3067a\u3092\u6c42\u3081\u3066\u304b\u3089b\u306b\u3064\u3044\u3066\u3082\u89e3\u304f\u3068</p> \\[ a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1 \\] <p>\u3088\u3063\u3066</p> \\[ \\begin{array}{l} a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1\\\\ c = v_0\\\\ d = P_0 \\end{array} \\] <p>a\u301cd\u3092x,y\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u6c42\u3081\u3066fx(t),fy(t)\u306b\u4ee3\u5165\u3059\u308b\u3053\u3068\u3067Hermite\u66f2\u7dda\u3092\u63cf\u753b\u3067\u304d\u308b</p> <p>\u30e1\u30e2\u66f8\u304d\u3068\u3057\u3066\u6b8b\u3057\u3066\u304a\u304f\u304ct\u306e\u6b21\u6570\u3067\u306f\u306a\u304fP0,\u2006P1,\u2006v0,\u2006v1\u306b\u3064\u3044\u3066\u304f\u304f\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ \\begin{array}{l} f(t) = \\\\ (2t^3 - 3t^2 + 1)P_0\\\\ (-2t^3 + 3t^2)P_1\\\\ (t^3 -2t^2 + t)v_0\\\\ (t^3 - t^2)v_1\\\\ \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#catmull-rom","title":"Catmull-Rom\u66f2\u7dda","text":"<p>\u5b9f\u969b\u554f\u984c\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3060\u3051\u3060\u3068\u8db3\u308a\u306a\u3044\u3053\u3068\u304c\u591a\u3044\u3068\u601d\u3046 \u305d\u3053\u3067Hermite\u66f2\u7dda\u3092\u3064\u306a\u3052\u3066\u4f5c\u3089\u308c\u308bCatmull-Rom\u66f2\u7dda\u3092\u8003\u3048\u308b\u3002\u7279\u5fb4\u306f </p> <ul> <li>N\u500b(N &gt; 1)\u306e\u70b9\u3092\u3059\u3079\u3066\u901a\u904e\u3059\u308b\u66f2\u7dda\u3092\u4f5c\u308c\u308b</li> <li>Herimite\u66f2\u7dda\u3067\u4f7f\u3063\u305f\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u5fc5\u8981\u3068\u3057\u306a\u3044</li> </ul> <p>(\u672c\u5f53\u306fHermite\u66f2\u7dda\u3068\u306f\u5225\u306bCatmull-\u66f2\u7dda\u304c\u3067\u304d\u3066\u540c\u30583\u6b21\u5f0f\u3060\u304b\u3089\u5909\u63db\u3067\u304d\u308b\u3088\u306d\u3001\u306e\u6d41\u308c\u306a\u6c17\u304c\u3059\u308b\u3051\u3069\u6587\u732e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u304b\u3063\u305f)</p> <p>i\u756a\u76ee\u306e\u7d42\u70b9\u3092i+1\u756a\u76ee\u306e\u59cb\u70b9\u306b\u3059\u308b\u3053\u3068\u3067\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u306f\u306a\u308b\u304c\u6ed1\u3089\u304b\u306b\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u3059\u308b\u305f\u3081\u306e\u62d8\u675f\u304c\u5fc5\u8981\u306b\u306a\u308b</p> <p>N\u70b9\u304b\u3089\u306a\u308b\u66f2\u7dda\u306e\u3046\u3061\u7aef\u70b9\u4ee5\u5916\u306e\u88dc\u9593\u306b\u3064\u3044\u3066\u8003\u3048\u308b i\u756a\u76ee\u306e\u70b9\u306b\u304a\u3051\u308b\u901f\u5ea6\u3092\u4e21\u96a3\u306e\u5ea7\u6a19\u304b\u3089\u4f5c\u308b\u3053\u3068\u3067\u6ed1\u3089\u304b\u306b\u3064\u306a\u3050</p> \\[ v_i = \\frac{1}{2}(P_{i+1} - P_{i-1}) \\] <p>\u66f2\u7dda\u306e\u7aef\u70b9(i\u2004=\u20040,\u2006N\u2005\u2212\u20051)\u3067\u306f\u3053\u306e\u5f0f\u304c\u4f7f\u3048\u306a\u3044\u306e\u3067\u81ea\u8eab\u306e\u5ea7\u6a19\u3068\u96a3\u306e\u5ea7\u6a19\u3067\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u4f5c\u308b</p> \\[ \\begin{array}{l} v_0 = P_1 - P_0\\\\ v_{N-1} = P_{N-1} - P_{N-2} \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#tension","title":"tension\u306b\u3064\u3044\u3066","text":"<p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#_4","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u533a\u5206\u306b\u3064\u3044\u3066","text":"<p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#cubic-spline","title":"Cubic-Spline\u66f2\u7dda","text":"<p>\u81ea\u5206\u304c\u9ad8\u5c02\u30ed\u30dc\u30b3\u30f3\u3067\u53c2\u7167\u8ecc\u9053\u306f\u3053\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3060\u3063\u305f\u3002</p> <p>\u7279\u5fb4\u3068\u3057\u3066 </p> <ul> <li>\u5165\u529b\u306fCatmull-Rom\u3068\u540c\u3058\u901a\u904e\u70b9\u306e\u307f\u3060\u304c\u3088\u308a\u6ed1\u3089\u304b\u3067\u3042\u308b</li> <li>(\u3082\u3057\u304b\u3057\u305f\u3089\u5c11\u3057\u91cd\u3044?)</li> </ul> <p>3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3067\u306f\u4ee5\u4e0b\u306e\u6761\u4ef6\u306b\u5f93\u3046\u3088\u3046\u306a\u66f2\u7dda\u3092\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f\u3053\u3068\u306b\u3088\u3063\u3066\u6c42\u3081\u308b</p> \\[ \\begin{array}{l} S_j(x_j) = y_j\\\\ S_j(x_{j+1}) = S_{j+1}(x_{j+1}) = y_{j+1}\\\\ S'_j(x_{j+1}) = S'_{j+1}(x_{j+1})\\\\ S''_j(x_{j+1}) = S''_{j+1}(x_{j+1})\\\\ S'_0(x_{0}) = S'_{n-1}(x_{n}) = 0 \\end{array} \\] <p>\u3053\u308c\u3089\u306f</p> <ul> <li>\u591a\u9805\u5f0fS\u306bx\u3092\u5165\u529b\u3059\u308b\u3068y\u3092\u51fa\u529b\u3059\u308b</li> <li>\u591a\u9805\u5f0fS\u306e\u304c\u7e4b\u304c\u3063\u3066\u3044\u3066\u5236\u5fa1\u70b9\u3092\u901a\u308b</li> <li>\u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b</li> <li>\u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u52a0\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b</li> <li>\u7aef\u70b9\u3067\u306f\u52a0\u901f\u5ea6\u306f0\u3067\u3042\u308b \u3053\u3068\u3092\u793a\u3059\u3002</li> </ul>"},{"location":"tech_note/path_planning/spline/#hermitebezier","title":"Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b","text":"<p>\u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u901a\u904e\u3057\u306a\u3044\u5ea7\u6a19\u3092\u4e0e\u3048\u308b\u305f\u3081\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089\u66f2\u7dda\u3092\u60f3\u50cf\u3057\u3065\u3089\u3044\u305f\u3081\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda\u306e\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u30894\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b\u5b9f\u88c5\u304c\u3055\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u3092\u898b\u304b\u3051\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u305d\u306e\u5b9f\u88c5\u306e\u5c0e\u51fa\u3092\u3057\u3066\u3044\u304f\u3002</p> <p>\u307e\u305a\u305d\u308c\u305e\u308c\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092 Bezier\u66f2\u7dda: B0,\u2006B1,\u2006B2,\u2006B3(\u5236\u5fa1\u70b9) Hermite\u66f2\u7dda: P0,\u2006P1,\u2006v0,\u2006v1(\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb) \u3068\u3059\u308b\u3002</p> <p>\u6b21\u306b\u305d\u308c\u305e\u308c\u5f0f\u3092\u66f8\u304d\u4e0b\u3057\u3001t\u306e\u6b21\u6570\u3054\u3068\u306b\u62ec\u308b\u3068</p> \\[ \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} \\] \\[ \\begin{array}{l} P_{herimite}(t) = \\\\ (2 P _0 - 2 P_1 + v_0 + v_1)t^3\\\\ (-3 P_0 + 3 P_1 -2 v_0  - v_1)t^2\\\\ (v_0)t^1\\\\ (P_0)t^0 \\end{array} \\] <p>Pbezier(t)\u2004=\u2004Pherimite(t)\u3068\u3057\u3066\u6052\u7b49\u5f0f\u3092\u89e3\u304f\u3068 (t0\u306b\u3064\u3044\u3066)</p> \\[ B_0 = P_0 \\] <p>(t1\u306b\u3064\u3044\u3066)</p> \\[ v_0 = -3 B_0 + 3 B_1\\\\ B_1 = P_0 + \\frac{1}{3}v_0 \\] <p>(t2\u306b\u3064\u3044\u3066)</p> \\[ -3 P_0 + 3 P_1 -2 v_0  - v_1 = 3 P_0 -6(P_0 + \\frac{1}{3} v_0) + 3 B_2\\\\ B_2 = P_1 - \\frac{1}{3} v_1 \\] <p>(t3\u306b\u3064\u3044\u3066)</p> \\[ 2 P _0 - 2 P_1 + v_0 + v_1 = - P_0 + 3(P_0 + \\frac{1}{3}v_0) - 3(P_1 - \\frac{1}{3}v_1) + B_3\\\\ B_3 = P_1 \\] <p>\u3088\u3063\u3066</p> \\[ \\begin{array}{l} B_0 = P_0\\\\   B_1 = P_0 + \\frac{1}{3}v_0\\\\ B_2 = P_1 - \\frac{1}{3} v_1\\\\ B_3 = P_1 \\end{array} \\] <p>\u3068\u3059\u308b\u3068Hermite\u66f2\u7dda\u306e\u5165\u529b\u3092Bezier\u66f2\u7dda\u3067\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u5b9f\u88c5\u3059\u308b\u306b\u5f53\u305f\u3063\u3066</p> \\[ \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}v_0\\\\ BP_2 = P_1 - \\frac{1}{3} v_1 \\end{array} \\] <p>\u3068\u4e00\u6642\u5909\u6570\u3092\u5ba3\u8a00\u3057\u3066\u3044\u308b\u3053\u3068\u3082\u3042\u308b</p>"},{"location":"tech_note/path_planning/spline/#catmull-rombezier","title":"Catmull-Rom\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b","text":"<p>Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u6c42\u3081\u3066\u3044\u308c\u3070\u4ee3\u5165\u3059\u308b\u3060\u3051</p> \\[ \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1})\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) \\end{array} \\] <p>i=0\u306e\u3068\u304d</p> \\[ \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}(P_1 - P_0)\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) (\u5909\u308f\u3089\u305a) \\end{array} \\] <p>i = N-1\u306e\u3068\u304d</p> \\[ \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1})  (\u5909\u308f\u3089\u305a)\\\\ BP_2 = P_{N-1} - \\frac{1}{3} (P_{N-1} - P_{N-2}) \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#bezier_1","title":"\u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b","text":"<p>\u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f</p> \\[ f(t) = a t^3 + b t^2 + c t + d \\] <p>\u306b\u3064\u3044\u3066Bezier\u66f2\u7dda\u3068\u6052\u7b49\u5f0f\u3068\u3057\u3066\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b(Hermite-&gt;Bezier\u306e\u6642\u3068\u540c\u3058)</p> \\[ \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} \\] <p>\u3088\u3063\u3066</p> \\[ \\begin{array}{l} a = B_0 + 3 B_1 -3 B_2 + B_3\\\\ b = 3 B_0 -6 B_1 + 3 B_2\\\\ c = -3 B_0 + 3 B_1\\\\ d = B_0 \\end{array} \\] <p>\u3053\u308c\u3092\u89e3\u304f\u3068</p> \\[ \\begin{array}{l} B_0 = d\\\\ B_1 = d + \\frac{1}{3}c\\\\ B_2 = \\frac{1}{3}b + \\frac{2}{3}c + d\\\\ B_3 = a + b + c + d \\end{array} \\]"},{"location":"tech_note/path_planning/spline/#_5","title":"\u4f4d\u7f6e\u30fb\u901f\u5ea6\u30fb\u52a0\u901f\u5ea6","text":"<p>Bezier\u66f2\u7dda\u306e\u5b9a\u7fa9\u3088\u308a\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570\u306b\u3088\u308b\u91cd\u307f\u3092\u305d\u308c\u305e\u308c</p> \\[ B = \\left[B_0, B_1, B_2, B_3\\right] \\] \\[ W = \\left[ \\begin{array}{c} -t^3 + 3t^2 - 3t + 1\\\\ 3t^3 -6 t^2 +3 t\\\\ -3 t^3 + t^2\\\\ t^3 \\end{array} \\right] \\] <p>\u3068\u30d9\u30af\u30c8\u30eb\u8868\u8a18\u3057\u305f\u5834\u5408\u3001\u4f4d\u7f6e\u306f\u6b21\u5f0f\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p> \\[ P(t) = B \\cdot W \\] <p>\u3053\u3053\u3067W\u3092\u4fc2\u6570\u3068tn\u306b\u5206\u89e3\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308b</p> \\[ W = W_m T =   \\left [\\begin{array}{c} -1 &amp; 3 &amp; -3 &amp; 1\\\\ 3 &amp; -6 &amp; 3 &amp; 0\\\\ -3 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] \\] <p>\u3053\u308c\u3092\u4f7f\u3046\u3068\u4f4d\u7f6e\u306e\u5f0f\u306f\u6b21\u306e\u3088\u3046\u306b\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b</p> \\[ P(t) = B  W_m T = \\left[B_0, B_1, B_2, B_3\\right] \\left [\\begin{array}{c} -1 &amp; 3 &amp; -3 &amp; 1\\\\ 3 &amp; -6 &amp; 3 &amp; 0\\\\ -3 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] \\] <p>T\u306e\u8981\u7d20\u3092t\u30671\u56de\u5fae\u5206\u30012\u56de\u5fae\u5206\u3057\u3066\u3059\u308b\u3053\u3068\u3067\u901f\u5ea6\u3001\u52a0\u901f\u5ea6\u3082\u8868\u73fe\u53ef\u80fd\u3067\u3042\u308b \u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408</p> \\[ T =  \\left [\\begin{array}{c} 3t^2\\\\ 2t\\\\ 1\\\\ 0 \\end{array} \\right ] \\] <p>\u52a0\u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408</p> \\[ T =  \\left [\\begin{array}{c} 6t\\\\ 2\\\\ 0\\\\ 0 \\end{array} \\right ] \\]"},{"location":"tech_note/path_planning/spline/#de-casteljaubezier","title":"De Casteljau\u6cd5\u306b\u3088\u308bBezier\u66f2\u7dda\u306e\u5206\u5272","text":"<p>\u89e3\u6790\u7684\u306b\u9023\u7d9a\u306a\u95a2\u6570\u3068\u3057\u3066\u66f2\u7dda\u304c\u5f97\u3089\u308c\u3066\u3082\u5b9f\u7528\u4e0a\u306f\u76f4\u7dda\u8fd1\u4f3c\u3057\u3066\u4f7f\u3046\u307f\u305f\u3044\u306a\u306e\u306f \u305d\u3093\u306a\u3068\u304d\u5a92\u4ecb\u5909\u6570t\u3067\u7b49\u5206\u3059\u308b\u3053\u3068\u3092\u307e\u305a\u601d\u3044\u3064\u304f\u3060\u308d\u3046\u304c\u66f2\u7387\u304c\u5c0f\u3055\u3044\u3068\u3053\u308d\u3067\u7121\u99c4\u306b\u5206\u5272\u3055\u308c\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3057\u3001\u66f2\u7387\u304c\u5927\u304d\u3044\u3068\u3053\u308d\u3067\u5206\u5272\u304c\u8db3\u308a\u305a\u306b\u4e0a\u624b\u304f\u66f2\u7dda\u8fd1\u4f3c\u3067\u304d\u306a\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\u76f4\u7dda\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306b\u306f\u66f2\u7387\u306b\u3088\u3063\u3066\u5206\u5272\u3059\u308b\u533a\u5206\u306e\u9577\u3055\u3092\u5909\u3048\u305f\u307b\u3046\u304c\u8fd1\u4f3c\u5ea6\u304b\u3089\u8003\u3048\u308b\u3068\u5408\u7406\u7684\u3060\u308d\u3046\u3002</p> <p>Bezier\u66f2\u7dda</p> \\[ P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) \\quad \\quad t \\in [0, 1] \\] <p>\u3092t0\u30672\u3064\u306e\u533a\u9593\u306b\u5206\u5272\u3059\u308b</p> \\[ P_0(t) = \\sum_{i = 0}^{N-1}B_{0i} J_{N-1, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] \\] \\[ P_1(t) = \\sum_{i = 0}^{N-1}B_{1i} J_{N-1, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] \\] <p>\u4eca\u3001\u898b\u3084\u3059\u3055\u306e\u305f\u3081\u306bn\u2004=\u2004N\u2005\u2212\u20051\u3068\u3057\u3066\u304a\u304f</p> \\[ P_0(t) = \\sum_{i = 0}^{n}B_{0i} J_{n, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] \\] \\[ P_1(t) = \\sum_{i = 0}^{n}B_{1i} J_{n, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] \\] <p>\u3053\u306e\u3068\u304dB0n,\u2006B1n\u306e\u8a08\u7b97\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u518d\u5e30\u7684\u306b\u4e0e\u3048\u3089\u308c\u308b</p> \\[ \\begin{array}{l} B_i^{(0)} := B_i \\quad \\quad \\quad i = 0, 1 \\cdots n\\\\ B_i^{(j)} := B_i^{(j-1)}(1-t_0) + B_{i+1}^{(j-1)}t_0 i \\quad \\quad i = 0, 1 \\cdots (n-j), \\quad  j = 1, 2 \\cdots n\\\\ \\end{array} \\] <p>\u3068\u5b9a\u7fa9\u3057\u305f\u3068\u304d</p> \\[ \\begin{array}{l} B_{0n} = B_0^{(i)}\\\\ B_{1n}= B_i^{(n-1)} \\end{array} \\] <p>N\u2004=\u20044\u306b\u3064\u3044\u3066\u7dda\u5f62\u88dc\u9593\u95a2\u6570lerp(a,\u2006b,\u2006t)\u3092\u5b9a\u7fa9\u3057\u305f\u4e0a\u3067\u66f8\u304d\u4e0b\u3057\u3066\u307f\u308b</p> \\[ lerp(a, b, t) := a(1-t) + bt \\quad \\quad t \\in [0, 1] \\] <p>\u3068\u3057\u3066\u5206\u5272\u524d\u306e\u4fc2\u6570B\u2004=\u2004[B0,\u2006B1,\u2006B2,\u2006B3],\u5206\u5272\u5f8c\u306e\u4fc2\u6570\u3092\u305d\u308c\u305e\u308cSB0\u2004=\u2004[B00,\u2006B01,\u2006B02,\u2006B03],SB1\u2004=\u2004[B10,\u2006B11,\u2006B12,\u2006B13]\u3068\u3057\u3066t0\u3067B\u3092\u5206\u5272\u3059\u308b\u3068</p> \\[ SB_0 =  \\left[ \\begin{array}{l} B_0\\\\ lerp(B_0, B_1, t_0)\\\\ lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0)\\\\ lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0) \\end{array} \\right] \\] \\[ SB_1 =  \\left[ \\begin{array}{l} lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0)\\\\ lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0)\\\\ lerp(B_2, B_3, t_0)\\\\ B_3 \\end{array} \\right] \\]"},{"location":"tech_note/path_planning/spline/#_6","title":"\u66f2\u7dda\u306e\u9577\u3055","text":"<p>Bezier\u66f2\u7dda\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b Bezier\u66f2\u7dda\u3067\u306a\u3044\u66f2\u7dda\u306b\u3064\u3044\u3066\u306fBezier\u66f2\u7dda\u306b\u5909\u63db\u3067\u304d\u308b\u306e\u3067\u3053\u3053\u3067\u306f\u8003\u3048\u306a\u3044\u3082\u306e\u3068\u3059\u308b</p>"},{"location":"tech_note/path_planning/spline/#_7","title":"\u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u3066\u307f\u308b","text":"<p>\u53b3\u5bc6\u306b\u8003\u3048\u305a\u306b\u3042\u308b\u7a0b\u5ea6\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3053\u3068\u3092\u8003\u3048\u308b \u4e0b\u306e\u56f3\u3088\u308a\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u9577\u3055\u306f\u5927\u96d1\u628a\u306b\u898b\u3066\u3082|P3\u2212P0|\u4ee5\u4e0a\u3067|P1\u2212P0|\u2005+\u2005|P2\u2212P1|\u2005+\u2005|P3\u2212P2|\u4ee5\u4e0b\u3067\u3042\u308b\u3053\u3068\u304c\u898b\u3066\u53d6\u308c\u308b\u3060\u308d\u3046</p> <p></p> <p>(\u51fa\u5178\uff1a1.\u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u306f)</p> <p>\u4ecaMinLength\u3068MaxLength\u3092\u6b21\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3059\u308b</p> \\[ \\begin{aligned} MinLnegth &amp;= |P_3-P_0|\\\\ &amp;= \\sqrt{(P_{3x}-P_{0x})^2 + (P_{3y}-P_{0y})^2}\\\\ MaxLength &amp;= |P_1-P_0| + |P_2-P_1| + |P_3-P_2|\\\\ &amp;= \\sqrt{(P_{1x}-P_{0x})^2 + (P_{1y}-P_{0y})^2} +  \\sqrt{(P_{2x}-P_{1x})^2 + (P_{2y}-P_{1y})^2} + \\sqrt{(P_{3x}-P_{2x})^2 + (P_{3y}-P_{2y})^2} \\end{aligned} \\] <p>(Pn\u306f\u524d\u9805\u307e\u3067Bn\u3068\u8a18\u8ff0\u3057\u3066\u3044\u305f\u3051\u3069\u753b\u50cf\u3092\u4f5c\u308b\u306e\u304c\u9762\u5012\u304f\u3055\u304f\u3066\u6301\u3063\u3066\u304d\u305f\u306e\u306b\u5408\u308f\u305b\u305f\u3060\u3051\u306a\u306e\u3067\u8aa4\u89e3\u3057\u306a\u3044\u3067\u306d)</p> <p>\u3053\u306e\u5e73\u5747\u3092\u5927\u4f53\u306e\u9577\u3055\u3068\u3057\u3066\u5b9a\u7fa9\u3059\u308b</p> \\[ EstimateLength = \\frac{MinLength + MaxLength}{2} \\] <p>\u3059\u308b\u3068\u8aa4\u5dee\u306f\u5927\u304d\u304f\u3066\u3082\u5dee\u306e\u534a\u5206\u3067\u3042\u308b</p> \\[ MaxError = \\frac{MaxLength - MinLength}{2} \\]"},{"location":"tech_note/path_planning/spline/#_8","title":"\u8a31\u5bb9\u8aa4\u5dee\u306e\u60c5\u5831\u3092\u4f7f\u3063\u3066\u89e3\u50cf\u5ea6\u3092\u6700\u9069\u5316\u3059\u308b","text":"<p>\u4e0a\u8a18\u306e\u65b9\u6cd5\u3067\u300c\u5927\u4f53\u306e\u300d\u9577\u3055\u304c\u6c42\u307e\u308b\u3002MaxError\u306e\u5024\u304c\u5927\u304d\u3051\u308c\u3070\u66f2\u7dda\u306e\u524d\u8ff0\u306e\u65b9\u6cd5\u3067\u5206\u89e3\u3057\u3066\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u518d\u5e30\u7684\u306a\u51e6\u7406\u306b\u306a\u308b\u3060\u308d\u3046\u3002\u3053\u3053\u3067\u6ce8\u610f\u3059\u308b\u306e\u306fMaxError\u306f\u3042\u304f\u307e\u3067MinLength\u3068MaxLength\u304b\u3089\u898b\u305f\u8aa4\u5dee\u306e\u6700\u5927\u3067\u7cbe\u5ea6\u304c\u307b\u3057\u3044\u304b\u3089\u3068\u8a00\u3063\u3066MaxError\u304c0.001\u3092\u4e0b\u56de\u308b\u307e\u3067\u5206\u5272\u3057\u7d9a\u3051\u308b\u306a\u3093\u3066\u5fc5\u8981\u306f\u306a\u3044\u3002\u691c\u8a3c\u306f\u3057\u3066\u306a\u3044\u304c0.1\u3001\u5c0f\u3055\u304f\u3066\u30820.05\u3092\u4e0b\u56de\u3063\u3066\u3044\u308c\u3070\u5341\u5206\u306a\u7cbe\u5ea6\u3092\u5f97\u3089\u308c\u308b\u3068\u601d\u3046\u3002</p>"},{"location":"tech_note/path_planning/spline/#_9","title":"\u533a\u9593\u3092\u6307\u5b9a\u3057\u3066\u9577\u3055\u3092\u6c42\u3081\u308b","text":"<p>\u4e0a\u3067\u6c42\u3081\u305f\u9577\u3055\u306ft\u304c0\u304b\u30891\u307e\u3067\u306e\u9577\u3055\u3068\u6349\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u4efb\u610f\u306et\u306e\u533a\u9593\u306b\u304a\u3051\u308b\u9577\u3055\u306b\u3064\u3044\u3066\u62e1\u5f35\u3059\u308b\u306b\u306f\u533a\u9593\u306e\u5206\u5272\u3092\u6d3b\u7528\u3059\u308b</p> <p>t0\u304b\u3089t1\u306e\u7bc4\u56f2\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3068\u304d t0\u2004=\u20040\u306e\u3068\u304d -&gt; t1\u3067\u5206\u5272\u3057\u305f\u524d\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 t1\u2004=\u20041\u306e\u3068\u304d -&gt; t0\u3067\u5206\u5272\u3057\u3066\u5f8c\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 \u305d\u308c\u4ee5\u5916\u306e\u3068\u304d -&gt; \u5206\u5272\u3092\u4e8c\u56de\u884c\u3063\u3066\u533a\u9593\u3092\u51fa\u3057\u3066\u304b\u3089\u9577\u3055\u3092\u51fa\u3059</p>"},{"location":"tech_note/path_planning/spline/#1","title":"\u6570\u5024\u7684\u306b\u901f\u5ea6\u30921\u306b\u3059\u308b","text":"<p>\u5a92\u4ecb\u5909\u6570t\u3092\u7528\u3044\u3066t\u3092\u52d5\u304b\u3057\u305f\u3068\u304d\u306b\u66f2\u7dda\u306e\u4e0a\u3092\u79fb\u52d5\u3059\u308b\u70b9\u306e\u901f\u5ea6\u306f\u4e00\u5b9a\u3067\u306f\u306a\u3044\u3002Catmull-Rom\u66f2\u7dda\u3084Cubic-Spline\u66f2\u7dda\u3067\u306f\u901f\u5ea6\u3092\u6307\u5b9a\u3057\u306a\u3044\u305f\u3081\u901f\u5ea6\u306b\u3064\u3044\u3066\u8003\u3048\u306b\u304f\u3044\u3002 \u901f\u5ea6\u3092\u7dda\u5f62\u5316\u3059\u308b\u3088\u3046\u306a\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u3066\u5a92\u4ecb\u5909\u6570\u3068\u3057\u3066\u66f2\u7dda\u306e\u95a2\u6570\u306b\u6e21\u3059\u3053\u3068\u306b\u306a\u308b\u304c\u3053\u306e\u95a2\u6570\u306f\u89e3\u6790\u7684\u306b\u6c42\u3081\u308b\u306e\u306f\u3067\u304d\u306a\u3044(\u3068\u601d\u3046)\u306e\u3067\u6570\u5024\u7684\u306b\u5b9f\u88c5\u3059\u308b\u65b9\u6cd5\u3092\u3068\u308b</p> <p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#_10","title":"\u66f2\u7387","text":"<p>\u8a73\u7d30\u306f\u7701\u7565\u3059\u308b\u304c\u5fd8\u308c\u304c\u3061\u306a\u306e\u3067\u66f8\u3044\u3066\u304a\u304f</p> <p>\u66f2\u7387\u03ba\u3068\u66f2\u7387\u534a\u5f84R\u306e\u95a2\u4fc2</p> \\[ \\kappa = \\frac{1}{R} \\] <p>\u901f\u5ea6\u30d9\u30af\u30c8\u30ebv\u3068\u52a0\u901f\u5ea6\u30d9\u30af\u30c8\u30eba\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d</p> \\[ R = \\frac{|v|^3}{|v\\times a|} \\]"},{"location":"tech_note/path_planning/spline/#todo","title":"(Todo)\u4efb\u610f\u306e\u5ea7\u6a19\u304b\u3089\u4e00\u756a\u8fd1\u3044\u66f2\u7dda\u4e0a\u306e\u70b9\u3092\u51fa\u3059","text":"<p>Info</p> <p>Todo</p>"},{"location":"tech_note/path_planning/spline/#_11","title":"\u5186\u5f27\u8fd1\u4f3c","text":"<p>\u5186\u5468\u4e0a\u306e\u4e8c\u70b9\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u305d\u306e\u4e8c\u70b9\u3092\u7d50\u3076\u5186\u5f27\u3092Hermite\u66f2\u7dda\u3067\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8003\u3048\u308b\u3002</p> <p>\u524d\u63d0\u6761\u4ef6\u3068\u3057\u3066</p> <ul> <li>\u4e8c\u70b9\u306f\u4e00\u3064\u306e\u5186\u5468\u4e0a\u306b\u3042\u308b</li> </ul> <p>Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\\(P_0\\), \\(P_1\\), \\(v_0\\), \\(v_1\\)\u306e\u3046\u3061\\(P_0\\), \\(P_1\\)\u306f\u4e0e\u3048\u3089\u308c\u305f\u4e8c\u70b9\u3001\\(v_0\\), \\(v_1\\)\u306e\u65b9\u5411\u306f\u5186\u306b\u6b63\u63a5\u3067\u5927\u304d\u3055\u306f\u4ee5\u4e0b\u3067\u8fd1\u4f3c\u3055\u308c\u308b</p> \\[ \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \\] <p>\u3053\u3053\u3067\\(\\theta\\)\u306f\u5186\u5f27\u306e\u89d2\u5ea6\u3001\\(r\\)\u306f\u5186\u306e\u534a\u5f84</p> <p>\u307e\u305f\u3053\u306e\u8fd1\u4f3c\u306f\\(\\theta &lt; \\pi\\)\u306e\u3068\u304d\u306b\u6709\u52b9\u3067\u3042\u308a\u305d\u308c\u4ee5\u4e0a\u3067\u306f\u8457\u3057\u304f\u5186\u5f27\u304b\u3089\u96e2\u308c\u3066\u3057\u307e\u3046\u305f\u3081\u6ce8\u610f\u304c\u5fc5\u8981</p>"},{"location":"tech_note/path_planning/spline/#_12","title":"\u7279\u6b8a\u306a\u6761\u4ef6\u3067\u306e\u5186\u5f27\u8fd1\u4f3c(\u5f0f\u5909\u5f62)","text":"<p>\u65e2\u77e5\u306e\u30d1\u30e9\u30e1\u30fc\u30bf</p> <ul> <li>\\(r\\)</li> <li>\\(P_0\\), \\(P_1\\)</li> <li>\\(v_0\\), \\(v_1\\)\u306e\u65b9\u5411</li> </ul> \\[ cos\\theta = \\frac{v_0 \\cdot v_1}{|v_0| |v_1|} \\] <p>\u534a\u89d2\u516c\u5f0f</p> \\[ cos\\theta = \\sqrt{\\frac{1+cos\\theta}{2}} \\] <p>\u534a\u89d2\u516c\u5f0f</p> \\[ \\tan\\frac{\\theta}{4} = \\sqrt{ \\frac{1-\\cos{ \\frac{\\theta}{2}}}{1+\\cos{\\frac{\\theta}{2}}}  } \\] \\[ \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \\]"},{"location":"tech_note/path_planning/spline/#_13","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u30d9\u30b8\u30a7\u66f2\u7dda</li> <li>\u30b2\u30fc\u30e0\u30d7\u30ed\u30b0\u30e9\u30de\u306e\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30c8\u30ea\u30c3\u30af\u66f2\u7dda\u5165\u9580(Hermite Curve)</li> <li>t-pot\u300e3\u6b21\u66f2\u7dda\u300f</li> <li>\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b0\u30e9\u30d5\u30a3\u30af\u30b9\u8ad6</li> <li>\u7c21\u7565\u5316\u3057\u305f3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u751f\u6210\u65b9\u6cd5</li> <li>\uff13\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u88dc\u9593\u306e\u6982\u8981\u3068C++, Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9</li> <li> <p>De Casteljau\u2019s algorithm</p> </li> <li> <p>\u30d9\u30b8\u30a7\u66f2\u7dda\u3067\u63cf\u304f\u5186\u5f27\u3068\u672c\u7269\u306e\u5186\u5f27\u306e\u5dee\uff08\u4e2d\u5fc3\u89d2\u306b\u3064\u3044\u3066\u4e00\u822c\u5316\uff09</p> </li> </ul>"},{"location":"tech_note/path_planning/wave_propagation/","title":"Wave propagation","text":"<p>Wave propagation\u306f\u30b0\u30ea\u30c3\u30c9\u306e\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u4e00\u7a2e\u3067\u3042\u308b\u3002A*\u3088\u308a\u5c48\u6298\u304c\u5c11\u306a\u3044\u5f62\u306e\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u3002</p>"},{"location":"tech_note/path_planning/wave_propagation/#_1","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>Path Planning #2 Wave Propagation, Potential Fields &amp; Modern(ish) C++ (YouTube)</li> </ul>"},{"location":"tech_note/software_design/design_pattern/","title":"\u30c7\u30b6\u30a4\u30f3\u30d1\u30bf\u30fc\u30f3","text":""},{"location":"tech_note/software_design/solid/","title":"SOLID\u539f\u5247","text":"<p>SOLID\u539f\u5247\u3068\u306f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u5de5\u5b66\u306e\u7528\u8a9e\u3067\u3001\u7279\u306b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u3067\u7528\u3044\u3089\u308c\u308b5\u3064\u306e\u539f\u5247\u306e\u982d\u6587\u5b57\u3092\u53d6\u3063\u305f\u3082\u306e\u3002 \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u8a2d\u8a08\u3092\u3088\u308a\u5e73\u6613\u304b\u3064\u67d4\u8edf\u306b\u3057\u3066\u4fdd\u5b88\u3057\u3084\u3059\u304f\u3059\u308b\u3053\u3068\u3092\u76ee\u7684\u306b\u3057\u3066\u3044\u308b\u3002\u305d\u306e\u7279\u5fb4\u306f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u4ef2\u4ecb\u306b\u3057\u3066\u306e\u6a5f\u80fd\u306e\u4f7f\u7528\u3068\u3001\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306b\u3088\u308b\u6a5f\u80fd\u306e\u6ce8\u5165\u3067\u3042\u308b\u3002</p> <p>SOLID\u306f\u3001\u6b21\u306e5\u3064\u306e\u539f\u5247\u304b\u3089\u306a\u308b\u3002</p> <ul> <li>\u5358\u4e00\u8cac\u4efb\u306e\u539f\u5247 (single-responsibility principle)</li> <li>\u958b\u653e\u9589\u9396\u306e\u539f\u5247\uff08open/closed principle\uff09</li> <li>\u30ea\u30b9\u30b3\u30d5\u306e\u7f6e\u63db\u539f\u5247\uff08Liskov substitution principle\uff09</li> <li>\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u5206\u96e2\u306e\u539f\u5247 (interface segregation principle)</li> <li>\u4f9d\u5b58\u6027\u9006\u8ee2\u306e\u539f\u5247\uff08dependency inversion principle\uff09</li> </ul>"},{"location":"tech_note/software_design/solid/#_1","title":"\u5358\u4e00\u8cac\u4efb\u306e\u539f\u5247","text":"<p>\u300c\u5909\u66f4\u3059\u308b\u305f\u3081\u306e\u7406\u7531\u304c\u3001\u4e00\u3064\u306e\u30af\u30e9\u30b9\u306b\u5bfe\u3057\u3066\u4e00\u3064\u4ee5\u4e0a\u3042\u3063\u3066\u306f\u306a\u3089\u306a\u3044\u300d</p> <p>\u5404\u30af\u30e9\u30b9\u306f\u305d\u308c\u305e\u308c\u3072\u3068\u3064\u3060\u3051\u306e\u8cac\u52d9(=\u63d0\u4f9b\u6a5f\u80fd)\u3092\u6301\u3064\u3079\u304d\u3067\u3042\u308a\u3001\u30b2\u30fc\u30e0\u3092\u4f8b\u306b\u53d6\u308c\u3070\u30b2\u30fc\u30e0\u306e\u9032\u884c\u30ed\u30b8\u30c3\u30af\u3092\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u306f\u63cf\u753b\u3084\u30b5\u30a6\u30f3\u30c9\u306e\u51e6\u7406\u307e\u3067\u3092\u62c5\u5f53\u3057\u306a\u3044\u3053\u3068\u306b\u306a\u308b\u3002</p>"},{"location":"tech_note/software_design/solid/#_2","title":"\u958b\u653e\u9589\u9396\u306e\u539f\u5247","text":"<p>\u300c\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306e\u5b9f\u4f53\uff08\u30af\u30e9\u30b9\u3001\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u95a2\u6570\u306a\u3069\uff09\u306f\u3001\u62e1\u5f35\u306b\u5bfe\u3057\u3066\u958b\u304b\u308c\u3066\u3044\u308b\u3079\u304d\u3067\u3042\u308a\u3001\u4fee\u6b63\u306b\u5bfe\u3057\u3066\u9589\u3058\u3066\u3044\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u300d</p> <p>\u30af\u30e9\u30b9\u3092\u5909\u66f4\u3059\u308b\u3068\u305d\u306e\u30af\u30e9\u30b9\u3092\u4f7f\u7528\u3057\u3066\u3044\u308b\u5168\u3066\u306e\u30b7\u30b9\u30c6\u30e0\u306b\u5f71\u97ff\u304c\u3042\u308b\u3002\u5f71\u97ff\u3092\u6700\u5c0f\u9650\u306b\u6291\u3048\u308b\u305f\u3081\u30d0\u30b0\u4fee\u6b63\u3084\u5909\u66f4\u306f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306b\u307e\u3067\u5909\u66f4\u3092\u52a0\u3048\u305a\u9589\u3058\u305f\u3082\u306e\u3067\u5728\u308b\u3079\u304d\u3067\u3001\u9006\u306b\u958b\u3044\u305f\u3082\u306e\u3067\u3042\u308b\u306e\u306f\u6a5f\u80fd\u8ffd\u52a0\u306a\u3069\u306e\u62e1\u5f35\u306e\u307f\u3067\u3042\u308b\u3079\u304d</p>"},{"location":"tech_note/software_design/solid/#_3","title":"\u30ea\u30b9\u30b3\u30d5\u306e\u7f6e\u63db\u539f\u5247","text":"<p>\u300c\u3042\u308b\u57fa\u5e95\u30af\u30e9\u30b9\u3078\u306e\u30dd\u30a4\u30f3\u30bf\u306a\u3044\u3057\u53c2\u7167\u3092\u6271\u3063\u3066\u3044\u308b\u95a2\u6570\u7fa4\u306f\u3001\u305d\u306e\u6d3e\u751f\u30af\u30e9\u30b9\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u8a73\u7d30\u3092\u77e5\u3089\u306a\u304f\u3066\u3082\u6271\u3048\u308b\u3088\u3046\u306b\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u300d</p> <p>\u5b50\u30af\u30e9\u30b9\u306f\u89aa\u30af\u30e9\u30b9\u306e\u4ed5\u69d8\u3092\u6e80\u305f\u3059\u3079\u304d\u3067\u3042\u308b</p>"},{"location":"tech_note/software_design/solid/#_4","title":"\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u5206\u96e2\u306e\u539f\u5247","text":"<p>\u300c\u6c4e\u7528\u306a\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u304c\u4e00\u3064\u3042\u308b\u3088\u308a\u3082\u3001\u5404\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u7279\u5316\u3057\u305f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u304c\u305f\u304f\u3055\u3093\u3042\u3063\u305f\u65b9\u304c\u3088\u3044\u300d</p> <p>\u4f3c\u305f\u6a5f\u80fd\u3092\u63d0\u4f9b\u3059\u308b\u30af\u30e9\u30b9\u3067\u3082\u7528\u9014\u3054\u3068\u306b\u6a5f\u80fd\u5206\u5316\u3055\u308c\u308b\u3079\u304d\u3067\u3001\u5de8\u5927\u306a\u5171\u901a\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u4f5c\u308b\u3053\u3068\u306f\u4e88\u671f\u3057\u306a\u3044\u30d0\u30b0\u3092\u767a\u751f\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b</p>"},{"location":"tech_note/software_design/solid/#_5","title":"\u4f9d\u5b58\u6027\u9006\u8ee2\u306e\u539f\u5247","text":"<p>\u300c\u4e0a\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u306f\u3044\u304b\u306a\u308b\u3082\u306e\u3082\u4e0b\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u304b\u3089\u6301\u3061\u8fbc\u3093\u3067\u306f\u306a\u3089\u306a\u3044\u3002\u53cc\u65b9\u3068\u3082\u5177\u8c61\u3067\u306f\u306a\u304f\u3001\u62bd\u8c61\uff08\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306a\u3069\uff09\u306b\u4f9d\u5b58\u3059\u308b\u3079\u304d\u3067\u3042\u308b\u300d</p> <p>\u3042\u308b\u30af\u30e9\u30b9\u304c\u5225\u30af\u30e9\u30b9\u3092\u4e0b\u4f4d\u30e2\u30b8\u30e5\u30fc\u30eb\u3084\u30e1\u30f3\u30d0\u3068\u3057\u3066\u4f7f\u3046\u969b\u306b\u306f\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u901a\u3058\u3066\u95a2\u4fc2\u6027\u304c\u62bd\u8c61\u5316\u3055\u308c\u308b\u3053\u3068\u3067\u4f9d\u5b58\u5ea6\u3092\u6e1b\u3089\u3059\u3079\u304d</p>"},{"location":"tech_note/software_design/solid/#_6","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>SOLID</li> <li>\u30a4\u30e9\u30b9\u30c8\u3067\u7406\u89e3\u3059\u308bSOLID\u539f\u5247</li> </ul>"},{"location":"tech_note/system/discrete/","title":"\u96e2\u6563\u5316","text":"<p>\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u30b7\u30b9\u30c6\u30e0\u30e2\u30c7\u30eb\u3092\u6271\u3046\u969b\u306b\u306f\u3075\u308b\u307e\u3044\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b\u305f\u3081\u306b\u9023\u7d9a\u6642\u9593\u9818\u57df\u3084s\u9818\u57df\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u4ee5\u4e0b\u306b\u96e2\u6563\u5316\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u8ff0\u3079\u308b\u3002</p>"},{"location":"tech_note/system/discrete/#_2","title":"\u96e2\u6563\u5316\u624b\u6cd5\u3068\u65b9\u6cd5","text":"<ul> <li>ZOH\u6cd5(0\u6b21\u30db\u30fc\u30eb\u30c9)</li> <li>\u5f8c\u9000\u5dee\u5206\u6cd5</li> <li>\u30aa\u30a4\u30e9\u30fc\u6cd5</li> <li>\u53cc\u4e00\u6b21\u5909\u63db</li> </ul>"},{"location":"tech_note/system/discrete/#_3","title":"\u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316","text":"<p>\u4f1d\u9054\u95a2\u6570</p> \\[ G(s) = \\frac{num(s)}{den(s)} \\] <p>\u306b\u5bfe\u3057\u3066</p> \\[ s = \\frac{2}{T} \\frac{z-1}{z+1} \\] <p>\u3068\u3057\u3066z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306b\u5909\u63db\u3057\u305f\u5f8c</p> \\[ \\frac{y}{u} = \\frac{num(z)}{den(z)} \\] <p>\u306e\u5f62\u3092\u5909\u5f62\u3059\u308b\u3053\u3068\u3067</p> \\[ y = f(u, u^{-1}, u^{-2} \\cdots, y^{-1}, y^{-2} \\cdots) \\] <p>\u3092\u5f97\u308b\u3002</p>"},{"location":"tech_note/system/discrete/#_4","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316","text":"<p>Waring</p> <p>Todo</p>"},{"location":"tech_note/system/discrete/#_5","title":"\u53c2\u8003\u6587\u732e","text":"<ul> <li>\u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u96e2\u6563\u5316\u624b\u6cd5\u306e\u6bd4\u8f03 [Python Scipy]</li> <li>\u96e2\u6563\u5316 (Wikipedia)</li> <li>\u53cc\u4e00\u6b21\u5909\u63db (Wikipedia)</li> <li>\u9023\u7d9a\u7cfb\u306e\u4ee3\u8868\u7684\u306a\u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316</li> </ul>"},{"location":"tech_note/system/state_space_system/","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe","text":"<p>\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u3068\u306f\u5165\u529b\u3068\u51fa\u529b\u3068\u72b6\u614b\u5909\u6570\u3092\u4f7f\u3063\u305f\u4e00\u968e\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3067\u8868\u3057\u305f\u6570\u5b66\u7684\u30e2\u30c7\u30eb\u3067\u3042\u308b\u3002</p> \\[ \\begin{array}{lll} \\dot{x}(t) &amp;=&amp; Ax(t) + Bu(t)\\\\ y(t) &amp;=&amp; Cx(t) + Du(t) \\end{array} \\]"},{"location":"tech_note/system/state_space_system/#_2","title":"\u53ef\u5236\u5fa1\u6027","text":"<p>\u53ef\u5236\u5fa1\u6027\u3068\u306f\u6709\u9650\u6642\u9593\u306e\u5165\u529b\u3067\u521d\u671f\u72b6\u614b\u304b\u3089\u4efb\u610f\u306e\u72b6\u614b\u306b\u5909\u5316\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u5236\u5fa1\u3067\u3042\u308b\u3068\u3044\u3046\u3002</p> \\[ \\rm{rank} \\left[ B \\space AB \\space A^2B \\cdots A^{n-1}B\\right] = n \\]"},{"location":"tech_note/system/state_space_system/#_3","title":"\u53ef\u89b3\u6e2c\u6027","text":"<p>\u53ef\u89b3\u6e2c\u6027\u3068\u306f\u30b7\u30b9\u30c6\u30e0\u306e\u51fa\u529b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u3067\u30b7\u30b9\u30c6\u30e0\u306e\u5185\u90e8\u72b6\u614b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u89b3\u6e2c\u3067\u3042\u308b\u3068\u3044\u3046\u3002</p> \\[ \\rm{rank} \\begin{bmatrix}  C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n-1} \\end{bmatrix} = n \\]"},{"location":"tech_note/system/state_space_system/#_4","title":"\u6b63\u6e96\u5f62","text":"<p>\u30b7\u30b9\u30c6\u30e0\u306e\u751f\u606f\u884c\u5217\u306b\u3088\u3063\u3066\u540c\u5024\u5909\u63db\u3057\u3066\u3082\u57fa\u672c\u7684\u306a\u6027\u8cea\u306f\u5909\u5316\u3057\u306a\u3044\u3002\u4e2d\u3067\u3082\u6709\u540d\u306a\u6b63\u6e96\u5f62\u3092\u7d39\u4ecb\u3059\u308b</p>"},{"location":"tech_note/system/state_space_system/#_5","title":"\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62","text":"<p>\u5909\u63db\u884c\u5217\u306b\u53ef\u5236\u5fa1\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u5909\u63db\u3092\u884c\u3046\u3002\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092\\(U_c\\)\u3068\u3057\u3066</p> \\[ \\begin{array}{lll} \\tilde{A} = U_c^{-1} A U_c \\\\ \\tilde{B} = U_c^{-1} B \\\\ \\tilde{C} = C U_c \\\\ \\tilde{D} = D \\end{array} \\]"},{"location":"tech_note/system/state_space_system/#_6","title":"\u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62","text":"<p>\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306b\u5bfe\u3057\u3066\u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62\u306f\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3002</p> \\[ \\begin{array}{lll} A_o = A_c^T \\\\ B_o = C_c^T \\\\ C_o = B_c^T \\\\ D_o = D_c \\end{array} \\]"},{"location":"tech_note/system/transfer_function/","title":"\u4f1d\u9054\u95a2\u6570","text":"<p>\u4f1d\u9054\u95a2\u6570\u3068\u306f1\u5165\u529b1\u51fa\u529b\u30b7\u30b9\u30c6\u30e0\u306e\u5165\u51fa\u529b\u95a2\u4fc2\u3092\u8868\u3059\u95a2\u6570\u306e\u4e00\u7a2e\u3067\u3042\u308b\u3002 \u30b7\u30b9\u30c6\u30e0\u306e\u5168\u3066\u306e\u5909\u6570\u306e\u521d\u671f\u5024\u30920\u3068\u3057\u3066\u5165\u529b\u4fe1\u53f7\u3068\u51fa\u529b\u4fe1\u53f7\u306e\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u3092\\(X(s)\\),\\(Y(s)\\)\u3068\u3059\u308b\u3068 </p> \\[ G(s) = \\frac{Y(s)}{X(s)} \\] <p>\u3067\u8868\u3055\u308c\u308b\u3002</p> <p>\u6642\u9593\u9818\u57df\u306e\u5fae\u5206\u65b9\u7a0b\u5f0f\u7b49\u3067\u8868\u3055\u308c\u308b\u30e2\u30c7\u30eb\u3092\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u306b\u3088\u308a\u8907\u7d20\u5e73\u9762\u306b\u5199\u50cf\u3092\u53d6\u308b\u3002 \u5468\u6ce2\u6570\u9818\u57df\u306e\u5468\u6ce2\u6570\u4f1d\u9054\u95a2\u6570\u306f\u5b89\u5b9a\u6027\u306a\u3069\u306e\u89e3\u6790\u30fb\u8a55\u4fa1\u306b\u7528\u3044\u3089\u308c\u308b\u3002 \u7279\u6027\u306e\u8a55\u4fa1\u65b9\u6cd5\u3068\u3057\u3066\u30dc\u30fc\u30c9\u7dda\u56f3\u3084\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u7528\u3044\u305f\u3082\u306e\u304c\u3042\u308b\u3002</p> <p>\u4f1d\u9054\u95a2\u6570\u306f\u5206\u6bcd\u5206\u5b50\u306e\u4fc2\u6570\u3092\u884c\u5217\u306b\u914d\u7f6e\u3059\u308b\u3053\u3068\u3067\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306b\u5909\u63db\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002</p>"},{"location":"tech_note/system/transfer_function/#_2","title":"\u4f1d\u9054\u95a2\u6570\u4f8b","text":"\u8aac\u660e \u4f1d\u9054\u95a2\u6570 \u96e2\u6563\u4f1d\u9054\u95a2\u6570(\u53cc\u4e00\u6b21\u5909\u63db) \u7a4d\u5206\u8981\u7d20 \\(\\dfrac{1}{s}\\) \\(\\dfrac{T}{2} \\dfrac{z+1}{z-1}\\) \u5fae\u5206\u8981\u7d20 \\(s\\) - \u7121\u99c4\u6642\u9593\u8981\u7d20 \\(e^{-s\\tau}\\) - 1\u6b21\u9045\u308c \\(\\dfrac{\\omega}{s + \\omega}\\) \\(\\dfrac{T\\omega z + T\\omega}{(T\\omega + 2)z + (T\\omega - 2)}\\) 2\u6b21\u9045\u308c \\(\\dfrac{\\omega^2}{s^2 + 2\\zeta\\omega s + \\omega^2}\\) \\(\\dfrac{(T^2\\omega^2)z^2 + (2T^2\\omega^2)z + (T^2\\omega^2)}{(4+ 4T\\zeta \\omega +T^2\\omega^2)z^2 + (-8+2T^2\\omega^2)z + (4-4T\\zeta \\omega + T^2\\omega^2)}\\)"},{"location":"tech_note/system/transfer_function/#_3","title":"\u5468\u6ce2\u6570\u3068\u6642\u5b9a\u6570","text":"<p>\u4f1d\u9054\u95a2\u6570\u3084\u30dc\u30fc\u30c9\u7dda\u56f3\u3067\u8b70\u8ad6\u3059\u308b\u3068\u304d\u306f\u5468\u6ce2\u6570\u306e\u5358\u4f4d\u304c[rad/s]\u3067\u3042\u308b\u3053\u3068\u304c\u591a\u3044\u3002[Hz]\u3068\u306e\u95a2\u4fc2\u306f</p> \\[ \\omega = 2\\pi f \\] <p>\u6642\u5b9a\u6570\u3068\u5468\u6ce2\u6570\u306e\u95a2\u4fc2\u306f</p> \\[ \\tau = \\frac{1}{\\omega} \\]"},{"location":"tech_note/system/transfer_function/#_4","title":"\u53c2\u8003\u6587\u732e","text":""}]}