{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cpp_robotics \u5236\u5fa1\u5de5\u5b66\u3001\u6700\u9069\u5316\u3001\u9006\u904b\u52d5\u5b66\u306a\u3069\u30ed\u30dc\u30c6\u30a3\u30af\u30b9\u306b\u591a\u7528\u3055\u308c\u308b\u6280\u8853\u3092\u30d1\u30c3\u30b1\u30fc\u30b8\u5316\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea \u6a5f\u80fd \u4f1d\u9054\u95a2\u6570\u30fb\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u8868\u73fe\u3068\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3 \u4f1d\u9054\u95a2\u6570\u3084\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u30af\u30e9\u30b9\u3092\u4f7f\u7528\u3057\u3066\u30b7\u30b9\u30c6\u30e0\u3092\u8868\u73fe\u3057\u3001\u5fdc\u7b54\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b \u69d8\u3005\u306a\u5236\u5fa1\u5668\u306b\u3088\u308b\u5236\u5fa1\u7cfb\u306e\u5b9f\u73fe PID\u5236\u5fa1\u5668\u3001LQR\u3001\u6975\u914d\u7f6e\u7b49\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u7b49\u306b\u3088\u308a\u5236\u5fa1\u7cfb\u3092\u69cb\u6210\u3059\u308b \u6700\u9069\u5316\u95a2\u6570 \u9023\u7d9a\u95a2\u6570\u306e\u6700\u9069\u5316\u95a2\u6570\u304c\u7528\u610f\u3055\u308c\u3066\u304a\u308a\u6700\u9069\u5236\u5fa1\u306e\u5b9f\u73fe\u3092\u88dc\u52a9\u3059\u308b \u30d5\u30a3\u30eb\u30bf \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3084\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u306f\u3058\u3081\u3001\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3084\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3001\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u308b \u9006\u904b\u52d5\u5b66 \u79fb\u52d5\u6a5f\u69cb\u3084\u30ed\u30dc\u30c3\u30c8\u306e\u30a2\u30fc\u30e0\u306e\u9006\u904b\u52d5\u5b66\u3092\u89e3\u304f\u305f\u3081\u306e\u30af\u30e9\u30b9\u3092\u7528\u610f \u5358\u4f4d\u30af\u30e9\u30b9 SI\u5358\u4f4d\u7cfb\u3092\u5b9f\u88c5\u3057\u3066\u3042\u308a\u7269\u7406\u7684\u306a\u610f\u5473\u3092\u5bfe\u5fdc\u3055\u305b\u306a\u304c\u3089\u306e\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u304c\u53ef\u80fd \u7d44\u7acb\u5358\u4f4d\u306b\u3082\u5bfe\u5fdc \u983b\u7e41\u306b\u4f7f\u7528\u3059\u308b\u30d9\u30af\u30c8\u30eb\u6f14\u7b97\u30af\u30e9\u30b9 Vector2 Vector3 Vector4 Quaternion Transform\u3092\u7528\u610f \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u6f14\u7b97\u3084\u30ce\u30eb\u30e0\u3001\u56de\u8ee2\u306e\u51e6\u7406\u3092\u7c21\u5358\u306b\u8a18\u8ff0 \u30d7\u30ed\u30b0\u30e9\u30e0\u4f8b \u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u30b5\u30f3\u30d7\u30eb\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u308b\u305f\u3081\u52d5\u304b\u3057\u306a\u304c\u3089\u7406\u89e3\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/cpp_robotics.hpp> int main () { namespace cr = cpp_robotics ; constexpr cr :: Vector2d vec ( 3.0 , 4.0 ); printf ( \"constexpr 2D vector: %f, %f \\n \" , vec . x , vec . y ); Eigen :: MatrixXd A ( 2 , 2 ), B ( 2 , 1 ), Q ( 2 , 2 ), R ( 1 , 1 ), P ( 2 , 2 ); A << 0 , 1 , -10 , -1 ; B << 0 , 1 ; Q << 300 , 0 , 0 , 60 ; R << 1 ; Eigen :: MatrixXd K = cr :: lqr ( A , B , Q , R ); std :: cout << \"LQR feedback vector\" << std :: endl ; std :: cout << K << std :: endl ; std :: cout << \"polynomial\" << std :: endl ; cr :: Polynomial p0 ({ 1 , 0 , 3 }); std :: cout << p0 << std :: endl ; cr :: Polynomial p1 = cr :: Polynomial ({ 1 , -2 }) * cr :: Polynomial ({ 1 , 2 }); std :: cout << p1 << std :: endl ; cr :: TransferFunction tf ({ 1.0 }, { 1 , 1.0 }, 0.01 ); namespace plt = matplotlibcpp ; std :: cout << \"transfer function step responce\" << std :: endl ; { auto [ t , y ] = cr :: step ( tf , 30 ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function sin cruve input responce\" << std :: endl ; { auto input = cr :: sinspace ( 1 , 0.1 , 1000 ); auto [ t , y ] = cr :: lsim ( tf , input ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function bode fig plot\" << std :: endl ; cr :: bode_plot ( tf ); std :: cout << \"transfer function nyquist fig plot\" << std :: endl ; cr :: nyquist_plot ( tf ); } (\u30d7\u30ed\u30b0\u30e9\u30e0\u4f8b\u306e HelloWorld \u3088\u308a) \u6280\u8853\u8cc7\u6599 \u5b9f\u88c5\u3057\u3066\u3042\u308b\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u3064\u3044\u3066\u306e\u6280\u8853\u8cc7\u6599\u3082\u7528\u610f\u3057\u3066\u3042\u308b\u305f\u3081\u30d7\u30ed\u30b0\u30e9\u30e0\u3068\u7406\u8ad6\u3092\u5bfe\u5fdc\u3055\u305b\u306a\u304c\u3089\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u308b API \u4f7f\u7528\u3067\u304d\u308b\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u306b\u3064\u3044\u3066\u306f \u3053\u3061\u3089","title":"\u6982\u8981"},{"location":"#cpp_robotics","text":"\u5236\u5fa1\u5de5\u5b66\u3001\u6700\u9069\u5316\u3001\u9006\u904b\u52d5\u5b66\u306a\u3069\u30ed\u30dc\u30c6\u30a3\u30af\u30b9\u306b\u591a\u7528\u3055\u308c\u308b\u6280\u8853\u3092\u30d1\u30c3\u30b1\u30fc\u30b8\u5316\u3057\u305f\u30e9\u30a4\u30d6\u30e9\u30ea","title":"cpp_robotics"},{"location":"#_1","text":"","title":"\u6a5f\u80fd"},{"location":"#_2","text":"\u4f1d\u9054\u95a2\u6570\u3084\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u30af\u30e9\u30b9\u3092\u4f7f\u7528\u3057\u3066\u30b7\u30b9\u30c6\u30e0\u3092\u8868\u73fe\u3057\u3001\u5fdc\u7b54\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b","title":"\u4f1d\u9054\u95a2\u6570\u30fb\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u8868\u73fe\u3068\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3"},{"location":"#_3","text":"PID\u5236\u5fa1\u5668\u3001LQR\u3001\u6975\u914d\u7f6e\u7b49\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u7b49\u306b\u3088\u308a\u5236\u5fa1\u7cfb\u3092\u69cb\u6210\u3059\u308b","title":"\u69d8\u3005\u306a\u5236\u5fa1\u5668\u306b\u3088\u308b\u5236\u5fa1\u7cfb\u306e\u5b9f\u73fe"},{"location":"#_4","text":"\u9023\u7d9a\u95a2\u6570\u306e\u6700\u9069\u5316\u95a2\u6570\u304c\u7528\u610f\u3055\u308c\u3066\u304a\u308a\u6700\u9069\u5236\u5fa1\u306e\u5b9f\u73fe\u3092\u88dc\u52a9\u3059\u308b","title":"\u6700\u9069\u5316\u95a2\u6570"},{"location":"#_5","text":"\u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3084\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u3092\u306f\u3058\u3081\u3001\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3084\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3001\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u308b","title":"\u30d5\u30a3\u30eb\u30bf"},{"location":"#_6","text":"\u79fb\u52d5\u6a5f\u69cb\u3084\u30ed\u30dc\u30c3\u30c8\u306e\u30a2\u30fc\u30e0\u306e\u9006\u904b\u52d5\u5b66\u3092\u89e3\u304f\u305f\u3081\u306e\u30af\u30e9\u30b9\u3092\u7528\u610f","title":"\u9006\u904b\u52d5\u5b66"},{"location":"#_7","text":"SI\u5358\u4f4d\u7cfb\u3092\u5b9f\u88c5\u3057\u3066\u3042\u308a\u7269\u7406\u7684\u306a\u610f\u5473\u3092\u5bfe\u5fdc\u3055\u305b\u306a\u304c\u3089\u306e\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u304c\u53ef\u80fd \u7d44\u7acb\u5358\u4f4d\u306b\u3082\u5bfe\u5fdc","title":"\u5358\u4f4d\u30af\u30e9\u30b9"},{"location":"#_8","text":"Vector2 Vector3 Vector4 Quaternion Transform\u3092\u7528\u610f \u30d9\u30af\u30c8\u30eb\u540c\u58eb\u306e\u6f14\u7b97\u3084\u30ce\u30eb\u30e0\u3001\u56de\u8ee2\u306e\u51e6\u7406\u3092\u7c21\u5358\u306b\u8a18\u8ff0","title":"\u983b\u7e41\u306b\u4f7f\u7528\u3059\u308b\u30d9\u30af\u30c8\u30eb\u6f14\u7b97\u30af\u30e9\u30b9"},{"location":"#_9","text":"\u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u30b5\u30f3\u30d7\u30eb\u304c\u7528\u610f\u3055\u308c\u3066\u3044\u308b\u305f\u3081\u52d5\u304b\u3057\u306a\u304c\u3089\u7406\u89e3\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/cpp_robotics.hpp> int main () { namespace cr = cpp_robotics ; constexpr cr :: Vector2d vec ( 3.0 , 4.0 ); printf ( \"constexpr 2D vector: %f, %f \\n \" , vec . x , vec . y ); Eigen :: MatrixXd A ( 2 , 2 ), B ( 2 , 1 ), Q ( 2 , 2 ), R ( 1 , 1 ), P ( 2 , 2 ); A << 0 , 1 , -10 , -1 ; B << 0 , 1 ; Q << 300 , 0 , 0 , 60 ; R << 1 ; Eigen :: MatrixXd K = cr :: lqr ( A , B , Q , R ); std :: cout << \"LQR feedback vector\" << std :: endl ; std :: cout << K << std :: endl ; std :: cout << \"polynomial\" << std :: endl ; cr :: Polynomial p0 ({ 1 , 0 , 3 }); std :: cout << p0 << std :: endl ; cr :: Polynomial p1 = cr :: Polynomial ({ 1 , -2 }) * cr :: Polynomial ({ 1 , 2 }); std :: cout << p1 << std :: endl ; cr :: TransferFunction tf ({ 1.0 }, { 1 , 1.0 }, 0.01 ); namespace plt = matplotlibcpp ; std :: cout << \"transfer function step responce\" << std :: endl ; { auto [ t , y ] = cr :: step ( tf , 30 ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function sin cruve input responce\" << std :: endl ; { auto input = cr :: sinspace ( 1 , 0.1 , 1000 ); auto [ t , y ] = cr :: lsim ( tf , input ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function bode fig plot\" << std :: endl ; cr :: bode_plot ( tf ); std :: cout << \"transfer function nyquist fig plot\" << std :: endl ; cr :: nyquist_plot ( tf ); } (\u30d7\u30ed\u30b0\u30e9\u30e0\u4f8b\u306e HelloWorld \u3088\u308a)","title":"\u30d7\u30ed\u30b0\u30e9\u30e0\u4f8b"},{"location":"#_10","text":"\u5b9f\u88c5\u3057\u3066\u3042\u308b\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u3064\u3044\u3066\u306e\u6280\u8853\u8cc7\u6599\u3082\u7528\u610f\u3057\u3066\u3042\u308b\u305f\u3081\u30d7\u30ed\u30b0\u30e9\u30e0\u3068\u7406\u8ad6\u3092\u5bfe\u5fdc\u3055\u305b\u306a\u304c\u3089\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u308b","title":"\u6280\u8853\u8cc7\u6599"},{"location":"#api","text":"\u4f7f\u7528\u3067\u304d\u308b\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u306b\u3064\u3044\u3066\u306f \u3053\u3061\u3089","title":"API"},{"location":"doxybook/classes/","text":"Classes namespace cpp_robotics class AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) class ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct Problem struct Result class AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b class BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class CatumullRom2D Catumull\u66f2\u7dda struct Circle \u5186\u30af\u30e9\u30b9 struct Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 class CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda struct DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb class DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf class DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 class Differentiator \u7591\u4f3c\u5fae\u5206\u5668 class Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class DiscreteTransferFunction z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570 class DubinsPath Dubins\u30d1\u30b9 struct PlanningResult class ExtendedKalmanFilter class FilterConnector class FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 struct GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb class HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class Integrator \u7a4d\u5206\u5668 class KDTree k-d\u6728 struct Node class KMeansMethod K-means\u6cd5 class KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf struct Line \u76f4\u7dda\u30af\u30e9\u30b9 class LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc class MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct Config class NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 class NctfController NCTF\u5236\u5fa1\u5668 class NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf class Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct Config class Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct Config class PID2Controller 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 struct pid_param_t class PIDController PID\u5236\u5fa1\u5668 struct pid_param_t struct Polynomial \u591a\u9805\u5f0f class PurePursuit Pure pursuit\u5236\u5fa1\u5668 struct Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 class QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 struct Param struct Result class Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 class RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 struct Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) class SQP SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) struct Problem struct Result class Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b class SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 struct func_list_t class Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 struct segment_info_t struct segment_t class StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb class SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb struct Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb class VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 struct GridNode namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 struct spline_c namespace unit \u5358\u4f4d\u7cfb struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 namespace prefix struct pfx_div struct pfx_inv struct pfx_min struct pfx_mul namespace tag struct is_normal_tag struct is_normal_tag< 0 > struct is_normal_tag<-1 > namespace unit_dimention struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 namespace prefix struct pfx_div struct pfx_inv struct pfx_min struct pfx_mul namespace tag struct is_normal_tag struct is_normal_tag< 0 > struct is_normal_tag<-1 > namespace unit_dimention namespace unit_dim_assem Updated on 2022-09-30 at 00:12:50 +0900","title":"Classes"},{"location":"doxybook/classes/#classes","text":"namespace cpp_robotics class AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) class ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct Problem struct Result class AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b class BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class CatumullRom2D Catumull\u66f2\u7dda struct Circle \u5186\u30af\u30e9\u30b9 struct Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 class CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda struct DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb class DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf class DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 class Differentiator \u7591\u4f3c\u5fae\u5206\u5668 class Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class DiscreteTransferFunction z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570 class DubinsPath Dubins\u30d1\u30b9 struct PlanningResult class ExtendedKalmanFilter class FilterConnector class FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 struct GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb class HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class Integrator \u7a4d\u5206\u5668 class KDTree k-d\u6728 struct Node class KMeansMethod K-means\u6cd5 class KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf struct Line \u76f4\u7dda\u30af\u30e9\u30b9 class LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc class MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct Config class NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 class NctfController NCTF\u5236\u5fa1\u5668 class NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf class Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct Config class Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct Config class PID2Controller 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 struct pid_param_t class PIDController PID\u5236\u5fa1\u5668 struct pid_param_t struct Polynomial \u591a\u9805\u5f0f class PurePursuit Pure pursuit\u5236\u5fa1\u5668 struct Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 class QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 struct Param struct Result class Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 class RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 struct Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) class SQP SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) struct Problem struct Result class Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b class SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 struct func_list_t class Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 struct segment_info_t struct segment_t class StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb class SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb struct Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb class VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 struct GridNode namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 struct spline_c namespace unit \u5358\u4f4d\u7cfb struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 namespace prefix struct pfx_div struct pfx_inv struct pfx_min struct pfx_mul namespace tag struct is_normal_tag struct is_normal_tag< 0 > struct is_normal_tag<-1 > namespace unit_dimention struct Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 namespace prefix struct pfx_div struct pfx_inv struct pfx_min struct pfx_mul namespace tag struct is_normal_tag struct is_normal_tag< 0 > struct is_normal_tag<-1 > namespace unit_dimention namespace unit_dim_assem Updated on 2022-09-30 at 00:12:50 +0900","title":"Classes"},{"location":"doxybook/examples/","text":"Examples Updated on 2022-09-30 at 00:12:50 +0900","title":"Examples"},{"location":"doxybook/examples/#examples","text":"Updated on 2022-09-30 at 00:12:50 +0900","title":"Examples"},{"location":"doxybook/files/","text":"Files dir include dir include/cpp_robotics file include/cpp_robotics/core.hpp file include/cpp_robotics/cpp_robotics.hpp dir include/cpp_robotics/algorithm file include/cpp_robotics/algorithm/algorithm.hpp file include/cpp_robotics/algorithm/icp.hpp file include/cpp_robotics/algorithm/k_means_method.hpp file include/cpp_robotics/algorithm/kdtree.hpp file include/cpp_robotics/algorithm/mahalanobis.hpp file include/cpp_robotics/algorithm/misc.hpp file include/cpp_robotics/algorithm/ndt.hpp file include/cpp_robotics/algorithm/poly_regression.hpp file include/cpp_robotics/algorithm/random.hpp file include/cpp_robotics/algorithm/state_machine.hpp dir include/cpp_robotics/arm_ik file include/cpp_robotics/arm_ik/delta_robot.hpp dir include/cpp_robotics/chassis file include/cpp_robotics/chassis/chassis.hpp file include/cpp_robotics/chassis/mecanum_ik.hpp file include/cpp_robotics/chassis/omni_ik.hpp file include/cpp_robotics/chassis/swerve_ik.hpp dir include/cpp_robotics/controller file include/cpp_robotics/controller/controller.hpp file include/cpp_robotics/controller/lqr.hpp file include/cpp_robotics/controller/modern_control.hpp file include/cpp_robotics/controller/nctf.hpp file include/cpp_robotics/controller/pfc.hpp file include/cpp_robotics/controller/pid.hpp file include/cpp_robotics/controller/pid2.hpp file include/cpp_robotics/controller/pure_pursuit.hpp dir include/cpp_robotics/filter file include/cpp_robotics/filter/acceleration_limit_filter.hpp file include/cpp_robotics/filter/band_pass_filter.hpp file include/cpp_robotics/filter/delay_filter.hpp file include/cpp_robotics/filter/differentiator.hpp file include/cpp_robotics/filter/extended_kalman_filter.hpp file include/cpp_robotics/filter/filter.hpp file include/cpp_robotics/filter/filter_connector.hpp file include/cpp_robotics/filter/filter_state_holder.hpp file include/cpp_robotics/filter/high_pass_filter.hpp file include/cpp_robotics/filter/integrator.hpp file include/cpp_robotics/filter/kalman_filter.hpp file include/cpp_robotics/filter/low_pass_filter.hpp file include/cpp_robotics/filter/notch_filter.hpp file include/cpp_robotics/filter/velocity_limit_filter.hpp dir include/cpp_robotics/geometry file include/cpp_robotics/geometry/geometry.hpp file include/cpp_robotics/geometry/geometry_stream.hpp file include/cpp_robotics/geometry/shape.hpp file include/cpp_robotics/geometry/shape.ipp dir include/cpp_robotics/motor file include/cpp_robotics/motor/dc_motor_list.hpp file include/cpp_robotics/motor/dc_motor_param.hpp file include/cpp_robotics/motor/motor_tf.hpp dir include/cpp_robotics/optimize file include/cpp_robotics/optimize/active_set_method.hpp file include/cpp_robotics/optimize/barrier_method.hpp file include/cpp_robotics/optimize/bfgs.hpp file include/cpp_robotics/optimize/bracketing_serach.hpp file include/cpp_robotics/optimize/constraint.hpp file include/cpp_robotics/optimize/derivative.hpp file include/cpp_robotics/optimize/golden_serach.hpp file include/cpp_robotics/optimize/interior_point_method.hpp file include/cpp_robotics/optimize/linprog.hpp file include/cpp_robotics/optimize/newton_method.hpp file include/cpp_robotics/optimize/optimize.hpp file include/cpp_robotics/optimize/penalty_method.hpp file include/cpp_robotics/optimize/quadprog.hpp file include/cpp_robotics/optimize/quasi_newton_method.hpp file include/cpp_robotics/optimize/sqp.hpp file include/cpp_robotics/optimize/steepest_descent_method.hpp dir include/cpp_robotics/path_planning file include/cpp_robotics/path_planning/a_star.hpp file include/cpp_robotics/path_planning/dubins_path.hpp file include/cpp_robotics/path_planning/dwa.hpp file include/cpp_robotics/path_planning/frenet_frame.hpp file include/cpp_robotics/path_planning/grid_path_planning_utils.hpp file include/cpp_robotics/path_planning/path_planning.hpp file include/cpp_robotics/path_planning/wave_propagation.hpp dir include/cpp_robotics/robots dir include/cpp_robotics/robots/penbulum file include/cpp_robotics/robots/penbulum/interface.hpp file include/cpp_robotics/robots/penbulum/pendulum.hpp dir include/cpp_robotics/robots/quadcopter file include/cpp_robotics/robots/quadcopter/interface.hpp file include/cpp_robotics/robots/quadcopter/quadcopter.hpp dir include/cpp_robotics/robots/robot_utils file include/cpp_robotics/robots/robot_utils/robot_utils.hpp dir include/cpp_robotics/spline file include/cpp_robotics/spline/spline.hpp dir include/cpp_robotics/system file include/cpp_robotics/system/bode.hpp file include/cpp_robotics/system/discret.hpp file include/cpp_robotics/system/discrete_transfer_function.hpp file include/cpp_robotics/system/nyquist.hpp file include/cpp_robotics/system/polynomial.hpp file include/cpp_robotics/system/siso_system.hpp file include/cpp_robotics/system/state_space_system.hpp file include/cpp_robotics/system/system.hpp file include/cpp_robotics/system/time_responce.hpp file include/cpp_robotics/system/transfer_function.hpp dir include/cpp_robotics/units file include/cpp_robotics/units/si_unit.hpp file include/cpp_robotics/units/unit_core.hpp file include/cpp_robotics/units/units.hpp dir include/cpp_robotics/utility file include/cpp_robotics/utility/angle_range.hpp file include/cpp_robotics/utility/cpp_support.hpp file include/cpp_robotics/utility/math_utils.hpp file include/cpp_robotics/utility/singleton.hpp file include/cpp_robotics/utility/space.hpp file include/cpp_robotics/utility/utility.hpp dir include/cpp_robotics/vector file include/cpp_robotics/vector/quaternion.hpp file include/cpp_robotics/vector/transform.hpp file include/cpp_robotics/vector/vector.hpp file include/cpp_robotics/vector/vector2.hpp file include/cpp_robotics/vector/vector3.hpp file include/cpp_robotics/vector/vector4.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/files/#files","text":"dir include dir include/cpp_robotics file include/cpp_robotics/core.hpp file include/cpp_robotics/cpp_robotics.hpp dir include/cpp_robotics/algorithm file include/cpp_robotics/algorithm/algorithm.hpp file include/cpp_robotics/algorithm/icp.hpp file include/cpp_robotics/algorithm/k_means_method.hpp file include/cpp_robotics/algorithm/kdtree.hpp file include/cpp_robotics/algorithm/mahalanobis.hpp file include/cpp_robotics/algorithm/misc.hpp file include/cpp_robotics/algorithm/ndt.hpp file include/cpp_robotics/algorithm/poly_regression.hpp file include/cpp_robotics/algorithm/random.hpp file include/cpp_robotics/algorithm/state_machine.hpp dir include/cpp_robotics/arm_ik file include/cpp_robotics/arm_ik/delta_robot.hpp dir include/cpp_robotics/chassis file include/cpp_robotics/chassis/chassis.hpp file include/cpp_robotics/chassis/mecanum_ik.hpp file include/cpp_robotics/chassis/omni_ik.hpp file include/cpp_robotics/chassis/swerve_ik.hpp dir include/cpp_robotics/controller file include/cpp_robotics/controller/controller.hpp file include/cpp_robotics/controller/lqr.hpp file include/cpp_robotics/controller/modern_control.hpp file include/cpp_robotics/controller/nctf.hpp file include/cpp_robotics/controller/pfc.hpp file include/cpp_robotics/controller/pid.hpp file include/cpp_robotics/controller/pid2.hpp file include/cpp_robotics/controller/pure_pursuit.hpp dir include/cpp_robotics/filter file include/cpp_robotics/filter/acceleration_limit_filter.hpp file include/cpp_robotics/filter/band_pass_filter.hpp file include/cpp_robotics/filter/delay_filter.hpp file include/cpp_robotics/filter/differentiator.hpp file include/cpp_robotics/filter/extended_kalman_filter.hpp file include/cpp_robotics/filter/filter.hpp file include/cpp_robotics/filter/filter_connector.hpp file include/cpp_robotics/filter/filter_state_holder.hpp file include/cpp_robotics/filter/high_pass_filter.hpp file include/cpp_robotics/filter/integrator.hpp file include/cpp_robotics/filter/kalman_filter.hpp file include/cpp_robotics/filter/low_pass_filter.hpp file include/cpp_robotics/filter/notch_filter.hpp file include/cpp_robotics/filter/velocity_limit_filter.hpp dir include/cpp_robotics/geometry file include/cpp_robotics/geometry/geometry.hpp file include/cpp_robotics/geometry/geometry_stream.hpp file include/cpp_robotics/geometry/shape.hpp file include/cpp_robotics/geometry/shape.ipp dir include/cpp_robotics/motor file include/cpp_robotics/motor/dc_motor_list.hpp file include/cpp_robotics/motor/dc_motor_param.hpp file include/cpp_robotics/motor/motor_tf.hpp dir include/cpp_robotics/optimize file include/cpp_robotics/optimize/active_set_method.hpp file include/cpp_robotics/optimize/barrier_method.hpp file include/cpp_robotics/optimize/bfgs.hpp file include/cpp_robotics/optimize/bracketing_serach.hpp file include/cpp_robotics/optimize/constraint.hpp file include/cpp_robotics/optimize/derivative.hpp file include/cpp_robotics/optimize/golden_serach.hpp file include/cpp_robotics/optimize/interior_point_method.hpp file include/cpp_robotics/optimize/linprog.hpp file include/cpp_robotics/optimize/newton_method.hpp file include/cpp_robotics/optimize/optimize.hpp file include/cpp_robotics/optimize/penalty_method.hpp file include/cpp_robotics/optimize/quadprog.hpp file include/cpp_robotics/optimize/quasi_newton_method.hpp file include/cpp_robotics/optimize/sqp.hpp file include/cpp_robotics/optimize/steepest_descent_method.hpp dir include/cpp_robotics/path_planning file include/cpp_robotics/path_planning/a_star.hpp file include/cpp_robotics/path_planning/dubins_path.hpp file include/cpp_robotics/path_planning/dwa.hpp file include/cpp_robotics/path_planning/frenet_frame.hpp file include/cpp_robotics/path_planning/grid_path_planning_utils.hpp file include/cpp_robotics/path_planning/path_planning.hpp file include/cpp_robotics/path_planning/wave_propagation.hpp dir include/cpp_robotics/robots dir include/cpp_robotics/robots/penbulum file include/cpp_robotics/robots/penbulum/interface.hpp file include/cpp_robotics/robots/penbulum/pendulum.hpp dir include/cpp_robotics/robots/quadcopter file include/cpp_robotics/robots/quadcopter/interface.hpp file include/cpp_robotics/robots/quadcopter/quadcopter.hpp dir include/cpp_robotics/robots/robot_utils file include/cpp_robotics/robots/robot_utils/robot_utils.hpp dir include/cpp_robotics/spline file include/cpp_robotics/spline/spline.hpp dir include/cpp_robotics/system file include/cpp_robotics/system/bode.hpp file include/cpp_robotics/system/discret.hpp file include/cpp_robotics/system/discrete_transfer_function.hpp file include/cpp_robotics/system/nyquist.hpp file include/cpp_robotics/system/polynomial.hpp file include/cpp_robotics/system/siso_system.hpp file include/cpp_robotics/system/state_space_system.hpp file include/cpp_robotics/system/system.hpp file include/cpp_robotics/system/time_responce.hpp file include/cpp_robotics/system/transfer_function.hpp dir include/cpp_robotics/units file include/cpp_robotics/units/si_unit.hpp file include/cpp_robotics/units/unit_core.hpp file include/cpp_robotics/units/units.hpp dir include/cpp_robotics/utility file include/cpp_robotics/utility/angle_range.hpp file include/cpp_robotics/utility/cpp_support.hpp file include/cpp_robotics/utility/math_utils.hpp file include/cpp_robotics/utility/singleton.hpp file include/cpp_robotics/utility/space.hpp file include/cpp_robotics/utility/utility.hpp dir include/cpp_robotics/vector file include/cpp_robotics/vector/quaternion.hpp file include/cpp_robotics/vector/transform.hpp file include/cpp_robotics/vector/vector.hpp file include/cpp_robotics/vector/vector2.hpp file include/cpp_robotics/vector/vector3.hpp file include/cpp_robotics/vector/vector4.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/groups/","text":"Modules Updated on 2022-09-30 at 00:12:50 +0900","title":"Modules"},{"location":"doxybook/groups/#modules","text":"Updated on 2022-09-30 at 00:12:50 +0900","title":"Modules"},{"location":"doxybook/namespaces/","text":"Namespaces namespace cpp_robotics namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 namespace unit \u5358\u4f4d\u7cfb namespace prefix namespace tag namespace unit_dimention namespace prefix namespace tag namespace unit_dimention namespace unit_dim_assem Updated on 2022-09-30 at 00:12:50 +0900","title":"Namespaces"},{"location":"doxybook/namespaces/#namespaces","text":"namespace cpp_robotics namespace constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 namespace grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 namespace spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 namespace unit \u5358\u4f4d\u7cfb namespace prefix namespace tag namespace unit_dimention namespace prefix namespace tag namespace unit_dimention namespace unit_dim_assem Updated on 2022-09-30 at 00:12:50 +0900","title":"Namespaces"},{"location":"doxybook/related_pages/","text":"Pages Updated on 2022-09-30 at 00:12:50 +0900","title":"Pages"},{"location":"doxybook/related_pages/#pages","text":"Updated on 2022-09-30 at 00:12:50 +0900","title":"Pages"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/","text":"cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) More... #include <acceleration_limit_filter.hpp> Public Functions Name AccelerationLimitFilter (double acc_max, double Ts, double gpd, double Kx, double Kv, std::optional< std::pair< double, double >> limit =std::nullopt) AccelerationLimitFilter (double acc_max, double Ts, std::optional< std::pair< double, double >> limit =std::nullopt) virtual void reset () virtual double filtering (double u) Detailed Description class cpp_robotics :: AccelerationLimitFilter ; \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) \u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f Public Functions Documentation function AccelerationLimitFilter inline AccelerationLimitFilter ( double acc_max , double Ts , double gpd , double Kx , double Kv , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) function AccelerationLimitFilter inline AccelerationLimitFilter ( double acc_max , double Ts , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) function reset inline virtual void reset () function filtering inline virtual double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::AccelerationLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#cpp_roboticsaccelerationlimitfilter","text":"\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) More... #include <acceleration_limit_filter.hpp>","title":"cpp_robotics::AccelerationLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#public-functions","text":"Name AccelerationLimitFilter (double acc_max, double Ts, double gpd, double Kx, double Kv, std::optional< std::pair< double, double >> limit =std::nullopt) AccelerationLimitFilter (double acc_max, double Ts, std::optional< std::pair< double, double >> limit =std::nullopt) virtual void reset () virtual double filtering (double u)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#detailed-description","text":"class cpp_robotics :: AccelerationLimitFilter ; \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) \u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-accelerationlimitfilter","text":"inline AccelerationLimitFilter ( double acc_max , double Ts , double gpd , double Kx , double Kv , std :: optional < std :: pair < double , double >> limit = std :: nullopt )","title":"function AccelerationLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-accelerationlimitfilter_1","text":"inline AccelerationLimitFilter ( double acc_max , double Ts , std :: optional < std :: pair < double , double >> limit = std :: nullopt )","title":"function AccelerationLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-reset","text":"inline virtual void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1AccelerationLimitFilter/#function-filtering","text":"inline virtual double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/","text":"cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 #include <active_set_method.hpp> Public Classes Name struct Problem struct Result Public Functions Name Result solve ( Problem prob, Eigen::VectorXd x) Public Functions Documentation function solve inline Result solve ( Problem prob , Eigen :: VectorXd x ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::ActiveSetMethod"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#cpp_roboticsactivesetmethod","text":"\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 #include <active_set_method.hpp>","title":"cpp_robotics::ActiveSetMethod"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-classes","text":"Name struct Problem struct Result","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-functions","text":"Name Result solve ( Problem prob, Eigen::VectorXd x)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1ActiveSetMethod/#function-solve","text":"inline Result solve ( Problem prob , Eigen :: VectorXd x ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function solve"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/","text":"cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b #include <angle_range.hpp> Public Types Name using std::pair< double, double > range_pair_t Public Functions Name AngleRange () =default void add_range (const AngleRange & range) void add_range (double start, double end) size_t size () const AngleRange invert () const double most_near_by (double angle) bool in_range_part ( range_pair_t & range, double angle) bool in_range (double angle) std::vector< range_pair_t > ranges () const Public Attributes Name constexpr static double PI Public Types Documentation using range_pair_t using cpp_robotics :: AngleRange :: range_pair_t = std :: pair < double , double > ; Public Functions Documentation function AngleRange AngleRange () = default function add_range inline void add_range ( const AngleRange & range ) function add_range inline void add_range ( double start , double end ) function size inline size_t size () const function invert inline AngleRange invert () const function most_near_by inline double most_near_by ( double angle ) function in_range_part inline bool in_range_part ( range_pair_t & range , double angle ) function in_range inline bool in_range ( double angle ) function ranges inline std :: vector < range_pair_t > ranges () const Public Attributes Documentation variable PI static constexpr static double PI = M_PI ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::AngleRange"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#cpp_roboticsanglerange","text":"\u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b #include <angle_range.hpp>","title":"cpp_robotics::AngleRange"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-types","text":"Name using std::pair< double, double > range_pair_t","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-functions","text":"Name AngleRange () =default void add_range (const AngleRange & range) void add_range (double start, double end) size_t size () const AngleRange invert () const double most_near_by (double angle) bool in_range_part ( range_pair_t & range, double angle) bool in_range (double angle) std::vector< range_pair_t > ranges () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-attributes","text":"Name constexpr static double PI","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#using-range_pair_t","text":"using cpp_robotics :: AngleRange :: range_pair_t = std :: pair < double , double > ;","title":"using range_pair_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-anglerange","text":"AngleRange () = default","title":"function AngleRange"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-add_range","text":"inline void add_range ( const AngleRange & range )","title":"function add_range"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-add_range_1","text":"inline void add_range ( double start , double end )","title":"function add_range"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-size","text":"inline size_t size () const","title":"function size"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-invert","text":"inline AngleRange invert () const","title":"function invert"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-most_near_by","text":"inline double most_near_by ( double angle )","title":"function most_near_by"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-in_range_part","text":"inline bool in_range_part ( range_pair_t & range , double angle )","title":"function in_range_part"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-in_range","text":"inline bool in_range ( double angle )","title":"function in_range"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#function-ranges","text":"inline std :: vector < range_pair_t > ranges () const","title":"function ranges"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1AngleRange/#variable-pi","text":"static constexpr static double PI = M_PI ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable PI"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/","text":"cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf #include <band_pass_filter.hpp> Public Functions Name BandPassFilter (double w, double zeta, double dt) Construct a new Notch Filter object. void reset () double filtering (double u) double w () const double zeta () const double dt () const Public Functions Documentation function BandPassFilter inline BandPassFilter ( double w , double zeta , double dt ) Construct a new Notch Filter object. Parameters : w \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] zeta \u92ed\u3055 dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f function reset inline void reset () function filtering inline double filtering ( double u ) function w inline double w () const function zeta inline double zeta () const function dt inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::BandPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#cpp_roboticsbandpassfilter","text":"\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf #include <band_pass_filter.hpp>","title":"cpp_robotics::BandPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#public-functions","text":"Name BandPassFilter (double w, double zeta, double dt) Construct a new Notch Filter object. void reset () double filtering (double u) double w () const double zeta () const double dt () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-bandpassfilter","text":"inline BandPassFilter ( double w , double zeta , double dt ) Construct a new Notch Filter object. Parameters : w \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] zeta \u92ed\u3055 dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f","title":"function BandPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-reset","text":"inline void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-filtering","text":"inline double filtering ( double u )","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-w","text":"inline double w () const","title":"function w"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-zeta","text":"inline double zeta () const","title":"function zeta"},{"location":"doxybook/Classes/classcpp__robotics_1_1BandPassFilter/#function-dt","text":"inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function dt"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/","text":"cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda #include <spline.hpp> Inherits from cpp_robotics::Spline2D Public Functions Name CatumullRom2D (std::vector< Vector2d > & points, const double error =0.1) Additional inherited members Protected Classes inherited from cpp_robotics::Spline2D Name struct segment_info_t struct segment_t Public Functions inherited from cpp_robotics::Spline2D Name Spline2D () =default bool is_empty () size_t size () size_t point_num () double length () double length (size_t i) Vector2d position (double t) Vector2d velocity (double t) Vector2d acceleration (double t) Protected Functions inherited from cpp_robotics::Spline2D Name segment_info_t get_segmet_idx (const double t) Protected Attributes inherited from cpp_robotics::Spline2D Name std::vector< segment_t > _spline bool _is_empty size_t _size double _all_length Public Functions Documentation function CatumullRom2D inline CatumullRom2D ( std :: vector < Vector2d > & points , const double error = 0.1 ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::CatumullRom2D"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#cpp_roboticscatumullrom2d","text":"Catumull\u66f2\u7dda #include <spline.hpp> Inherits from cpp_robotics::Spline2D","title":"cpp_robotics::CatumullRom2D"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#public-functions","text":"Name CatumullRom2D (std::vector< Vector2d > & points, const double error =0.1)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#additional-inherited-members","text":"Protected Classes inherited from cpp_robotics::Spline2D Name struct segment_info_t struct segment_t Public Functions inherited from cpp_robotics::Spline2D Name Spline2D () =default bool is_empty () size_t size () size_t point_num () double length () double length (size_t i) Vector2d position (double t) Vector2d velocity (double t) Vector2d acceleration (double t) Protected Functions inherited from cpp_robotics::Spline2D Name segment_info_t get_segmet_idx (const double t) Protected Attributes inherited from cpp_robotics::Spline2D Name std::vector< segment_t > _spline bool _is_empty size_t _size double _all_length","title":"Additional inherited members"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1CatumullRom2D/#function-catumullrom2d","text":"inline CatumullRom2D ( std :: vector < Vector2d > & points , const double error = 0.1 ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function CatumullRom2D"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/","text":"cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 #include <constraint.hpp> Inherits from std::vector< Constraint > Public Functions Name std::vector< double > eval (const Eigen::VectorXd & x) const double eval_sum (const Eigen::VectorXd & x) const bool all_satisfy (const Eigen::VectorXd & x, const double tol) const std::vector< Constraint >::size_type eq_constraint_size () const std::vector< Constraint >::size_type ineq_constraint_size () const std::vector< Constraint > gen_eq_constraint_list () const std::vector< Constraint > gen_ineq_constraint_list () const Public Functions Documentation function eval inline std :: vector < double > eval ( const Eigen :: VectorXd & x ) const function eval_sum inline double eval_sum ( const Eigen :: VectorXd & x ) const function all_satisfy inline bool all_satisfy ( const Eigen :: VectorXd & x , const double tol ) const function eq_constraint_size inline std :: vector < Constraint >:: size_type eq_constraint_size () const function ineq_constraint_size inline std :: vector < Constraint >:: size_type ineq_constraint_size () const function gen_eq_constraint_list inline std :: vector < Constraint > gen_eq_constraint_list () const function gen_ineq_constraint_list inline std :: vector < Constraint > gen_ineq_constraint_list () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::ConstraintArray"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#cpp_roboticsconstraintarray","text":"\u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 #include <constraint.hpp> Inherits from std::vector< Constraint >","title":"cpp_robotics::ConstraintArray"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#public-functions","text":"Name std::vector< double > eval (const Eigen::VectorXd & x) const double eval_sum (const Eigen::VectorXd & x) const bool all_satisfy (const Eigen::VectorXd & x, const double tol) const std::vector< Constraint >::size_type eq_constraint_size () const std::vector< Constraint >::size_type ineq_constraint_size () const std::vector< Constraint > gen_eq_constraint_list () const std::vector< Constraint > gen_ineq_constraint_list () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eval","text":"inline std :: vector < double > eval ( const Eigen :: VectorXd & x ) const","title":"function eval"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eval_sum","text":"inline double eval_sum ( const Eigen :: VectorXd & x ) const","title":"function eval_sum"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-all_satisfy","text":"inline bool all_satisfy ( const Eigen :: VectorXd & x , const double tol ) const","title":"function all_satisfy"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-eq_constraint_size","text":"inline std :: vector < Constraint >:: size_type eq_constraint_size () const","title":"function eq_constraint_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-ineq_constraint_size","text":"inline std :: vector < Constraint >:: size_type ineq_constraint_size () const","title":"function ineq_constraint_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-gen_eq_constraint_list","text":"inline std :: vector < Constraint > gen_eq_constraint_list () const","title":"function gen_eq_constraint_list"},{"location":"doxybook/Classes/classcpp__robotics_1_1ConstraintArray/#function-gen_ineq_constraint_list","text":"inline std :: vector < Constraint > gen_ineq_constraint_list () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function gen_ineq_constraint_list"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/","text":"cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda #include <spline.hpp> Inherits from cpp_robotics::Spline2D Public Functions Name CubicSpline (std::vector< Vector2d > & points, const double error =0.1) Additional inherited members Protected Classes inherited from cpp_robotics::Spline2D Name struct segment_info_t struct segment_t Public Functions inherited from cpp_robotics::Spline2D Name Spline2D () =default bool is_empty () size_t size () size_t point_num () double length () double length (size_t i) Vector2d position (double t) Vector2d velocity (double t) Vector2d acceleration (double t) Protected Functions inherited from cpp_robotics::Spline2D Name segment_info_t get_segmet_idx (const double t) Protected Attributes inherited from cpp_robotics::Spline2D Name std::vector< segment_t > _spline bool _is_empty size_t _size double _all_length Public Functions Documentation function CubicSpline inline CubicSpline ( std :: vector < Vector2d > & points , const double error = 0.1 ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::CubicSpline"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#cpp_roboticscubicspline","text":"3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda #include <spline.hpp> Inherits from cpp_robotics::Spline2D","title":"cpp_robotics::CubicSpline"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#public-functions","text":"Name CubicSpline (std::vector< Vector2d > & points, const double error =0.1)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#additional-inherited-members","text":"Protected Classes inherited from cpp_robotics::Spline2D Name struct segment_info_t struct segment_t Public Functions inherited from cpp_robotics::Spline2D Name Spline2D () =default bool is_empty () size_t size () size_t point_num () double length () double length (size_t i) Vector2d position (double t) Vector2d velocity (double t) Vector2d acceleration (double t) Protected Functions inherited from cpp_robotics::Spline2D Name segment_info_t get_segmet_idx (const double t) Protected Attributes inherited from cpp_robotics::Spline2D Name std::vector< segment_t > _spline bool _is_empty size_t _size double _all_length","title":"Additional inherited members"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1CubicSpline/#function-cubicspline","text":"inline CubicSpline ( std :: vector < Vector2d > & points , const double error = 0.1 ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function CubicSpline"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/","text":"cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf More... #include <delay_filter.hpp> Public Functions Name DelayFilter (double delay_time, double Ts) virtual void reset () virtual double filtering (double u) Detailed Description class cpp_robotics :: DelayFilter ; \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf G(s) = e^(-T*s) \u9045\u5ef6\u6642\u9593\u306f\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593\u306e\u6574\u6570\u500d\u306e\u307f Public Functions Documentation function DelayFilter inline DelayFilter ( double delay_time , double Ts ) function reset inline virtual void reset () function filtering inline virtual double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DelayFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#cpp_roboticsdelayfilter","text":"\u9045\u5ef6\u30d5\u30a3\u30eb\u30bf More... #include <delay_filter.hpp>","title":"cpp_robotics::DelayFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#public-functions","text":"Name DelayFilter (double delay_time, double Ts) virtual void reset () virtual double filtering (double u)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#detailed-description","text":"class cpp_robotics :: DelayFilter ; \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf G(s) = e^(-T*s) \u9045\u5ef6\u6642\u9593\u306f\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593\u306e\u6574\u6570\u500d\u306e\u307f","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-delayfilter","text":"inline DelayFilter ( double delay_time , double Ts )","title":"function DelayFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-reset","text":"inline virtual void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1DelayFilter/#function-filtering","text":"inline virtual double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/","text":"cpp_robotics::DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 #include <delta_robot.hpp> Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DeltaRobotIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1DeltaRobotIk/#cpp_roboticsdeltarobotik","text":"\u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 #include <delta_robot.hpp> Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DeltaRobotIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/","text":"cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668 More... #include <differentiator.hpp> Public Functions Name Differentiator (double bandwidth, double sample_time) void reset () double filtering (double u) Detailed Description class cpp_robotics :: Differentiator ; \u7591\u4f3c\u5fae\u5206\u5668 G(s) = s / (Ts + 1) \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e Public Functions Documentation function Differentiator inline Differentiator ( double bandwidth , double sample_time ) function reset inline void reset () function filtering inline double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Differentiator"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#cpp_roboticsdifferentiator","text":"\u7591\u4f3c\u5fae\u5206\u5668 More... #include <differentiator.hpp>","title":"cpp_robotics::Differentiator"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#public-functions","text":"Name Differentiator (double bandwidth, double sample_time) void reset () double filtering (double u)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#detailed-description","text":"class cpp_robotics :: Differentiator ; \u7591\u4f3c\u5fae\u5206\u5668 G(s) = s / (Ts + 1) \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-differentiator","text":"inline Differentiator ( double bandwidth , double sample_time )","title":"function Differentiator"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-reset","text":"inline void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1Differentiator/#function-filtering","text":"inline double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/","text":"cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b #include <discret.hpp> Public Functions Name template <typename Derived > auto discretize_a (const Eigen::MatrixBase< Derived > & A, const float Ts) template <typename Derived1 ,typename Derived2 > auto discretize_b (const Eigen::MatrixBase< Derived1 > & A, const Eigen::MatrixBase< Derived2 > & B, const float & Ts, size_t hdiv =1000) template <typename Derived1 ,typename Derived2 > auto discritize (const Eigen::MatrixBase< Derived1 > & A, const Eigen::MatrixBase< Derived2 > & B, const float & Ts, size_t hdiv =1000) \u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b Public Functions Documentation function discretize_a template < typename Derived > static inline auto discretize_a ( const Eigen :: MatrixBase < Derived > & A , const float Ts ) function discretize_b template < typename Derived1 , typename Derived2 > static inline auto discretize_b ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 ) function discritize template < typename Derived1 , typename Derived2 > static inline auto discritize ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 ) \u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b Parameters : A B Ts hdiv Template Parameters : Derived1 Derived2 Return : auto Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Discret"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#cpp_roboticsdiscret","text":"\u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b #include <discret.hpp>","title":"cpp_robotics::Discret"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#public-functions","text":"Name template <typename Derived > auto discretize_a (const Eigen::MatrixBase< Derived > & A, const float Ts) template <typename Derived1 ,typename Derived2 > auto discretize_b (const Eigen::MatrixBase< Derived1 > & A, const Eigen::MatrixBase< Derived2 > & B, const float & Ts, size_t hdiv =1000) template <typename Derived1 ,typename Derived2 > auto discritize (const Eigen::MatrixBase< Derived1 > & A, const Eigen::MatrixBase< Derived2 > & B, const float & Ts, size_t hdiv =1000) \u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discretize_a","text":"template < typename Derived > static inline auto discretize_a ( const Eigen :: MatrixBase < Derived > & A , const float Ts )","title":"function discretize_a"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discretize_b","text":"template < typename Derived1 , typename Derived2 > static inline auto discretize_b ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 )","title":"function discretize_b"},{"location":"doxybook/Classes/classcpp__robotics_1_1Discret/#function-discritize","text":"template < typename Derived1 , typename Derived2 > static inline auto discritize ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 ) \u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b Parameters : A B Ts hdiv Template Parameters : Derived1 Derived2 Return : auto Updated on 2022-09-30 at 00:12:50 +0900","title":"function discritize"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/","text":"cpp_robotics::DiscreteTransferFunction z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570 #include <discrete_transfer_function.hpp> Public Functions Name DiscreteTransferFunction () =default DiscreteTransferFunction (std::vector< double > num_disc, std::vector< double > den_disc, const double dt) void set_discrite (std::vector< double > num_disc, std::vector< double > den_disc, const double dt) double Ts () const virtual void reset (double state =0) double responce (double u) Public Functions Documentation function DiscreteTransferFunction DiscreteTransferFunction () = default function DiscreteTransferFunction inline DiscreteTransferFunction ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt ) function set_discrite inline void set_discrite ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt ) function Ts inline double Ts () const function reset inline virtual void reset ( double state = 0 ) function responce inline double responce ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DiscreteTransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#cpp_roboticsdiscretetransferfunction","text":"z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570 #include <discrete_transfer_function.hpp>","title":"cpp_robotics::DiscreteTransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#public-functions","text":"Name DiscreteTransferFunction () =default DiscreteTransferFunction (std::vector< double > num_disc, std::vector< double > den_disc, const double dt) void set_discrite (std::vector< double > num_disc, std::vector< double > den_disc, const double dt) double Ts () const virtual void reset (double state =0) double responce (double u)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#function-discretetransferfunction","text":"DiscreteTransferFunction () = default","title":"function DiscreteTransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#function-discretetransferfunction_1","text":"inline DiscreteTransferFunction ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt )","title":"function DiscreteTransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#function-set_discrite","text":"inline void set_discrite ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt )","title":"function set_discrite"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#function-ts","text":"inline double Ts () const","title":"function Ts"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#function-reset","text":"inline virtual void reset ( double state = 0 )","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1DiscreteTransferFunction/#function-responce","text":"inline double responce ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function responce"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/","text":"cpp_robotics::DubinsPath Dubins\u30d1\u30b9 #include <dubins_path.hpp> Public Types Name enum class Mode Public Functions Name DubinsPath ( Transformd start, Transformd end, double cavature) double length () const double segment_length (size_t i) const Transformd position (double len) const std::string path_type () const Public Types Documentation enum Mode Enumerator Value Description LRL RLR LSL LSR RSL RSR NONE Public Functions Documentation function DubinsPath inline DubinsPath ( Transformd start , Transformd end , double cavature ) function length inline double length () const function segment_length inline double segment_length ( size_t i ) const function position inline Transformd position ( double len ) const function path_type inline std :: string path_type () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DubinsPath"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#cpp_roboticsdubinspath","text":"Dubins\u30d1\u30b9 #include <dubins_path.hpp>","title":"cpp_robotics::DubinsPath"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-types","text":"Name enum class Mode","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-functions","text":"Name DubinsPath ( Transformd start, Transformd end, double cavature) double length () const double segment_length (size_t i) const Transformd position (double len) const std::string path_type () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#enum-mode","text":"Enumerator Value Description LRL RLR LSL LSR RSL RSR NONE","title":"enum Mode"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-dubinspath","text":"inline DubinsPath ( Transformd start , Transformd end , double cavature )","title":"function DubinsPath"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-length","text":"inline double length () const","title":"function length"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-segment_length","text":"inline double segment_length ( size_t i ) const","title":"function segment_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-position","text":"inline Transformd position ( double len ) const","title":"function position"},{"location":"doxybook/Classes/classcpp__robotics_1_1DubinsPath/#function-path_type","text":"inline std :: string path_type () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function path_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/","text":"cpp_robotics::ExtendedKalmanFilter #include <extended_kalman_filter.hpp> Public Functions Name ExtendedKalmanFilter (const double dt, size_t input_size, size_t state_size, size_t observe_size) void reset (Eigen::VectorXd new_x, Eigen::MatrixXd new_P) Eigen::VectorXd filtering (Eigen::VectorXd u, Eigen::VectorXd z) double dt () const Eigen::VectorXd get_x () const Eigen::MatrixXd get_P () const virtual Eigen::VectorXd system (Eigen::VectorXd x, Eigen::VectorXd u) =0 \u30b7\u30b9\u30c6\u30e0 virtual Eigen::VectorXd observe (Eigen::VectorXd x) =0 \u89b3\u6e2c virtual void system_noise_conv (Eigen::MatrixXd & Q, Eigen::VectorXd x, Eigen::VectorXd u) =0 \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217 virtual void observe_noise_conv (Eigen::MatrixXd & R, Eigen::VectorXd x, Eigen::VectorXd u) =0 \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 virtual void linearized_system_matrix (Eigen::MatrixXd & F, Eigen::VectorXd x, Eigen::VectorXd u) \u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217 virtual void linearized_observe_matrix (Eigen::MatrixXd & H, Eigen::VectorXd x) \u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217 Public Attributes Name Eigen::VectorXd x \u72b6\u614b\u91cf Eigen::MatrixXd F \u9077\u79fb\u884c\u5217 Eigen::MatrixXd B \u5236\u5fa1\u884c\u5217 Eigen::MatrixXd H \u89b3\u6e2c\u884c\u5217 Eigen::MatrixXd Q \u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd R \u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd P \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 Protected Attributes Name const double dt_ const size_t input_size_ const size_t state_size_ const size_t observe_size_ Public Functions Documentation function ExtendedKalmanFilter inline ExtendedKalmanFilter ( const double dt , size_t input_size , size_t state_size , size_t observe_size ) function reset inline void reset ( Eigen :: VectorXd new_x , Eigen :: MatrixXd new_P ) function filtering inline Eigen :: VectorXd filtering ( Eigen :: VectorXd u , Eigen :: VectorXd z ) function dt inline double dt () const function get_x inline Eigen :: VectorXd get_x () const function get_P inline Eigen :: MatrixXd get_P () const function system virtual Eigen :: VectorXd system ( Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 \u30b7\u30b9\u30c6\u30e0 function observe virtual Eigen :: VectorXd observe ( Eigen :: VectorXd x ) = 0 \u89b3\u6e2c function system_noise_conv virtual void system_noise_conv ( Eigen :: MatrixXd & Q , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217 function observe_noise_conv virtual void observe_noise_conv ( Eigen :: MatrixXd & R , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 function linearized_system_matrix inline virtual void linearized_system_matrix ( Eigen :: MatrixXd & F , Eigen :: VectorXd x , Eigen :: VectorXd u ) \u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217 function linearized_observe_matrix inline virtual void linearized_observe_matrix ( Eigen :: MatrixXd & H , Eigen :: VectorXd x ) \u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217 Public Attributes Documentation variable x Eigen :: VectorXd x ; \u72b6\u614b\u91cf variable F Eigen :: MatrixXd F ; \u9077\u79fb\u884c\u5217 variable B Eigen :: MatrixXd B ; \u5236\u5fa1\u884c\u5217 variable H Eigen :: MatrixXd H ; \u89b3\u6e2c\u884c\u5217 variable Q Eigen :: MatrixXd Q ; \u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 variable R Eigen :: MatrixXd R ; \u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 variable P Eigen :: MatrixXd P ; \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 Protected Attributes Documentation variable dt_ const double dt_ ; variable input_size_ const size_t input_size_ ; variable state_size_ const size_t state_size_ ; variable observe_size_ const size_t observe_size_ ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::ExtendedKalmanFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#cpp_roboticsextendedkalmanfilter","text":"#include <extended_kalman_filter.hpp>","title":"cpp_robotics::ExtendedKalmanFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-functions","text":"Name ExtendedKalmanFilter (const double dt, size_t input_size, size_t state_size, size_t observe_size) void reset (Eigen::VectorXd new_x, Eigen::MatrixXd new_P) Eigen::VectorXd filtering (Eigen::VectorXd u, Eigen::VectorXd z) double dt () const Eigen::VectorXd get_x () const Eigen::MatrixXd get_P () const virtual Eigen::VectorXd system (Eigen::VectorXd x, Eigen::VectorXd u) =0 \u30b7\u30b9\u30c6\u30e0 virtual Eigen::VectorXd observe (Eigen::VectorXd x) =0 \u89b3\u6e2c virtual void system_noise_conv (Eigen::MatrixXd & Q, Eigen::VectorXd x, Eigen::VectorXd u) =0 \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217 virtual void observe_noise_conv (Eigen::MatrixXd & R, Eigen::VectorXd x, Eigen::VectorXd u) =0 \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 virtual void linearized_system_matrix (Eigen::MatrixXd & F, Eigen::VectorXd x, Eigen::VectorXd u) \u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217 virtual void linearized_observe_matrix (Eigen::MatrixXd & H, Eigen::VectorXd x) \u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-attributes","text":"Name Eigen::VectorXd x \u72b6\u614b\u91cf Eigen::MatrixXd F \u9077\u79fb\u884c\u5217 Eigen::MatrixXd B \u5236\u5fa1\u884c\u5217 Eigen::MatrixXd H \u89b3\u6e2c\u884c\u5217 Eigen::MatrixXd Q \u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd R \u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217 Eigen::MatrixXd P \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#protected-attributes","text":"Name const double dt_ const size_t input_size_ const size_t state_size_ const size_t observe_size_","title":"Protected Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-extendedkalmanfilter","text":"inline ExtendedKalmanFilter ( const double dt , size_t input_size , size_t state_size , size_t observe_size )","title":"function ExtendedKalmanFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-reset","text":"inline void reset ( Eigen :: VectorXd new_x , Eigen :: MatrixXd new_P )","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-filtering","text":"inline Eigen :: VectorXd filtering ( Eigen :: VectorXd u , Eigen :: VectorXd z )","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-dt","text":"inline double dt () const","title":"function dt"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-get_x","text":"inline Eigen :: VectorXd get_x () const","title":"function get_x"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-get_p","text":"inline Eigen :: MatrixXd get_P () const","title":"function get_P"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-system","text":"virtual Eigen :: VectorXd system ( Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 \u30b7\u30b9\u30c6\u30e0","title":"function system"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-observe","text":"virtual Eigen :: VectorXd observe ( Eigen :: VectorXd x ) = 0 \u89b3\u6e2c","title":"function observe"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-system_noise_conv","text":"virtual void system_noise_conv ( Eigen :: MatrixXd & Q , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u5171\u5206\u6563\u884c\u5217","title":"function system_noise_conv"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-observe_noise_conv","text":"virtual void observe_noise_conv ( Eigen :: MatrixXd & R , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217","title":"function observe_noise_conv"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-linearized_system_matrix","text":"inline virtual void linearized_system_matrix ( Eigen :: MatrixXd & F , Eigen :: VectorXd x , Eigen :: VectorXd u ) \u30b7\u30b9\u30c6\u30e0\u7dda\u5f62\u5316\u884c\u5217","title":"function linearized_system_matrix"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#function-linearized_observe_matrix","text":"inline virtual void linearized_observe_matrix ( Eigen :: MatrixXd & H , Eigen :: VectorXd x ) \u89b3\u6e2c\u7dda\u5f62\u5316\u884c\u5217","title":"function linearized_observe_matrix"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-x","text":"Eigen :: VectorXd x ; \u72b6\u614b\u91cf","title":"variable x"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-f","text":"Eigen :: MatrixXd F ; \u9077\u79fb\u884c\u5217","title":"variable F"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-b","text":"Eigen :: MatrixXd B ; \u5236\u5fa1\u884c\u5217","title":"variable B"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-h","text":"Eigen :: MatrixXd H ; \u89b3\u6e2c\u884c\u5217","title":"variable H"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-q","text":"Eigen :: MatrixXd Q ; \u72b6\u614b\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217","title":"variable Q"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-r","text":"Eigen :: MatrixXd R ; \u89b3\u6e2c\u91cf\u30ce\u30a4\u30ba\u5206\u6563\u884c\u5217","title":"variable R"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-p","text":"Eigen :: MatrixXd P ; \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217","title":"variable P"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-dt_","text":"const double dt_ ;","title":"variable dt_"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-input_size_","text":"const size_t input_size_ ;","title":"variable input_size_"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-state_size_","text":"const size_t state_size_ ;","title":"variable state_size_"},{"location":"doxybook/Classes/classcpp__robotics_1_1ExtendedKalmanFilter/#variable-observe_size_","text":"const size_t observe_size_ ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable observe_size_"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/","text":"cpp_robotics::FilterConnector More... #include <filter_connector.hpp> Public Types Name using std::variant< FILTER_TYPE... > variant_type Public Functions Name FilterConnector () Public Attributes Name constexpr size_t filter_count Detailed Description template < class ... FILTER_TYPE > class cpp_robotics :: FilterConnector ; Public Types Documentation using variant_type using cpp_robotics :: FilterConnector < FILTER_TYPE >:: variant_type = std :: variant < FILTER_TYPE ... > ; Public Functions Documentation function FilterConnector inline FilterConnector () Public Attributes Documentation variable filter_count static constexpr size_t filter_count = sizeof ...( FILTER_TYPE ); Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::FilterConnector"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#cpp_roboticsfilterconnector","text":"More... #include <filter_connector.hpp>","title":"cpp_robotics::FilterConnector"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-types","text":"Name using std::variant< FILTER_TYPE... > variant_type","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-functions","text":"Name FilterConnector ()","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-attributes","text":"Name constexpr size_t filter_count","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#detailed-description","text":"template < class ... FILTER_TYPE > class cpp_robotics :: FilterConnector ;","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#using-variant_type","text":"using cpp_robotics :: FilterConnector < FILTER_TYPE >:: variant_type = std :: variant < FILTER_TYPE ... > ;","title":"using variant_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#function-filterconnector","text":"inline FilterConnector ()","title":"function FilterConnector"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterConnector/#variable-filter_count","text":"static constexpr size_t filter_count = sizeof ...( FILTER_TYPE ); Updated on 2022-09-30 at 00:12:50 +0900","title":"variable filter_count"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/","text":"cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 More... #include <filter_state_holder.hpp> Inherits from BASE_FILTER_TYPE Public Functions Name void set_input (double u) double filtering () double u () const double y () const Detailed Description template < class BASE_FILTER_TYPE > class cpp_robotics :: FilterStateHolder ; \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 Template Parameters : BASE_FILTER_TYPE Public Functions Documentation function set_input inline void set_input ( double u ) function filtering inline double filtering () function u inline double u () const function y inline double y () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::FilterStateHolder"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#cpp_roboticsfilterstateholder","text":"\u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 More... #include <filter_state_holder.hpp> Inherits from BASE_FILTER_TYPE","title":"cpp_robotics::FilterStateHolder"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#public-functions","text":"Name void set_input (double u) double filtering () double u () const double y () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#detailed-description","text":"template < class BASE_FILTER_TYPE > class cpp_robotics :: FilterStateHolder ; \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 Template Parameters : BASE_FILTER_TYPE","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-set_input","text":"inline void set_input ( double u )","title":"function set_input"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-filtering","text":"inline double filtering ()","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-u","text":"inline double u () const","title":"function u"},{"location":"doxybook/Classes/classcpp__robotics_1_1FilterStateHolder/#function-y","text":"inline double y () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function y"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/","text":"cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf #include <high_pass_filter.hpp> Public Functions Name HighPassFilter (double w, double dt) Construct a new High Pass Filter object. void reset (double val =0) double filtering (double u) double w () const double dt () const Public Functions Documentation function HighPassFilter inline HighPassFilter ( double w , double dt ) Construct a new High Pass Filter object. Parameters : w \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] dt function reset inline void reset ( double val = 0 ) function filtering inline double filtering ( double u ) function w inline double w () const function dt inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::HighPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#cpp_roboticshighpassfilter","text":"\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf #include <high_pass_filter.hpp>","title":"cpp_robotics::HighPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#public-functions","text":"Name HighPassFilter (double w, double dt) Construct a new High Pass Filter object. void reset (double val =0) double filtering (double u) double w () const double dt () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-highpassfilter","text":"inline HighPassFilter ( double w , double dt ) Construct a new High Pass Filter object. Parameters : w \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] dt","title":"function HighPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-reset","text":"inline void reset ( double val = 0 )","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-filtering","text":"inline double filtering ( double u )","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-w","text":"inline double w () const","title":"function w"},{"location":"doxybook/Classes/classcpp__robotics_1_1HighPassFilter/#function-dt","text":"inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function dt"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/","text":"cpp_robotics::Integrator \u7a4d\u5206\u5668 #include <integrator.hpp> Public Functions Name Integrator (double Ts) void reset (double val =0) double filtering (double u) Public Functions Documentation function Integrator inline Integrator ( double Ts ) function reset inline void reset ( double val = 0 ) function filtering inline double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Integrator"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#cpp_roboticsintegrator","text":"\u7a4d\u5206\u5668 #include <integrator.hpp>","title":"cpp_robotics::Integrator"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#public-functions","text":"Name Integrator (double Ts) void reset (double val =0) double filtering (double u)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#function-integrator","text":"inline Integrator ( double Ts )","title":"function Integrator"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#function-reset","text":"inline void reset ( double val = 0 )","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1Integrator/#function-filtering","text":"inline double filtering ( double u ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/","text":"cpp_robotics::KDTree k-d\u6728 More... #include <kdtree.hpp> Public Types Name using POINT_T point_type Public Functions Name KDTree () =default KDTree (std::vector< point_type > point) void clear () void build (std::vector< point_type > point) size_t nn_search (const point_type & point) const std::vector< size_t > nn_search (const std::vector< point_type > & point) const std::vector< size_t > knn_search (const point_type & point, size_t k) const std::vector< size_t > radius_search (const point_type & point, double radius) const std::vector< point_type > get_points (const std::vector< size_t > & idx) const std::vector< point_type > knn_search_points (const point_type & point, size_t k) const std::vector< point_type > radius_search_points (const point_type & point, double radius) const void debug_node () Public Attributes Name constexpr size_t dimention Detailed Description template < class POINT_T , int DIM > class cpp_robotics :: KDTree ; k-d\u6728 Template Parameters : POINT_T \u30c7\u30fc\u30bf\u578b DIM \u6b21\u5143\u30b5\u30a4\u30ba Public Types Documentation using point_type using cpp_robotics :: KDTree < POINT_T , DIM >:: point_type = POINT_T ; Public Functions Documentation function KDTree KDTree () = default function KDTree inline KDTree ( std :: vector < point_type > point ) function clear inline void clear () function build inline void build ( std :: vector < point_type > point ) function nn_search inline size_t nn_search ( const point_type & point ) const function nn_search inline std :: vector < size_t > nn_search ( const std :: vector < point_type > & point ) const function knn_search inline std :: vector < size_t > knn_search ( const point_type & point , size_t k ) const function radius_search inline std :: vector < size_t > radius_search ( const point_type & point , double radius ) const function get_points inline std :: vector < point_type > get_points ( const std :: vector < size_t > & idx ) const function knn_search_points inline std :: vector < point_type > knn_search_points ( const point_type & point , size_t k ) const function radius_search_points inline std :: vector < point_type > radius_search_points ( const point_type & point , double radius ) const function debug_node inline void debug_node () Public Attributes Documentation variable dimention static constexpr size_t dimention = DIM ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::KDTree"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#cpp_roboticskdtree","text":"k-d\u6728 More... #include <kdtree.hpp>","title":"cpp_robotics::KDTree"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-types","text":"Name using POINT_T point_type","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-functions","text":"Name KDTree () =default KDTree (std::vector< point_type > point) void clear () void build (std::vector< point_type > point) size_t nn_search (const point_type & point) const std::vector< size_t > nn_search (const std::vector< point_type > & point) const std::vector< size_t > knn_search (const point_type & point, size_t k) const std::vector< size_t > radius_search (const point_type & point, double radius) const std::vector< point_type > get_points (const std::vector< size_t > & idx) const std::vector< point_type > knn_search_points (const point_type & point, size_t k) const std::vector< point_type > radius_search_points (const point_type & point, double radius) const void debug_node ()","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-attributes","text":"Name constexpr size_t dimention","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#detailed-description","text":"template < class POINT_T , int DIM > class cpp_robotics :: KDTree ; k-d\u6728 Template Parameters : POINT_T \u30c7\u30fc\u30bf\u578b DIM \u6b21\u5143\u30b5\u30a4\u30ba","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#using-point_type","text":"using cpp_robotics :: KDTree < POINT_T , DIM >:: point_type = POINT_T ;","title":"using point_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-kdtree","text":"KDTree () = default","title":"function KDTree"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-kdtree_1","text":"inline KDTree ( std :: vector < point_type > point )","title":"function KDTree"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-clear","text":"inline void clear ()","title":"function clear"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-build","text":"inline void build ( std :: vector < point_type > point )","title":"function build"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-nn_search","text":"inline size_t nn_search ( const point_type & point ) const","title":"function nn_search"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-nn_search_1","text":"inline std :: vector < size_t > nn_search ( const std :: vector < point_type > & point ) const","title":"function nn_search"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-knn_search","text":"inline std :: vector < size_t > knn_search ( const point_type & point , size_t k ) const","title":"function knn_search"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-radius_search","text":"inline std :: vector < size_t > radius_search ( const point_type & point , double radius ) const","title":"function radius_search"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-get_points","text":"inline std :: vector < point_type > get_points ( const std :: vector < size_t > & idx ) const","title":"function get_points"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-knn_search_points","text":"inline std :: vector < point_type > knn_search_points ( const point_type & point , size_t k ) const","title":"function knn_search_points"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-radius_search_points","text":"inline std :: vector < point_type > radius_search_points ( const point_type & point , double radius ) const","title":"function radius_search_points"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#function-debug_node","text":"inline void debug_node ()","title":"function debug_node"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KDTree/#variable-dimention","text":"static constexpr size_t dimention = DIM ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable dimention"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/","text":"cpp_robotics::KMeansMethod K-means\u6cd5 More... #include <k_means_method.hpp> Public Types Name using PointType point_t Public Functions Name KMeansMethod () =default std::vector< size_t > fit (std::vector< point_t > & data_set, size_t cluster_size, size_t max_iter =1000) \u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b size_t predict (const point_t & x) \u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b Detailed Description template < class PointType > class cpp_robotics :: KMeansMethod ; K-means\u6cd5 Template Parameters : PointType \u30c7\u30fc\u30bf\u578b Public Types Documentation using point_t using cpp_robotics :: KMeansMethod < PointType >:: point_t = PointType ; Public Functions Documentation function KMeansMethod KMeansMethod () = default function fit inline std :: vector < size_t > fit ( std :: vector < point_t > & data_set , size_t cluster_size , size_t max_iter = 1000 ) \u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b Parameters : data_set \u70b9\u7fa4\u30c7\u30fc\u30bf cluster_size \u751f\u6210\u3059\u308b\u30af\u30e9\u30b9\u30bf\u306e\u30b5\u30a4\u30ba max_iter \u6700\u5927\u53cd\u5fa9\u56de\u6570 Return : std::vector data_set\u306e\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c function predict inline size_t predict ( const point_t & x ) \u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b Parameters : x \u70b9\u30c7\u30fc\u30bf Return : size_t \u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::KMeansMethod"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#cpp_roboticskmeansmethod","text":"K-means\u6cd5 More... #include <k_means_method.hpp>","title":"cpp_robotics::KMeansMethod"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-types","text":"Name using PointType point_t","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-functions","text":"Name KMeansMethod () =default std::vector< size_t > fit (std::vector< point_t > & data_set, size_t cluster_size, size_t max_iter =1000) \u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b size_t predict (const point_t & x) \u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#detailed-description","text":"template < class PointType > class cpp_robotics :: KMeansMethod ; K-means\u6cd5 Template Parameters : PointType \u30c7\u30fc\u30bf\u578b","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#using-point_t","text":"using cpp_robotics :: KMeansMethod < PointType >:: point_t = PointType ;","title":"using point_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-kmeansmethod","text":"KMeansMethod () = default","title":"function KMeansMethod"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-fit","text":"inline std :: vector < size_t > fit ( std :: vector < point_t > & data_set , size_t cluster_size , size_t max_iter = 1000 ) \u70b9\u7fa4\u30c7\u30fc\u30bf\u3092\u4e0e\u3048\u3066\u30af\u30e9\u30b9\u30bf\u3092\u751f\u6210\u3059\u308b Parameters : data_set \u70b9\u7fa4\u30c7\u30fc\u30bf cluster_size \u751f\u6210\u3059\u308b\u30af\u30e9\u30b9\u30bf\u306e\u30b5\u30a4\u30ba max_iter \u6700\u5927\u53cd\u5fa9\u56de\u6570 Return : std::vector data_set\u306e\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c","title":"function fit"},{"location":"doxybook/Classes/classcpp__robotics_1_1KMeansMethod/#function-predict","text":"inline size_t predict ( const point_t & x ) \u70b9\u3092\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3059\u308b Parameters : x \u70b9\u30c7\u30fc\u30bf Return : size_t \u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u7d50\u679c Updated on 2022-09-30 at 00:12:50 +0900","title":"function predict"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/","text":"cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf More... #include <kalman_filter.hpp> Public Types Name using FLOATING_TYPE value_type using Eigen::Matrix< value_type , state_size , 1 > x_vec_t using Eigen::Matrix< value_type , input_size , 1 > u_vec_t using Eigen::Matrix< value_type , observe_size , 1 > z_vec_t using Eigen::Matrix< value_type , state_size , state_size > f_mat_t using Eigen::Matrix< value_type , state_size , input_size > g_mat_t using Eigen::Matrix< value_type , observe_size , state_size > h_mat_t using Eigen::Matrix< value_type , state_size , state_size > q_mat_t using Eigen::Matrix< value_type , observe_size , observe_size > r_mat_t using Eigen::Matrix< value_type , state_size , state_size > p_mat_t Public Functions Name KalmanFilter () =default void reset ( x_vec_t x, p_mat_t P) x_vec_t filtering ( u_vec_t u, z_vec_t z) x_vec_t get_x () p_mat_t get_P () Public Attributes Name constexpr size_t state_size constexpr size_t input_size constexpr size_t observe_size f_mat_t F g_mat_t G h_mat_t H q_mat_t Q r_mat_t R Detailed Description template < typename FLOATING_TYPE , size_t STATE_SIZE , size_t INPUT_SIZE , size_t OBSERVE_SIZE > class cpp_robotics :: KalmanFilter ; \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf Template Parameters : FLOATING_TYPE \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b STATE_SIZE \u72b6\u614b\u91cf\u306e\u30b5\u30a4\u30ba INPUT_SIZE \u5165\u529b\u91cf\u306e\u30b5\u30a4\u30ba OBSERVE_SIZE \u89b3\u6e2c\u91cf\u306e\u30b5\u30a4\u30ba Public Types Documentation using value_type using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: value_type = FLOATING_TYPE ; using x_vec_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: x_vec_t = Eigen :: Matrix < value_type , state_size , 1 > ; using u_vec_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: u_vec_t = Eigen :: Matrix < value_type , input_size , 1 > ; using z_vec_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: z_vec_t = Eigen :: Matrix < value_type , observe_size , 1 > ; using f_mat_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: f_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; using g_mat_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: g_mat_t = Eigen :: Matrix < value_type , state_size , input_size > ; using h_mat_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: h_mat_t = Eigen :: Matrix < value_type , observe_size , state_size > ; using q_mat_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: q_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; using r_mat_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: r_mat_t = Eigen :: Matrix < value_type , observe_size , observe_size > ; using p_mat_t using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: p_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; Public Functions Documentation function KalmanFilter KalmanFilter () = default function reset inline void reset ( x_vec_t x , p_mat_t P ) function filtering inline x_vec_t filtering ( u_vec_t u , z_vec_t z ) function get_x inline x_vec_t get_x () function get_P inline p_mat_t get_P () Public Attributes Documentation variable state_size static constexpr size_t state_size = STATE_SIZE ; variable input_size static constexpr size_t input_size = INPUT_SIZE ; variable observe_size static constexpr size_t observe_size = OBSERVE_SIZE ; variable F f_mat_t F ; variable G g_mat_t G ; variable H h_mat_t H ; variable Q q_mat_t Q ; variable R r_mat_t R ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::KalmanFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#cpp_roboticskalmanfilter","text":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf More... #include <kalman_filter.hpp>","title":"cpp_robotics::KalmanFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-types","text":"Name using FLOATING_TYPE value_type using Eigen::Matrix< value_type , state_size , 1 > x_vec_t using Eigen::Matrix< value_type , input_size , 1 > u_vec_t using Eigen::Matrix< value_type , observe_size , 1 > z_vec_t using Eigen::Matrix< value_type , state_size , state_size > f_mat_t using Eigen::Matrix< value_type , state_size , input_size > g_mat_t using Eigen::Matrix< value_type , observe_size , state_size > h_mat_t using Eigen::Matrix< value_type , state_size , state_size > q_mat_t using Eigen::Matrix< value_type , observe_size , observe_size > r_mat_t using Eigen::Matrix< value_type , state_size , state_size > p_mat_t","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-functions","text":"Name KalmanFilter () =default void reset ( x_vec_t x, p_mat_t P) x_vec_t filtering ( u_vec_t u, z_vec_t z) x_vec_t get_x () p_mat_t get_P ()","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-attributes","text":"Name constexpr size_t state_size constexpr size_t input_size constexpr size_t observe_size f_mat_t F g_mat_t G h_mat_t H q_mat_t Q r_mat_t R","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#detailed-description","text":"template < typename FLOATING_TYPE , size_t STATE_SIZE , size_t INPUT_SIZE , size_t OBSERVE_SIZE > class cpp_robotics :: KalmanFilter ; \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf Template Parameters : FLOATING_TYPE \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b STATE_SIZE \u72b6\u614b\u91cf\u306e\u30b5\u30a4\u30ba INPUT_SIZE \u5165\u529b\u91cf\u306e\u30b5\u30a4\u30ba OBSERVE_SIZE \u89b3\u6e2c\u91cf\u306e\u30b5\u30a4\u30ba","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-value_type","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: value_type = FLOATING_TYPE ;","title":"using value_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-x_vec_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: x_vec_t = Eigen :: Matrix < value_type , state_size , 1 > ;","title":"using x_vec_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-u_vec_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: u_vec_t = Eigen :: Matrix < value_type , input_size , 1 > ;","title":"using u_vec_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-z_vec_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: z_vec_t = Eigen :: Matrix < value_type , observe_size , 1 > ;","title":"using z_vec_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-f_mat_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: f_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ;","title":"using f_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-g_mat_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: g_mat_t = Eigen :: Matrix < value_type , state_size , input_size > ;","title":"using g_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-h_mat_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: h_mat_t = Eigen :: Matrix < value_type , observe_size , state_size > ;","title":"using h_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-q_mat_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: q_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ;","title":"using q_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-r_mat_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: r_mat_t = Eigen :: Matrix < value_type , observe_size , observe_size > ;","title":"using r_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#using-p_mat_t","text":"using cpp_robotics :: KalmanFilter < FLOATING_TYPE , STATE_SIZE , INPUT_SIZE , OBSERVE_SIZE >:: p_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ;","title":"using p_mat_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-kalmanfilter","text":"KalmanFilter () = default","title":"function KalmanFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-reset","text":"inline void reset ( x_vec_t x , p_mat_t P )","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-filtering","text":"inline x_vec_t filtering ( u_vec_t u , z_vec_t z )","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-get_x","text":"inline x_vec_t get_x ()","title":"function get_x"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#function-get_p","text":"inline p_mat_t get_P ()","title":"function get_P"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-state_size","text":"static constexpr size_t state_size = STATE_SIZE ;","title":"variable state_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-input_size","text":"static constexpr size_t input_size = INPUT_SIZE ;","title":"variable input_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-observe_size","text":"static constexpr size_t observe_size = OBSERVE_SIZE ;","title":"variable observe_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-f","text":"f_mat_t F ;","title":"variable F"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-g","text":"g_mat_t G ;","title":"variable G"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-h","text":"h_mat_t H ;","title":"variable H"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-q","text":"q_mat_t Q ;","title":"variable Q"},{"location":"doxybook/Classes/classcpp__robotics_1_1KalmanFilter/#variable-r","text":"r_mat_t R ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable R"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/","text":"cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc #include <low_pass_filter.hpp> Public Functions Name LowPassFilter (double w, double dt) Construct a new Low Pass Filter object. void reset (double val =0) double filtering (double u) double w () const double dt () const Public Functions Documentation function LowPassFilter inline LowPassFilter ( double w , double dt ) Construct a new Low Pass Filter object. Parameters : w \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f function reset inline void reset ( double val = 0 ) function filtering inline double filtering ( double u ) function w inline double w () const function dt inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::LowPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#cpp_roboticslowpassfilter","text":"\u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc #include <low_pass_filter.hpp>","title":"cpp_robotics::LowPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#public-functions","text":"Name LowPassFilter (double w, double dt) Construct a new Low Pass Filter object. void reset (double val =0) double filtering (double u) double w () const double dt () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-lowpassfilter","text":"inline LowPassFilter ( double w , double dt ) Construct a new Low Pass Filter object. Parameters : w \u6298\u308c\u70b9\u5468\u6ce2\u6570[rad/s] dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f","title":"function LowPassFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-reset","text":"inline void reset ( double val = 0 )","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-filtering","text":"inline double filtering ( double u )","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-w","text":"inline double w () const","title":"function w"},{"location":"doxybook/Classes/classcpp__robotics_1_1LowPassFilter/#function-dt","text":"inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function dt"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/","text":"cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <mecanum_ik.hpp> Public Classes Name struct Config Public Functions Name MecanumIk (double width, double length) MecanumIk ( Config config) std::array< double, 4 > calculate ( Transformd velocity) Config config () const Public Functions Documentation function MecanumIk inline MecanumIk ( double width , double length ) function MecanumIk inline MecanumIk ( Config config ) function calculate inline std :: array < double , 4 > calculate ( Transformd velocity ) function config inline Config config () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::MecanumIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#cpp_roboticsmecanumik","text":"\u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <mecanum_ik.hpp>","title":"cpp_robotics::MecanumIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-classes","text":"Name struct Config","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-functions","text":"Name MecanumIk (double width, double length) MecanumIk ( Config config) std::array< double, 4 > calculate ( Transformd velocity) Config config () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-mecanumik","text":"inline MecanumIk ( double width , double length )","title":"function MecanumIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-mecanumik_1","text":"inline MecanumIk ( Config config )","title":"function MecanumIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-calculate","text":"inline std :: array < double , 4 > calculate ( Transformd velocity )","title":"function calculate"},{"location":"doxybook/Classes/classcpp__robotics_1_1MecanumIk/#function-config","text":"inline Config config () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function config"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/","text":"cpp_robotics::NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 #include <ndt.hpp> Public Functions Name NDT2d () =default Public Functions Documentation function NDT2d NDT2d () = default Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::NDT2d"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/#cpp_roboticsndt2d","text":"2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 #include <ndt.hpp>","title":"cpp_robotics::NDT2d"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/#public-functions","text":"Name NDT2d () =default","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1NDT2d/#function-ndt2d","text":"NDT2d () = default Updated on 2022-09-30 at 00:12:50 +0900","title":"function NDT2d"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/","text":"cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668 #include <nctf.hpp> Public Functions Name std::function< double(double)> make_simple_nct (double max_velocity, double slope) NctfController (double max_velocity, double nct_slope, PIDController::pid_param_t pid_param, double dt) NctfController (std::function< double(double)> nct, PIDController::pid_param_t pid_param, double dt) void reset () double control (double target, double state) double control (double e) std::function< double(double)> nct () const Public Functions Documentation function make_simple_nct static inline std :: function < double ( double ) > make_simple_nct ( double max_velocity , double slope ) function NctfController inline NctfController ( double max_velocity , double nct_slope , PIDController :: pid_param_t pid_param , double dt ) function NctfController inline NctfController ( std :: function < double ( double ) > nct , PIDController :: pid_param_t pid_param , double dt ) function reset inline void reset () function control inline double control ( double target , double state ) function control inline double control ( double e ) function nct inline std :: function < double ( double ) > nct () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::NctfController"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#cpp_roboticsnctfcontroller","text":"NCTF\u5236\u5fa1\u5668 #include <nctf.hpp>","title":"cpp_robotics::NctfController"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-functions","text":"Name std::function< double(double)> make_simple_nct (double max_velocity, double slope) NctfController (double max_velocity, double nct_slope, PIDController::pid_param_t pid_param, double dt) NctfController (std::function< double(double)> nct, PIDController::pid_param_t pid_param, double dt) void reset () double control (double target, double state) double control (double e) std::function< double(double)> nct () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-make_simple_nct","text":"static inline std :: function < double ( double ) > make_simple_nct ( double max_velocity , double slope )","title":"function make_simple_nct"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nctfcontroller","text":"inline NctfController ( double max_velocity , double nct_slope , PIDController :: pid_param_t pid_param , double dt )","title":"function NctfController"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nctfcontroller_1","text":"inline NctfController ( std :: function < double ( double ) > nct , PIDController :: pid_param_t pid_param , double dt )","title":"function NctfController"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-reset","text":"inline void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-control","text":"inline double control ( double target , double state )","title":"function control"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-control_1","text":"inline double control ( double e )","title":"function control"},{"location":"doxybook/Classes/classcpp__robotics_1_1NctfController/#function-nct","text":"inline std :: function < double ( double ) > nct () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function nct"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/","text":"cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf #include <notch_filter.hpp> Public Functions Name NotchFilter (double w, double zeta, double d, double dt) Construct a new Notch Filter object. void reset () double filtering (double u) double w () const double zeta () const double d () const double dt () const Public Functions Documentation function NotchFilter inline NotchFilter ( double w , double zeta , double d , double dt ) Construct a new Notch Filter object. Parameters : w \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] zeta \u92ed\u3055 d \u6df1\u3055(0.0\u3067\u4e00\u756a\u6df1\u304f\u30011.0\u306b\u8fd1\u3065\u3051\u308b\u307b\u3069\u30d5\u30a3\u30eb\u30bf\u306e\u52b9\u679c\u304c\u5f31\u304f\u306a\u308b) dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f function reset inline void reset () function filtering inline double filtering ( double u ) function w inline double w () const function zeta inline double zeta () const function d inline double d () const function dt inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::NotchFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#cpp_roboticsnotchfilter","text":"\u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf #include <notch_filter.hpp>","title":"cpp_robotics::NotchFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#public-functions","text":"Name NotchFilter (double w, double zeta, double d, double dt) Construct a new Notch Filter object. void reset () double filtering (double u) double w () const double zeta () const double d () const double dt () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-notchfilter","text":"inline NotchFilter ( double w , double zeta , double d , double dt ) Construct a new Notch Filter object. Parameters : w \u4e2d\u5fc3\u5468\u6ce2\u6570[rad/s] zeta \u92ed\u3055 d \u6df1\u3055(0.0\u3067\u4e00\u756a\u6df1\u304f\u30011.0\u306b\u8fd1\u3065\u3051\u308b\u307b\u3069\u30d5\u30a3\u30eb\u30bf\u306e\u52b9\u679c\u304c\u5f31\u304f\u306a\u308b) dt \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f","title":"function NotchFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-reset","text":"inline void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-filtering","text":"inline double filtering ( double u )","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-w","text":"inline double w () const","title":"function w"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-zeta","text":"inline double zeta () const","title":"function zeta"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-d","text":"inline double d () const","title":"function d"},{"location":"doxybook/Classes/classcpp__robotics_1_1NotchFilter/#function-dt","text":"inline double dt () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function dt"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/","text":"cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <omni_ik.hpp> Public Classes Name struct Config Public Functions Name Omni3Ik (double radius, double first_wheel_angle =M_PI/6) Omni3Ik ( Config config) std::array< double, 3 > calculate ( Transformd velocity) Config config () const Public Functions Documentation function Omni3Ik inline Omni3Ik ( double radius , double first_wheel_angle = M_PI / 6 ) function Omni3Ik inline Omni3Ik ( Config config ) function calculate inline std :: array < double , 3 > calculate ( Transformd velocity ) function config inline Config config () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Omni3Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#cpp_roboticsomni3ik","text":"3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <omni_ik.hpp>","title":"cpp_robotics::Omni3Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-classes","text":"Name struct Config","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-functions","text":"Name Omni3Ik (double radius, double first_wheel_angle =M_PI/6) Omni3Ik ( Config config) std::array< double, 3 > calculate ( Transformd velocity) Config config () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-omni3ik","text":"inline Omni3Ik ( double radius , double first_wheel_angle = M_PI / 6 )","title":"function Omni3Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-omni3ik_1","text":"inline Omni3Ik ( Config config )","title":"function Omni3Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-calculate","text":"inline std :: array < double , 3 > calculate ( Transformd velocity )","title":"function calculate"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni3Ik/#function-config","text":"inline Config config () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function config"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/","text":"cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <omni_ik.hpp> Public Classes Name struct Config Public Functions Name Omni4Ik (double radius, double first_wheel_angle =M_PI/4) Omni4Ik ( Config config) std::array< double, 4 > calculate ( Transformd velocity) Config config () const Public Functions Documentation function Omni4Ik inline Omni4Ik ( double radius , double first_wheel_angle = M_PI / 4 ) function Omni4Ik inline Omni4Ik ( Config config ) function calculate inline std :: array < double , 4 > calculate ( Transformd velocity ) function config inline Config config () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Omni4Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#cpp_roboticsomni4ik","text":"4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <omni_ik.hpp>","title":"cpp_robotics::Omni4Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-classes","text":"Name struct Config","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-functions","text":"Name Omni4Ik (double radius, double first_wheel_angle =M_PI/4) Omni4Ik ( Config config) std::array< double, 4 > calculate ( Transformd velocity) Config config () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-omni4ik","text":"inline Omni4Ik ( double radius , double first_wheel_angle = M_PI / 4 )","title":"function Omni4Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-omni4ik_1","text":"inline Omni4Ik ( Config config )","title":"function Omni4Ik"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-calculate","text":"inline std :: array < double , 4 > calculate ( Transformd velocity )","title":"function calculate"},{"location":"doxybook/Classes/classcpp__robotics_1_1Omni4Ik/#function-config","text":"inline Config config () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function config"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/","text":"cpp_robotics::PID2Controller 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 #include <pid2.hpp> Public Classes Name struct pid_param_t Public Functions Name PID2Controller ( pid_param_t param) void setParam ( pid_param_t param) void set_param ( pid_param_t param) void reset () double calculate (double target, double present, double dt) double calculate (double target, double present) Public Functions Documentation function PID2Controller inline PID2Controller ( pid_param_t param ) function setParam inline void setParam ( pid_param_t param ) function set_param inline void set_param ( pid_param_t param ) function reset inline void reset () function calculate inline double calculate ( double target , double present , double dt ) function calculate inline double calculate ( double target , double present ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::PID2Controller"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#cpp_roboticspid2controller","text":"2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 #include <pid2.hpp>","title":"cpp_robotics::PID2Controller"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#public-classes","text":"Name struct pid_param_t","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#public-functions","text":"Name PID2Controller ( pid_param_t param) void setParam ( pid_param_t param) void set_param ( pid_param_t param) void reset () double calculate (double target, double present, double dt) double calculate (double target, double present)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#function-pid2controller","text":"inline PID2Controller ( pid_param_t param )","title":"function PID2Controller"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#function-setparam","text":"inline void setParam ( pid_param_t param )","title":"function setParam"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#function-set_param","text":"inline void set_param ( pid_param_t param )","title":"function set_param"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#function-reset","text":"inline void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#function-calculate","text":"inline double calculate ( double target , double present , double dt )","title":"function calculate"},{"location":"doxybook/Classes/classcpp__robotics_1_1PID2Controller/#function-calculate_1","text":"inline double calculate ( double target , double present ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function calculate"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/","text":"cpp_robotics::PIDController PID\u5236\u5fa1\u5668 #include <pid.hpp> Public Classes Name struct pid_param_t Public Functions Name PIDController ( pid_param_t param) void set_param ( pid_param_t param) void reset () double calculate (double error) Public Functions Documentation function PIDController inline PIDController ( pid_param_t param ) function set_param inline void set_param ( pid_param_t param ) function reset inline void reset () function calculate inline double calculate ( double error ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::PIDController"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#cpp_roboticspidcontroller","text":"PID\u5236\u5fa1\u5668 #include <pid.hpp>","title":"cpp_robotics::PIDController"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#public-classes","text":"Name struct pid_param_t","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#public-functions","text":"Name PIDController ( pid_param_t param) void set_param ( pid_param_t param) void reset () double calculate (double error)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#function-pidcontroller","text":"inline PIDController ( pid_param_t param )","title":"function PIDController"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#function-set_param","text":"inline void set_param ( pid_param_t param )","title":"function set_param"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#function-reset","text":"inline void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1PIDController/#function-calculate","text":"inline double calculate ( double error ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function calculate"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/","text":"cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668 #include <pure_pursuit.hpp> Public Functions Name PurePursuit (double K) void set_K (double K) std::tuple< bool, double > control (std::function< Vector2d (double)> traj_ref, double traj_progress, Vector2d pos_present, double vel, double angle_present) Public Functions Documentation function PurePursuit inline PurePursuit ( double K ) function set_K inline void set_K ( double K ) function control inline std :: tuple < bool , double > control ( std :: function < Vector2d ( double ) > traj_ref , double traj_progress , Vector2d pos_present , double vel , double angle_present ) Parameters : traj_ref \u59cb\u70b9\u304b\u3089\u306e\u9577\u3055\u306b\u3088\u308b\u7d4c\u8def\u306e\u95a2\u6570 traj_progress \u73fe\u5728\u306e\u7d4c\u8def\u4e0a\u306e\u9577\u3055\u4f4d\u7f6e pos_present \u73fe\u5728\u306e\u5ea7\u6a19 target_angle_offset traj_ref\u304b\u3089\u76ee\u6a19\u5ea7\u6a19\u3092\u53d6\u3063\u3066\u304d\u305f\u6642\u306b\u4f4d\u7f6e\u8aa4\u5dee\u304b\u3089\u89d2\u5ea6\u3092\u51fa\u3057\u305f\u6642\u306b\u52a0\u3048\u308b\u30aa\u30d5\u30bb\u30c3\u30c8 vel \u73fe\u5728\u306e\u9032\u884c\u65b9\u5411\u306e\u901f\u5ea6 angle_present \u73fe\u5728\u306e\u30ed\u30dc\u30c3\u30c8\u306eYaw\u89d2\u5ea6 Return : std::tuple [Pure Pursuit\u304c\u6709\u52b9\u306a\u51fa\u529b\u3092\u8fd4\u3059\u304b, \u51fa\u529b\u5024] Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::PurePursuit"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#cpp_roboticspurepursuit","text":"Pure pursuit\u5236\u5fa1\u5668 #include <pure_pursuit.hpp>","title":"cpp_robotics::PurePursuit"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#public-functions","text":"Name PurePursuit (double K) void set_K (double K) std::tuple< bool, double > control (std::function< Vector2d (double)> traj_ref, double traj_progress, Vector2d pos_present, double vel, double angle_present)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-purepursuit","text":"inline PurePursuit ( double K )","title":"function PurePursuit"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-set_k","text":"inline void set_K ( double K )","title":"function set_K"},{"location":"doxybook/Classes/classcpp__robotics_1_1PurePursuit/#function-control","text":"inline std :: tuple < bool , double > control ( std :: function < Vector2d ( double ) > traj_ref , double traj_progress , Vector2d pos_present , double vel , double angle_present ) Parameters : traj_ref \u59cb\u70b9\u304b\u3089\u306e\u9577\u3055\u306b\u3088\u308b\u7d4c\u8def\u306e\u95a2\u6570 traj_progress \u73fe\u5728\u306e\u7d4c\u8def\u4e0a\u306e\u9577\u3055\u4f4d\u7f6e pos_present \u73fe\u5728\u306e\u5ea7\u6a19 target_angle_offset traj_ref\u304b\u3089\u76ee\u6a19\u5ea7\u6a19\u3092\u53d6\u3063\u3066\u304d\u305f\u6642\u306b\u4f4d\u7f6e\u8aa4\u5dee\u304b\u3089\u89d2\u5ea6\u3092\u51fa\u3057\u305f\u6642\u306b\u52a0\u3048\u308b\u30aa\u30d5\u30bb\u30c3\u30c8 vel \u73fe\u5728\u306e\u9032\u884c\u65b9\u5411\u306e\u901f\u5ea6 angle_present \u73fe\u5728\u306e\u30ed\u30dc\u30c3\u30c8\u306eYaw\u89d2\u5ea6 Return : std::tuple [Pure Pursuit\u304c\u6709\u52b9\u306a\u51fa\u529b\u3092\u8fd4\u3059\u304b, \u51fa\u529b\u5024] Updated on 2022-09-30 at 00:12:50 +0900","title":"function control"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/","text":"cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 #include <quadprog.hpp> Public Classes Name struct Param struct Result Public Functions Name void set_problem_size (const size_t valiable_size, const size_t ineq_constraint_size, const size_t eq_constraint_size) void debug_prog () Result solve (Eigen::VectorXd x_init) double evaluate (const Eigen::VectorXd & x) double evaluate_merit (const Eigen::VectorXd & x, const Eigen::VectorXd & s, const double rho, const double eta) Eigen::VectorXd grad_lagrange (const Eigen::VectorXd & x, const Eigen::VectorXd & u, const Eigen::VectorXd & v) Public Attributes Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd Aeq Eigen::VectorXd beq Eigen::MatrixXd A Eigen::VectorXd b Param param Public Functions Documentation function set_problem_size inline void set_problem_size ( const size_t valiable_size , const size_t ineq_constraint_size , const size_t eq_constraint_size ) function debug_prog inline void debug_prog () function solve inline Result solve ( Eigen :: VectorXd x_init ) function evaluate inline double evaluate ( const Eigen :: VectorXd & x ) function evaluate_merit inline double evaluate_merit ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & s , const double rho , const double eta ) function grad_lagrange inline Eigen :: VectorXd grad_lagrange ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & u , const Eigen :: VectorXd & v ) Public Attributes Documentation variable Q Eigen :: MatrixXd Q ; variable c Eigen :: VectorXd c ; variable Aeq Eigen :: MatrixXd Aeq ; variable beq Eigen :: VectorXd beq ; variable A Eigen :: MatrixXd A ; variable b Eigen :: VectorXd b ; variable param Param param ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::QuadProg"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#cpp_roboticsquadprog","text":"\u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 #include <quadprog.hpp>","title":"cpp_robotics::QuadProg"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-classes","text":"Name struct Param struct Result","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-functions","text":"Name void set_problem_size (const size_t valiable_size, const size_t ineq_constraint_size, const size_t eq_constraint_size) void debug_prog () Result solve (Eigen::VectorXd x_init) double evaluate (const Eigen::VectorXd & x) double evaluate_merit (const Eigen::VectorXd & x, const Eigen::VectorXd & s, const double rho, const double eta) Eigen::VectorXd grad_lagrange (const Eigen::VectorXd & x, const Eigen::VectorXd & u, const Eigen::VectorXd & v)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-attributes","text":"Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd Aeq Eigen::VectorXd beq Eigen::MatrixXd A Eigen::VectorXd b Param param","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-set_problem_size","text":"inline void set_problem_size ( const size_t valiable_size , const size_t ineq_constraint_size , const size_t eq_constraint_size )","title":"function set_problem_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-debug_prog","text":"inline void debug_prog ()","title":"function debug_prog"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-solve","text":"inline Result solve ( Eigen :: VectorXd x_init )","title":"function solve"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-evaluate","text":"inline double evaluate ( const Eigen :: VectorXd & x )","title":"function evaluate"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-evaluate_merit","text":"inline double evaluate_merit ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & s , const double rho , const double eta )","title":"function evaluate_merit"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#function-grad_lagrange","text":"inline Eigen :: VectorXd grad_lagrange ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & u , const Eigen :: VectorXd & v )","title":"function grad_lagrange"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-q","text":"Eigen :: MatrixXd Q ;","title":"variable Q"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-c","text":"Eigen :: VectorXd c ;","title":"variable c"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-aeq","text":"Eigen :: MatrixXd Aeq ;","title":"variable Aeq"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-beq","text":"Eigen :: VectorXd beq ;","title":"variable beq"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-a","text":"Eigen :: MatrixXd A ;","title":"variable A"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-b","text":"Eigen :: VectorXd b ;","title":"variable b"},{"location":"doxybook/Classes/classcpp__robotics_1_1QuadProg/#variable-param","text":"Param param ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable param"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/","text":"cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 More... #include <random.hpp> Inherits from Distribution Public Types Name using Distribution distribution_t using EngineMethod engine_method_t Public Functions Name template <typename ... Arg> RandomGenerator (Arg ... arg) \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 distribution_t::result_type value () \u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046 Detailed Description template < class Distribution , class EngineMethod = std :: mt19937 > class cpp_robotics :: RandomGenerator ; std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 Template Parameters : Distribution \u4e71\u6570\u306e\u5206\u5e03, std::normal_distribution \u7b49 EngineMethod \u7591\u4f3c\u4e71\u6570\u751f\u6210\u6cd5, std::mt19937\u7b49 Public Types Documentation using distribution_t using cpp_robotics :: RandomGenerator < Distribution , EngineMethod >:: distribution_t = Distribution ; using engine_method_t using cpp_robotics :: RandomGenerator < Distribution , EngineMethod >:: engine_method_t = EngineMethod ; Public Functions Documentation function RandomGenerator template < typename ... Arg > inline RandomGenerator ( Arg ... arg ) \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 Parameters : arg Template Parameters : Arg function value inline distribution_t :: result_type value () \u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046 Return : distribution_t::result_type Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::RandomGenerator"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#cpp_roboticsrandomgenerator","text":"std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 More... #include <random.hpp> Inherits from Distribution","title":"cpp_robotics::RandomGenerator"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-types","text":"Name using Distribution distribution_t using EngineMethod engine_method_t","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-functions","text":"Name template <typename ... Arg> RandomGenerator (Arg ... arg) \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 distribution_t::result_type value () \u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#detailed-description","text":"template < class Distribution , class EngineMethod = std :: mt19937 > class cpp_robotics :: RandomGenerator ; std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 Template Parameters : Distribution \u4e71\u6570\u306e\u5206\u5e03, std::normal_distribution \u7b49 EngineMethod \u7591\u4f3c\u4e71\u6570\u751f\u6210\u6cd5, std::mt19937\u7b49","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#using-distribution_t","text":"using cpp_robotics :: RandomGenerator < Distribution , EngineMethod >:: distribution_t = Distribution ;","title":"using distribution_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#using-engine_method_t","text":"using cpp_robotics :: RandomGenerator < Distribution , EngineMethod >:: engine_method_t = EngineMethod ;","title":"using engine_method_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#function-randomgenerator","text":"template < typename ... Arg > inline RandomGenerator ( Arg ... arg ) \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5f15\u6570\u306fDistribution\u306b\u5f93\u3046 Parameters : arg Template Parameters : Arg","title":"function RandomGenerator"},{"location":"doxybook/Classes/classcpp__robotics_1_1RandomGenerator/#function-value","text":"inline distribution_t :: result_type value () \u4e71\u6570\u3092\u53d6\u5f97\u3059\u308b, \u623b\u308a\u5024\u306e\u578b\u306fDistribution\u306b\u5f93\u3046 Return : distribution_t::result_type Updated on 2022-09-30 at 00:12:50 +0900","title":"function value"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/","text":"cpp_robotics::SQP SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) #include <sqp.hpp> Public Classes Name struct Problem struct Result Public Types Name using std::function< double(Eigen::VectorXd)> func_type Public Functions Name Result solve ( Problem prob, const Eigen::VectorXd & x0, std::optional< std::function< void(Eigen::VectorXd)>> callback) Public Types Documentation using func_type using cpp_robotics :: SQP :: func_type = std :: function < double ( Eigen :: VectorXd ) > ; Public Functions Documentation function solve inline Result solve ( Problem prob , const Eigen :: VectorXd & x0 , std :: optional < std :: function < void ( Eigen :: VectorXd ) >> callback ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::SQP"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#cpp_roboticssqp","text":"SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) #include <sqp.hpp>","title":"cpp_robotics::SQP"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-classes","text":"Name struct Problem struct Result","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-types","text":"Name using std::function< double(Eigen::VectorXd)> func_type","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-functions","text":"Name Result solve ( Problem prob, const Eigen::VectorXd & x0, std::optional< std::function< void(Eigen::VectorXd)>> callback)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#using-func_type","text":"using cpp_robotics :: SQP :: func_type = std :: function < double ( Eigen :: VectorXd ) > ;","title":"using func_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1SQP/#function-solve","text":"inline Result solve ( Problem prob , const Eigen :: VectorXd & x0 , std :: optional < std :: function < void ( Eigen :: VectorXd ) >> callback ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function solve"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/","text":"cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b More... #include <singleton.hpp> Public Types Name using T class_t using std::shared_ptr< class_t > shared_t Public Functions Name shared_t get_shared_instance () \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059 Detailed Description template < class T > class cpp_robotics :: Singleton ; \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b Template Parameters : T \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u3067\u751f\u6210\u3057\u305f\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u578b Public Types Documentation using class_t using cpp_robotics :: Singleton < T >:: class_t = T ; using shared_t using cpp_robotics :: Singleton < T >:: shared_t = std :: shared_ptr < class_t > ; Public Functions Documentation function get_shared_instance static inline shared_t get_shared_instance () \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059 Return : shared_t \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306eshared_ptr Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Singleton"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#cpp_roboticssingleton","text":"\u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b More... #include <singleton.hpp>","title":"cpp_robotics::Singleton"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-types","text":"Name using T class_t using std::shared_ptr< class_t > shared_t","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-functions","text":"Name shared_t get_shared_instance () \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#detailed-description","text":"template < class T > class cpp_robotics :: Singleton ; \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b Template Parameters : T \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u3067\u751f\u6210\u3057\u305f\u3044\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u578b","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#using-class_t","text":"using cpp_robotics :: Singleton < T >:: class_t = T ;","title":"using class_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#using-shared_t","text":"using cpp_robotics :: Singleton < T >:: shared_t = std :: shared_ptr < class_t > ;","title":"using shared_t"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Singleton/#function-get_shared_instance","text":"static inline shared_t get_shared_instance () \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092std::shared_ptr\u3067\u8fd4\u3059 Return : shared_t \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306eshared_ptr Updated on 2022-09-30 at 00:12:50 +0900","title":"function get_shared_instance"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/","text":"cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 #include <siso_system.hpp> Public Classes Name struct func_list_t Public Functions Name SisoFeedbackSystem () =default SisoFeedbackSystem ( func_list_t fn) void reset () double control (double target) double u () const double y () const std::function< double(double)> make_control_function () operator std::function< double (double ) Public Functions Documentation function SisoFeedbackSystem SisoFeedbackSystem () = default function SisoFeedbackSystem inline SisoFeedbackSystem ( func_list_t fn ) function reset inline void reset () function control inline double control ( double target ) function u inline double u () const function y inline double y () const function make_control_function inline std :: function < double ( double ) > make_control_function () function operator std::function< double inline operator std :: function < double ( double ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::SisoFeedbackSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#cpp_roboticssisofeedbacksystem","text":"\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 #include <siso_system.hpp>","title":"cpp_robotics::SisoFeedbackSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-classes","text":"Name struct func_list_t","title":"Public Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-functions","text":"Name SisoFeedbackSystem () =default SisoFeedbackSystem ( func_list_t fn) void reset () double control (double target) double u () const double y () const std::function< double(double)> make_control_function () operator std::function< double (double )","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-sisofeedbacksystem","text":"SisoFeedbackSystem () = default","title":"function SisoFeedbackSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-sisofeedbacksystem_1","text":"inline SisoFeedbackSystem ( func_list_t fn )","title":"function SisoFeedbackSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-reset","text":"inline void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-control","text":"inline double control ( double target )","title":"function control"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-u","text":"inline double u () const","title":"function u"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-y","text":"inline double y () const","title":"function y"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-make_control_function","text":"inline std :: function < double ( double ) > make_control_function ()","title":"function make_control_function"},{"location":"doxybook/Classes/classcpp__robotics_1_1SisoFeedbackSystem/#function-operator-stdfunction-double","text":"inline operator std :: function < double ( double ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function operator std::function&lt; double"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/","text":"cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 #include <spline.hpp> Inherited by cpp_robotics::CatumullRom2D , cpp_robotics::CubicSpline Protected Classes Name struct segment_info_t struct segment_t Public Functions Name Spline2D () =default bool is_empty () size_t size () size_t point_num () double length () double length (size_t i) Vector2d position (double t) Vector2d velocity (double t) Vector2d acceleration (double t) Protected Functions Name segment_info_t get_segmet_idx (const double t) Protected Attributes Name std::vector< segment_t > _spline bool _is_empty size_t _size double _all_length Public Functions Documentation function Spline2D Spline2D () = default function is_empty inline bool is_empty () function size inline size_t size () function point_num inline size_t point_num () function length inline double length () function length inline double length ( size_t i ) function position inline Vector2d position ( double t ) function velocity inline Vector2d velocity ( double t ) function acceleration inline Vector2d acceleration ( double t ) Protected Functions Documentation function get_segmet_idx inline segment_info_t get_segmet_idx ( const double t ) Protected Attributes Documentation variable _spline std :: vector < segment_t > _spline ; variable _is_empty bool _is_empty ; variable _size size_t _size ; variable _all_length double _all_length ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Spline2D"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#cpp_roboticsspline2d","text":"2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 #include <spline.hpp> Inherited by cpp_robotics::CatumullRom2D , cpp_robotics::CubicSpline","title":"cpp_robotics::Spline2D"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-classes","text":"Name struct segment_info_t struct segment_t","title":"Protected Classes"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#public-functions","text":"Name Spline2D () =default bool is_empty () size_t size () size_t point_num () double length () double length (size_t i) Vector2d position (double t) Vector2d velocity (double t) Vector2d acceleration (double t)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-functions","text":"Name segment_info_t get_segmet_idx (const double t)","title":"Protected Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-attributes","text":"Name std::vector< segment_t > _spline bool _is_empty size_t _size double _all_length","title":"Protected Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-spline2d","text":"Spline2D () = default","title":"function Spline2D"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-is_empty","text":"inline bool is_empty ()","title":"function is_empty"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-size","text":"inline size_t size ()","title":"function size"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-point_num","text":"inline size_t point_num ()","title":"function point_num"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-length","text":"inline double length ()","title":"function length"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-length_1","text":"inline double length ( size_t i )","title":"function length"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-position","text":"inline Vector2d position ( double t )","title":"function position"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-velocity","text":"inline Vector2d velocity ( double t )","title":"function velocity"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-acceleration","text":"inline Vector2d acceleration ( double t )","title":"function acceleration"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#function-get_segmet_idx","text":"inline segment_info_t get_segmet_idx ( const double t )","title":"function get_segmet_idx"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_spline","text":"std :: vector < segment_t > _spline ;","title":"variable _spline"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_is_empty","text":"bool _is_empty ;","title":"variable _is_empty"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_size","text":"size_t _size ;","title":"variable _size"},{"location":"doxybook/Classes/classcpp__robotics_1_1Spline2D/#variable-_all_length","text":"double _all_length ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable _all_length"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/","text":"cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb #include <state_space_system.hpp> Inherited by cpp_robotics::TransferFunction Public Functions Name StateSpaceSystem () =default template <typename DerivedA ,typename DerivedB ,typename DerivedC > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const Eigen::MatrixBase< DerivedD > & Dd, const double Ts, const bool skip_state_reset =false) size_t state_size () const size_t input_size () const size_t output_size () const bool is_siso_model () const void set_state_zero () void set_state (const Eigen::VectorXd & x) void set_state (const double & x) auto responce (const Eigen::VectorXd & u) double responce (double u) std::optional< Eigen::MatrixXd > A () const std::optional< Eigen::MatrixXd > B () const double Ts () const Eigen::MatrixXd Ad () const Eigen::MatrixXd Bd () const Eigen::MatrixXd C () const Eigen::MatrixXd Cd () const Eigen::MatrixXd D () const Eigen::MatrixXd Dd () const Eigen::VectorXd x () const Eigen::VectorXd y () const Public Functions Documentation function StateSpaceSystem StateSpaceSystem () = default function StateSpaceSystem template < typename DerivedA , typename DerivedB , typename DerivedC > inline StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts ) function StateSpaceSystem template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > inline StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts ) function set_continuous template < typename DerivedA , typename DerivedB , typename DerivedC > inline void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts , const bool skip_state_reset = false ) function set_continuous template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > inline void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts , const bool skip_state_reset = false ) function set_discrite template < typename DerivedA , typename DerivedB , typename DerivedC > inline void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const double Ts , const bool skip_state_reset = false ) function set_discrite template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > inline void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const Eigen :: MatrixBase < DerivedD > & Dd , const double Ts , const bool skip_state_reset = false ) function state_size inline size_t state_size () const function input_size inline size_t input_size () const function output_size inline size_t output_size () const function is_siso_model inline bool is_siso_model () const function set_state_zero inline void set_state_zero () function set_state inline void set_state ( const Eigen :: VectorXd & x ) function set_state inline void set_state ( const double & x ) function responce inline auto responce ( const Eigen :: VectorXd & u ) function responce inline double responce ( double u ) function A inline std :: optional < Eigen :: MatrixXd > A () const function B inline std :: optional < Eigen :: MatrixXd > B () const function Ts inline double Ts () const function Ad inline Eigen :: MatrixXd Ad () const function Bd inline Eigen :: MatrixXd Bd () const function C inline Eigen :: MatrixXd C () const function Cd inline Eigen :: MatrixXd Cd () const function D inline Eigen :: MatrixXd D () const function Dd inline Eigen :: MatrixXd Dd () const function x inline Eigen :: VectorXd x () const function y inline Eigen :: VectorXd y () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::StateSpaceSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#cpp_roboticsstatespacesystem","text":"\u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb #include <state_space_system.hpp> Inherited by cpp_robotics::TransferFunction","title":"cpp_robotics::StateSpaceSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#public-functions","text":"Name StateSpaceSystem () =default template <typename DerivedA ,typename DerivedB ,typename DerivedC > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const Eigen::MatrixBase< DerivedD > & Dd, const double Ts, const bool skip_state_reset =false) size_t state_size () const size_t input_size () const size_t output_size () const bool is_siso_model () const void set_state_zero () void set_state (const Eigen::VectorXd & x) void set_state (const double & x) auto responce (const Eigen::VectorXd & u) double responce (double u) std::optional< Eigen::MatrixXd > A () const std::optional< Eigen::MatrixXd > B () const double Ts () const Eigen::MatrixXd Ad () const Eigen::MatrixXd Bd () const Eigen::MatrixXd C () const Eigen::MatrixXd Cd () const Eigen::MatrixXd D () const Eigen::MatrixXd Dd () const Eigen::VectorXd x () const Eigen::VectorXd y () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-statespacesystem","text":"StateSpaceSystem () = default","title":"function StateSpaceSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-statespacesystem_1","text":"template < typename DerivedA , typename DerivedB , typename DerivedC > inline StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts )","title":"function StateSpaceSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-statespacesystem_2","text":"template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > inline StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts )","title":"function StateSpaceSystem"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_continuous","text":"template < typename DerivedA , typename DerivedB , typename DerivedC > inline void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts , const bool skip_state_reset = false )","title":"function set_continuous"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_continuous_1","text":"template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > inline void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts , const bool skip_state_reset = false )","title":"function set_continuous"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_discrite","text":"template < typename DerivedA , typename DerivedB , typename DerivedC > inline void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const double Ts , const bool skip_state_reset = false )","title":"function set_discrite"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_discrite_1","text":"template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > inline void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const Eigen :: MatrixBase < DerivedD > & Dd , const double Ts , const bool skip_state_reset = false )","title":"function set_discrite"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-state_size","text":"inline size_t state_size () const","title":"function state_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-input_size","text":"inline size_t input_size () const","title":"function input_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-output_size","text":"inline size_t output_size () const","title":"function output_size"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-is_siso_model","text":"inline bool is_siso_model () const","title":"function is_siso_model"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state_zero","text":"inline void set_state_zero ()","title":"function set_state_zero"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state","text":"inline void set_state ( const Eigen :: VectorXd & x )","title":"function set_state"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-set_state_1","text":"inline void set_state ( const double & x )","title":"function set_state"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-responce","text":"inline auto responce ( const Eigen :: VectorXd & u )","title":"function responce"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-responce_1","text":"inline double responce ( double u )","title":"function responce"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-a","text":"inline std :: optional < Eigen :: MatrixXd > A () const","title":"function A"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-b","text":"inline std :: optional < Eigen :: MatrixXd > B () const","title":"function B"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-ts","text":"inline double Ts () const","title":"function Ts"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-ad","text":"inline Eigen :: MatrixXd Ad () const","title":"function Ad"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-bd","text":"inline Eigen :: MatrixXd Bd () const","title":"function Bd"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-c","text":"inline Eigen :: MatrixXd C () const","title":"function C"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-cd","text":"inline Eigen :: MatrixXd Cd () const","title":"function Cd"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-d","text":"inline Eigen :: MatrixXd D () const","title":"function D"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-dd","text":"inline Eigen :: MatrixXd Dd () const","title":"function Dd"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-x","text":"inline Eigen :: VectorXd x () const","title":"function x"},{"location":"doxybook/Classes/classcpp__robotics_1_1StateSpaceSystem/#function-y","text":"inline Eigen :: VectorXd y () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function y"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/","text":"cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <swerve_ik.hpp> Public Types Name using std::array< Vector2d , 4 > VecArray Public Functions Name SwerveIk (const double width, const double length) SwerveIk ( VecArray wheel_place) VecArray calculate ( Transformd velocity) VecArray wheel_place () const Public Types Documentation using VecArray using cpp_robotics :: SwerveIk :: VecArray = std :: array < Vector2d , 4 > ; Public Functions Documentation function SwerveIk inline SwerveIk ( const double width , const double length ) function SwerveIk inline SwerveIk ( VecArray wheel_place ) function calculate inline VecArray calculate ( Transformd velocity ) function wheel_place inline VecArray wheel_place () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::SwerveIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#cpp_roboticsswerveik","text":"\u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb #include <swerve_ik.hpp>","title":"cpp_robotics::SwerveIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-types","text":"Name using std::array< Vector2d , 4 > VecArray","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-functions","text":"Name SwerveIk (const double width, const double length) SwerveIk ( VecArray wheel_place) VecArray calculate ( Transformd velocity) VecArray wheel_place () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#using-vecarray","text":"using cpp_robotics :: SwerveIk :: VecArray = std :: array < Vector2d , 4 > ;","title":"using VecArray"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-swerveik","text":"inline SwerveIk ( const double width , const double length )","title":"function SwerveIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-swerveik_1","text":"inline SwerveIk ( VecArray wheel_place )","title":"function SwerveIk"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-calculate","text":"inline VecArray calculate ( Transformd velocity )","title":"function calculate"},{"location":"doxybook/Classes/classcpp__robotics_1_1SwerveIk/#function-wheel_place","text":"inline VecArray wheel_place () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function wheel_place"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/","text":"cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb #include <transfer_function.hpp> Inherits from cpp_robotics::StateSpaceSystem Public Functions Name TransferFunction make_first_order_system (const double T, const double Ts) TransferFunction make_second_order_system (const double omega, const double zeta, const double Ts) TransferFunction () TransferFunction (std::vector< double > num, std::vector< double > den, const double Ts) size_t num_deg (size_t num_idx =0) const size_t den_deg (size_t num_idx =0) const std::vector< double > num_array () const std::vector< double > den_array () const Additional inherited members Public Functions inherited from cpp_robotics::StateSpaceSystem Name StateSpaceSystem () =default template <typename DerivedA ,typename DerivedB ,typename DerivedC > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const Eigen::MatrixBase< DerivedD > & Dd, const double Ts, const bool skip_state_reset =false) size_t state_size () const size_t input_size () const size_t output_size () const bool is_siso_model () const void set_state_zero () void set_state (const Eigen::VectorXd & x) void set_state (const double & x) auto responce (const Eigen::VectorXd & u) double responce (double u) std::optional< Eigen::MatrixXd > A () const std::optional< Eigen::MatrixXd > B () const double Ts () const Eigen::MatrixXd Ad () const Eigen::MatrixXd Bd () const Eigen::MatrixXd C () const Eigen::MatrixXd Cd () const Eigen::MatrixXd D () const Eigen::MatrixXd Dd () const Eigen::VectorXd x () const Eigen::VectorXd y () const Public Functions Documentation function make_first_order_system static inline TransferFunction make_first_order_system ( const double T , const double Ts ) function make_second_order_system static inline TransferFunction make_second_order_system ( const double omega , const double zeta , const double Ts ) function TransferFunction inline TransferFunction () function TransferFunction inline TransferFunction ( std :: vector < double > num , std :: vector < double > den , const double Ts ) function num_deg inline size_t num_deg ( size_t num_idx = 0 ) const function den_deg inline size_t den_deg ( size_t num_idx = 0 ) const function num_array inline std :: vector < double > num_array () const function den_array inline std :: vector < double > den_array () const Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::TransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#cpp_roboticstransferfunction","text":"\u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb #include <transfer_function.hpp> Inherits from cpp_robotics::StateSpaceSystem","title":"cpp_robotics::TransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#public-functions","text":"Name TransferFunction make_first_order_system (const double T, const double Ts) TransferFunction make_second_order_system (const double omega, const double zeta, const double Ts) TransferFunction () TransferFunction (std::vector< double > num, std::vector< double > den, const double Ts) size_t num_deg (size_t num_idx =0) const size_t den_deg (size_t num_idx =0) const std::vector< double > num_array () const std::vector< double > den_array () const","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#additional-inherited-members","text":"Public Functions inherited from cpp_robotics::StateSpaceSystem Name StateSpaceSystem () =default template <typename DerivedA ,typename DerivedB ,typename DerivedC > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > StateSpaceSystem (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_continuous (const Eigen::MatrixBase< DerivedA > & A, const Eigen::MatrixBase< DerivedB > & B, const Eigen::MatrixBase< DerivedC > & C, const Eigen::MatrixBase< DerivedD > & D, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const double Ts, const bool skip_state_reset =false) template <typename DerivedA ,typename DerivedB ,typename DerivedC ,typename DerivedD > void set_discrite (const Eigen::MatrixBase< DerivedA > & Ad, const Eigen::MatrixBase< DerivedB > & Bd, const Eigen::MatrixBase< DerivedC > & Cd, const Eigen::MatrixBase< DerivedD > & Dd, const double Ts, const bool skip_state_reset =false) size_t state_size () const size_t input_size () const size_t output_size () const bool is_siso_model () const void set_state_zero () void set_state (const Eigen::VectorXd & x) void set_state (const double & x) auto responce (const Eigen::VectorXd & u) double responce (double u) std::optional< Eigen::MatrixXd > A () const std::optional< Eigen::MatrixXd > B () const double Ts () const Eigen::MatrixXd Ad () const Eigen::MatrixXd Bd () const Eigen::MatrixXd C () const Eigen::MatrixXd Cd () const Eigen::MatrixXd D () const Eigen::MatrixXd Dd () const Eigen::VectorXd x () const Eigen::VectorXd y () const","title":"Additional inherited members"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-make_first_order_system","text":"static inline TransferFunction make_first_order_system ( const double T , const double Ts )","title":"function make_first_order_system"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-make_second_order_system","text":"static inline TransferFunction make_second_order_system ( const double omega , const double zeta , const double Ts )","title":"function make_second_order_system"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-transferfunction","text":"inline TransferFunction ()","title":"function TransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-transferfunction_1","text":"inline TransferFunction ( std :: vector < double > num , std :: vector < double > den , const double Ts )","title":"function TransferFunction"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-num_deg","text":"inline size_t num_deg ( size_t num_idx = 0 ) const","title":"function num_deg"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-den_deg","text":"inline size_t den_deg ( size_t num_idx = 0 ) const","title":"function den_deg"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-num_array","text":"inline std :: vector < double > num_array () const","title":"function num_array"},{"location":"doxybook/Classes/classcpp__robotics_1_1TransferFunction/#function-den_array","text":"inline std :: vector < double > den_array () const Updated on 2022-09-30 at 00:12:50 +0900","title":"function den_array"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/","text":"cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf #include <velocity_limit_filter.hpp> Public Functions Name VelocityLimitFilter (double v_max_, double Ts_) VelocityLimitFilter (double v_max_, double Ts_, std::pair< double, double > limit) VelocityLimitFilter (double v_max_, double Ts_, double gpd_, double fb_gain, std::optional< std::pair< double, double >> limit =std::nullopt) virtual void reset () void reset (double u) virtual double filtering (double u) Public Attributes Name double prev_v_ Public Functions Documentation function VelocityLimitFilter inline VelocityLimitFilter ( double v_max_ , double Ts_ ) function VelocityLimitFilter inline VelocityLimitFilter ( double v_max_ , double Ts_ , std :: pair < double , double > limit ) function VelocityLimitFilter inline VelocityLimitFilter ( double v_max_ , double Ts_ , double gpd_ , double fb_gain , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) function reset inline virtual void reset () function reset inline void reset ( double u ) function filtering inline virtual double filtering ( double u ) Public Attributes Documentation variable prev_v_ double prev_v_ ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::VelocityLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#cpp_roboticsvelocitylimitfilter","text":"\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf #include <velocity_limit_filter.hpp>","title":"cpp_robotics::VelocityLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-functions","text":"Name VelocityLimitFilter (double v_max_, double Ts_) VelocityLimitFilter (double v_max_, double Ts_, std::pair< double, double > limit) VelocityLimitFilter (double v_max_, double Ts_, double gpd_, double fb_gain, std::optional< std::pair< double, double >> limit =std::nullopt) virtual void reset () void reset (double u) virtual double filtering (double u)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-attributes","text":"Name double prev_v_","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter","text":"inline VelocityLimitFilter ( double v_max_ , double Ts_ )","title":"function VelocityLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter_1","text":"inline VelocityLimitFilter ( double v_max_ , double Ts_ , std :: pair < double , double > limit )","title":"function VelocityLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-velocitylimitfilter_2","text":"inline VelocityLimitFilter ( double v_max_ , double Ts_ , double gpd_ , double fb_gain , std :: optional < std :: pair < double , double >> limit = std :: nullopt )","title":"function VelocityLimitFilter"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-reset","text":"inline virtual void reset ()","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-reset_1","text":"inline void reset ( double u )","title":"function reset"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#function-filtering","text":"inline virtual double filtering ( double u )","title":"function filtering"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1VelocityLimitFilter/#variable-prev_v_","text":"double prev_v_ ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable prev_v_"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/","text":"cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9 More... #include <unit_core.hpp> Public Types Name using T value_type using UnitDimType unit_dimention_type using P prefix_type using Unit < T, UnitDimType, P > unit_type Public Functions Name Unit () =default constexpr Unit (T val) constexpr T value () const constexpr T raw_value () const constexpr unit_type operator+ () const constexpr unit_type operator- () const constexpr unit_type operator+ (const unit_type & rhl) const constexpr unit_type operator- (const unit_type & rhl) const constexpr auto operator* (const unit_type & rhl) const constexpr unit_type & operator+= (const unit_type & rhl) constexpr unit_type & operator-= (const unit_type & rhl) template <int R_Tag> constexpr operator Unit< value_type, unit_dimention_type, prefix_type, R_Tag > () const template <class R_P > constexpr operator Unit< value_type, unit_dimention_type, R_P, tag > () const constexpr operator value_type () const constexpr bool operator== (const unit_type & r_value) constexpr bool operator!= (const unit_type & r_value) Public Attributes Name constexpr int tag Detailed Description template < class T , class UnitDimType , class P , int Tag = -1 > class cpp_robotics :: unit :: Unit ; \u5358\u4f4d\u30af\u30e9\u30b9 Template Parameters : T \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u578b UnitDimType \u6b21\u5143 P \u63a5\u982d\u8f9e Tag \u540c\u6b21\u5143\u306e\u5358\u4f4d\u7cfb\u3092\u533a\u5225\u3059\u308b\u30bf\u30b0 Public Types Documentation using value_type using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: value_type = T ; using unit_dimention_type using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: unit_dimention_type = UnitDimType ; using prefix_type using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: prefix_type = P ; using unit_type using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: unit_type = Unit < T , UnitDimType , P > ; Public Functions Documentation function Unit Unit () = default function Unit inline constexpr Unit ( T val ) function value inline constexpr T value () const function raw_value inline constexpr T raw_value () const function operator+ inline constexpr unit_type operator + () const function operator- inline constexpr unit_type operator - () const function operator+ inline constexpr unit_type operator + ( const unit_type & rhl ) const function operator- inline constexpr unit_type operator - ( const unit_type & rhl ) const function operator* inline constexpr auto operator * ( const unit_type & rhl ) const function operator+= inline constexpr unit_type & operator += ( const unit_type & rhl ) function operator-= inline constexpr unit_type & operator -= ( const unit_type & rhl ) function operator Unit< value_type, unit_dimention_type, prefix_type, R_Tag > template < int R_Tag > inline constexpr operator Unit < value_type , unit_dimention_type , prefix_type , R_Tag > () const function operator Unit< value_type, unit_dimention_type, R_P, tag > template < class R_P > inline constexpr operator Unit < value_type , unit_dimention_type , R_P , tag > () const function operator value_type inline constexpr operator value_type () const function operator== inline constexpr bool operator == ( const unit_type & r_value ) function operator!= inline constexpr bool operator != ( const unit_type & r_value ) Public Attributes Documentation variable tag static constexpr int tag = Tag ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::Unit"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#cpp_roboticsunitunit","text":"\u5358\u4f4d\u30af\u30e9\u30b9 More... #include <unit_core.hpp>","title":"cpp_robotics::unit::Unit"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-types","text":"Name using T value_type using UnitDimType unit_dimention_type using P prefix_type using Unit < T, UnitDimType, P > unit_type","title":"Public Types"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-functions","text":"Name Unit () =default constexpr Unit (T val) constexpr T value () const constexpr T raw_value () const constexpr unit_type operator+ () const constexpr unit_type operator- () const constexpr unit_type operator+ (const unit_type & rhl) const constexpr unit_type operator- (const unit_type & rhl) const constexpr auto operator* (const unit_type & rhl) const constexpr unit_type & operator+= (const unit_type & rhl) constexpr unit_type & operator-= (const unit_type & rhl) template <int R_Tag> constexpr operator Unit< value_type, unit_dimention_type, prefix_type, R_Tag > () const template <class R_P > constexpr operator Unit< value_type, unit_dimention_type, R_P, tag > () const constexpr operator value_type () const constexpr bool operator== (const unit_type & r_value) constexpr bool operator!= (const unit_type & r_value)","title":"Public Functions"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-attributes","text":"Name constexpr int tag","title":"Public Attributes"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#detailed-description","text":"template < class T , class UnitDimType , class P , int Tag = -1 > class cpp_robotics :: unit :: Unit ; \u5358\u4f4d\u30af\u30e9\u30b9 Template Parameters : T \u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u578b UnitDimType \u6b21\u5143 P \u63a5\u982d\u8f9e Tag \u540c\u6b21\u5143\u306e\u5358\u4f4d\u7cfb\u3092\u533a\u5225\u3059\u308b\u30bf\u30b0","title":"Detailed Description"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-value_type","text":"using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: value_type = T ;","title":"using value_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-unit_dimention_type","text":"using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: unit_dimention_type = UnitDimType ;","title":"using unit_dimention_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-prefix_type","text":"using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: prefix_type = P ;","title":"using prefix_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#using-unit_type","text":"using cpp_robotics :: unit :: Unit < T , UnitDimType , P , Tag >:: unit_type = Unit < T , UnitDimType , P > ;","title":"using unit_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-unit","text":"Unit () = default","title":"function Unit"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-unit_1","text":"inline constexpr Unit ( T val )","title":"function Unit"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-value","text":"inline constexpr T value () const","title":"function value"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-raw_value","text":"inline constexpr T raw_value () const","title":"function raw_value"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator","text":"inline constexpr unit_type operator + () const","title":"function operator+"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-","text":"inline constexpr unit_type operator - () const","title":"function operator-"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_1","text":"inline constexpr unit_type operator + ( const unit_type & rhl ) const","title":"function operator+"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-_1","text":"inline constexpr unit_type operator - ( const unit_type & rhl ) const","title":"function operator-"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_2","text":"inline constexpr auto operator * ( const unit_type & rhl ) const","title":"function operator*"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_3","text":"inline constexpr unit_type & operator += ( const unit_type & rhl )","title":"function operator+="},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-_2","text":"inline constexpr unit_type & operator -= ( const unit_type & rhl )","title":"function operator-="},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-unit-value_type-unit_dimention_type-prefix_type-r_tag","text":"template < int R_Tag > inline constexpr operator Unit < value_type , unit_dimention_type , prefix_type , R_Tag > () const","title":"function operator Unit&lt; value_type, unit_dimention_type, prefix_type, R_Tag &gt;"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-unit-value_type-unit_dimention_type-r_p-tag","text":"template < class R_P > inline constexpr operator Unit < value_type , unit_dimention_type , R_P , tag > () const","title":"function operator Unit&lt; value_type, unit_dimention_type, R_P, tag &gt;"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator-value_type","text":"inline constexpr operator value_type () const","title":"function operator value_type"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_4","text":"inline constexpr bool operator == ( const unit_type & r_value )","title":"function operator=="},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#function-operator_5","text":"inline constexpr bool operator != ( const unit_type & r_value )","title":"function operator!="},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/classcpp__robotics_1_1unit_1_1Unit/#variable-tag","text":"static constexpr int tag = Tag ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable tag"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/","text":"cpp_robotics::ActiveSetMethod::Problem #include <active_set_method.hpp> Public Functions Name Problem () =default Problem (size_t x_size_) void add_inequality_constraint (const Eigen::MatrixXd & An, Eigen::VectorXd bn) void add_equality_constraint (const Eigen::MatrixXd & An, Eigen::VectorXd bn) Public Attributes Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd A Eigen::VectorXd b size_t max_iter size_t max_iter_get_initial_feasible_x size_t x_size size_t constraint_size double alpha Public Functions Documentation function Problem Problem () = default function Problem inline Problem ( size_t x_size_ ) function add_inequality_constraint inline void add_inequality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn ) function add_equality_constraint inline void add_equality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn ) Public Attributes Documentation variable Q Eigen :: MatrixXd Q ; variable c Eigen :: VectorXd c ; variable A Eigen :: MatrixXd A ; variable b Eigen :: VectorXd b ; variable max_iter size_t max_iter = 1000 ; variable max_iter_get_initial_feasible_x size_t max_iter_get_initial_feasible_x = 1000 ; variable x_size size_t x_size = 0 ; variable constraint_size size_t constraint_size = 0 ; variable alpha double alpha = 1.1 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::ActiveSetMethod::Problem"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#cpp_roboticsactivesetmethodproblem","text":"#include <active_set_method.hpp>","title":"cpp_robotics::ActiveSetMethod::Problem"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-functions","text":"Name Problem () =default Problem (size_t x_size_) void add_inequality_constraint (const Eigen::MatrixXd & An, Eigen::VectorXd bn) void add_equality_constraint (const Eigen::MatrixXd & An, Eigen::VectorXd bn)","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-attributes","text":"Name Eigen::MatrixXd Q Eigen::VectorXd c Eigen::MatrixXd A Eigen::VectorXd b size_t max_iter size_t max_iter_get_initial_feasible_x size_t x_size size_t constraint_size double alpha","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-problem","text":"Problem () = default","title":"function Problem"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-problem_1","text":"inline Problem ( size_t x_size_ )","title":"function Problem"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-add_inequality_constraint","text":"inline void add_inequality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn )","title":"function add_inequality_constraint"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#function-add_equality_constraint","text":"inline void add_equality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn )","title":"function add_equality_constraint"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-q","text":"Eigen :: MatrixXd Q ;","title":"variable Q"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-c","text":"Eigen :: VectorXd c ;","title":"variable c"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-a","text":"Eigen :: MatrixXd A ;","title":"variable A"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-b","text":"Eigen :: VectorXd b ;","title":"variable b"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-max_iter","text":"size_t max_iter = 1000 ;","title":"variable max_iter"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-max_iter_get_initial_feasible_x","text":"size_t max_iter_get_initial_feasible_x = 1000 ;","title":"variable max_iter_get_initial_feasible_x"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-x_size","text":"size_t x_size = 0 ;","title":"variable x_size"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-constraint_size","text":"size_t constraint_size = 0 ;","title":"variable constraint_size"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Problem/#variable-alpha","text":"double alpha = 1.1 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable alpha"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/","text":"cpp_robotics::ActiveSetMethod::Result #include <active_set_method.hpp> Public Attributes Name bool is_solved Eigen::VectorXd x_opt Eigen::VectorXd lambda_opt size_t iter_cnt Public Attributes Documentation variable is_solved bool is_solved = false ; variable x_opt Eigen :: VectorXd x_opt ; variable lambda_opt Eigen :: VectorXd lambda_opt ; variable iter_cnt size_t iter_cnt = 0 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::ActiveSetMethod::Result"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#cpp_roboticsactivesetmethodresult","text":"#include <active_set_method.hpp>","title":"cpp_robotics::ActiveSetMethod::Result"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#public-attributes","text":"Name bool is_solved Eigen::VectorXd x_opt Eigen::VectorXd lambda_opt size_t iter_cnt","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-is_solved","text":"bool is_solved = false ;","title":"variable is_solved"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-x_opt","text":"Eigen :: VectorXd x_opt ;","title":"variable x_opt"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-lambda_opt","text":"Eigen :: VectorXd lambda_opt ;","title":"variable lambda_opt"},{"location":"doxybook/Classes/structcpp__robotics_1_1ActiveSetMethod_1_1Result/#variable-iter_cnt","text":"size_t iter_cnt = 0 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/","text":"cpp_robotics::Circle \u5186\u30af\u30e9\u30b9 #include <shape.hpp> Public Functions Name Circle () =default constexpr Circle (const Vector2d & center, const float r) constexpr bool has_area () const constexpr float area () const constexpr Vector2d angle_pos (const float theta) const Public Attributes Name Vector2d center float r Public Functions Documentation function Circle Circle () = default function Circle inline constexpr Circle ( const Vector2d & center , const float r ) function has_area inline constexpr bool has_area () const function area inline constexpr float area () const function angle_pos inline constexpr Vector2d angle_pos ( const float theta ) const Public Attributes Documentation variable center Vector2d center ; variable r float r ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Circle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#cpp_roboticscircle","text":"\u5186\u30af\u30e9\u30b9 #include <shape.hpp>","title":"cpp_robotics::Circle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-functions","text":"Name Circle () =default constexpr Circle (const Vector2d & center, const float r) constexpr bool has_area () const constexpr float area () const constexpr Vector2d angle_pos (const float theta) const","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-attributes","text":"Name Vector2d center float r","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-circle","text":"Circle () = default","title":"function Circle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-circle_1","text":"inline constexpr Circle ( const Vector2d & center , const float r )","title":"function Circle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-has_area","text":"inline constexpr bool has_area () const","title":"function has_area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-area","text":"inline constexpr float area () const","title":"function area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#function-angle_pos","text":"inline constexpr Vector2d angle_pos ( const float theta ) const","title":"function angle_pos"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#variable-center","text":"Vector2d center ;","title":"variable center"},{"location":"doxybook/Classes/structcpp__robotics_1_1Circle/#variable-r","text":"float r ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable r"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/","text":"cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 #include <constraint.hpp> Public Types Name enum uint8_t Type using std::function< double(Eigen::VectorXd)> func_type using std::function< Eigen::VectorXd(Eigen::VectorXd)> grad_func_type using std::function< Eigen::MatrixXd(Eigen::VectorXd)> hessian_func_type Public Functions Name Constraint ( Type type_, func_type con_) double eval (const Eigen::VectorXd & x) const bool satisfy (const Eigen::VectorXd & x, const double tol) const Eigen::VectorXd grad (Eigen::VectorXd x) Eigen::MatrixXd hessian (Eigen::VectorXd x) Public Attributes Name Type type func_type con_f std::optional< grad_func_type > con_grad_f std::optional< hessian_func_type > con_hessian_f Public Types Documentation enum Type Enumerator Value Description Eq Ineq using func_type using cpp_robotics :: Constraint :: func_type = std :: function < double ( Eigen :: VectorXd ) > ; using grad_func_type using cpp_robotics :: Constraint :: grad_func_type = std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > ; using hessian_func_type using cpp_robotics :: Constraint :: hessian_func_type = std :: function < Eigen :: MatrixXd ( Eigen :: VectorXd ) > ; Public Functions Documentation function Constraint inline Constraint ( Type type_ , func_type con_ ) function eval inline double eval ( const Eigen :: VectorXd & x ) const function satisfy inline bool satisfy ( const Eigen :: VectorXd & x , const double tol ) const function grad inline Eigen :: VectorXd grad ( Eigen :: VectorXd x ) function hessian inline Eigen :: MatrixXd hessian ( Eigen :: VectorXd x ) Public Attributes Documentation variable type Type type ; variable con_f func_type con_f ; variable con_grad_f std :: optional < grad_func_type > con_grad_f ; variable con_hessian_f std :: optional < hessian_func_type > con_hessian_f ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Constraint"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#cpp_roboticsconstraint","text":"\u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 #include <constraint.hpp>","title":"cpp_robotics::Constraint"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-types","text":"Name enum uint8_t Type using std::function< double(Eigen::VectorXd)> func_type using std::function< Eigen::VectorXd(Eigen::VectorXd)> grad_func_type using std::function< Eigen::MatrixXd(Eigen::VectorXd)> hessian_func_type","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-functions","text":"Name Constraint ( Type type_, func_type con_) double eval (const Eigen::VectorXd & x) const bool satisfy (const Eigen::VectorXd & x, const double tol) const Eigen::VectorXd grad (Eigen::VectorXd x) Eigen::MatrixXd hessian (Eigen::VectorXd x)","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-attributes","text":"Name Type type func_type con_f std::optional< grad_func_type > con_grad_f std::optional< hessian_func_type > con_hessian_f","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#enum-type","text":"Enumerator Value Description Eq Ineq","title":"enum Type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-func_type","text":"using cpp_robotics :: Constraint :: func_type = std :: function < double ( Eigen :: VectorXd ) > ;","title":"using func_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-grad_func_type","text":"using cpp_robotics :: Constraint :: grad_func_type = std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > ;","title":"using grad_func_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#using-hessian_func_type","text":"using cpp_robotics :: Constraint :: hessian_func_type = std :: function < Eigen :: MatrixXd ( Eigen :: VectorXd ) > ;","title":"using hessian_func_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-constraint","text":"inline Constraint ( Type type_ , func_type con_ )","title":"function Constraint"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-eval","text":"inline double eval ( const Eigen :: VectorXd & x ) const","title":"function eval"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-satisfy","text":"inline bool satisfy ( const Eigen :: VectorXd & x , const double tol ) const","title":"function satisfy"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-grad","text":"inline Eigen :: VectorXd grad ( Eigen :: VectorXd x )","title":"function grad"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#function-hessian","text":"inline Eigen :: MatrixXd hessian ( Eigen :: VectorXd x )","title":"function hessian"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-type","text":"Type type ;","title":"variable type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_f","text":"func_type con_f ;","title":"variable con_f"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_grad_f","text":"std :: optional < grad_func_type > con_grad_f ;","title":"variable con_grad_f"},{"location":"doxybook/Classes/structcpp__robotics_1_1Constraint/#variable-con_hessian_f","text":"std :: optional < hessian_func_type > con_hessian_f ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable con_hessian_f"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/","text":"cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb #include <dc_motor_param.hpp> Public Functions Name constexpr DCGearedMotorParam ( Volt voltage_, DCMotorParam motor_, GearHeadParam gear_head_, const double optional_gear_ratio_ =1) constexpr Rpm calcu_gear_head_steady_free_velocity ( Volt v) const constexpr Rpm calcu_endpoint_steady_free_velocity ( Volt v) const constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration ( Inertia optional_inertina =0) const Public Attributes Name const Volt voltage const DCMotorParam motor const GearHeadParam gear_head const double optional_gear_ratio Public Functions Documentation function DCGearedMotorParam inline constexpr DCGearedMotorParam ( Volt voltage_ , DCMotorParam motor_ , GearHeadParam gear_head_ , const double optional_gear_ratio_ = 1 ) function calcu_gear_head_steady_free_velocity inline constexpr Rpm calcu_gear_head_steady_free_velocity ( Volt v ) const function calcu_endpoint_steady_free_velocity inline constexpr Rpm calcu_endpoint_steady_free_velocity ( Volt v ) const function calcu_endpoint_max_angular_accleleration inline constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration ( Inertia optional_inertina = 0 ) const \u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u304c\u767a\u751f\u3055\u305b\u3089\u308c\u308b\u6700\u5927\u306e\u89d2\u52a0\u901f\u5ea6\u3092\u8a08\u7b97\u3059\u308b optional_inertina: \u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u306e\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8 Public Attributes Documentation variable voltage const Volt voltage ; variable motor const DCMotorParam motor ; variable gear_head const GearHeadParam gear_head ; variable optional_gear_ratio const double optional_gear_ratio ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DCGearedMotorParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#cpp_roboticsdcgearedmotorparam","text":"\u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb #include <dc_motor_param.hpp>","title":"cpp_robotics::DCGearedMotorParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-functions","text":"Name constexpr DCGearedMotorParam ( Volt voltage_, DCMotorParam motor_, GearHeadParam gear_head_, const double optional_gear_ratio_ =1) constexpr Rpm calcu_gear_head_steady_free_velocity ( Volt v) const constexpr Rpm calcu_endpoint_steady_free_velocity ( Volt v) const constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration ( Inertia optional_inertina =0) const","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-attributes","text":"Name const Volt voltage const DCMotorParam motor const GearHeadParam gear_head const double optional_gear_ratio","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-dcgearedmotorparam","text":"inline constexpr DCGearedMotorParam ( Volt voltage_ , DCMotorParam motor_ , GearHeadParam gear_head_ , const double optional_gear_ratio_ = 1 )","title":"function DCGearedMotorParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_gear_head_steady_free_velocity","text":"inline constexpr Rpm calcu_gear_head_steady_free_velocity ( Volt v ) const","title":"function calcu_gear_head_steady_free_velocity"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_endpoint_steady_free_velocity","text":"inline constexpr Rpm calcu_endpoint_steady_free_velocity ( Volt v ) const","title":"function calcu_endpoint_steady_free_velocity"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#function-calcu_endpoint_max_angular_accleleration","text":"inline constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration ( Inertia optional_inertina = 0 ) const \u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u304c\u767a\u751f\u3055\u305b\u3089\u308c\u308b\u6700\u5927\u306e\u89d2\u52a0\u901f\u5ea6\u3092\u8a08\u7b97\u3059\u308b optional_inertina: \u30ae\u30a2\u30d8\u30c3\u30c9(+\u8ffd\u52a0\u306e\u30ae\u30a2)\u306e\u8ef8\u5148\u306e\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8","title":"function calcu_endpoint_max_angular_accleleration"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-voltage","text":"const Volt voltage ;","title":"variable voltage"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-motor","text":"const DCMotorParam motor ;","title":"variable motor"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-gear_head","text":"const GearHeadParam gear_head ;","title":"variable gear_head"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCGearedMotorParam/#variable-optional_gear_ratio","text":"const double optional_gear_ratio ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable optional_gear_ratio"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/","text":"cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb #include <dc_motor_param.hpp> Public Functions Name constexpr DCMotorParam ( Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm Rm, Henry Lm, TorqueConstant Kt, BackEmfConstant Ke, Inertia Im, Second curr_set_time =0.1f) constexpr DCMotorParam (const DCMotorParam & ) =default constexpr void set_current_setting_time ( Second Tc) constexpr Rpm calcu_steady_free_velocity ( Volt v) const constexpr Ampere calcu_stall_current ( Volt v) const constexpr Torque calcu_stall_torque ( Volt v) const constexpr AngularAcceleration calcu_max_free_angular_acceleration ( Volt v) const constexpr Second get_Tm () const constexpr AngularVelocity get_Wi () const constexpr double get_Kip ( Volt volt) const constexpr double get_Kii ( Volt volt) const Public Attributes Name const Volt nominal_voltage const Rpm free_speed const Ampere free_current const Ohm resistance const Henry inductance const TorqueConstant torque_constant const BackEmfConstant back_emf_constance const FrictionConstant friction_constant const Inertia rotor_inertia const Second time_constant Public Functions Documentation function DCMotorParam inline constexpr DCMotorParam ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Ohm Rm , Henry Lm , TorqueConstant Kt , BackEmfConstant Ke , Inertia Im , Second curr_set_time = 0.1f ) function DCMotorParam constexpr DCMotorParam ( const DCMotorParam & ) = default function set_current_setting_time inline constexpr void set_current_setting_time ( Second Tc ) function calcu_steady_free_velocity inline constexpr Rpm calcu_steady_free_velocity ( Volt v ) const function calcu_stall_current inline constexpr Ampere calcu_stall_current ( Volt v ) const function calcu_stall_torque inline constexpr Torque calcu_stall_torque ( Volt v ) const function calcu_max_free_angular_acceleration inline constexpr AngularAcceleration calcu_max_free_angular_acceleration ( Volt v ) const function get_Tm inline constexpr Second get_Tm () const function get_Wi inline constexpr AngularVelocity get_Wi () const function get_Kip inline constexpr double get_Kip ( Volt volt ) const function get_Kii inline constexpr double get_Kii ( Volt volt ) const Public Attributes Documentation variable nominal_voltage const Volt nominal_voltage ; variable free_speed const Rpm free_speed ; variable free_current const Ampere free_current ; variable resistance const Ohm resistance ; variable inductance const Henry inductance ; variable torque_constant const TorqueConstant torque_constant ; variable back_emf_constance const BackEmfConstant back_emf_constance ; variable friction_constant const FrictionConstant friction_constant ; variable rotor_inertia const Inertia rotor_inertia ; variable time_constant const Second time_constant ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DCMotorParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#cpp_roboticsdcmotorparam","text":"DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb #include <dc_motor_param.hpp>","title":"cpp_robotics::DCMotorParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-functions","text":"Name constexpr DCMotorParam ( Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm Rm, Henry Lm, TorqueConstant Kt, BackEmfConstant Ke, Inertia Im, Second curr_set_time =0.1f) constexpr DCMotorParam (const DCMotorParam & ) =default constexpr void set_current_setting_time ( Second Tc) constexpr Rpm calcu_steady_free_velocity ( Volt v) const constexpr Ampere calcu_stall_current ( Volt v) const constexpr Torque calcu_stall_torque ( Volt v) const constexpr AngularAcceleration calcu_max_free_angular_acceleration ( Volt v) const constexpr Second get_Tm () const constexpr AngularVelocity get_Wi () const constexpr double get_Kip ( Volt volt) const constexpr double get_Kii ( Volt volt) const","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-attributes","text":"Name const Volt nominal_voltage const Rpm free_speed const Ampere free_current const Ohm resistance const Henry inductance const TorqueConstant torque_constant const BackEmfConstant back_emf_constance const FrictionConstant friction_constant const Inertia rotor_inertia const Second time_constant","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-dcmotorparam","text":"inline constexpr DCMotorParam ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Ohm Rm , Henry Lm , TorqueConstant Kt , BackEmfConstant Ke , Inertia Im , Second curr_set_time = 0.1f )","title":"function DCMotorParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-dcmotorparam_1","text":"constexpr DCMotorParam ( const DCMotorParam & ) = default","title":"function DCMotorParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-set_current_setting_time","text":"inline constexpr void set_current_setting_time ( Second Tc )","title":"function set_current_setting_time"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_steady_free_velocity","text":"inline constexpr Rpm calcu_steady_free_velocity ( Volt v ) const","title":"function calcu_steady_free_velocity"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_stall_current","text":"inline constexpr Ampere calcu_stall_current ( Volt v ) const","title":"function calcu_stall_current"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_stall_torque","text":"inline constexpr Torque calcu_stall_torque ( Volt v ) const","title":"function calcu_stall_torque"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-calcu_max_free_angular_acceleration","text":"inline constexpr AngularAcceleration calcu_max_free_angular_acceleration ( Volt v ) const","title":"function calcu_max_free_angular_acceleration"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_tm","text":"inline constexpr Second get_Tm () const","title":"function get_Tm"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_wi","text":"inline constexpr AngularVelocity get_Wi () const","title":"function get_Wi"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_kip","text":"inline constexpr double get_Kip ( Volt volt ) const","title":"function get_Kip"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#function-get_kii","text":"inline constexpr double get_Kii ( Volt volt ) const","title":"function get_Kii"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-nominal_voltage","text":"const Volt nominal_voltage ;","title":"variable nominal_voltage"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-free_speed","text":"const Rpm free_speed ;","title":"variable free_speed"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-free_current","text":"const Ampere free_current ;","title":"variable free_current"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-resistance","text":"const Ohm resistance ;","title":"variable resistance"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-inductance","text":"const Henry inductance ;","title":"variable inductance"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-torque_constant","text":"const TorqueConstant torque_constant ;","title":"variable torque_constant"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-back_emf_constance","text":"const BackEmfConstant back_emf_constance ;","title":"variable back_emf_constance"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-friction_constant","text":"const FrictionConstant friction_constant ;","title":"variable friction_constant"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-rotor_inertia","text":"const Inertia rotor_inertia ;","title":"variable rotor_inertia"},{"location":"doxybook/Classes/structcpp__robotics_1_1DCMotorParam/#variable-time_constant","text":"const Second time_constant ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable time_constant"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/","text":"cpp_robotics::DubinsPath::PlanningResult Public Attributes Name double t double p double q Mode mode Public Attributes Documentation variable t double t = 0 ; variable p double p = 0 ; variable q double q = 0 ; variable mode Mode mode = Mode :: NONE ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::DubinsPath::PlanningResult"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#cpp_roboticsdubinspathplanningresult","text":"","title":"cpp_robotics::DubinsPath::PlanningResult"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#public-attributes","text":"Name double t double p double q Mode mode","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-t","text":"double t = 0 ;","title":"variable t"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-p","text":"double p = 0 ;","title":"variable p"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-q","text":"double q = 0 ;","title":"variable q"},{"location":"doxybook/Classes/structcpp__robotics_1_1DubinsPath_1_1PlanningResult/#variable-mode","text":"Mode mode = Mode :: NONE ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable mode"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/","text":"cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb #include <dc_motor_param.hpp> Public Functions Name constexpr GearHeadParam (double ratio_, double efficiency_) Public Attributes Name const double ratio const double efficiency Public Functions Documentation function GearHeadParam inline constexpr GearHeadParam ( double ratio_ , double efficiency_ ) Public Attributes Documentation variable ratio const double ratio ; variable efficiency const double efficiency ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::GearHeadParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#cpp_roboticsgearheadparam","text":"\u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb #include <dc_motor_param.hpp>","title":"cpp_robotics::GearHeadParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-functions","text":"Name constexpr GearHeadParam (double ratio_, double efficiency_)","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-attributes","text":"Name const double ratio const double efficiency","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#function-gearheadparam","text":"inline constexpr GearHeadParam ( double ratio_ , double efficiency_ )","title":"function GearHeadParam"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#variable-ratio","text":"const double ratio ;","title":"variable ratio"},{"location":"doxybook/Classes/structcpp__robotics_1_1GearHeadParam/#variable-efficiency","text":"const double efficiency ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable efficiency"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/","text":"cpp_robotics::KDTree::Node Public Attributes Name int idx int axis std::unique_ptr< Node > child Public Attributes Documentation variable idx int idx = -1 ; variable axis int axis = -1 ; variable child std :: unique_ptr < Node > child = { nullptr , nullptr }; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::KDTree::Node"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#cpp_roboticskdtreenode","text":"","title":"cpp_robotics::KDTree::Node"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#public-attributes","text":"Name int idx int axis std::unique_ptr< Node > child","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-idx","text":"int idx = -1 ;","title":"variable idx"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-axis","text":"int axis = -1 ;","title":"variable axis"},{"location":"doxybook/Classes/structcpp__robotics_1_1KDTree_1_1Node/#variable-child","text":"std :: unique_ptr < Node > child = { nullptr , nullptr }; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable child"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/","text":"cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 #include <shape.hpp> Public Functions Name Line () =default constexpr Line (const Vector2d & p0, const Vector2d & p1) void set (const Vector2d & p0_, const Vector2d & p1_) constexpr float length () const constexpr float angle () const constexpr Vector2d lerp (const float t) const Public Attributes Name Vector2d p0 Vector2d p1 Public Functions Documentation function Line Line () = default function Line inline constexpr Line ( const Vector2d & p0 , const Vector2d & p1 ) function set inline void set ( const Vector2d & p0_ , const Vector2d & p1_ ) function length inline constexpr float length () const function angle inline constexpr float angle () const function lerp inline constexpr Vector2d lerp ( const float t ) const Public Attributes Documentation variable p0 Vector2d p0 ; variable p1 Vector2d p1 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Line"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#cpp_roboticsline","text":"\u76f4\u7dda\u30af\u30e9\u30b9 #include <shape.hpp>","title":"cpp_robotics::Line"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-functions","text":"Name Line () =default constexpr Line (const Vector2d & p0, const Vector2d & p1) void set (const Vector2d & p0_, const Vector2d & p1_) constexpr float length () const constexpr float angle () const constexpr Vector2d lerp (const float t) const","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-attributes","text":"Name Vector2d p0 Vector2d p1","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-line","text":"Line () = default","title":"function Line"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-line_1","text":"inline constexpr Line ( const Vector2d & p0 , const Vector2d & p1 )","title":"function Line"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-set","text":"inline void set ( const Vector2d & p0_ , const Vector2d & p1_ )","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-length","text":"inline constexpr float length () const","title":"function length"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-angle","text":"inline constexpr float angle () const","title":"function angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#function-lerp","text":"inline constexpr Vector2d lerp ( const float t ) const","title":"function lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#variable-p0","text":"Vector2d p0 ;","title":"variable p0"},{"location":"doxybook/Classes/structcpp__robotics_1_1Line/#variable-p1","text":"Vector2d p1 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable p1"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/","text":"cpp_robotics::MecanumIk::Config #include <mecanum_ik.hpp> Public Attributes Name double width double length Public Attributes Documentation variable width double width ; variable length double length ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::MecanumIk::Config"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#cpp_roboticsmecanumikconfig","text":"#include <mecanum_ik.hpp>","title":"cpp_robotics::MecanumIk::Config"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#public-attributes","text":"Name double width double length","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#variable-width","text":"double width ;","title":"variable width"},{"location":"doxybook/Classes/structcpp__robotics_1_1MecanumIk_1_1Config/#variable-length","text":"double length ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable length"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/","text":"cpp_robotics::Omni3Ik::Config #include <omni_ik.hpp> Public Attributes Name double radius double first_wheel_angle Public Attributes Documentation variable radius double radius ; variable first_wheel_angle double first_wheel_angle = M_PI / 6 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Omni3Ik::Config"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#cpp_roboticsomni3ikconfig","text":"#include <omni_ik.hpp>","title":"cpp_robotics::Omni3Ik::Config"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#public-attributes","text":"Name double radius double first_wheel_angle","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#variable-radius","text":"double radius ;","title":"variable radius"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni3Ik_1_1Config/#variable-first_wheel_angle","text":"double first_wheel_angle = M_PI / 6 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable first_wheel_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/","text":"cpp_robotics::Omni4Ik::Config #include <omni_ik.hpp> Public Attributes Name double radius double first_wheel_angle Public Attributes Documentation variable radius double radius ; variable first_wheel_angle double first_wheel_angle = M_PI / 4 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Omni4Ik::Config"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#cpp_roboticsomni4ikconfig","text":"#include <omni_ik.hpp>","title":"cpp_robotics::Omni4Ik::Config"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#public-attributes","text":"Name double radius double first_wheel_angle","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#variable-radius","text":"double radius ;","title":"variable radius"},{"location":"doxybook/Classes/structcpp__robotics_1_1Omni4Ik_1_1Config/#variable-first_wheel_angle","text":"double first_wheel_angle = M_PI / 4 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable first_wheel_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/","text":"cpp_robotics::PID2Controller::pid_param_t #include <pid2.hpp> Public Attributes Name double Ts double gpd double Kp double Ki double Kd double b double c Public Attributes Documentation variable Ts double Ts ; variable gpd double gpd ; variable Kp double Kp ; variable Ki double Ki ; variable Kd double Kd ; variable b double b ; variable c double c ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::PID2Controller::pid_param_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#cpp_roboticspid2controllerpid_param_t","text":"#include <pid2.hpp>","title":"cpp_robotics::PID2Controller::pid_param_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#public-attributes","text":"Name double Ts double gpd double Kp double Ki double Kd double b double c","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#variable-ts","text":"double Ts ;","title":"variable Ts"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#variable-gpd","text":"double gpd ;","title":"variable gpd"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#variable-kp","text":"double Kp ;","title":"variable Kp"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#variable-ki","text":"double Ki ;","title":"variable Ki"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#variable-kd","text":"double Kd ;","title":"variable Kd"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#variable-b","text":"double b ;","title":"variable b"},{"location":"doxybook/Classes/structcpp__robotics_1_1PID2Controller_1_1pid__param__t/#variable-c","text":"double c ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable c"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/","text":"cpp_robotics::PIDController::pid_param_t #include <pid.hpp> Public Attributes Name double Ts double gpd double Kp double Ki double Kd std::optional< std::pair< double, double > > output_limit Public Attributes Documentation variable Ts double Ts ; variable gpd double gpd ; variable Kp double Kp ; variable Ki double Ki ; variable Kd double Kd ; variable output_limit std :: optional < std :: pair < double , double > > output_limit ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::PIDController::pid_param_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#cpp_roboticspidcontrollerpid_param_t","text":"#include <pid.hpp>","title":"cpp_robotics::PIDController::pid_param_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#public-attributes","text":"Name double Ts double gpd double Kp double Ki double Kd std::optional< std::pair< double, double > > output_limit","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#variable-ts","text":"double Ts ;","title":"variable Ts"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#variable-gpd","text":"double gpd ;","title":"variable gpd"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#variable-kp","text":"double Kp ;","title":"variable Kp"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#variable-ki","text":"double Ki ;","title":"variable Ki"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#variable-kd","text":"double Kd ;","title":"variable Kd"},{"location":"doxybook/Classes/structcpp__robotics_1_1PIDController_1_1pid__param__t/#variable-output_limit","text":"std :: optional < std :: pair < double , double > > output_limit ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable output_limit"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/","text":"cpp_robotics::Polynomial \u591a\u9805\u5f0f #include <polynomial.hpp> Public Functions Name Polynomial (std::initializer_list< double > coeff) Polynomial (const std::vector< double > & coeff) template <class IteratorType > Polynomial (IteratorType begin, IteratorType end) void set_degree (size_t deg) size_t size () const size_t degree () const std::vector< double > coeff () const double & at (size_t i) double at (size_t i) const double & at_degree (size_t i) double at_degree (size_t i) const double & operator[] (size_t i) double operator[] (size_t i) const void check_degree () double evalute (double x) const Polynomial polyder (size_t i) const Polynomial polyint (double C =0) const void swap ( Polynomial & poly) double operator() (double x) const Polynomial operator+ () const Polynomial operator- () const Polynomial operator+ (double s) const Polynomial operator- (double s) const Polynomial operator* (double s) const Polynomial operator/ (double s) const Polynomial operator* (const Polynomial & p) const Polynomial expand (std::vector< double > roots) Friends Name Polynomial operator* (double s, const Polynomial & poly) bool operator== (const Polynomial & lhs, const Polynomial & rhs) bool operator!= (const Polynomial & lhs, const Polynomial & rhs) Public Functions Documentation function Polynomial inline Polynomial ( std :: initializer_list < double > coeff ) function Polynomial inline Polynomial ( const std :: vector < double > & coeff ) function Polynomial template < class IteratorType > inline Polynomial ( IteratorType begin , IteratorType end ) function set_degree inline void set_degree ( size_t deg ) function size inline size_t size () const function degree inline size_t degree () const function coeff inline std :: vector < double > coeff () const function at inline double & at ( size_t i ) function at inline double at ( size_t i ) const function at_degree inline double & at_degree ( size_t i ) function at_degree inline double at_degree ( size_t i ) const function operator[] inline double & operator []( size_t i ) function operator[] inline double operator []( size_t i ) const function check_degree inline void check_degree () function evalute inline double evalute ( double x ) const function polyder inline Polynomial polyder ( size_t i ) const function polyint inline Polynomial polyint ( double C = 0 ) const function swap inline void swap ( Polynomial & poly ) function operator() inline double operator ()( double x ) const function operator+ inline Polynomial operator + () const function operator- inline Polynomial operator - () const function operator+ inline Polynomial operator + ( double s ) const function operator- inline Polynomial operator - ( double s ) const function operator* inline Polynomial operator * ( double s ) const function operator/ inline Polynomial operator / ( double s ) const function operator* inline Polynomial operator * ( const Polynomial & p ) const function expand static inline Polynomial expand ( std :: vector < double > roots ) Friends friend operator* friend Polynomial operator * ( double s , const Polynomial & poly ); friend operator== friend bool operator == ( const Polynomial & lhs , const Polynomial & rhs ); friend operator!= friend bool operator != ( const Polynomial & lhs , const Polynomial & rhs ); Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Polynomial"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#cpp_roboticspolynomial","text":"\u591a\u9805\u5f0f #include <polynomial.hpp>","title":"cpp_robotics::Polynomial"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#public-functions","text":"Name Polynomial (std::initializer_list< double > coeff) Polynomial (const std::vector< double > & coeff) template <class IteratorType > Polynomial (IteratorType begin, IteratorType end) void set_degree (size_t deg) size_t size () const size_t degree () const std::vector< double > coeff () const double & at (size_t i) double at (size_t i) const double & at_degree (size_t i) double at_degree (size_t i) const double & operator[] (size_t i) double operator[] (size_t i) const void check_degree () double evalute (double x) const Polynomial polyder (size_t i) const Polynomial polyint (double C =0) const void swap ( Polynomial & poly) double operator() (double x) const Polynomial operator+ () const Polynomial operator- () const Polynomial operator+ (double s) const Polynomial operator- (double s) const Polynomial operator* (double s) const Polynomial operator/ (double s) const Polynomial operator* (const Polynomial & p) const Polynomial expand (std::vector< double > roots)","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friends","text":"Name Polynomial operator* (double s, const Polynomial & poly) bool operator== (const Polynomial & lhs, const Polynomial & rhs) bool operator!= (const Polynomial & lhs, const Polynomial & rhs)","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial","text":"inline Polynomial ( std :: initializer_list < double > coeff )","title":"function Polynomial"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_1","text":"inline Polynomial ( const std :: vector < double > & coeff )","title":"function Polynomial"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polynomial_2","text":"template < class IteratorType > inline Polynomial ( IteratorType begin , IteratorType end )","title":"function Polynomial"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-set_degree","text":"inline void set_degree ( size_t deg )","title":"function set_degree"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-size","text":"inline size_t size () const","title":"function size"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-degree","text":"inline size_t degree () const","title":"function degree"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-coeff","text":"inline std :: vector < double > coeff () const","title":"function coeff"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at","text":"inline double & at ( size_t i )","title":"function at"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_1","text":"inline double at ( size_t i ) const","title":"function at"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_degree","text":"inline double & at_degree ( size_t i )","title":"function at_degree"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-at_degree_1","text":"inline double at_degree ( size_t i ) const","title":"function at_degree"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator","text":"inline double & operator []( size_t i )","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_1","text":"inline double operator []( size_t i ) const","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-check_degree","text":"inline void check_degree ()","title":"function check_degree"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-evalute","text":"inline double evalute ( double x ) const","title":"function evalute"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polyder","text":"inline Polynomial polyder ( size_t i ) const","title":"function polyder"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-polyint","text":"inline Polynomial polyint ( double C = 0 ) const","title":"function polyint"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-swap","text":"inline void swap ( Polynomial & poly )","title":"function swap"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_2","text":"inline double operator ()( double x ) const","title":"function operator()"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_3","text":"inline Polynomial operator + () const","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-","text":"inline Polynomial operator - () const","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_4","text":"inline Polynomial operator + ( double s ) const","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator-_1","text":"inline Polynomial operator - ( double s ) const","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_5","text":"inline Polynomial operator * ( double s ) const","title":"function operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_6","text":"inline Polynomial operator / ( double s ) const","title":"function operator/"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-operator_7","text":"inline Polynomial operator * ( const Polynomial & p ) const","title":"function operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#function-expand","text":"static inline Polynomial expand ( std :: vector < double > roots )","title":"function expand"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friends_1","text":"","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator","text":"friend Polynomial operator * ( double s , const Polynomial & poly );","title":"friend operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator_1","text":"friend bool operator == ( const Polynomial & lhs , const Polynomial & rhs );","title":"friend operator=="},{"location":"doxybook/Classes/structcpp__robotics_1_1Polynomial/#friend-operator_2","text":"friend bool operator != ( const Polynomial & lhs , const Polynomial & rhs ); Updated on 2022-09-30 at 00:12:50 +0900","title":"friend operator!="},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/","text":"cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 #include <shape.hpp> Public Functions Name Quad () =default constexpr Quad (const std::array< Vector2d , 4 > & points) constexpr Quad (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2, const Vector2d & p3) void set (const Vector2d & p0_, const Vector2d & p1_, const Vector2d & p2_, const Vector2d & p3_) constexpr bool has_area () const constexpr float area () const constexpr std::array< Vector2d , 4 > vertex () const constexpr std::array< Line , 4 > outline () const Public Attributes Name Vector2d p0 Vector2d p1 Vector2d p2 Vector2d p3 Public Functions Documentation function Quad Quad () = default function Quad inline constexpr Quad ( const std :: array < Vector2d , 4 > & points ) function Quad inline constexpr Quad ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) function set inline void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ , const Vector2d & p3_ ) function has_area inline constexpr bool has_area () const function area inline constexpr float area () const function vertex inline constexpr std :: array < Vector2d , 4 > vertex () const function outline inline constexpr std :: array < Line , 4 > outline () const Public Attributes Documentation variable p0 Vector2d p0 ; variable p1 Vector2d p1 ; variable p2 Vector2d p2 ; variable p3 Vector2d p3 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Quad"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#cpp_roboticsquad","text":"\u56db\u89d2\u5f62\u30af\u30e9\u30b9 #include <shape.hpp>","title":"cpp_robotics::Quad"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-functions","text":"Name Quad () =default constexpr Quad (const std::array< Vector2d , 4 > & points) constexpr Quad (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2, const Vector2d & p3) void set (const Vector2d & p0_, const Vector2d & p1_, const Vector2d & p2_, const Vector2d & p3_) constexpr bool has_area () const constexpr float area () const constexpr std::array< Vector2d , 4 > vertex () const constexpr std::array< Line , 4 > outline () const","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-attributes","text":"Name Vector2d p0 Vector2d p1 Vector2d p2 Vector2d p3","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad","text":"Quad () = default","title":"function Quad"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad_1","text":"inline constexpr Quad ( const std :: array < Vector2d , 4 > & points )","title":"function Quad"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-quad_2","text":"inline constexpr Quad ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 )","title":"function Quad"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-set","text":"inline void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ , const Vector2d & p3_ )","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-has_area","text":"inline constexpr bool has_area () const","title":"function has_area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-area","text":"inline constexpr float area () const","title":"function area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-vertex","text":"inline constexpr std :: array < Vector2d , 4 > vertex () const","title":"function vertex"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#function-outline","text":"inline constexpr std :: array < Line , 4 > outline () const","title":"function outline"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p0","text":"Vector2d p0 ;","title":"variable p0"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p1","text":"Vector2d p1 ;","title":"variable p1"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p2","text":"Vector2d p2 ;","title":"variable p2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quad/#variable-p3","text":"Vector2d p3 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable p3"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/","text":"cpp_robotics::QuadProg::Param #include <quadprog.hpp> Public Attributes Name double tol_step double tol_con double eta double beta double t size_t max_iter Public Attributes Documentation variable tol_step double tol_step = 1e-6 ; variable tol_con double tol_con = 1e-6 ; variable eta double eta = 0.1 ; variable beta double beta = 0.9 ; variable t double t = 0.5 ; variable max_iter size_t max_iter = 100 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::QuadProg::Param"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#cpp_roboticsquadprogparam","text":"#include <quadprog.hpp>","title":"cpp_robotics::QuadProg::Param"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#public-attributes","text":"Name double tol_step double tol_con double eta double beta double t size_t max_iter","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-tol_step","text":"double tol_step = 1e-6 ;","title":"variable tol_step"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-tol_con","text":"double tol_con = 1e-6 ;","title":"variable tol_con"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-eta","text":"double eta = 0.1 ;","title":"variable eta"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-beta","text":"double beta = 0.9 ;","title":"variable beta"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-t","text":"double t = 0.5 ;","title":"variable t"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Param/#variable-max_iter","text":"size_t max_iter = 100 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable max_iter"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/","text":"cpp_robotics::QuadProg::Result #include <quadprog.hpp> Public Attributes Name bool is_solved Eigen::VectorXd x Eigen::VectorXd lambda_ineq Eigen::VectorXd lambda_eq size_t iter_cnt Public Attributes Documentation variable is_solved bool is_solved = false ; variable x Eigen :: VectorXd x ; variable lambda_ineq Eigen :: VectorXd lambda_ineq ; variable lambda_eq Eigen :: VectorXd lambda_eq ; variable iter_cnt size_t iter_cnt = 0 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::QuadProg::Result"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#cpp_roboticsquadprogresult","text":"#include <quadprog.hpp>","title":"cpp_robotics::QuadProg::Result"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#public-attributes","text":"Name bool is_solved Eigen::VectorXd x Eigen::VectorXd lambda_ineq Eigen::VectorXd lambda_eq size_t iter_cnt","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-is_solved","text":"bool is_solved = false ;","title":"variable is_solved"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-x","text":"Eigen :: VectorXd x ;","title":"variable x"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-lambda_ineq","text":"Eigen :: VectorXd lambda_ineq ;","title":"variable lambda_ineq"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-lambda_eq","text":"Eigen :: VectorXd lambda_eq ;","title":"variable lambda_eq"},{"location":"doxybook/Classes/structcpp__robotics_1_1QuadProg_1_1Result/#variable-iter_cnt","text":"size_t iter_cnt = 0 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/","text":"cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 More... #include <quaternion.hpp> Public Types Name using FLOATING_TYPE value_type Public Functions Name constexpr Quaternion () constexpr Quaternion ( value_type nx, value_type ny, value_type nz, value_type nw) Quaternion get_product ( Quaternion q) constexpr Quaternion conjugate () const constexpr value_type norm () const constexpr void normalize () constexpr Quaternion get_normalized () const constexpr void set_rpy ( value_type roll, value_type pitch, value_type yaw) constexpr Vector3d get_rpy () const constexpr value_type operator[] (const int index) const Public Attributes Name value_type x value_type y value_type z value_type w Detailed Description template < typename FLOATING_TYPE > class cpp_robotics :: Quaternion ; \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 Template Parameters : FLOATING_TYPE Public Types Documentation using value_type using cpp_robotics :: Quaternion < FLOATING_TYPE >:: value_type = FLOATING_TYPE ; Public Functions Documentation function Quaternion inline constexpr Quaternion () function Quaternion inline constexpr Quaternion ( value_type nx , value_type ny , value_type nz , value_type nw ) function get_product inline Quaternion get_product ( Quaternion q ) function conjugate inline constexpr Quaternion conjugate () const function norm inline constexpr value_type norm () const function normalize inline constexpr void normalize () function get_normalized inline constexpr Quaternion get_normalized () const function set_rpy inline constexpr void set_rpy ( value_type roll , value_type pitch , value_type yaw ) function get_rpy inline constexpr Vector3d get_rpy () const function operator[] inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type Public Attributes Documentation variable x value_type x ; variable y value_type y ; variable z value_type z ; variable w value_type w ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Quaternion"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#cpp_roboticsquaternion","text":"\u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 More... #include <quaternion.hpp>","title":"cpp_robotics::Quaternion"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-types","text":"Name using FLOATING_TYPE value_type","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-functions","text":"Name constexpr Quaternion () constexpr Quaternion ( value_type nx, value_type ny, value_type nz, value_type nw) Quaternion get_product ( Quaternion q) constexpr Quaternion conjugate () const constexpr value_type norm () const constexpr void normalize () constexpr Quaternion get_normalized () const constexpr void set_rpy ( value_type roll, value_type pitch, value_type yaw) constexpr Vector3d get_rpy () const constexpr value_type operator[] (const int index) const","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-attributes","text":"Name value_type x value_type y value_type z value_type w","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#detailed-description","text":"template < typename FLOATING_TYPE > class cpp_robotics :: Quaternion ; \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 Template Parameters : FLOATING_TYPE","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#using-value_type","text":"using cpp_robotics :: Quaternion < FLOATING_TYPE >:: value_type = FLOATING_TYPE ;","title":"using value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-quaternion","text":"inline constexpr Quaternion ()","title":"function Quaternion"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-quaternion_1","text":"inline constexpr Quaternion ( value_type nx , value_type ny , value_type nz , value_type nw )","title":"function Quaternion"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_product","text":"inline Quaternion get_product ( Quaternion q )","title":"function get_product"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-conjugate","text":"inline constexpr Quaternion conjugate () const","title":"function conjugate"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-norm","text":"inline constexpr value_type norm () const","title":"function norm"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-normalize","text":"inline constexpr void normalize ()","title":"function normalize"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_normalized","text":"inline constexpr Quaternion get_normalized () const","title":"function get_normalized"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-set_rpy","text":"inline constexpr void set_rpy ( value_type roll , value_type pitch , value_type yaw )","title":"function set_rpy"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-get_rpy","text":"inline constexpr Vector3d get_rpy () const","title":"function get_rpy"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#function-operator","text":"inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-x","text":"value_type x ;","title":"variable x"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-y","text":"value_type y ;","title":"variable y"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-z","text":"value_type z ;","title":"variable z"},{"location":"doxybook/Classes/structcpp__robotics_1_1Quaternion/#variable-w","text":"value_type w ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable w"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/","text":"cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) #include <shape.hpp> Public Functions Name Rect () =default constexpr Rect (const Vector2d & pos, const Vector2d & size) void set (const Vector2d & pos_, const Vector2d & size_) void set_center (const Vector2d & pos_, const Vector2d & size_) constexpr Vector2d center () const constexpr bool has_area () const constexpr float area () const constexpr std::array< Vector2d , 4 > vertex () const constexpr std::array< Line , 4 > outline () const constexpr Quad as_quad () const constexpr Quad get_rotated (float angle) const constexpr Rect gen_center (const Vector2d & center_pos, const Vector2d & size) Public Attributes Name Vector2d pos Vector2d size Public Functions Documentation function Rect Rect () = default function Rect inline constexpr Rect ( const Vector2d & pos , const Vector2d & size ) function set inline void set ( const Vector2d & pos_ , const Vector2d & size_ ) function set_center inline void set_center ( const Vector2d & pos_ , const Vector2d & size_ ) function center inline constexpr Vector2d center () const function has_area inline constexpr bool has_area () const function area inline constexpr float area () const function vertex inline constexpr std :: array < Vector2d , 4 > vertex () const function outline inline constexpr std :: array < Line , 4 > outline () const function as_quad constexpr Quad as_quad () const function get_rotated constexpr Quad get_rotated ( float angle ) const function gen_center static inline constexpr Rect gen_center ( const Vector2d & center_pos , const Vector2d & size ) Public Attributes Documentation variable pos Vector2d pos ; variable size Vector2d size ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Rect"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#cpp_roboticsrect","text":"\u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) #include <shape.hpp>","title":"cpp_robotics::Rect"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-functions","text":"Name Rect () =default constexpr Rect (const Vector2d & pos, const Vector2d & size) void set (const Vector2d & pos_, const Vector2d & size_) void set_center (const Vector2d & pos_, const Vector2d & size_) constexpr Vector2d center () const constexpr bool has_area () const constexpr float area () const constexpr std::array< Vector2d , 4 > vertex () const constexpr std::array< Line , 4 > outline () const constexpr Quad as_quad () const constexpr Quad get_rotated (float angle) const constexpr Rect gen_center (const Vector2d & center_pos, const Vector2d & size)","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-attributes","text":"Name Vector2d pos Vector2d size","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-rect","text":"Rect () = default","title":"function Rect"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-rect_1","text":"inline constexpr Rect ( const Vector2d & pos , const Vector2d & size )","title":"function Rect"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-set","text":"inline void set ( const Vector2d & pos_ , const Vector2d & size_ )","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-set_center","text":"inline void set_center ( const Vector2d & pos_ , const Vector2d & size_ )","title":"function set_center"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-center","text":"inline constexpr Vector2d center () const","title":"function center"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-has_area","text":"inline constexpr bool has_area () const","title":"function has_area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-area","text":"inline constexpr float area () const","title":"function area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-vertex","text":"inline constexpr std :: array < Vector2d , 4 > vertex () const","title":"function vertex"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-outline","text":"inline constexpr std :: array < Line , 4 > outline () const","title":"function outline"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-as_quad","text":"constexpr Quad as_quad () const","title":"function as_quad"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-get_rotated","text":"constexpr Quad get_rotated ( float angle ) const","title":"function get_rotated"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#function-gen_center","text":"static inline constexpr Rect gen_center ( const Vector2d & center_pos , const Vector2d & size )","title":"function gen_center"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#variable-pos","text":"Vector2d pos ;","title":"variable pos"},{"location":"doxybook/Classes/structcpp__robotics_1_1Rect/#variable-size","text":"Vector2d size ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable size"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/","text":"cpp_robotics::SQP::Problem #include <sqp.hpp> Public Attributes Name func_type func ConstraintArray con double tol_step double tol_con size_t max_iter Public Attributes Documentation variable func func_type func ; variable con ConstraintArray con ; variable tol_step double tol_step = 1e-6 ; variable tol_con double tol_con = 1e-6 ; variable max_iter size_t max_iter = 10 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::SQP::Problem"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#cpp_roboticssqpproblem","text":"#include <sqp.hpp>","title":"cpp_robotics::SQP::Problem"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#public-attributes","text":"Name func_type func ConstraintArray con double tol_step double tol_con size_t max_iter","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-func","text":"func_type func ;","title":"variable func"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-con","text":"ConstraintArray con ;","title":"variable con"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-tol_step","text":"double tol_step = 1e-6 ;","title":"variable tol_step"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-tol_con","text":"double tol_con = 1e-6 ;","title":"variable tol_con"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Problem/#variable-max_iter","text":"size_t max_iter = 10 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable max_iter"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/","text":"cpp_robotics::SQP::Result #include <sqp.hpp> Public Attributes Name bool is_solved Eigen::VectorXd x size_t iter_cnt Public Attributes Documentation variable is_solved bool is_solved = false ; variable x Eigen :: VectorXd x ; variable iter_cnt size_t iter_cnt = 0 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::SQP::Result"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#cpp_roboticssqpresult","text":"#include <sqp.hpp>","title":"cpp_robotics::SQP::Result"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#public-attributes","text":"Name bool is_solved Eigen::VectorXd x size_t iter_cnt","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-is_solved","text":"bool is_solved = false ;","title":"variable is_solved"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-x","text":"Eigen :: VectorXd x ;","title":"variable x"},{"location":"doxybook/Classes/structcpp__robotics_1_1SQP_1_1Result/#variable-iter_cnt","text":"size_t iter_cnt = 0 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable iter_cnt"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/","text":"cpp_robotics::SisoFeedbackSystem::func_list_t #include <siso_system.hpp> Public Attributes Name std::function< void(void)> controller_reset std::function< double(double)> controller std::function< void(void)> system_reset std::function< double(double)> system Public Attributes Documentation variable controller_reset std :: function < void ( void ) > controller_reset ; variable controller std :: function < double ( double ) > controller ; variable system_reset std :: function < void ( void ) > system_reset ; variable system std :: function < double ( double ) > system ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::SisoFeedbackSystem::func_list_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#cpp_roboticssisofeedbacksystemfunc_list_t","text":"#include <siso_system.hpp>","title":"cpp_robotics::SisoFeedbackSystem::func_list_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#public-attributes","text":"Name std::function< void(void)> controller_reset std::function< double(double)> controller std::function< void(void)> system_reset std::function< double(double)> system","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-controller_reset","text":"std :: function < void ( void ) > controller_reset ;","title":"variable controller_reset"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-controller","text":"std :: function < double ( double ) > controller ;","title":"variable controller"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-system_reset","text":"std :: function < void ( void ) > system_reset ;","title":"variable system_reset"},{"location":"doxybook/Classes/structcpp__robotics_1_1SisoFeedbackSystem_1_1func__list__t/#variable-system","text":"std :: function < double ( double ) > system ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable system"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/","text":"cpp_robotics::Spline2D::segment_info_t #include <spline.hpp> Public Attributes Name size_t i double t Public Attributes Documentation variable i size_t i ; variable t double t ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Spline2D::segment_info_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#cpp_roboticsspline2dsegment_info_t","text":"#include <spline.hpp>","title":"cpp_robotics::Spline2D::segment_info_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#public-attributes","text":"Name size_t i double t","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#variable-i","text":"size_t i ;","title":"variable i"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__info__t/#variable-t","text":"double t ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable t"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/","text":"cpp_robotics::Spline2D::segment_t #include <spline.hpp> Public Attributes Name spline::spline_c coeff double length Public Attributes Documentation variable coeff spline :: spline_c coeff ; variable length double length ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Spline2D::segment_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#cpp_roboticsspline2dsegment_t","text":"#include <spline.hpp>","title":"cpp_robotics::Spline2D::segment_t"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#public-attributes","text":"Name spline::spline_c coeff double length","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#variable-coeff","text":"spline :: spline_c coeff ;","title":"variable coeff"},{"location":"doxybook/Classes/structcpp__robotics_1_1Spline2D_1_1segment__t/#variable-length","text":"double length ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable length"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/","text":"cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 More... #include <transform.hpp> Public Types Name using FLOATING_TYPE value_type using Vector2 < value_type > vector_type Public Functions Name Transform () =default Construct a new Field Vector 2 object. constexpr Transform (const value_type _x, const value_type _y, const value_type _theta) Construct a new Field Vector 2 object. constexpr Transform (const vector_type & _xy, const value_type _theta) Construct a new Field Vector 2 object. constexpr Transform (const Transform & ) =default Construct a new Field Vector 2 object. constexpr vector_type make_vector2 () const xy\u6210\u5206\u306eVector2\u3092\u751f\u6210 constexpr void set ( value_type vx, value_type vy, value_type vtheta) value_type distance () const \u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 void rotate (const value_type theta) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate (const value_type rotX, const value_type rotY, const value_type theta) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate ( vector_type rotPos, const value_type theta) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void set_polar (const value_type radius, const value_type angle, const value_type robotTheta) \u6975\u5ea7\u6a19\u6307\u5b9a bool is_zero () const bool is_zero_pos () const bool is_zero_angle () const bool has_nan () const constexpr bool operator== (const Transform v) const constexpr bool operator!= (const Transform & v) const constexpr Transform operator+ (const Transform & v) const constexpr Transform operator- (const Transform & v) const constexpr Transform & operator+= (const Transform & v) constexpr Transform & operator-= (const Transform & v) constexpr Transform operator+ (const vector_type & v) const constexpr Transform operator- (const vector_type & v) const constexpr Transform operator+ (const value_type angle) const constexpr Transform operator- (const value_type angle) const constexpr Transform & operator+= (const vector_type & v) constexpr Transform & operator-= (const vector_type & v) constexpr Transform & operator+= (const value_type angle) constexpr Transform & operator-= (const value_type angle) constexpr Transform operator* (const value_type value) const constexpr Transform operator/ (const value_type value) const constexpr Transform & operator*= (const value_type value) constexpr Transform & operator/= (const value_type value) value_type & operator[] (const int index) constexpr value_type operator[] (const int index) const constexpr value_type get_angle ( Transform & a, Transform & b) Get the Angle object. value_type get_distance ( Transform & a, Transform & b) Get the Distance object. Transform get_lerp ( Transform & a, Transform & b, const value_type t) lerp function constexpr Transform origin () Public Attributes Name value_type x value_type y value_type theta Detailed Description template < typename FLOATING_TYPE > struct cpp_robotics :: Transform ; 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 Public Types Documentation using value_type using cpp_robotics :: Transform < FLOATING_TYPE >:: value_type = FLOATING_TYPE ; using vector_type using cpp_robotics :: Transform < FLOATING_TYPE >:: vector_type = Vector2 < value_type > ; Public Functions Documentation function Transform Transform () = default Construct a new Field Vector 2 object. function Transform inline constexpr Transform ( const value_type _x , const value_type _y , const value_type _theta ) Construct a new Field Vector 2 object. Parameters : x y theta function Transform inline constexpr Transform ( const vector_type & _xy , const value_type _theta ) Construct a new Field Vector 2 object. function Transform constexpr Transform ( const Transform & ) = default Construct a new Field Vector 2 object. Parameters : v function make_vector2 inline constexpr vector_type make_vector2 () const xy\u6210\u5206\u306eVector2\u3092\u751f\u6210 function set inline constexpr void set ( value_type vx , value_type vy , value_type vtheta ) Parameters : vx vy vtheta function distance inline value_type distance () const \u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 Return : value_type function rotate inline void rotate ( const value_type theta ) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : theta function rotate inline void rotate ( const value_type rotX , const value_type rotY , const value_type theta ) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : rotX rotY theta function rotate inline void rotate ( vector_type rotPos , const value_type theta ) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : rotPos theta function set_polar inline void set_polar ( const value_type radius , const value_type angle , const value_type robotTheta ) \u6975\u5ea7\u6a19\u6307\u5b9a Parameters : radius angle robotTheta function is_zero inline bool is_zero () const Return : true false function is_zero_pos inline bool is_zero_pos () const Return : true false function is_zero_angle inline bool is_zero_angle () const Return : true false function has_nan inline bool has_nan () const Return : true false function operator== inline constexpr bool operator == ( const Transform v ) const Parameters : v Return : true false function operator!= inline constexpr bool operator != ( const Transform & v ) const Parameters : v Return : true false function operator+ inline constexpr Transform operator + ( const Transform & v ) const Parameters : v Return : Transform function operator- inline constexpr Transform operator - ( const Transform & v ) const Parameters : v Return : Transform function operator+= inline constexpr Transform & operator += ( const Transform & v ) Parameters : v Return : Transform & function operator-= inline constexpr Transform & operator -= ( const Transform & v ) Parameters : v Return : Transform & function operator+ inline constexpr Transform operator + ( const vector_type & v ) const Parameters : v Return : Transform function operator- inline constexpr Transform operator - ( const vector_type & v ) const Parameters : v Return : Transform function operator+ inline constexpr Transform operator + ( const value_type angle ) const Parameters : angle Return : Transform function operator- inline constexpr Transform operator - ( const value_type angle ) const Parameters : angle Return : Transform function operator+= inline constexpr Transform & operator += ( const vector_type & v ) Parameters : v Return : Transform & function operator-= inline constexpr Transform & operator -= ( const vector_type & v ) Parameters : v Return : Transform & function operator+= inline constexpr Transform & operator += ( const value_type angle ) Parameters : angle Return : Transform & function operator-= inline constexpr Transform & operator -= ( const value_type angle ) Parameters : angle Return : Transform & function operator* inline constexpr Transform operator * ( const value_type value ) const Parameters : value Return : Transform function operator/ inline constexpr Transform operator / ( const value_type value ) const Parameters : value Return : Transform function operator*= inline constexpr Transform & operator *= ( const value_type value ) Parameters : value Return : Transform & function operator/= inline constexpr Transform & operator /= ( const value_type value ) Parameters : value Return : Transform & function operator[] inline value_type & operator []( const int index ) Parameters : index Return : value_type& function operator[] inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type function get_angle static inline constexpr value_type get_angle ( Transform & a , Transform & b ) Get the Angle object. Parameters : a b Return : value_type function get_distance static inline value_type get_distance ( Transform & a , Transform & b ) Get the Distance object. Parameters : a b Return : value_type function get_lerp static inline Transform get_lerp ( Transform & a , Transform & b , const value_type t ) lerp function Parameters : a b t Return : Transform function origin static inline constexpr Transform origin () Return : Transform Public Attributes Documentation variable x value_type x ; variable y value_type y ; variable theta value_type theta ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Transform"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#cpp_roboticstransform","text":"2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 More... #include <transform.hpp>","title":"cpp_robotics::Transform"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-types","text":"Name using FLOATING_TYPE value_type using Vector2 < value_type > vector_type","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-functions","text":"Name Transform () =default Construct a new Field Vector 2 object. constexpr Transform (const value_type _x, const value_type _y, const value_type _theta) Construct a new Field Vector 2 object. constexpr Transform (const vector_type & _xy, const value_type _theta) Construct a new Field Vector 2 object. constexpr Transform (const Transform & ) =default Construct a new Field Vector 2 object. constexpr vector_type make_vector2 () const xy\u6210\u5206\u306eVector2\u3092\u751f\u6210 constexpr void set ( value_type vx, value_type vy, value_type vtheta) value_type distance () const \u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 void rotate (const value_type theta) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate (const value_type rotX, const value_type rotY, const value_type theta) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void rotate ( vector_type rotPos, const value_type theta) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 void set_polar (const value_type radius, const value_type angle, const value_type robotTheta) \u6975\u5ea7\u6a19\u6307\u5b9a bool is_zero () const bool is_zero_pos () const bool is_zero_angle () const bool has_nan () const constexpr bool operator== (const Transform v) const constexpr bool operator!= (const Transform & v) const constexpr Transform operator+ (const Transform & v) const constexpr Transform operator- (const Transform & v) const constexpr Transform & operator+= (const Transform & v) constexpr Transform & operator-= (const Transform & v) constexpr Transform operator+ (const vector_type & v) const constexpr Transform operator- (const vector_type & v) const constexpr Transform operator+ (const value_type angle) const constexpr Transform operator- (const value_type angle) const constexpr Transform & operator+= (const vector_type & v) constexpr Transform & operator-= (const vector_type & v) constexpr Transform & operator+= (const value_type angle) constexpr Transform & operator-= (const value_type angle) constexpr Transform operator* (const value_type value) const constexpr Transform operator/ (const value_type value) const constexpr Transform & operator*= (const value_type value) constexpr Transform & operator/= (const value_type value) value_type & operator[] (const int index) constexpr value_type operator[] (const int index) const constexpr value_type get_angle ( Transform & a, Transform & b) Get the Angle object. value_type get_distance ( Transform & a, Transform & b) Get the Distance object. Transform get_lerp ( Transform & a, Transform & b, const value_type t) lerp function constexpr Transform origin ()","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-attributes","text":"Name value_type x value_type y value_type theta","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#detailed-description","text":"template < typename FLOATING_TYPE > struct cpp_robotics :: Transform ; 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#using-value_type","text":"using cpp_robotics :: Transform < FLOATING_TYPE >:: value_type = FLOATING_TYPE ;","title":"using value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#using-vector_type","text":"using cpp_robotics :: Transform < FLOATING_TYPE >:: vector_type = Vector2 < value_type > ;","title":"using vector_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform","text":"Transform () = default Construct a new Field Vector 2 object.","title":"function Transform"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_1","text":"inline constexpr Transform ( const value_type _x , const value_type _y , const value_type _theta ) Construct a new Field Vector 2 object. Parameters : x y theta","title":"function Transform"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_2","text":"inline constexpr Transform ( const vector_type & _xy , const value_type _theta ) Construct a new Field Vector 2 object.","title":"function Transform"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-transform_3","text":"constexpr Transform ( const Transform & ) = default Construct a new Field Vector 2 object. Parameters : v","title":"function Transform"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-make_vector2","text":"inline constexpr vector_type make_vector2 () const xy\u6210\u5206\u306eVector2\u3092\u751f\u6210","title":"function make_vector2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-set","text":"inline constexpr void set ( value_type vx , value_type vy , value_type vtheta ) Parameters : vx vy vtheta","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-distance","text":"inline value_type distance () const \u539f\u70b9\u304b\u3089xy\u5ea7\u6a19\u307e\u3067\u306e\u8ddd\u96e2\u3092\u8fd4\u3059 Return : value_type","title":"function distance"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate","text":"inline void rotate ( const value_type theta ) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : theta","title":"function rotate"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate_1","text":"inline void rotate ( const value_type rotX , const value_type rotY , const value_type theta ) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : rotX rotY theta","title":"function rotate"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-rotate_2","text":"inline void rotate ( vector_type rotPos , const value_type theta ) \u6307\u5b9a\u5ea7\u6a19\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : rotPos theta","title":"function rotate"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-set_polar","text":"inline void set_polar ( const value_type radius , const value_type angle , const value_type robotTheta ) \u6975\u5ea7\u6a19\u6307\u5b9a Parameters : radius angle robotTheta","title":"function set_polar"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero","text":"inline bool is_zero () const Return : true false","title":"function is_zero"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero_pos","text":"inline bool is_zero_pos () const Return : true false","title":"function is_zero_pos"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-is_zero_angle","text":"inline bool is_zero_angle () const Return : true false","title":"function is_zero_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-has_nan","text":"inline bool has_nan () const Return : true false","title":"function has_nan"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator","text":"inline constexpr bool operator == ( const Transform v ) const Parameters : v Return : true false","title":"function operator=="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_1","text":"inline constexpr bool operator != ( const Transform & v ) const Parameters : v Return : true false","title":"function operator!="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_2","text":"inline constexpr Transform operator + ( const Transform & v ) const Parameters : v Return : Transform","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-","text":"inline constexpr Transform operator - ( const Transform & v ) const Parameters : v Return : Transform","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_3","text":"inline constexpr Transform & operator += ( const Transform & v ) Parameters : v Return : Transform &","title":"function operator+="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_1","text":"inline constexpr Transform & operator -= ( const Transform & v ) Parameters : v Return : Transform &","title":"function operator-="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_4","text":"inline constexpr Transform operator + ( const vector_type & v ) const Parameters : v Return : Transform","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_2","text":"inline constexpr Transform operator - ( const vector_type & v ) const Parameters : v Return : Transform","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_5","text":"inline constexpr Transform operator + ( const value_type angle ) const Parameters : angle Return : Transform","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_3","text":"inline constexpr Transform operator - ( const value_type angle ) const Parameters : angle Return : Transform","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_6","text":"inline constexpr Transform & operator += ( const vector_type & v ) Parameters : v Return : Transform &","title":"function operator+="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_4","text":"inline constexpr Transform & operator -= ( const vector_type & v ) Parameters : v Return : Transform &","title":"function operator-="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_7","text":"inline constexpr Transform & operator += ( const value_type angle ) Parameters : angle Return : Transform &","title":"function operator+="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator-_5","text":"inline constexpr Transform & operator -= ( const value_type angle ) Parameters : angle Return : Transform &","title":"function operator-="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_8","text":"inline constexpr Transform operator * ( const value_type value ) const Parameters : value Return : Transform","title":"function operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_9","text":"inline constexpr Transform operator / ( const value_type value ) const Parameters : value Return : Transform","title":"function operator/"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_10","text":"inline constexpr Transform & operator *= ( const value_type value ) Parameters : value Return : Transform &","title":"function operator*="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_11","text":"inline constexpr Transform & operator /= ( const value_type value ) Parameters : value Return : Transform &","title":"function operator/="},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_12","text":"inline value_type & operator []( const int index ) Parameters : index Return : value_type&","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-operator_13","text":"inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_angle","text":"static inline constexpr value_type get_angle ( Transform & a , Transform & b ) Get the Angle object. Parameters : a b Return : value_type","title":"function get_angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_distance","text":"static inline value_type get_distance ( Transform & a , Transform & b ) Get the Distance object. Parameters : a b Return : value_type","title":"function get_distance"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-get_lerp","text":"static inline Transform get_lerp ( Transform & a , Transform & b , const value_type t ) lerp function Parameters : a b t Return : Transform","title":"function get_lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#function-origin","text":"static inline constexpr Transform origin () Return : Transform","title":"function origin"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-x","text":"value_type x ;","title":"variable x"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-y","text":"value_type y ;","title":"variable y"},{"location":"doxybook/Classes/structcpp__robotics_1_1Transform/#variable-theta","text":"value_type theta ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable theta"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/","text":"cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 #include <shape.hpp> Public Functions Name Triangle () =default constexpr Triangle (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2) void set (const Vector2d & p0_, const Vector2d & p1_, const Vector2d & p2_) constexpr bool has_area () const constexpr float area () const constexpr std::array< Vector2d , 3 > vertex () const constexpr std::array< Line , 3 > outline () const Public Attributes Name Vector2d p0 Vector2d p1 Vector2d p2 Public Functions Documentation function Triangle Triangle () = default function Triangle inline constexpr Triangle ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 ) function set inline void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ ) function has_area inline constexpr bool has_area () const function area inline constexpr float area () const function vertex inline constexpr std :: array < Vector2d , 3 > vertex () const function outline inline constexpr std :: array < Line , 3 > outline () const Public Attributes Documentation variable p0 Vector2d p0 ; variable p1 Vector2d p1 ; variable p2 Vector2d p2 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Triangle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#cpp_roboticstriangle","text":"\u4e09\u89d2\u5f62\u30af\u30e9\u30b9 #include <shape.hpp>","title":"cpp_robotics::Triangle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-functions","text":"Name Triangle () =default constexpr Triangle (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2) void set (const Vector2d & p0_, const Vector2d & p1_, const Vector2d & p2_) constexpr bool has_area () const constexpr float area () const constexpr std::array< Vector2d , 3 > vertex () const constexpr std::array< Line , 3 > outline () const","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-attributes","text":"Name Vector2d p0 Vector2d p1 Vector2d p2","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-triangle","text":"Triangle () = default","title":"function Triangle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-triangle_1","text":"inline constexpr Triangle ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 )","title":"function Triangle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-set","text":"inline void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ )","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-has_area","text":"inline constexpr bool has_area () const","title":"function has_area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-area","text":"inline constexpr float area () const","title":"function area"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-vertex","text":"inline constexpr std :: array < Vector2d , 3 > vertex () const","title":"function vertex"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#function-outline","text":"inline constexpr std :: array < Line , 3 > outline () const","title":"function outline"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p0","text":"Vector2d p0 ;","title":"variable p0"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p1","text":"Vector2d p1 ;","title":"variable p1"},{"location":"doxybook/Classes/structcpp__robotics_1_1Triangle/#variable-p2","text":"Vector2d p2 ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable p2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/","text":"cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb More... #include <vector2.hpp> Public Types Name using FLOATING_TYPE value_type Public Functions Name Vector2 () =default Construct a new Vector 2 object. constexpr Vector2 ( value_type vx, value_type vy) Construct a new Vector 2 object. constexpr Vector2 (const Vector2 & ) =default Construct a new Vector 2 object. constexpr void set (const value_type vx, const value_type vy) \u5024\u306e\u4ee3\u5165 void set_polar (const value_type radius, const value_type theta) \u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 constexpr value_type dot (const Vector2 & v) const constexpr value_type cross (const Vector2 & v) const constexpr value_type norm_sq () const constexpr value_type norm () const \u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 constexpr value_type angle () const \u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 constexpr Vector2 get_normalized () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 void rotate (const value_type theta) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 constexpr Vector2 get_rotated (const value_type theta) const \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 constexpr bool is_zero () const constexpr bool has_nan () const constexpr Vector2 yx () const constexpr Vector2 nyx () const constexpr Vector2 ynx () const constexpr Vector2 nxy () const constexpr Vector2 xny () const constexpr Vector2 lerp (const Vector2 & b, const value_type t) const constexpr Vector2 operator+ () const constexpr Vector2 operator- () const constexpr bool operator== (const Vector2 & v) const constexpr bool operator!= (const Vector2 & v) const constexpr Vector2 operator+ (const Vector2 & v) const constexpr Vector2 operator- (const Vector2 & v) const constexpr Vector2 & operator+= (const Vector2 & v) constexpr Vector2 & operator-= (const Vector2 & v) constexpr Vector2 & operator*= (const value_type value) constexpr Vector2 & operator/= (const value_type value) value_type & operator[] (const size_t index) constexpr value_type operator[] (const size_t index) const constexpr value_type dot (const Vector2 & a, const Vector2 & b) constexpr value_type angle (const Vector2 & a, const Vector2 & b) constexpr value_type distance (const Vector2 & a, const Vector2 & b) constexpr Vector2 lerp (const Vector2 & a, const Vector2 & b, const value_type t) constexpr Vector2 zero () constexpr Vector2 up () constexpr Vector2 down () constexpr Vector2 right () constexpr Vector2 left () Public Attributes Name value_type x value_type y Friends Name constexpr friend Vector2 operator/ (const Vector2 & v, const value_type value) constexpr friend Vector2 operator* (const Vector2 & v, const Scaler s) constexpr friend Vector2 operator* (const Scaler s, const Vector2 & v) Detailed Description template < typename FLOATING_TYPE > struct cpp_robotics :: Vector2 ; 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb Public Types Documentation using value_type using cpp_robotics :: Vector2 < FLOATING_TYPE >:: value_type = FLOATING_TYPE ; Public Functions Documentation function Vector2 Vector2 () = default Construct a new Vector 2 object. function Vector2 inline constexpr Vector2 ( value_type vx , value_type vy ) Construct a new Vector 2 object. Parameters : vx vy function Vector2 constexpr Vector2 ( const Vector2 & ) = default Construct a new Vector 2 object. Parameters : v function set inline constexpr void set ( const value_type vx , const value_type vy ) \u5024\u306e\u4ee3\u5165 Parameters : vx value_type vy function set_polar inline void set_polar ( const value_type radius , const value_type theta ) \u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 Parameters : radius \u534a\u5f84 theta \u89d2\u5ea6[rad] function dot inline constexpr value_type dot ( const Vector2 & v ) const Parameters : v Return : constexpr value_type function cross inline constexpr value_type cross ( const Vector2 & v ) const Parameters : v Return : constexpr value_type function norm_sq inline constexpr value_type norm_sq () const Return : constexpr value_type function norm inline constexpr value_type norm () const \u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 Return : value_type function normalize inline void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 function angle inline constexpr value_type angle () const \u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 Return : value_type function get_normalized inline constexpr Vector2 get_normalized () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 Return : Vector2 function rotate inline void rotate ( const value_type theta ) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : theta [rad] function get_rotated inline constexpr Vector2 get_rotated ( const value_type theta ) const \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 Parameters : theta Return : Vector2 function is_zero inline constexpr bool is_zero () const Return : true false function has_nan inline constexpr bool has_nan () const Return : true false function yx inline constexpr Vector2 yx () const Return : constexpr Vector2 function nyx inline constexpr Vector2 nyx () const Return : constexpr Vector2 function ynx inline constexpr Vector2 ynx () const Return : constexpr Vector2 function nxy inline constexpr Vector2 nxy () const function xny inline constexpr Vector2 xny () const function lerp inline constexpr Vector2 lerp ( const Vector2 & b , const value_type t ) const Parameters : b t Return : constexpr Vector2 function operator+ inline constexpr Vector2 operator + () const Return : constexpr Vector2 function operator- inline constexpr Vector2 operator - () const Return : constexpr Vector2 function operator== inline constexpr bool operator == ( const Vector2 & v ) const Parameters : v Return : true false function operator!= inline constexpr bool operator != ( const Vector2 & v ) const Parameters : v Return : true false function operator+ inline constexpr Vector2 operator + ( const Vector2 & v ) const Parameters : v Return : Vector2 function operator- inline constexpr Vector2 operator - ( const Vector2 & v ) const Parameters : v Return : Vector2 function operator+= inline constexpr Vector2 & operator += ( const Vector2 & v ) Parameters : v Return : Vector2 & function operator-= inline constexpr Vector2 & operator -= ( const Vector2 & v ) Parameters : v Return : Vector2 & function operator*= inline constexpr Vector2 & operator *= ( const value_type value ) Parameters : value Return : Vector2 & function operator/= inline constexpr Vector2 & operator /= ( const value_type value ) Parameters : value Return : Vector2 & function operator[] inline value_type & operator []( const size_t index ) Parameters : index Return : value_type& function operator[] inline constexpr value_type operator []( const size_t index ) const Parameters : index Return : constexpr value_type function dot static inline constexpr value_type dot ( const Vector2 & a , const Vector2 & b ) Parameters : a b Return : constexpr value_type function angle static inline constexpr value_type angle ( const Vector2 & a , const Vector2 & b ) Parameters : a b Return : value_type function distance static inline constexpr value_type distance ( const Vector2 & a , const Vector2 & b ) Parameters : a b Return : value_type function lerp static inline constexpr Vector2 lerp ( const Vector2 & a , const Vector2 & b , const value_type t ) Parameters : a b t Return : constexpr Vector2 function zero static inline constexpr Vector2 zero () Return : const Vector2 function up static inline constexpr Vector2 up () Return : const Vector2 function down static inline constexpr Vector2 down () Return : const Vector2 function right static inline constexpr Vector2 right () Return : const Vector2 function left static inline constexpr Vector2 left () Return : const Vector2 Public Attributes Documentation variable x value_type x ; variable y value_type y ; Friends friend operator/ friend constexpr friend Vector2 operator / ( const Vector2 & v , const value_type value ); Parameters : value Return : Vector2 friend operator* friend constexpr friend Vector2 operator * ( const Vector2 & v , const Scaler s ); Parameters : v s Template Parameters : Scaler Return : constexpr Vector2 friend operator* friend constexpr friend Vector2 operator * ( const Scaler s , const Vector2 & v ); Parameters : s v Template Parameters : Scaler Return : constexpr Vector2 Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Vector2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#cpp_roboticsvector2","text":"2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb More... #include <vector2.hpp>","title":"cpp_robotics::Vector2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-types","text":"Name using FLOATING_TYPE value_type","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-functions","text":"Name Vector2 () =default Construct a new Vector 2 object. constexpr Vector2 ( value_type vx, value_type vy) Construct a new Vector 2 object. constexpr Vector2 (const Vector2 & ) =default Construct a new Vector 2 object. constexpr void set (const value_type vx, const value_type vy) \u5024\u306e\u4ee3\u5165 void set_polar (const value_type radius, const value_type theta) \u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 constexpr value_type dot (const Vector2 & v) const constexpr value_type cross (const Vector2 & v) const constexpr value_type norm_sq () const constexpr value_type norm () const \u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 constexpr value_type angle () const \u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 constexpr Vector2 get_normalized () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 void rotate (const value_type theta) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 constexpr Vector2 get_rotated (const value_type theta) const \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 constexpr bool is_zero () const constexpr bool has_nan () const constexpr Vector2 yx () const constexpr Vector2 nyx () const constexpr Vector2 ynx () const constexpr Vector2 nxy () const constexpr Vector2 xny () const constexpr Vector2 lerp (const Vector2 & b, const value_type t) const constexpr Vector2 operator+ () const constexpr Vector2 operator- () const constexpr bool operator== (const Vector2 & v) const constexpr bool operator!= (const Vector2 & v) const constexpr Vector2 operator+ (const Vector2 & v) const constexpr Vector2 operator- (const Vector2 & v) const constexpr Vector2 & operator+= (const Vector2 & v) constexpr Vector2 & operator-= (const Vector2 & v) constexpr Vector2 & operator*= (const value_type value) constexpr Vector2 & operator/= (const value_type value) value_type & operator[] (const size_t index) constexpr value_type operator[] (const size_t index) const constexpr value_type dot (const Vector2 & a, const Vector2 & b) constexpr value_type angle (const Vector2 & a, const Vector2 & b) constexpr value_type distance (const Vector2 & a, const Vector2 & b) constexpr Vector2 lerp (const Vector2 & a, const Vector2 & b, const value_type t) constexpr Vector2 zero () constexpr Vector2 up () constexpr Vector2 down () constexpr Vector2 right () constexpr Vector2 left ()","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-attributes","text":"Name value_type x value_type y","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friends","text":"Name constexpr friend Vector2 operator/ (const Vector2 & v, const value_type value) constexpr friend Vector2 operator* (const Vector2 & v, const Scaler s) constexpr friend Vector2 operator* (const Scaler s, const Vector2 & v)","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#detailed-description","text":"template < typename FLOATING_TYPE > struct cpp_robotics :: Vector2 ; 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#using-value_type","text":"using cpp_robotics :: Vector2 < FLOATING_TYPE >:: value_type = FLOATING_TYPE ;","title":"using value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2","text":"Vector2 () = default Construct a new Vector 2 object.","title":"function Vector2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2_1","text":"inline constexpr Vector2 ( value_type vx , value_type vy ) Construct a new Vector 2 object. Parameters : vx vy","title":"function Vector2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-vector2_2","text":"constexpr Vector2 ( const Vector2 & ) = default Construct a new Vector 2 object. Parameters : v","title":"function Vector2"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-set","text":"inline constexpr void set ( const value_type vx , const value_type vy ) \u5024\u306e\u4ee3\u5165 Parameters : vx value_type vy","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-set_polar","text":"inline void set_polar ( const value_type radius , const value_type theta ) \u6975\u5f62\u5f0f\u3067\u306e\u5024\u306e\u4ee3\u5165 Parameters : radius \u534a\u5f84 theta \u89d2\u5ea6[rad]","title":"function set_polar"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-dot","text":"inline constexpr value_type dot ( const Vector2 & v ) const Parameters : v Return : constexpr value_type","title":"function dot"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-cross","text":"inline constexpr value_type cross ( const Vector2 & v ) const Parameters : v Return : constexpr value_type","title":"function cross"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-norm_sq","text":"inline constexpr value_type norm_sq () const Return : constexpr value_type","title":"function norm_sq"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-norm","text":"inline constexpr value_type norm () const \u30d9\u30af\u30c8\u30eb\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059 Return : value_type","title":"function norm"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-normalize","text":"inline void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316","title":"function normalize"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-angle","text":"inline constexpr value_type angle () const \u30d9\u30af\u30c8\u30eb\u306e\u89d2\u5ea6\u3092\u8fd4\u3059 Return : value_type","title":"function angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-get_normalized","text":"inline constexpr Vector2 get_normalized () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316\u3057\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 Return : Vector2","title":"function get_normalized"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-rotate","text":"inline void rotate ( const value_type theta ) \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2 Parameters : theta [rad]","title":"function rotate"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-get_rotated","text":"inline constexpr Vector2 get_rotated ( const value_type theta ) const \u539f\u70b9\u4e2d\u5fc3\u306b\u56de\u8ee2\u3055\u305b\u305f\u30d9\u30af\u30c8\u30eb\u3092\u8fd4\u3059 Parameters : theta Return : Vector2","title":"function get_rotated"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-is_zero","text":"inline constexpr bool is_zero () const Return : true false","title":"function is_zero"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-has_nan","text":"inline constexpr bool has_nan () const Return : true false","title":"function has_nan"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-yx","text":"inline constexpr Vector2 yx () const Return : constexpr Vector2","title":"function yx"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-nyx","text":"inline constexpr Vector2 nyx () const Return : constexpr Vector2","title":"function nyx"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-ynx","text":"inline constexpr Vector2 ynx () const Return : constexpr Vector2","title":"function ynx"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-nxy","text":"inline constexpr Vector2 nxy () const","title":"function nxy"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-xny","text":"inline constexpr Vector2 xny () const","title":"function xny"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-lerp","text":"inline constexpr Vector2 lerp ( const Vector2 & b , const value_type t ) const Parameters : b t Return : constexpr Vector2","title":"function lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator","text":"inline constexpr Vector2 operator + () const Return : constexpr Vector2","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-","text":"inline constexpr Vector2 operator - () const Return : constexpr Vector2","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_1","text":"inline constexpr bool operator == ( const Vector2 & v ) const Parameters : v Return : true false","title":"function operator=="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_2","text":"inline constexpr bool operator != ( const Vector2 & v ) const Parameters : v Return : true false","title":"function operator!="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_3","text":"inline constexpr Vector2 operator + ( const Vector2 & v ) const Parameters : v Return : Vector2","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-_1","text":"inline constexpr Vector2 operator - ( const Vector2 & v ) const Parameters : v Return : Vector2","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_4","text":"inline constexpr Vector2 & operator += ( const Vector2 & v ) Parameters : v Return : Vector2 &","title":"function operator+="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator-_2","text":"inline constexpr Vector2 & operator -= ( const Vector2 & v ) Parameters : v Return : Vector2 &","title":"function operator-="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_5","text":"inline constexpr Vector2 & operator *= ( const value_type value ) Parameters : value Return : Vector2 &","title":"function operator*="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_6","text":"inline constexpr Vector2 & operator /= ( const value_type value ) Parameters : value Return : Vector2 &","title":"function operator/="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_7","text":"inline value_type & operator []( const size_t index ) Parameters : index Return : value_type&","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-operator_8","text":"inline constexpr value_type operator []( const size_t index ) const Parameters : index Return : constexpr value_type","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-dot_1","text":"static inline constexpr value_type dot ( const Vector2 & a , const Vector2 & b ) Parameters : a b Return : constexpr value_type","title":"function dot"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-angle_1","text":"static inline constexpr value_type angle ( const Vector2 & a , const Vector2 & b ) Parameters : a b Return : value_type","title":"function angle"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-distance","text":"static inline constexpr value_type distance ( const Vector2 & a , const Vector2 & b ) Parameters : a b Return : value_type","title":"function distance"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-lerp_1","text":"static inline constexpr Vector2 lerp ( const Vector2 & a , const Vector2 & b , const value_type t ) Parameters : a b t Return : constexpr Vector2","title":"function lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-zero","text":"static inline constexpr Vector2 zero () Return : const Vector2","title":"function zero"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-up","text":"static inline constexpr Vector2 up () Return : const Vector2","title":"function up"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-down","text":"static inline constexpr Vector2 down () Return : const Vector2","title":"function down"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-right","text":"static inline constexpr Vector2 right () Return : const Vector2","title":"function right"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#function-left","text":"static inline constexpr Vector2 left () Return : const Vector2","title":"function left"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#variable-x","text":"value_type x ;","title":"variable x"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#variable-y","text":"value_type y ;","title":"variable y"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friends_1","text":"","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator","text":"friend constexpr friend Vector2 operator / ( const Vector2 & v , const value_type value ); Parameters : value Return : Vector2","title":"friend operator/"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator_1","text":"friend constexpr friend Vector2 operator * ( const Vector2 & v , const Scaler s ); Parameters : v s Template Parameters : Scaler Return : constexpr Vector2","title":"friend operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector2/#friend-operator_2","text":"friend constexpr friend Vector2 operator * ( const Scaler s , const Vector2 & v ); Parameters : s v Template Parameters : Scaler Return : constexpr Vector2 Updated on 2022-09-30 at 00:12:50 +0900","title":"friend operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/","text":"cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb More... #include <vector3.hpp> Public Types Name using FLOATING_TYPE value_type Public Functions Name Vector3 () =default Construct a new Vector 3 object. constexpr Vector3 ( value_type vx, value_type vy, value_type vz) Construct a new Vector 3 object. Vector3 (const Vector3 & v) =default Construct a new Vector 3 object. void set ( value_type vx, value_type vy, value_type vz) constexpr value_type dot (const Vector3 & v) const constexpr Vector3 cross (const Vector3 & v) const constexpr value_type norm_sq () const value_type norm () Get the Magnitude object. void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector3 get_normalized () Get the Normalized object. constexpr bool is_zero () const constexpr bool has_nan () const constexpr Vector3 lerp (const Vector3 & b, const value_type t) const constexpr Vector3 operator+ () const constexpr Vector3 operator- () const bool operator== (const Vector3 & v) const bool operator!= (const Vector3 & v) const constexpr Vector3 operator+ (const Vector3 & v) const constexpr Vector3 operator- (const Vector3 & v) const constexpr Vector3 & operator+= (const Vector3 & v) constexpr Vector3 & operator-= (const Vector3 & v) constexpr Vector3 & operator*= (const value_type value) constexpr Vector3 & operator/= (const value_type value) value_type & operator[] (const int index) constexpr value_type operator[] (const int index) const constexpr value_type dot (const Vector3 & a, const Vector3 & b) value_type distance (const Vector3 & a, const Vector3 & b) constexpr Vector3 lerp (const Vector3 & a, const Vector3 & b, const value_type t) constexpr Vector3 zero () constexpr Vector3 forward () constexpr Vector3 back () constexpr Vector3 up () constexpr Vector3 down () constexpr Vector3 right () constexpr Vector3 left () Public Attributes Name value_type x value_type y value_type z Friends Name constexpr friend Vector3 operator/ (const Vector3 & v, const value_type value) constexpr friend Vector3 operator* (const Vector3 & v, const Scaler s) constexpr friend Vector3 operator* (const Scaler s, const Vector3 & v) Detailed Description template < typename FLOATING_TYPE > struct cpp_robotics :: Vector3 ; 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb Public Types Documentation using value_type using cpp_robotics :: Vector3 < FLOATING_TYPE >:: value_type = FLOATING_TYPE ; Public Functions Documentation function Vector3 Vector3 () = default Construct a new Vector 3 object. function Vector3 inline constexpr Vector3 ( value_type vx , value_type vy , value_type vz ) Construct a new Vector 3 object. Parameters : vx vy vz function Vector3 Vector3 ( const Vector3 & v ) = default Construct a new Vector 3 object. Parameters : v function set inline void set ( value_type vx , value_type vy , value_type vz ) Parameters : vx vy vz function dot inline constexpr value_type dot ( const Vector3 & v ) const Parameters : v Return : constexpr value_type function cross inline constexpr Vector3 cross ( const Vector3 & v ) const Parameters : v Return : constexpr Vector3 function norm_sq inline constexpr value_type norm_sq () const Return : constexpr value_type function norm inline value_type norm () Get the Magnitude object. Return : value_type function normalize inline void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 function get_normalized inline Vector3 get_normalized () Get the Normalized object. Return : Vector3 function is_zero inline constexpr bool is_zero () const Return : true false function has_nan inline constexpr bool has_nan () const Return : true false function lerp inline constexpr Vector3 lerp ( const Vector3 & b , const value_type t ) const Parameters : b t Return : constexpr Vector3 function operator+ inline constexpr Vector3 operator + () const Return : constexpr Vector3 function operator- inline constexpr Vector3 operator - () const Return : constexpr Vector3 function operator== inline bool operator == ( const Vector3 & v ) const Parameters : v Return : true false function operator!= inline bool operator != ( const Vector3 & v ) const Parameters : v Return : true false function operator+ inline constexpr Vector3 operator + ( const Vector3 & v ) const Parameters : v Return : Vector3 function operator- inline constexpr Vector3 operator - ( const Vector3 & v ) const Parameters : v Return : Vector3 function operator+= inline constexpr Vector3 & operator += ( const Vector3 & v ) Parameters : v Return : Vector3 & function operator-= inline constexpr Vector3 & operator -= ( const Vector3 & v ) Parameters : v Return : Vector3 & function operator*= inline constexpr Vector3 & operator *= ( const value_type value ) Parameters : value Return : Vector3 & function operator/= inline constexpr Vector3 & operator /= ( const value_type value ) Parameters : value Return : Vector3 & function operator[] inline value_type & operator []( const int index ) Parameters : index Return : value_type& function operator[] inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type function dot static inline constexpr value_type dot ( const Vector3 & a , const Vector3 & b ) Parameters : a b Return : constexpr value_type function distance static inline value_type distance ( const Vector3 & a , const Vector3 & b ) Parameters : a b Return : value_type function lerp static inline constexpr Vector3 lerp ( const Vector3 & a , const Vector3 & b , const value_type t ) Parameters : a b t Return : constexpr Vector3 function zero static inline constexpr Vector3 zero () Return : Vector3 function forward static inline constexpr Vector3 forward () Return : Vector3 function back static inline constexpr Vector3 back () Return : Vector3 function up static inline constexpr Vector3 up () Return : Vector3 function down static inline constexpr Vector3 down () Return : Vector3 function right static inline constexpr Vector3 right () Return : Vector3 function left static inline constexpr Vector3 left () Return : Vector3 Public Attributes Documentation variable x value_type x ; variable y value_type y ; variable z value_type z ; Friends friend operator/ friend constexpr friend Vector3 operator / ( const Vector3 & v , const value_type value ); Parameters : value Return : Vector3 friend operator* friend constexpr friend Vector3 operator * ( const Vector3 & v , const Scaler s ); Parameters : v s Template Parameters : Scaler Return : constexpr Vector3 friend operator* friend constexpr friend Vector3 operator * ( const Scaler s , const Vector3 & v ); Parameters : s v Template Parameters : Scaler Return : constexpr Vector3 Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Vector3"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#cpp_roboticsvector3","text":"3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb More... #include <vector3.hpp>","title":"cpp_robotics::Vector3"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-types","text":"Name using FLOATING_TYPE value_type","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-functions","text":"Name Vector3 () =default Construct a new Vector 3 object. constexpr Vector3 ( value_type vx, value_type vy, value_type vz) Construct a new Vector 3 object. Vector3 (const Vector3 & v) =default Construct a new Vector 3 object. void set ( value_type vx, value_type vy, value_type vz) constexpr value_type dot (const Vector3 & v) const constexpr Vector3 cross (const Vector3 & v) const constexpr value_type norm_sq () const value_type norm () Get the Magnitude object. void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector3 get_normalized () Get the Normalized object. constexpr bool is_zero () const constexpr bool has_nan () const constexpr Vector3 lerp (const Vector3 & b, const value_type t) const constexpr Vector3 operator+ () const constexpr Vector3 operator- () const bool operator== (const Vector3 & v) const bool operator!= (const Vector3 & v) const constexpr Vector3 operator+ (const Vector3 & v) const constexpr Vector3 operator- (const Vector3 & v) const constexpr Vector3 & operator+= (const Vector3 & v) constexpr Vector3 & operator-= (const Vector3 & v) constexpr Vector3 & operator*= (const value_type value) constexpr Vector3 & operator/= (const value_type value) value_type & operator[] (const int index) constexpr value_type operator[] (const int index) const constexpr value_type dot (const Vector3 & a, const Vector3 & b) value_type distance (const Vector3 & a, const Vector3 & b) constexpr Vector3 lerp (const Vector3 & a, const Vector3 & b, const value_type t) constexpr Vector3 zero () constexpr Vector3 forward () constexpr Vector3 back () constexpr Vector3 up () constexpr Vector3 down () constexpr Vector3 right () constexpr Vector3 left ()","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-attributes","text":"Name value_type x value_type y value_type z","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friends","text":"Name constexpr friend Vector3 operator/ (const Vector3 & v, const value_type value) constexpr friend Vector3 operator* (const Vector3 & v, const Scaler s) constexpr friend Vector3 operator* (const Scaler s, const Vector3 & v)","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#detailed-description","text":"template < typename FLOATING_TYPE > struct cpp_robotics :: Vector3 ; 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#using-value_type","text":"using cpp_robotics :: Vector3 < FLOATING_TYPE >:: value_type = FLOATING_TYPE ;","title":"using value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3","text":"Vector3 () = default Construct a new Vector 3 object.","title":"function Vector3"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3_1","text":"inline constexpr Vector3 ( value_type vx , value_type vy , value_type vz ) Construct a new Vector 3 object. Parameters : vx vy vz","title":"function Vector3"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-vector3_2","text":"Vector3 ( const Vector3 & v ) = default Construct a new Vector 3 object. Parameters : v","title":"function Vector3"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-set","text":"inline void set ( value_type vx , value_type vy , value_type vz ) Parameters : vx vy vz","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-dot","text":"inline constexpr value_type dot ( const Vector3 & v ) const Parameters : v Return : constexpr value_type","title":"function dot"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-cross","text":"inline constexpr Vector3 cross ( const Vector3 & v ) const Parameters : v Return : constexpr Vector3","title":"function cross"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-norm_sq","text":"inline constexpr value_type norm_sq () const Return : constexpr value_type","title":"function norm_sq"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-norm","text":"inline value_type norm () Get the Magnitude object. Return : value_type","title":"function norm"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-normalize","text":"inline void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316","title":"function normalize"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-get_normalized","text":"inline Vector3 get_normalized () Get the Normalized object. Return : Vector3","title":"function get_normalized"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-is_zero","text":"inline constexpr bool is_zero () const Return : true false","title":"function is_zero"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-has_nan","text":"inline constexpr bool has_nan () const Return : true false","title":"function has_nan"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-lerp","text":"inline constexpr Vector3 lerp ( const Vector3 & b , const value_type t ) const Parameters : b t Return : constexpr Vector3","title":"function lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator","text":"inline constexpr Vector3 operator + () const Return : constexpr Vector3","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-","text":"inline constexpr Vector3 operator - () const Return : constexpr Vector3","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_1","text":"inline bool operator == ( const Vector3 & v ) const Parameters : v Return : true false","title":"function operator=="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_2","text":"inline bool operator != ( const Vector3 & v ) const Parameters : v Return : true false","title":"function operator!="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_3","text":"inline constexpr Vector3 operator + ( const Vector3 & v ) const Parameters : v Return : Vector3","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-_1","text":"inline constexpr Vector3 operator - ( const Vector3 & v ) const Parameters : v Return : Vector3","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_4","text":"inline constexpr Vector3 & operator += ( const Vector3 & v ) Parameters : v Return : Vector3 &","title":"function operator+="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator-_2","text":"inline constexpr Vector3 & operator -= ( const Vector3 & v ) Parameters : v Return : Vector3 &","title":"function operator-="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_5","text":"inline constexpr Vector3 & operator *= ( const value_type value ) Parameters : value Return : Vector3 &","title":"function operator*="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_6","text":"inline constexpr Vector3 & operator /= ( const value_type value ) Parameters : value Return : Vector3 &","title":"function operator/="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_7","text":"inline value_type & operator []( const int index ) Parameters : index Return : value_type&","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-operator_8","text":"inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-dot_1","text":"static inline constexpr value_type dot ( const Vector3 & a , const Vector3 & b ) Parameters : a b Return : constexpr value_type","title":"function dot"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-distance","text":"static inline value_type distance ( const Vector3 & a , const Vector3 & b ) Parameters : a b Return : value_type","title":"function distance"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-lerp_1","text":"static inline constexpr Vector3 lerp ( const Vector3 & a , const Vector3 & b , const value_type t ) Parameters : a b t Return : constexpr Vector3","title":"function lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-zero","text":"static inline constexpr Vector3 zero () Return : Vector3","title":"function zero"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-forward","text":"static inline constexpr Vector3 forward () Return : Vector3","title":"function forward"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-back","text":"static inline constexpr Vector3 back () Return : Vector3","title":"function back"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-up","text":"static inline constexpr Vector3 up () Return : Vector3","title":"function up"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-down","text":"static inline constexpr Vector3 down () Return : Vector3","title":"function down"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-right","text":"static inline constexpr Vector3 right () Return : Vector3","title":"function right"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#function-left","text":"static inline constexpr Vector3 left () Return : Vector3","title":"function left"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-x","text":"value_type x ;","title":"variable x"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-y","text":"value_type y ;","title":"variable y"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#variable-z","text":"value_type z ;","title":"variable z"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friends_1","text":"","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator","text":"friend constexpr friend Vector3 operator / ( const Vector3 & v , const value_type value ); Parameters : value Return : Vector3","title":"friend operator/"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator_1","text":"friend constexpr friend Vector3 operator * ( const Vector3 & v , const Scaler s ); Parameters : v s Template Parameters : Scaler Return : constexpr Vector3","title":"friend operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector3/#friend-operator_2","text":"friend constexpr friend Vector3 operator * ( const Scaler s , const Vector3 & v ); Parameters : s v Template Parameters : Scaler Return : constexpr Vector3 Updated on 2022-09-30 at 00:12:50 +0900","title":"friend operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/","text":"cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb More... #include <vector4.hpp> Public Types Name using FLOATING_TYPE value_type Public Functions Name Vector4 () =default Construct a new Vector 4 object. constexpr Vector4 ( value_type vx, value_type vy, value_type vz, value_type vw) Construct a new Vector 4 object. Vector4 (const Vector4 & v) =default Construct a new Vector 4 object. void set ( value_type vx, value_type vy, value_type vz, value_type vw) constexpr value_type dot (const Vector4 & v) const constexpr value_type norm_sq () const value_type norm () Get the Magnitude object. void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector4 get_normalized () Get the Normalized object. constexpr bool is_zero () const constexpr bool has_nan () const constexpr Vector4 lerp (const Vector4 & b, const value_type t) const constexpr Vector4 operator+ () const constexpr Vector4 operator- () const bool operator== (const Vector4 & v) const bool operator!= (const Vector4 & v) const constexpr Vector4 operator+ (const Vector4 & v) const constexpr Vector4 operator- (const Vector4 & v) const constexpr Vector4 operator* (const value_type value) const constexpr Vector4 operator/ (const value_type value) const constexpr Vector4 & operator+= (const Vector4 & v) constexpr Vector4 & operator-= (const Vector4 & v) constexpr Vector4 & operator*= (const value_type value) constexpr Vector4 & operator/= (const value_type value) value_type & operator[] (const int index) constexpr value_type operator[] (const int index) const constexpr value_type dot (const Vector4 & a, const Vector4 & b) value_type distance (const Vector4 & a, const Vector4 & b) constexpr Vector4 lerp (const Vector4 & a, const Vector4 & b, const value_type t) constexpr Vector4 zero () Public Attributes Name value_type x value_type y value_type z value_type w Friends Name constexpr friend Vector4 operator* (Scaler s, Vector4 v) Detailed Description template < typename FLOATING_TYPE > struct cpp_robotics :: Vector4 ; 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb Public Types Documentation using value_type using cpp_robotics :: Vector4 < FLOATING_TYPE >:: value_type = FLOATING_TYPE ; Public Functions Documentation function Vector4 Vector4 () = default Construct a new Vector 4 object. function Vector4 inline constexpr Vector4 ( value_type vx , value_type vy , value_type vz , value_type vw ) Construct a new Vector 4 object. Parameters : vx vy vz vw function Vector4 Vector4 ( const Vector4 & v ) = default Construct a new Vector 4 object. Parameters : v function set inline void set ( value_type vx , value_type vy , value_type vz , value_type vw ) Parameters : vx vy vz vw function dot inline constexpr value_type dot ( const Vector4 & v ) const Parameters : v Return : constexpr value_type function norm_sq inline constexpr value_type norm_sq () const Return : constexpr value_type function norm inline value_type norm () Get the Magnitude object. Return : value_type function normalize inline void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 function get_normalized inline Vector4 get_normalized () Get the Normalized object. Return : Vector4 function is_zero inline constexpr bool is_zero () const Return : true false function has_nan inline constexpr bool has_nan () const Return : true false function lerp inline constexpr Vector4 lerp ( const Vector4 & b , const value_type t ) const Parameters : b t Return : constexpr Vector4 function operator+ inline constexpr Vector4 operator + () const Return : constexpr Vector4 function operator- inline constexpr Vector4 operator - () const Return : constexpr Vector4 function operator== inline bool operator == ( const Vector4 & v ) const Parameters : v Return : true false function operator!= inline bool operator != ( const Vector4 & v ) const Parameters : v Return : true false function operator+ inline constexpr Vector4 operator + ( const Vector4 & v ) const Parameters : v Return : Vector4 function operator- inline constexpr Vector4 operator - ( const Vector4 & v ) const Parameters : v Return : Vector4 function operator* inline constexpr Vector4 operator * ( const value_type value ) const Parameters : value Return : Vector4 function operator/ inline constexpr Vector4 operator / ( const value_type value ) const Parameters : value Return : Vector4 function operator+= inline constexpr Vector4 & operator += ( const Vector4 & v ) Parameters : v Return : Vector4 & function operator-= inline constexpr Vector4 & operator -= ( const Vector4 & v ) Parameters : v Return : Vector4 & function operator*= inline constexpr Vector4 & operator *= ( const value_type value ) Parameters : value Return : Vector4 & function operator/= inline constexpr Vector4 & operator /= ( const value_type value ) Parameters : value Return : Vector4 & function operator[] inline value_type & operator []( const int index ) Parameters : index Return : value_type& function operator[] inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type function dot static inline constexpr value_type dot ( const Vector4 & a , const Vector4 & b ) Parameters : a b Return : constexpr value_type function distance static inline value_type distance ( const Vector4 & a , const Vector4 & b ) Parameters : a b Return : value_type function lerp static inline constexpr Vector4 lerp ( const Vector4 & a , const Vector4 & b , const value_type t ) Parameters : a b t Return : constexpr Vector4 function zero static inline constexpr Vector4 zero () Return : Vector4 Public Attributes Documentation variable x value_type x ; variable y value_type y ; variable z value_type z ; variable w value_type w ; Friends friend operator* friend constexpr friend Vector4 operator * ( Scaler s , Vector4 v ); Parameters : s v Template Parameters : Scaler Return : constexpr Vector4 Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::Vector4"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#cpp_roboticsvector4","text":"4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb More... #include <vector4.hpp>","title":"cpp_robotics::Vector4"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-types","text":"Name using FLOATING_TYPE value_type","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-functions","text":"Name Vector4 () =default Construct a new Vector 4 object. constexpr Vector4 ( value_type vx, value_type vy, value_type vz, value_type vw) Construct a new Vector 4 object. Vector4 (const Vector4 & v) =default Construct a new Vector 4 object. void set ( value_type vx, value_type vy, value_type vz, value_type vw) constexpr value_type dot (const Vector4 & v) const constexpr value_type norm_sq () const value_type norm () Get the Magnitude object. void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316 Vector4 get_normalized () Get the Normalized object. constexpr bool is_zero () const constexpr bool has_nan () const constexpr Vector4 lerp (const Vector4 & b, const value_type t) const constexpr Vector4 operator+ () const constexpr Vector4 operator- () const bool operator== (const Vector4 & v) const bool operator!= (const Vector4 & v) const constexpr Vector4 operator+ (const Vector4 & v) const constexpr Vector4 operator- (const Vector4 & v) const constexpr Vector4 operator* (const value_type value) const constexpr Vector4 operator/ (const value_type value) const constexpr Vector4 & operator+= (const Vector4 & v) constexpr Vector4 & operator-= (const Vector4 & v) constexpr Vector4 & operator*= (const value_type value) constexpr Vector4 & operator/= (const value_type value) value_type & operator[] (const int index) constexpr value_type operator[] (const int index) const constexpr value_type dot (const Vector4 & a, const Vector4 & b) value_type distance (const Vector4 & a, const Vector4 & b) constexpr Vector4 lerp (const Vector4 & a, const Vector4 & b, const value_type t) constexpr Vector4 zero ()","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-attributes","text":"Name value_type x value_type y value_type z value_type w","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friends","text":"Name constexpr friend Vector4 operator* (Scaler s, Vector4 v)","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#detailed-description","text":"template < typename FLOATING_TYPE > struct cpp_robotics :: Vector4 ; 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#using-value_type","text":"using cpp_robotics :: Vector4 < FLOATING_TYPE >:: value_type = FLOATING_TYPE ;","title":"using value_type"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4","text":"Vector4 () = default Construct a new Vector 4 object.","title":"function Vector4"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4_1","text":"inline constexpr Vector4 ( value_type vx , value_type vy , value_type vz , value_type vw ) Construct a new Vector 4 object. Parameters : vx vy vz vw","title":"function Vector4"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-vector4_2","text":"Vector4 ( const Vector4 & v ) = default Construct a new Vector 4 object. Parameters : v","title":"function Vector4"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-set","text":"inline void set ( value_type vx , value_type vy , value_type vz , value_type vw ) Parameters : vx vy vz vw","title":"function set"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-dot","text":"inline constexpr value_type dot ( const Vector4 & v ) const Parameters : v Return : constexpr value_type","title":"function dot"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-norm_sq","text":"inline constexpr value_type norm_sq () const Return : constexpr value_type","title":"function norm_sq"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-norm","text":"inline value_type norm () Get the Magnitude object. Return : value_type","title":"function norm"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-normalize","text":"inline void normalize () \u5358\u4f4d\u30d9\u30af\u30c8\u30eb\u5316","title":"function normalize"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-get_normalized","text":"inline Vector4 get_normalized () Get the Normalized object. Return : Vector4","title":"function get_normalized"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-is_zero","text":"inline constexpr bool is_zero () const Return : true false","title":"function is_zero"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-has_nan","text":"inline constexpr bool has_nan () const Return : true false","title":"function has_nan"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-lerp","text":"inline constexpr Vector4 lerp ( const Vector4 & b , const value_type t ) const Parameters : b t Return : constexpr Vector4","title":"function lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator","text":"inline constexpr Vector4 operator + () const Return : constexpr Vector4","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-","text":"inline constexpr Vector4 operator - () const Return : constexpr Vector4","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_1","text":"inline bool operator == ( const Vector4 & v ) const Parameters : v Return : true false","title":"function operator=="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_2","text":"inline bool operator != ( const Vector4 & v ) const Parameters : v Return : true false","title":"function operator!="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_3","text":"inline constexpr Vector4 operator + ( const Vector4 & v ) const Parameters : v Return : Vector4","title":"function operator+"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-_1","text":"inline constexpr Vector4 operator - ( const Vector4 & v ) const Parameters : v Return : Vector4","title":"function operator-"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_4","text":"inline constexpr Vector4 operator * ( const value_type value ) const Parameters : value Return : Vector4","title":"function operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_5","text":"inline constexpr Vector4 operator / ( const value_type value ) const Parameters : value Return : Vector4","title":"function operator/"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_6","text":"inline constexpr Vector4 & operator += ( const Vector4 & v ) Parameters : v Return : Vector4 &","title":"function operator+="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator-_2","text":"inline constexpr Vector4 & operator -= ( const Vector4 & v ) Parameters : v Return : Vector4 &","title":"function operator-="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_7","text":"inline constexpr Vector4 & operator *= ( const value_type value ) Parameters : value Return : Vector4 &","title":"function operator*="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_8","text":"inline constexpr Vector4 & operator /= ( const value_type value ) Parameters : value Return : Vector4 &","title":"function operator/="},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_9","text":"inline value_type & operator []( const int index ) Parameters : index Return : value_type&","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-operator_10","text":"inline constexpr value_type operator []( const int index ) const Parameters : index Return : constexpr value_type","title":"function operator[]"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-dot_1","text":"static inline constexpr value_type dot ( const Vector4 & a , const Vector4 & b ) Parameters : a b Return : constexpr value_type","title":"function dot"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-distance","text":"static inline value_type distance ( const Vector4 & a , const Vector4 & b ) Parameters : a b Return : value_type","title":"function distance"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-lerp_1","text":"static inline constexpr Vector4 lerp ( const Vector4 & a , const Vector4 & b , const value_type t ) Parameters : a b t Return : constexpr Vector4","title":"function lerp"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#function-zero","text":"static inline constexpr Vector4 zero () Return : Vector4","title":"function zero"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-x","text":"value_type x ;","title":"variable x"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-y","text":"value_type y ;","title":"variable y"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-z","text":"value_type z ;","title":"variable z"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#variable-w","text":"value_type w ;","title":"variable w"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friends_1","text":"","title":"Friends"},{"location":"doxybook/Classes/structcpp__robotics_1_1Vector4/#friend-operator","text":"friend constexpr friend Vector4 operator * ( Scaler s , Vector4 v ); Parameters : s v Template Parameters : Scaler Return : constexpr Vector4 Updated on 2022-09-30 at 00:12:50 +0900","title":"friend operator*"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/","text":"cpp_robotics::grid_path_planning_utils::GridNode #include <grid_path_planning_utils.hpp> Public Functions Name bool operator== (const GridNode & o) bool operator== (const Eigen::Vector2i & o) bool operator< (const GridNode & o) int score () Public Attributes Name Eigen::Vector2i pos Eigen::Vector2i parent int cost int hcost Public Functions Documentation function operator== inline bool operator == ( const GridNode & o ) function operator== inline bool operator == ( const Eigen :: Vector2i & o ) function operator< inline bool operator < ( const GridNode & o ) function score inline int score () Public Attributes Documentation variable pos Eigen :: Vector2i pos ; variable parent Eigen :: Vector2i parent ; variable cost int cost ; variable hcost int hcost ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::grid_path_planning_utils::GridNode"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#cpp_roboticsgrid_path_planning_utilsgridnode","text":"#include <grid_path_planning_utils.hpp>","title":"cpp_robotics::grid_path_planning_utils::GridNode"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-functions","text":"Name bool operator== (const GridNode & o) bool operator== (const Eigen::Vector2i & o) bool operator< (const GridNode & o) int score ()","title":"Public Functions"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-attributes","text":"Name Eigen::Vector2i pos Eigen::Vector2i parent int cost int hcost","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator","text":"inline bool operator == ( const GridNode & o )","title":"function operator=="},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator_1","text":"inline bool operator == ( const Eigen :: Vector2i & o )","title":"function operator=="},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-operator_2","text":"inline bool operator < ( const GridNode & o )","title":"function operator&lt;"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#function-score","text":"inline int score ()","title":"function score"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-pos","text":"Eigen :: Vector2i pos ;","title":"variable pos"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-parent","text":"Eigen :: Vector2i parent ;","title":"variable parent"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-cost","text":"int cost ;","title":"variable cost"},{"location":"doxybook/Classes/structcpp__robotics_1_1grid__path__planning__utils_1_1GridNode/#variable-hcost","text":"int hcost ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable hcost"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/","text":"cpp_robotics::spline::spline_c #include <spline.hpp> Public Attributes Name Vector4d xb Vector4d yb Public Attributes Documentation variable xb Vector4d xb ; variable yb Vector4d yb ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::spline::spline_c"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#cpp_roboticssplinespline_c","text":"#include <spline.hpp>","title":"cpp_robotics::spline::spline_c"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#public-attributes","text":"Name Vector4d xb Vector4d yb","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#variable-xb","text":"Vector4d xb ;","title":"variable xb"},{"location":"doxybook/Classes/structcpp__robotics_1_1spline_1_1spline__c/#variable-yb","text":"Vector4d yb ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable yb"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/","text":"cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 More... #include <unit_core.hpp> Inherits from PrefixBase Public Types Name using Prefix < N, D > type Public Attributes Name constexpr uint32_t num constexpr uint32_t den Detailed Description template < uint32_t N , uint32_t D > struct cpp_robotics :: unit :: Prefix ; \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 Template Parameters : N D Public Types Documentation using type using cpp_robotics :: unit :: Prefix < N , D >:: type = Prefix < N , D > ; Public Attributes Documentation variable num static constexpr uint32_t num = N / std :: gcd ( N , D ); variable den static constexpr uint32_t den = D / std :: gcd ( N , D ); Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::Prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#cpp_roboticsunitprefix","text":"\u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 More... #include <unit_core.hpp> Inherits from PrefixBase","title":"cpp_robotics::unit::Prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-types","text":"Name using Prefix < N, D > type","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-attributes","text":"Name constexpr uint32_t num constexpr uint32_t den","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#detailed-description","text":"template < uint32_t N , uint32_t D > struct cpp_robotics :: unit :: Prefix ; \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 Template Parameters : N D","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#using-type","text":"using cpp_robotics :: unit :: Prefix < N , D >:: type = Prefix < N , D > ;","title":"using type"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#variable-num","text":"static constexpr uint32_t num = N / std :: gcd ( N , D );","title":"variable num"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1Prefix/#variable-den","text":"static constexpr uint32_t den = D / std :: gcd ( N , D ); Updated on 2022-09-30 at 00:12:50 +0900","title":"variable den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/","text":"cpp_robotics::unit::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 More... #include <unit_core.hpp> Public Attributes Name constexpr int dim1 \u30e1\u30fc\u30c8\u30eb(m) constexpr int dim2 \u30ad\u30ed\u30b0\u30e9\u30e0(kg) constexpr int dim3 \u79d2(s) constexpr int dim4 \u30a2\u30f3\u30da\u30a2(A) constexpr int dim5 \u30b1\u30eb\u30d3\u30f3(K) constexpr int dim6 \u30e2\u30eb(mol) constexpr int dim7 \u30ab\u30f3\u30c7\u30e9(cd) Detailed Description template < int DIM1 , int DIM2 , int DIM3 , int DIM4 , int DIM5 , int DIM6 , int DIM7 > struct cpp_robotics :: unit :: UnitType ; SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 Public Attributes Documentation variable dim1 static constexpr int dim1 = DIM1 ; \u30e1\u30fc\u30c8\u30eb(m) variable dim2 static constexpr int dim2 = DIM2 ; \u30ad\u30ed\u30b0\u30e9\u30e0(kg) variable dim3 static constexpr int dim3 = DIM3 ; \u79d2(s) variable dim4 static constexpr int dim4 = DIM4 ; \u30a2\u30f3\u30da\u30a2(A) variable dim5 static constexpr int dim5 = DIM5 ; \u30b1\u30eb\u30d3\u30f3(K) variable dim6 static constexpr int dim6 = DIM6 ; \u30e2\u30eb(mol) variable dim7 static constexpr int dim7 = DIM7 ; \u30ab\u30f3\u30c7\u30e9(cd) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::UnitType"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#cpp_roboticsunitunittype","text":"SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 More... #include <unit_core.hpp>","title":"cpp_robotics::unit::UnitType"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#public-attributes","text":"Name constexpr int dim1 \u30e1\u30fc\u30c8\u30eb(m) constexpr int dim2 \u30ad\u30ed\u30b0\u30e9\u30e0(kg) constexpr int dim3 \u79d2(s) constexpr int dim4 \u30a2\u30f3\u30da\u30a2(A) constexpr int dim5 \u30b1\u30eb\u30d3\u30f3(K) constexpr int dim6 \u30e2\u30eb(mol) constexpr int dim7 \u30ab\u30f3\u30c7\u30e9(cd)","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#detailed-description","text":"template < int DIM1 , int DIM2 , int DIM3 , int DIM4 , int DIM5 , int DIM6 , int DIM7 > struct cpp_robotics :: unit :: UnitType ; SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim1","text":"static constexpr int dim1 = DIM1 ; \u30e1\u30fc\u30c8\u30eb(m)","title":"variable dim1"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim2","text":"static constexpr int dim2 = DIM2 ; \u30ad\u30ed\u30b0\u30e9\u30e0(kg)","title":"variable dim2"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim3","text":"static constexpr int dim3 = DIM3 ; \u79d2(s)","title":"variable dim3"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim4","text":"static constexpr int dim4 = DIM4 ; \u30a2\u30f3\u30da\u30a2(A)","title":"variable dim4"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim5","text":"static constexpr int dim5 = DIM5 ; \u30b1\u30eb\u30d3\u30f3(K)","title":"variable dim5"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim6","text":"static constexpr int dim6 = DIM6 ; \u30e2\u30eb(mol)","title":"variable dim6"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1UnitType/#variable-dim7","text":"static constexpr int dim7 = DIM7 ; \u30ab\u30f3\u30c7\u30e9(cd) Updated on 2022-09-30 at 00:12:50 +0900","title":"variable dim7"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/","text":"cpp_robotics::unit::prefix::pfx_div More... #include <unit_core.hpp> Public Types Name using Prefix < raw_num , raw_den > prefix Public Attributes Name constexpr uint32_t raw_num constexpr uint32_t raw_den Detailed Description template < class P1 , class P2 > struct cpp_robotics :: unit :: prefix :: pfx_div ; Public Types Documentation using prefix using cpp_robotics :: unit :: prefix :: pfx_div < P1 , P2 >:: prefix = Prefix < raw_num , raw_den > ; Public Attributes Documentation variable raw_num static constexpr uint32_t raw_num = P1 :: num * P2 :: den ; variable raw_den static constexpr uint32_t raw_den = P1 :: den * P2 :: num ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::prefix::pfx_div"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#cpp_roboticsunitprefixpfx_div","text":"More... #include <unit_core.hpp>","title":"cpp_robotics::unit::prefix::pfx_div"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-types","text":"Name using Prefix < raw_num , raw_den > prefix","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#detailed-description","text":"template < class P1 , class P2 > struct cpp_robotics :: unit :: prefix :: pfx_div ;","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#using-prefix","text":"using cpp_robotics :: unit :: prefix :: pfx_div < P1 , P2 >:: prefix = Prefix < raw_num , raw_den > ;","title":"using prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#variable-raw_num","text":"static constexpr uint32_t raw_num = P1 :: num * P2 :: den ;","title":"variable raw_num"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__div/#variable-raw_den","text":"static constexpr uint32_t raw_den = P1 :: den * P2 :: num ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/","text":"cpp_robotics::unit::prefix::pfx_inv More... #include <unit_core.hpp> Public Types Name using Prefix < P::den, P::num > prefix Detailed Description template < class P > struct cpp_robotics :: unit :: prefix :: pfx_inv ; Public Types Documentation using prefix using cpp_robotics :: unit :: prefix :: pfx_inv < P >:: prefix = Prefix < P :: den , P :: num > ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::prefix::pfx_inv"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#cpp_roboticsunitprefixpfx_inv","text":"More... #include <unit_core.hpp>","title":"cpp_robotics::unit::prefix::pfx_inv"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#public-types","text":"Name using Prefix < P::den, P::num > prefix","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#detailed-description","text":"template < class P > struct cpp_robotics :: unit :: prefix :: pfx_inv ;","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__inv/#using-prefix","text":"using cpp_robotics :: unit :: prefix :: pfx_inv < P >:: prefix = Prefix < P :: den , P :: num > ; Updated on 2022-09-30 at 00:12:50 +0900","title":"using prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/","text":"cpp_robotics::unit::prefix::pfx_min More... #include <unit_core.hpp> Public Types Name using Prefix < raw_num , raw_den > prefix Public Attributes Name constexpr uint32_t raw_num constexpr uint32_t raw_den Detailed Description template < class P1 , class P2 > struct cpp_robotics :: unit :: prefix :: pfx_min ; Public Types Documentation using prefix using cpp_robotics :: unit :: prefix :: pfx_min < P1 , P2 >:: prefix = Prefix < raw_num , raw_den > ; Public Attributes Documentation variable raw_num static constexpr uint32_t raw_num = std :: min ( P1 :: num * P2 :: den , P2 :: num * P1 :: den ); variable raw_den static constexpr uint32_t raw_den = P1 :: den * P2 :: den ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::prefix::pfx_min"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#cpp_roboticsunitprefixpfx_min","text":"More... #include <unit_core.hpp>","title":"cpp_robotics::unit::prefix::pfx_min"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-types","text":"Name using Prefix < raw_num , raw_den > prefix","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#detailed-description","text":"template < class P1 , class P2 > struct cpp_robotics :: unit :: prefix :: pfx_min ;","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#using-prefix","text":"using cpp_robotics :: unit :: prefix :: pfx_min < P1 , P2 >:: prefix = Prefix < raw_num , raw_den > ;","title":"using prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#variable-raw_num","text":"static constexpr uint32_t raw_num = std :: min ( P1 :: num * P2 :: den , P2 :: num * P1 :: den );","title":"variable raw_num"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__min/#variable-raw_den","text":"static constexpr uint32_t raw_den = P1 :: den * P2 :: den ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/","text":"cpp_robotics::unit::prefix::pfx_mul More... #include <unit_core.hpp> Public Types Name using Prefix < raw_num , raw_den > prefix Public Attributes Name constexpr uint32_t raw_num constexpr uint32_t raw_den Detailed Description template < class P1 , class P2 > struct cpp_robotics :: unit :: prefix :: pfx_mul ; Public Types Documentation using prefix using cpp_robotics :: unit :: prefix :: pfx_mul < P1 , P2 >:: prefix = Prefix < raw_num , raw_den > ; Public Attributes Documentation variable raw_num static constexpr uint32_t raw_num = P2 :: num * P1 :: num ; variable raw_den static constexpr uint32_t raw_den = P2 :: den * P1 :: den ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::prefix::pfx_mul"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#cpp_roboticsunitprefixpfx_mul","text":"More... #include <unit_core.hpp>","title":"cpp_robotics::unit::prefix::pfx_mul"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-types","text":"Name using Prefix < raw_num , raw_den > prefix","title":"Public Types"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-attributes","text":"Name constexpr uint32_t raw_num constexpr uint32_t raw_den","title":"Public Attributes"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#detailed-description","text":"template < class P1 , class P2 > struct cpp_robotics :: unit :: prefix :: pfx_mul ;","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#using-prefix","text":"using cpp_robotics :: unit :: prefix :: pfx_mul < P1 , P2 >:: prefix = Prefix < raw_num , raw_den > ;","title":"using prefix"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#variable-raw_num","text":"static constexpr uint32_t raw_num = P2 :: num * P1 :: num ;","title":"variable raw_num"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1prefix_1_1pfx__mul/#variable-raw_den","text":"static constexpr uint32_t raw_den = P2 :: den * P1 :: den ; Updated on 2022-09-30 at 00:12:50 +0900","title":"variable raw_den"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag/","text":"cpp_robotics::unit::tag::is_normal_tag More... #include <unit_core.hpp> Inherits from false_type Detailed Description template < int Tag > struct cpp_robotics :: unit :: tag :: is_normal_tag ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::tag::is_normal_tag"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag/#cpp_roboticsunittagis_normal_tag","text":"More... #include <unit_core.hpp> Inherits from false_type","title":"cpp_robotics::unit::tag::is_normal_tag"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag/#detailed-description","text":"template < int Tag > struct cpp_robotics :: unit :: tag :: is_normal_tag ; Updated on 2022-09-30 at 00:12:50 +0900","title":"Detailed Description"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3-1_01_4/","text":"cpp_robotics::unit::tag::is_normal_tag<-1 > #include <unit_core.hpp> Inherits from true_type Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::tag::is_normal_tag<-1 >"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3-1_01_4/#cpp_roboticsunittagis_normal_tag-1","text":"#include <unit_core.hpp> Inherits from true_type Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::tag::is_normal_tag&lt;-1 &gt;"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3_010_01_4/","text":"cpp_robotics::unit::tag::is_normal_tag< 0 > #include <unit_core.hpp> Inherits from true_type Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::tag::is_normal_tag< 0 >"},{"location":"doxybook/Classes/structcpp__robotics_1_1unit_1_1tag_1_1is__normal__tag_3_010_01_4/#cpp_roboticsunittagis_normal_tag-0","text":"#include <unit_core.hpp> Inherits from true_type Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::tag::is_normal_tag&lt; 0 &gt;"},{"location":"doxybook/Files/a__star_8hpp/","text":"include/cpp_robotics/path_planning/a_star.hpp Namespaces Name cpp_robotics Source code #pragma once #include <vector> #include <list> #include <Eigen/Dense> #include \"grid_path_planning_utils.hpp\" namespace cpp_robotics { static std :: vector < Eigen :: Vector2i > a_star ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) { using namespace grid_path_planning_utils ; if ( not contain_in_map ( map , start ) || not contain_in_map ( map , end )) return { start }; const static std :: array < Eigen :: Vector2i , 8 > nb = { Eigen :: Vector2i { 1 , 0 }, { 0 , 1 }, { -1 , 0 }, { 0 , -1 }, { 1 , 1 }, { -1 , 1 }, { -1 , -1 }, { 1 , -1 }}; std :: list < GridNode > open ; std :: list < GridNode > closed ; GridNode sn ; sn . pos = start ; sn . parent = start ; sn . cost = 0 ; sn . hcost = dist ( start , end ); // first step open open . push_back ( sn ); while ( not open . empty ()) { // \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u9078\u3076 // Todo: \u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u308c\u3070\u8907\u6570\u958b\u304f? // \u30b4\u30fc\u30eb\u306b\u5230\u9054\u3059\u308b\u76f4\u524d\u306b\u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u3063\u3066\u3082\u305d\u3093\u306a\u306b\u554f\u984c\u306a\u3044\u6c17\u3082\u3059\u308b auto min_itr = open . begin (); int min_score = open . front (). score (); for ( auto i = open . begin (); i != open . end (); i ++ ) { if ( min_score > ( * i ). score ()) { min_itr = i ; min_score = ( * i ). score (); } } // \u30b9\u30b3\u30a2\u6700\u5c0f\u30ce\u30fc\u30c9\u3092\u57fa\u6e96\u306b\u3059\u308b GridNode n = * min_itr ; open . erase ( min_itr ); // \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u30af\u30ed\u30fc\u30ba closed . push_back ( n ); // \u57fa\u6e96\u30ce\u30fc\u30c9\u304b\u30898\u65b9\u5411\u30aa\u30fc\u30d7\u30f3 for ( size_t i = 0 ; i < 8 ; i ++ ) { Eigen :: Vector2i np = n . pos + nb [ i ]; if ( np == end ) { std :: vector < Eigen :: Vector2i > path ; path . push_back ( np ); // closed\u304b\u3089\u9006\u9806\u306b\u30d1\u30b9\u3092\u53d6\u5f97 Eigen :: Vector2i parent = closed . back (). pos ; for ( auto it = closed . rbegin (); it != closed . rend (); it ++ ) { if (( * it ). pos == parent ) { path . insert ( path . begin (), ( * it ). pos ); parent = ( * it ). parent ; } } return path ; } if ( is_correct_step ( np , map )) { GridNode nn ; nn . pos = np ; nn . parent = n . pos ; nn . cost = n . cost + 3 ; // \uff18\u65b9\u5411\u3069\u306e\u79fb\u52d5\u3067\u3082\u30b3\u30b9\u30c8\u306f\u540c\u7b49\u3068\u3059\u308b Eigen :: Vector2i d1 = n . pos - n . parent , d2 = nn . pos - nn . parent ; if ( d1 ( 0 ) != d2 ( 0 )) nn . cost ++ ; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059 if ( d1 ( 1 ) != d2 ( 1 )) nn . cost ++ ; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059 nn . hcost = dist ( np , end ); if ( not exist ( open , closed , nn . pos , nn . cost + nn . hcost )) { open . push_front ( nn ); } } } } return {}; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning/a_star.hpp"},{"location":"doxybook/Files/a__star_8hpp/#includecpp_roboticspath_planninga_starhpp","text":"","title":"include/cpp_robotics/path_planning/a_star.hpp"},{"location":"doxybook/Files/a__star_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/a__star_8hpp/#source-code","text":"#pragma once #include <vector> #include <list> #include <Eigen/Dense> #include \"grid_path_planning_utils.hpp\" namespace cpp_robotics { static std :: vector < Eigen :: Vector2i > a_star ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) { using namespace grid_path_planning_utils ; if ( not contain_in_map ( map , start ) || not contain_in_map ( map , end )) return { start }; const static std :: array < Eigen :: Vector2i , 8 > nb = { Eigen :: Vector2i { 1 , 0 }, { 0 , 1 }, { -1 , 0 }, { 0 , -1 }, { 1 , 1 }, { -1 , 1 }, { -1 , -1 }, { 1 , -1 }}; std :: list < GridNode > open ; std :: list < GridNode > closed ; GridNode sn ; sn . pos = start ; sn . parent = start ; sn . cost = 0 ; sn . hcost = dist ( start , end ); // first step open open . push_back ( sn ); while ( not open . empty ()) { // \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u9078\u3076 // Todo: \u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u308c\u3070\u8907\u6570\u958b\u304f? // \u30b4\u30fc\u30eb\u306b\u5230\u9054\u3059\u308b\u76f4\u524d\u306b\u6700\u5c0f\u30b9\u30b3\u30a2\u304c\u8907\u6570\u3042\u3063\u3066\u3082\u305d\u3093\u306a\u306b\u554f\u984c\u306a\u3044\u6c17\u3082\u3059\u308b auto min_itr = open . begin (); int min_score = open . front (). score (); for ( auto i = open . begin (); i != open . end (); i ++ ) { if ( min_score > ( * i ). score ()) { min_itr = i ; min_score = ( * i ). score (); } } // \u30b9\u30b3\u30a2\u6700\u5c0f\u30ce\u30fc\u30c9\u3092\u57fa\u6e96\u306b\u3059\u308b GridNode n = * min_itr ; open . erase ( min_itr ); // \u57fa\u6e96\u30ce\u30fc\u30c9\u3092\u30af\u30ed\u30fc\u30ba closed . push_back ( n ); // \u57fa\u6e96\u30ce\u30fc\u30c9\u304b\u30898\u65b9\u5411\u30aa\u30fc\u30d7\u30f3 for ( size_t i = 0 ; i < 8 ; i ++ ) { Eigen :: Vector2i np = n . pos + nb [ i ]; if ( np == end ) { std :: vector < Eigen :: Vector2i > path ; path . push_back ( np ); // closed\u304b\u3089\u9006\u9806\u306b\u30d1\u30b9\u3092\u53d6\u5f97 Eigen :: Vector2i parent = closed . back (). pos ; for ( auto it = closed . rbegin (); it != closed . rend (); it ++ ) { if (( * it ). pos == parent ) { path . insert ( path . begin (), ( * it ). pos ); parent = ( * it ). parent ; } } return path ; } if ( is_correct_step ( np , map )) { GridNode nn ; nn . pos = np ; nn . parent = n . pos ; nn . cost = n . cost + 3 ; // \uff18\u65b9\u5411\u3069\u306e\u79fb\u52d5\u3067\u3082\u30b3\u30b9\u30c8\u306f\u540c\u7b49\u3068\u3059\u308b Eigen :: Vector2i d1 = n . pos - n . parent , d2 = nn . pos - nn . parent ; if ( d1 ( 0 ) != d2 ( 0 )) nn . cost ++ ; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059 if ( d1 ( 1 ) != d2 ( 1 )) nn . cost ++ ; // \u5c48\u6298\u3059\u308b\u5834\u5408\u306f\u30b3\u30b9\u30c8\u3092\u5897\u3084\u3059 nn . hcost = dist ( np , end ); if ( not exist ( open , closed , nn . pos , nn . cost + nn . hcost )) { open . push_front ( nn ); } } } } return {}; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/","text":"include/cpp_robotics/filter/acceleration_limit_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) Source code #pragma once #include <cmath> #include <optional> #include <tuple> #include <algorithm> #include \"integrator.hpp\" namespace cpp_robotics { namespace internal { class DiffTri { public : DiffTri ( double Ts , double gpd ) : Ts_ ( Ts ), gpd_ ( gpd ) { reset (); } void reset () { u1_ = u2_ = 0 ; diff21_ = diff22_ = 0 ; diff11_ = diff12_ = 0 ; pass2_ = pass1_ = 0 ; } std :: tuple < double , double , double > filtering ( double u ) { const double tau_ = 1 / gpd_ ; const double y1_coeff = ( -4 * tau_ * tau_ + 2 * Ts_ * Ts_ ); const double y2_coeff = ( 2 * tau_ * tau_ - 4 * tau_ * Ts_ + Ts_ * Ts_ ); const double y_coeff = 2 * tau_ * tau_ + 4 * tau_ * Ts_ + Ts_ * Ts_ ; // double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_; // double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_; const double prev_diff2 = y1_coeff * diff21_ + y2_coeff * diff22_ ; const double prev_diff1 = y1_coeff * diff11_ + y2_coeff * diff12_ ; const double prev_pass = y1_coeff * pass1_ + y2_coeff * pass2_ ; double diff2 = ( 4 * ( u -2 * u1_ + u2_ ) - prev_diff2 ) / y_coeff ; double diff1 = ( 2 * Ts_ * ( u - u2_ ) - prev_diff1 ) / y_coeff ; double pass = ( Ts_ * Ts_ * ( u + 2 * u1_ + u2_ ) - prev_pass ) / y_coeff ; u2_ = u1_ ; u1_ = u ; diff22_ = diff21_ ; diff21_ = diff2 ; diff12_ = diff11_ ; diff11_ = diff1 ; pass2_ = pass1_ ; pass1_ = pass ; return { diff2 , diff1 , pass }; } private : double Ts_ , gpd_ ; double u1_ , u2_ ; double diff21_ , diff22_ ; double diff11_ , diff12_ ; double pass1_ , pass2_ ; }; } class AccelerationLimitFilter { public : AccelerationLimitFilter ( double acc_max , double Ts , double gpd , double Kx , double Kv , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) : acc_max_ ( acc_max ), Ts_ ( Ts ), gpd_ ( gpd ), Kx_ ( Kx ), Kv_ ( Kv ), limit_ ( limit ), diff_ ( Ts , gpd ), vel_integ_ ( Ts ), pos_integ_ ( Ts ) { reset (); } // \u76ee\u5b89\u3068\u3057\u3066\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3001\u52a0\u901f\u5ea6\u306b\u3088\u3063\u3066\u30aa\u30fc\u30d0\u30fc\u30b7\u30e5\u30fc\u30c8\u91cf\u304c\u5909\u308f\u308b\u306e\u3067\u6ce8\u610f AccelerationLimitFilter ( double acc_max , double Ts , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) : AccelerationLimitFilter ( acc_max , Ts , 1 / Ts , 1000.0 / Ts , 500.0 / Ts / std :: sqrt ( acc_max ), limit ) { } virtual void reset () { y1_ = 0 ; v1_ = 0 ; diff_ . reset (); vel_integ_ . reset (); pos_integ_ . reset (); } virtual double filtering ( double u ) { auto [ diff2 , diff1 , pass ] = diff_ . filtering ( u ); double acc = diff2 - ( Kx_ * ( y1_ - pass )) - ( Kv_ * ( v1_ - diff1 )); acc = std :: clamp ( acc , - acc_max_ , acc_max_ ); double vel = vel_integ_ . filtering ( acc ); double pos = pos_integ_ . filtering ( vel ); v1_ = vel ; y1_ = pos ; return pos ; } private : const double acc_max_ ; const double Ts_ ; const double gpd_ ; const double Kx_ ; const double Kv_ ; const std :: optional < std :: pair < double , double >> limit_ ; internal :: DiffTri diff_ ; Integrator vel_integ_ , pos_integ_ ; double y1_ , v1_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/acceleration_limit_filter.hpp"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#includecpp_roboticsfilteracceleration_limit_filterhpp","text":"","title":"include/cpp_robotics/filter/acceleration_limit_filter.hpp"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#classes","text":"Name class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f)","title":"Classes"},{"location":"doxybook/Files/acceleration__limit__filter_8hpp/#source-code","text":"#pragma once #include <cmath> #include <optional> #include <tuple> #include <algorithm> #include \"integrator.hpp\" namespace cpp_robotics { namespace internal { class DiffTri { public : DiffTri ( double Ts , double gpd ) : Ts_ ( Ts ), gpd_ ( gpd ) { reset (); } void reset () { u1_ = u2_ = 0 ; diff21_ = diff22_ = 0 ; diff11_ = diff12_ = 0 ; pass2_ = pass1_ = 0 ; } std :: tuple < double , double , double > filtering ( double u ) { const double tau_ = 1 / gpd_ ; const double y1_coeff = ( -4 * tau_ * tau_ + 2 * Ts_ * Ts_ ); const double y2_coeff = ( 2 * tau_ * tau_ - 4 * tau_ * Ts_ + Ts_ * Ts_ ); const double y_coeff = 2 * tau_ * tau_ + 4 * tau_ * Ts_ + Ts_ * Ts_ ; // double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_; // double prev_y = (-4*tau_*tau_ + 2*Ts_*Ts_)*y1_ + (2*tau_*tau_ - 4*tau_*Ts_ + Ts_*Ts_)*y2_; const double prev_diff2 = y1_coeff * diff21_ + y2_coeff * diff22_ ; const double prev_diff1 = y1_coeff * diff11_ + y2_coeff * diff12_ ; const double prev_pass = y1_coeff * pass1_ + y2_coeff * pass2_ ; double diff2 = ( 4 * ( u -2 * u1_ + u2_ ) - prev_diff2 ) / y_coeff ; double diff1 = ( 2 * Ts_ * ( u - u2_ ) - prev_diff1 ) / y_coeff ; double pass = ( Ts_ * Ts_ * ( u + 2 * u1_ + u2_ ) - prev_pass ) / y_coeff ; u2_ = u1_ ; u1_ = u ; diff22_ = diff21_ ; diff21_ = diff2 ; diff12_ = diff11_ ; diff11_ = diff1 ; pass2_ = pass1_ ; pass1_ = pass ; return { diff2 , diff1 , pass }; } private : double Ts_ , gpd_ ; double u1_ , u2_ ; double diff21_ , diff22_ ; double diff11_ , diff12_ ; double pass1_ , pass2_ ; }; } class AccelerationLimitFilter { public : AccelerationLimitFilter ( double acc_max , double Ts , double gpd , double Kx , double Kv , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) : acc_max_ ( acc_max ), Ts_ ( Ts ), gpd_ ( gpd ), Kx_ ( Kx ), Kv_ ( Kv ), limit_ ( limit ), diff_ ( Ts , gpd ), vel_integ_ ( Ts ), pos_integ_ ( Ts ) { reset (); } // \u76ee\u5b89\u3068\u3057\u3066\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3001\u52a0\u901f\u5ea6\u306b\u3088\u3063\u3066\u30aa\u30fc\u30d0\u30fc\u30b7\u30e5\u30fc\u30c8\u91cf\u304c\u5909\u308f\u308b\u306e\u3067\u6ce8\u610f AccelerationLimitFilter ( double acc_max , double Ts , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) : AccelerationLimitFilter ( acc_max , Ts , 1 / Ts , 1000.0 / Ts , 500.0 / Ts / std :: sqrt ( acc_max ), limit ) { } virtual void reset () { y1_ = 0 ; v1_ = 0 ; diff_ . reset (); vel_integ_ . reset (); pos_integ_ . reset (); } virtual double filtering ( double u ) { auto [ diff2 , diff1 , pass ] = diff_ . filtering ( u ); double acc = diff2 - ( Kx_ * ( y1_ - pass )) - ( Kv_ * ( v1_ - diff1 )); acc = std :: clamp ( acc , - acc_max_ , acc_max_ ); double vel = vel_integ_ . filtering ( acc ); double pos = pos_integ_ . filtering ( vel ); v1_ = vel ; y1_ = pos ; return pos ; } private : const double acc_max_ ; const double Ts_ ; const double gpd_ ; const double Kx_ ; const double Kv_ ; const std :: optional < std :: pair < double , double >> limit_ ; internal :: DiffTri diff_ ; Integrator vel_integ_ , pos_integ_ ; double y1_ , v1_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/active__set__method_8hpp/","text":"include/cpp_robotics/optimize/active_set_method.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct cpp_robotics::ActiveSetMethod::Problem struct cpp_robotics::ActiveSetMethod::Result Source code #pragma once #include <Eigen/Dense> #include \"./newton_method.hpp\" namespace cpp_robotics { // min 1/2 x^T Q x + cx // s.t. Ax <= b // x \u7b49\u5f0f\u5236\u7d04\u306f2\u3064\u306e\u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u5909\u63db\u3059\u308b // o \u7b49\u5f0f\u5236\u7d04\u306f\u5e38\u306b\u30a2\u30af\u30c6\u30a3\u30d6\u3067\u3042\u308b\u3068\u3059\u308b class ActiveSetMethod { public : struct Problem { Problem () = default ; // Problem(size_t x_size_, size_t constraint_size_) // { // x_size = x_size_; // constraint_size = constraint_size_; // Q = Eigen::MatrixXd::Zero(x_size, x_size); // c = Eigen::VectorXd::Zero(x_size_); // A = Eigen::MatrixXd::Zero(constraint_size, x_size_); // b = Eigen::VectorXd::Zero(constraint_size); // } Problem ( size_t x_size_ ) { x_size = x_size_ ; Q = Eigen :: MatrixXd :: Zero ( x_size , x_size ); c = Eigen :: VectorXd :: Zero ( x_size_ ); } // Ax <= b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b void add_inequality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn ) { // for(Eigen::MatrixXd::Index i = 0; i < An.rows(); i++) // { // if(An.row(i).norm() < 1e-9) // return; // } if ( A . cols () != 0 ) { assert ( A . cols () == An . cols ()); Eigen :: MatrixXd new_A ( A . rows () + An . rows (), A . cols ()); new_A << A , An ; A = new_A ; } else { A = An ; } if ( b . cols () != 0 ) { Eigen :: VectorXd new_b ( b . rows () + bn . rows ()); new_b << b , bn ; b = new_b ; } else { b = bn ; } // std::cout << \"add A\" << std::endl << A << std::endl; // std::cout << \"add b\" << std::endl << b << std::endl; assert ( A . rows () == b . rows ()); constraint_size = A . rows (); } // Ax = b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b void add_equality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn ) { ( void ) An ; ( void ) bn ; } Eigen :: MatrixXd Q ; Eigen :: VectorXd c ; Eigen :: MatrixXd A ; Eigen :: VectorXd b ; size_t max_iter = 1000 ; size_t max_iter_get_initial_feasible_x = 1000 ; size_t x_size = 0 ; size_t constraint_size = 0 ; double alpha = 1.1 ; }; struct Result { bool is_solved = false ; Eigen :: VectorXd x_opt ; Eigen :: VectorXd lambda_opt ; size_t iter_cnt = 0 ; }; Result solve ( Problem prob , Eigen :: VectorXd x ) { prob_ = prob ; Result result ; // \u5236\u7d04\u304c\u306a\u3044\u5834\u5408\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f if ( prob_ . constraint_size == 0 ) { auto grad = [ & ]( const Eigen :: VectorXd & x ) { return ( prob_ . Q * x + prob_ . c ); }; auto hess = [ & ]( const Eigen :: VectorXd & x ) { ( void ) x ; return prob_ . Q ; }; std :: tie ( result . is_solved , result . x_opt , result . iter_cnt ) = newton_method ( grad , hess , x , 1e-6 , prob_ . max_iter ); return result ; } // std::cout << \"--------------------\" << std::endl; // std::cout << \"Q\" << std::endl << prob_.Q << std::endl; // std::cout << \"c\" << std::endl << prob_.c << std::endl; // std::cout << \"A\" << std::endl << prob_.A << std::endl; // std::cout << \"b\" << std::endl << prob_.b << std::endl; // \u521d\u671f\u5024\u306e\u30c1\u30a7\u30c3\u30af if ( not discrimination_feasiblity ( x )) { // std::cout << \"\u521d\u671f\u5024\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\" << std::endl; x = get_initial_feasible_x ( x ); } auto active_idx = active_set_index ( x ); // debug // std::cout << \"active_idx\" << std::endl; // std::for_each(active_idx.begin(), active_idx.end(), [&](auto idx) // { // std::cout << \"- \" << idx << std::endl; // }); // \u89e3\u7121\u3057 if ( not discrimination_feasiblity ( x )) { // std::cout << \"\u89e3\u7121\u3057 & \u4fee\u6b63\u4e0d\u53ef\u80fd\" << std::endl; return result ; } // \u53cd\u5fa9\u8a08\u7b97 result . is_solved = false ; for ( result . iter_cnt = 0 ; result . iter_cnt < prob_ . max_iter ; result . iter_cnt ++ ) { if ( result . is_solved ) break ; auto [ x_hat , lambda_hat ] = get_solution ( active_idx ); // std::cout << \"x_hat = \" << std::endl; // std::cout << x_hat.transpose() << std::endl << std::endl; // std::cout << \"lambda_hat = \" << std::endl; // std::cout << lambda_hat.transpose() << std::endl << std::endl; if ( not discrimination_feasiblity ( x_hat )) { // std::cout << \"\u5b9f\u884c\u4e0d\u53ef\u80fd & x_hat_dash \u4fee\u6b63\" << std::endl; // \u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5916\u306b\u51fa\u305f\u306e\u3067\u4e2d\u306b\u623b\u3059 x = get_x_hat_dash ( x_hat , x ); x_hat = x ; active_idx = active_set_index ( x ); // std::cout << \"x_hat_dash\" << std::endl; // std::cout << x << std::endl; } else { // std::cout << \"\u5b9f\u884c\u53ef\u80fd\" << std::endl; // \u6700\u9069\u6027\u306e\u5224\u5225 if (( lambda_hat . array () >= 0.0 ). count () == lambda_hat . rows ()) { // \u30e9\u30e0\u30c0\u304c\u5168\u3066\u8ca0\u306e\u5024\u3067\u306a\u3044 = \u5168\u3066\u306e\u5236\u7d04\u3092\u6e80\u305f\u3059 result . is_solved = true ; } else { // lambda_i < 0 \u304c\u5b58\u5728\u3059\u308b\u5b9f\u884c\u4e0d\u53ef\u80fd\u89e3 // lambda_hat\u306e\u6700\u5c0f\u5024\u3092\u524a\u9664\u3057\u3066lambda\u3068\u3059\u308b Eigen :: VectorXd :: Index min_idx ; lambda_hat . minCoeff ( & min_idx ); for ( auto itr = active_idx . begin (); itr != active_idx . end (); itr ++ ) { if ( * itr == static_cast < size_t > ( min_idx )) { active_idx . erase ( itr ); break ; } } std :: sort ( active_idx . begin (), active_idx . end ()); } } result . x_opt = x_hat ; result . lambda_opt = lambda_hat ; } return result ; } private : auto f ( const Eigen :: VectorXd & x ) const { return ( 0.5 * x . transpose () * prob_ . Q * x + prob_ . c * x ); } auto grad_f ( const Eigen :: VectorXd & x ) const { return ( prob_ . Q * x + prob_ . c ); } auto g ( const Eigen :: VectorXd & x ) const { return ( prob_ . A * x - prob_ . b ); } auto grad_g ( void ) const { return prob_ . A ; } std :: vector < size_t > active_set_index ( const Eigen :: VectorXd & x ) const { auto gval = g ( x ); std :: vector < size_t > idx ; idx . reserve ( gval . rows ()); for ( Eigen :: VectorXd :: Index i = 0 ; i < gval . rows (); i ++ ) { if ( std :: abs ( gval ( i )) < eps_ ) idx . push_back ( i ); } return idx ; } std :: pair < Eigen :: VectorXd , Eigen :: VectorXd > get_solution ( const std :: vector < size_t > & active_idx ) const { size_t m = prob_ . A . rows (); size_t n = prob_ . A . cols (); Eigen :: VectorXd x_hat , lambda_hat ; // std::cout << \"active_idx.size(): \" << active_idx.size() << std::endl; if ( active_idx . size () == 0 ) { // \u6709\u52b9\u5236\u7d04\u306a\u3057 x_hat = prob_ . Q . inverse () * - prob_ . c ; lambda_hat = Eigen :: VectorXd :: Zero ( m ); } else { // \u6709\u52b9\u5236\u7d04\u3042\u308a Eigen :: MatrixXd Aq = Eigen :: MatrixXd :: Zero ( active_idx . size (), prob_ . A . cols ()); Eigen :: VectorXd bq = Eigen :: VectorXd :: Zero ( active_idx . size ()); for ( size_t i = 0 ; i < active_idx . size (); i ++ ) { Aq . row ( i ) = prob_ . A . row ( active_idx [ i ]); bq . row ( i ) = prob_ . b . row ( active_idx [ i ]); } // std::cout << \"Aq= \" << std::endl; // std::cout << Aq << std::endl << std::endl; // std::cout << \"bq= \" << std::endl; // std::cout << bq << std::endl << std::endl; size_t mq = Aq . rows (); // size_t nq = Aq.cols(); // = n // tmp_a = | Aq 0 | // | Q Aq^T | Eigen :: MatrixXd tmp_a = Eigen :: MatrixXd :: Zero ( mq + n , mq + n ); tmp_a . block ( 0 , 0 , mq , n ) = Aq ; tmp_a . block ( mq , 0 , n , n ) = prob_ . Q ; tmp_a . block ( mq , n , n , mq ) = Aq . transpose (); // tmp_b = | bq | // | c | Eigen :: VectorXd tmp_b = Eigen :: VectorXd ( mq + n ); tmp_b << bq , - prob_ . c ; // std::cout << \"tmp_a= \" << std::endl; // std::cout << tmp_a << std::endl << std::endl; // std::cout << \"tmp_b= \" << std::endl; // std::cout << tmp_b << std::endl << std::endl; Eigen :: VectorXd p_hat = tmp_a . fullPivLu (). solve ( tmp_b ); // std::cout << \"p_hat.size()= \" << p_hat.size() << std::endl; // std::cout << \"p_hat= \" << std::endl; // std::cout << p_hat << std::endl << std::endl; x_hat = p_hat . head ( n ); lambda_hat = Eigen :: VectorXd :: Zero ( m ); for ( size_t i = 0 ; i < mq ; i ++ ) { lambda_hat ( active_idx [ i ]) = p_hat ( n + i ); } // std::cout << \"x_hat= \" << std::endl; // std::cout << x_hat << std::endl << std::endl; // std::cout << \"lambda_hat= \" << std::endl; // std::cout << lambda_hat << std::endl << std::endl; } return { x_hat , lambda_hat }; } // x\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u3067\u3042\u3063\u305f\u5834\u5408\u306b\u5b9f\u884c\u53ef\u80fd\u306ax\u3092\u8fd4\u3059 // \u6700\u9069\u6027\u306f\u554f\u308f\u306a\u3044 Eigen :: VectorXd get_initial_feasible_x ( Eigen :: VectorXd x ) { for ( size_t i = 0 ; i < prob_ . max_iter_get_initial_feasible_x ; i ++ ) { auto gval = g ( x ); // std::cout << \"gval:\" << std::endl; // std::cout << gval.transpose() << std::endl; size_t max_g_idx = 0 ; gval . maxCoeff ( & max_g_idx ); // std::cout << \"max_g_idx: \" << max_g_idx << std::endl; x -= prob_ . alpha * grad_g (). row ( max_g_idx ) * std :: abs ( ( prob_ . A . row ( max_g_idx ) * x - prob_ . b . row ( max_g_idx ))( 0 ) ) / prob_ . A . row ( max_g_idx ). squaredNorm (); // std::cout << \"new x:\" << std::endl; // std::cout << x.transpose() << std::endl; if ( discrimination_feasiblity ( x )) break ; } return x ; } // x\u304c\u5168\u3066\u306e\u6210\u7d04\u306b\u5bfe\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u304b\u30c1\u30a7\u30c3\u30af\u3059\u308b bool discrimination_feasiblity ( const Eigen :: VectorXd & x ) const { bool is_feasible = true ; auto gval = g ( x ); // g(x) <= 0 \u3092\u6e80\u305f\u3055\u306a\u3044\u3082\u306e\u304c\u4e00\u3064\u3067\u3082\u3042\u308c\u3070\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u3044\u308b if (( gval . array () > eps_ ). count () > 0 ) is_feasible = false ; return is_feasible ; } // x_hat\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd, x\u304c\u5b9f\u884c\u53ef\u80fd\u3060\u3068\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u306ax_hat_dash\u3092\u751f\u6210\u3059\u308b Eigen :: VectorXd get_x_hat_dash ( Eigen :: VectorXd x_hat , Eigen :: VectorXd x ) { double t = get_t ( x_hat , x ); // std::cout << \"t = \" << t << std::endl; // std::cout << \"x:\" << std::endl; // std::cout << x.transpose() << std::endl; // std::cout << \"x_hat:\" << std::endl; // std::cout << x_hat.transpose() << std::endl; return x + t * ( x_hat - x ); } double get_t ( Eigen :: VectorXd x_hat , Eigen :: VectorXd x ) { Eigen :: VectorXd gg = prob_ . A * ( x_hat - x ); for ( Eigen :: VectorXd :: Index i = 0 ; i < gg . size (); i ++ ) { if ( std :: abs ( gg ( i )) < eps_ ) gg ( i ) = eps_ ; } // std::cout << \"gg:\" << std::endl; // std::cout << gg.transpose() << std::endl; auto T = - g ( x ). array () / gg . array (); auto T_selected = ( T . array () > 0.0 ); // T_selected\u306f0/1\u306e\u30d0\u30a4\u30ca\u30ea\u578b Eigen :: VectorXd T_nn ( T_selected . count ()); size_t row = 0 ; for ( Eigen :: VectorXd :: Index i = 0 ; i < T . size (); i ++ ) { if ( T_selected [ i ]) T_nn ( row ++ ) = T ( i ); } // std::cout << \"-g(x):\" << std::endl; // std::cout << (-g(x)).transpose() << std::endl; // std::cout << \"gg:\" << std::endl; // std::cout << gg.transpose() << std::endl; // std::cout << \"T:\" << std::endl; // std::cout << T.transpose() << std::endl; // std::cout << \"T_nn:\" << std::endl; // std::cout << T_nn.transpose() << std::endl; if ( T_selected . count () != 0 ) { // T_i > 0 \u3092\u6e80\u305f\u3059\u3088\u3046\u305d\u306e\u3046\u3061\u6700\u5c0f\u306eT_i\u3092\u8fd4\u3059 return T_nn . minCoeff (); } return 0.0 ; } Problem prob_ ; static constexpr double eps_ = 1e-9 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/active_set_method.hpp"},{"location":"doxybook/Files/active__set__method_8hpp/#includecpp_roboticsoptimizeactive_set_methodhpp","text":"","title":"include/cpp_robotics/optimize/active_set_method.hpp"},{"location":"doxybook/Files/active__set__method_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/active__set__method_8hpp/#classes","text":"Name class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 struct cpp_robotics::ActiveSetMethod::Problem struct cpp_robotics::ActiveSetMethod::Result","title":"Classes"},{"location":"doxybook/Files/active__set__method_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> #include \"./newton_method.hpp\" namespace cpp_robotics { // min 1/2 x^T Q x + cx // s.t. Ax <= b // x \u7b49\u5f0f\u5236\u7d04\u306f2\u3064\u306e\u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u5909\u63db\u3059\u308b // o \u7b49\u5f0f\u5236\u7d04\u306f\u5e38\u306b\u30a2\u30af\u30c6\u30a3\u30d6\u3067\u3042\u308b\u3068\u3059\u308b class ActiveSetMethod { public : struct Problem { Problem () = default ; // Problem(size_t x_size_, size_t constraint_size_) // { // x_size = x_size_; // constraint_size = constraint_size_; // Q = Eigen::MatrixXd::Zero(x_size, x_size); // c = Eigen::VectorXd::Zero(x_size_); // A = Eigen::MatrixXd::Zero(constraint_size, x_size_); // b = Eigen::VectorXd::Zero(constraint_size); // } Problem ( size_t x_size_ ) { x_size = x_size_ ; Q = Eigen :: MatrixXd :: Zero ( x_size , x_size ); c = Eigen :: VectorXd :: Zero ( x_size_ ); } // Ax <= b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b void add_inequality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn ) { // for(Eigen::MatrixXd::Index i = 0; i < An.rows(); i++) // { // if(An.row(i).norm() < 1e-9) // return; // } if ( A . cols () != 0 ) { assert ( A . cols () == An . cols ()); Eigen :: MatrixXd new_A ( A . rows () + An . rows (), A . cols ()); new_A << A , An ; A = new_A ; } else { A = An ; } if ( b . cols () != 0 ) { Eigen :: VectorXd new_b ( b . rows () + bn . rows ()); new_b << b , bn ; b = new_b ; } else { b = bn ; } // std::cout << \"add A\" << std::endl << A << std::endl; // std::cout << \"add b\" << std::endl << b << std::endl; assert ( A . rows () == b . rows ()); constraint_size = A . rows (); } // Ax = b \u306e\u5236\u7d04\u3092\u8ffd\u52a0\u3059\u308b void add_equality_constraint ( const Eigen :: MatrixXd & An , Eigen :: VectorXd bn ) { ( void ) An ; ( void ) bn ; } Eigen :: MatrixXd Q ; Eigen :: VectorXd c ; Eigen :: MatrixXd A ; Eigen :: VectorXd b ; size_t max_iter = 1000 ; size_t max_iter_get_initial_feasible_x = 1000 ; size_t x_size = 0 ; size_t constraint_size = 0 ; double alpha = 1.1 ; }; struct Result { bool is_solved = false ; Eigen :: VectorXd x_opt ; Eigen :: VectorXd lambda_opt ; size_t iter_cnt = 0 ; }; Result solve ( Problem prob , Eigen :: VectorXd x ) { prob_ = prob ; Result result ; // \u5236\u7d04\u304c\u306a\u3044\u5834\u5408\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f if ( prob_ . constraint_size == 0 ) { auto grad = [ & ]( const Eigen :: VectorXd & x ) { return ( prob_ . Q * x + prob_ . c ); }; auto hess = [ & ]( const Eigen :: VectorXd & x ) { ( void ) x ; return prob_ . Q ; }; std :: tie ( result . is_solved , result . x_opt , result . iter_cnt ) = newton_method ( grad , hess , x , 1e-6 , prob_ . max_iter ); return result ; } // std::cout << \"--------------------\" << std::endl; // std::cout << \"Q\" << std::endl << prob_.Q << std::endl; // std::cout << \"c\" << std::endl << prob_.c << std::endl; // std::cout << \"A\" << std::endl << prob_.A << std::endl; // std::cout << \"b\" << std::endl << prob_.b << std::endl; // \u521d\u671f\u5024\u306e\u30c1\u30a7\u30c3\u30af if ( not discrimination_feasiblity ( x )) { // std::cout << \"\u521d\u671f\u5024\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\" << std::endl; x = get_initial_feasible_x ( x ); } auto active_idx = active_set_index ( x ); // debug // std::cout << \"active_idx\" << std::endl; // std::for_each(active_idx.begin(), active_idx.end(), [&](auto idx) // { // std::cout << \"- \" << idx << std::endl; // }); // \u89e3\u7121\u3057 if ( not discrimination_feasiblity ( x )) { // std::cout << \"\u89e3\u7121\u3057 & \u4fee\u6b63\u4e0d\u53ef\u80fd\" << std::endl; return result ; } // \u53cd\u5fa9\u8a08\u7b97 result . is_solved = false ; for ( result . iter_cnt = 0 ; result . iter_cnt < prob_ . max_iter ; result . iter_cnt ++ ) { if ( result . is_solved ) break ; auto [ x_hat , lambda_hat ] = get_solution ( active_idx ); // std::cout << \"x_hat = \" << std::endl; // std::cout << x_hat.transpose() << std::endl << std::endl; // std::cout << \"lambda_hat = \" << std::endl; // std::cout << lambda_hat.transpose() << std::endl << std::endl; if ( not discrimination_feasiblity ( x_hat )) { // std::cout << \"\u5b9f\u884c\u4e0d\u53ef\u80fd & x_hat_dash \u4fee\u6b63\" << std::endl; // \u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5916\u306b\u51fa\u305f\u306e\u3067\u4e2d\u306b\u623b\u3059 x = get_x_hat_dash ( x_hat , x ); x_hat = x ; active_idx = active_set_index ( x ); // std::cout << \"x_hat_dash\" << std::endl; // std::cout << x << std::endl; } else { // std::cout << \"\u5b9f\u884c\u53ef\u80fd\" << std::endl; // \u6700\u9069\u6027\u306e\u5224\u5225 if (( lambda_hat . array () >= 0.0 ). count () == lambda_hat . rows ()) { // \u30e9\u30e0\u30c0\u304c\u5168\u3066\u8ca0\u306e\u5024\u3067\u306a\u3044 = \u5168\u3066\u306e\u5236\u7d04\u3092\u6e80\u305f\u3059 result . is_solved = true ; } else { // lambda_i < 0 \u304c\u5b58\u5728\u3059\u308b\u5b9f\u884c\u4e0d\u53ef\u80fd\u89e3 // lambda_hat\u306e\u6700\u5c0f\u5024\u3092\u524a\u9664\u3057\u3066lambda\u3068\u3059\u308b Eigen :: VectorXd :: Index min_idx ; lambda_hat . minCoeff ( & min_idx ); for ( auto itr = active_idx . begin (); itr != active_idx . end (); itr ++ ) { if ( * itr == static_cast < size_t > ( min_idx )) { active_idx . erase ( itr ); break ; } } std :: sort ( active_idx . begin (), active_idx . end ()); } } result . x_opt = x_hat ; result . lambda_opt = lambda_hat ; } return result ; } private : auto f ( const Eigen :: VectorXd & x ) const { return ( 0.5 * x . transpose () * prob_ . Q * x + prob_ . c * x ); } auto grad_f ( const Eigen :: VectorXd & x ) const { return ( prob_ . Q * x + prob_ . c ); } auto g ( const Eigen :: VectorXd & x ) const { return ( prob_ . A * x - prob_ . b ); } auto grad_g ( void ) const { return prob_ . A ; } std :: vector < size_t > active_set_index ( const Eigen :: VectorXd & x ) const { auto gval = g ( x ); std :: vector < size_t > idx ; idx . reserve ( gval . rows ()); for ( Eigen :: VectorXd :: Index i = 0 ; i < gval . rows (); i ++ ) { if ( std :: abs ( gval ( i )) < eps_ ) idx . push_back ( i ); } return idx ; } std :: pair < Eigen :: VectorXd , Eigen :: VectorXd > get_solution ( const std :: vector < size_t > & active_idx ) const { size_t m = prob_ . A . rows (); size_t n = prob_ . A . cols (); Eigen :: VectorXd x_hat , lambda_hat ; // std::cout << \"active_idx.size(): \" << active_idx.size() << std::endl; if ( active_idx . size () == 0 ) { // \u6709\u52b9\u5236\u7d04\u306a\u3057 x_hat = prob_ . Q . inverse () * - prob_ . c ; lambda_hat = Eigen :: VectorXd :: Zero ( m ); } else { // \u6709\u52b9\u5236\u7d04\u3042\u308a Eigen :: MatrixXd Aq = Eigen :: MatrixXd :: Zero ( active_idx . size (), prob_ . A . cols ()); Eigen :: VectorXd bq = Eigen :: VectorXd :: Zero ( active_idx . size ()); for ( size_t i = 0 ; i < active_idx . size (); i ++ ) { Aq . row ( i ) = prob_ . A . row ( active_idx [ i ]); bq . row ( i ) = prob_ . b . row ( active_idx [ i ]); } // std::cout << \"Aq= \" << std::endl; // std::cout << Aq << std::endl << std::endl; // std::cout << \"bq= \" << std::endl; // std::cout << bq << std::endl << std::endl; size_t mq = Aq . rows (); // size_t nq = Aq.cols(); // = n // tmp_a = | Aq 0 | // | Q Aq^T | Eigen :: MatrixXd tmp_a = Eigen :: MatrixXd :: Zero ( mq + n , mq + n ); tmp_a . block ( 0 , 0 , mq , n ) = Aq ; tmp_a . block ( mq , 0 , n , n ) = prob_ . Q ; tmp_a . block ( mq , n , n , mq ) = Aq . transpose (); // tmp_b = | bq | // | c | Eigen :: VectorXd tmp_b = Eigen :: VectorXd ( mq + n ); tmp_b << bq , - prob_ . c ; // std::cout << \"tmp_a= \" << std::endl; // std::cout << tmp_a << std::endl << std::endl; // std::cout << \"tmp_b= \" << std::endl; // std::cout << tmp_b << std::endl << std::endl; Eigen :: VectorXd p_hat = tmp_a . fullPivLu (). solve ( tmp_b ); // std::cout << \"p_hat.size()= \" << p_hat.size() << std::endl; // std::cout << \"p_hat= \" << std::endl; // std::cout << p_hat << std::endl << std::endl; x_hat = p_hat . head ( n ); lambda_hat = Eigen :: VectorXd :: Zero ( m ); for ( size_t i = 0 ; i < mq ; i ++ ) { lambda_hat ( active_idx [ i ]) = p_hat ( n + i ); } // std::cout << \"x_hat= \" << std::endl; // std::cout << x_hat << std::endl << std::endl; // std::cout << \"lambda_hat= \" << std::endl; // std::cout << lambda_hat << std::endl << std::endl; } return { x_hat , lambda_hat }; } // x\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u3067\u3042\u3063\u305f\u5834\u5408\u306b\u5b9f\u884c\u53ef\u80fd\u306ax\u3092\u8fd4\u3059 // \u6700\u9069\u6027\u306f\u554f\u308f\u306a\u3044 Eigen :: VectorXd get_initial_feasible_x ( Eigen :: VectorXd x ) { for ( size_t i = 0 ; i < prob_ . max_iter_get_initial_feasible_x ; i ++ ) { auto gval = g ( x ); // std::cout << \"gval:\" << std::endl; // std::cout << gval.transpose() << std::endl; size_t max_g_idx = 0 ; gval . maxCoeff ( & max_g_idx ); // std::cout << \"max_g_idx: \" << max_g_idx << std::endl; x -= prob_ . alpha * grad_g (). row ( max_g_idx ) * std :: abs ( ( prob_ . A . row ( max_g_idx ) * x - prob_ . b . row ( max_g_idx ))( 0 ) ) / prob_ . A . row ( max_g_idx ). squaredNorm (); // std::cout << \"new x:\" << std::endl; // std::cout << x.transpose() << std::endl; if ( discrimination_feasiblity ( x )) break ; } return x ; } // x\u304c\u5168\u3066\u306e\u6210\u7d04\u306b\u5bfe\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u304b\u30c1\u30a7\u30c3\u30af\u3059\u308b bool discrimination_feasiblity ( const Eigen :: VectorXd & x ) const { bool is_feasible = true ; auto gval = g ( x ); // g(x) <= 0 \u3092\u6e80\u305f\u3055\u306a\u3044\u3082\u306e\u304c\u4e00\u3064\u3067\u3082\u3042\u308c\u3070\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u3044\u308b if (( gval . array () > eps_ ). count () > 0 ) is_feasible = false ; return is_feasible ; } // x_hat\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd, x\u304c\u5b9f\u884c\u53ef\u80fd\u3060\u3068\u3057\u3066\u5b9f\u884c\u53ef\u80fd\u306ax_hat_dash\u3092\u751f\u6210\u3059\u308b Eigen :: VectorXd get_x_hat_dash ( Eigen :: VectorXd x_hat , Eigen :: VectorXd x ) { double t = get_t ( x_hat , x ); // std::cout << \"t = \" << t << std::endl; // std::cout << \"x:\" << std::endl; // std::cout << x.transpose() << std::endl; // std::cout << \"x_hat:\" << std::endl; // std::cout << x_hat.transpose() << std::endl; return x + t * ( x_hat - x ); } double get_t ( Eigen :: VectorXd x_hat , Eigen :: VectorXd x ) { Eigen :: VectorXd gg = prob_ . A * ( x_hat - x ); for ( Eigen :: VectorXd :: Index i = 0 ; i < gg . size (); i ++ ) { if ( std :: abs ( gg ( i )) < eps_ ) gg ( i ) = eps_ ; } // std::cout << \"gg:\" << std::endl; // std::cout << gg.transpose() << std::endl; auto T = - g ( x ). array () / gg . array (); auto T_selected = ( T . array () > 0.0 ); // T_selected\u306f0/1\u306e\u30d0\u30a4\u30ca\u30ea\u578b Eigen :: VectorXd T_nn ( T_selected . count ()); size_t row = 0 ; for ( Eigen :: VectorXd :: Index i = 0 ; i < T . size (); i ++ ) { if ( T_selected [ i ]) T_nn ( row ++ ) = T ( i ); } // std::cout << \"-g(x):\" << std::endl; // std::cout << (-g(x)).transpose() << std::endl; // std::cout << \"gg:\" << std::endl; // std::cout << gg.transpose() << std::endl; // std::cout << \"T:\" << std::endl; // std::cout << T.transpose() << std::endl; // std::cout << \"T_nn:\" << std::endl; // std::cout << T_nn.transpose() << std::endl; if ( T_selected . count () != 0 ) { // T_i > 0 \u3092\u6e80\u305f\u3059\u3088\u3046\u305d\u306e\u3046\u3061\u6700\u5c0f\u306eT_i\u3092\u8fd4\u3059 return T_nn . minCoeff (); } return 0.0 ; } Problem prob_ ; static constexpr double eps_ = 1e-9 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/algorithm_8hpp/","text":"include/cpp_robotics/algorithm/algorithm.hpp Source code #pragma once #include \"kdtree.hpp\" #include \"icp.hpp\" #include \"ndt.hpp\" #include \"poly_regression.hpp\" #include \"state_machine.hpp\" #include \"k_means_method.hpp\" #include \"mahalanobis.hpp\" #include \"random.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/algorithm.hpp"},{"location":"doxybook/Files/algorithm_8hpp/#includecpp_roboticsalgorithmalgorithmhpp","text":"","title":"include/cpp_robotics/algorithm/algorithm.hpp"},{"location":"doxybook/Files/algorithm_8hpp/#source-code","text":"#pragma once #include \"kdtree.hpp\" #include \"icp.hpp\" #include \"ndt.hpp\" #include \"poly_regression.hpp\" #include \"state_machine.hpp\" #include \"k_means_method.hpp\" #include \"mahalanobis.hpp\" #include \"random.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/angle__range_8hpp/","text":"include/cpp_robotics/utility/angle_range.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b Source code #pragma once #include <cstdio> #include <cmath> #include <utility> #include <vector> #include <algorithm> namespace cpp_robotics { class AngleRange { public : using range_pair_t = std :: pair < double , double > ; constexpr static double PI = M_PI ; AngleRange () = default ; void add_range ( const AngleRange & range ) { for ( auto r : range . ranges_ ) { add_range ( r . first , r . second ); } } void add_range ( double start , double end ) { if ( start == end ) return ; // \u4e00\u822c\u89d2\u306b\u5206\u5272\u3057\u3066\u633f\u5165\u3059\u308b if ( start > end ) std :: swap ( start , end ); double diff = end - start ; start = normalize_angle_positive ( start ); end = start + diff ; if ( diff > 2 * PI ) { // \u4e00\u5468\u56de\u3063\u3066\u308b ranges_ . push_back ({ 0 , 2 * PI }); } else { if ( end > 2 * PI ) { ranges_ . push_back ({ start , 2 * PI }); ranges_ . push_back ({ 0 , end - 2 * PI }); } else { ranges_ . push_back ({ start , end }); } } // ranges_\u306e\u7d50\u5408\u30fb\u5206\u5272 join_start : for ( size_t look = 0 ; look < ranges_ . size (); look ++ ) { for ( size_t dest = 0 ; dest < ranges_ . size (); dest ++ ) { if ( look != dest ) { // \u7bc4\u56f2\u304c\u304b\u3076\u3063\u3066\u305f\u3089\u7d50\u5408\u3059\u308b if ( in_range_part ( ranges_ [ look ], ranges_ [ dest ]. first )) { if ( ranges_ [ look ]. second < ranges_ [ dest ]. second ) ranges_ [ look ]. second = ranges_ [ dest ]. second ; ranges_ . erase ( ranges_ . begin () + dest ); goto join_start ; } if ( in_range_part ( ranges_ [ look ], ranges_ [ dest ]. second )) { if ( ranges_ [ look ]. first > ranges_ [ dest ]. first ) ranges_ [ look ]. first = ranges_ [ dest ]. first ; ranges_ . erase ( ranges_ . begin () + dest ); goto join_start ; } } } } std :: sort ( ranges_ . begin (), ranges_ . end (), []( auto a , auto b ){ return a . first < b . first ; }); } size_t size () const { return ranges_ . size (); } AngleRange invert () const { AngleRange ret ; if ( size () == 0 ) { ret . add_range ( 0.0 , 2 * PI ); return ret ; } for ( size_t i = 0 ; i < size () -1 ; i ++ ) { ret . add_range ( ranges_ [ i ]. second , ranges_ [ i + 1 ]. first ); } ret . add_range ( ranges_ . back (). second , ranges_ . front (). first + 2 * PI ); return ret ; } // \u5f15\u6570\u306e\u89d2\u5ea6\u306b\u5bfe\u3057\u7bc4\u56f2\u306e\u4e2d\u3067\u4e00\u756a\u8fd1\u3044\u89d2\u5ea6\u3092\u8a08\u7b97\u3059\u308b double most_near_by ( double angle ) { angle = normalize_angle_positive ( angle ); if ( in_range ( angle )) return angle ; auto inv_ranges = this -> invert (). ranges_ ; // 2pi\u3092\u307e\u305f\u3050\u5834\u5408\u306f\u9023\u7d50\u3055\u305b\u308b if ( inv_ranges . front (). first == 0.0 && inv_ranges . back (). second == 2 * PI ) { range_pair_t new_back = { inv_ranges . back (). first , 2 * PI + inv_ranges . front (). second }; inv_ranges . erase ( inv_ranges . begin ()); inv_ranges . back () = new_back ; if ( angle < inv_ranges . front (). first ) angle += 2 * PI ; } for ( auto & ir : inv_ranges ) { if ( in_range_part ( ir , angle )) { if ( std :: abs ( shortest_angular_distance ( angle , ir . first )) < std :: abs ( shortest_angular_distance ( angle , ir . second ))) { return normalize_angle_positive ( ir . first ); } else { return normalize_angle_positive ( ir . second ); } } } // error return normalize_angle_positive ( angle ); } inline bool in_range_part ( range_pair_t & range , double angle ) { if ( range . first <= angle && angle <= range . second ) return true ; return false ; } bool in_range ( double angle ) { angle = normalize_angle_positive ( angle ); for ( auto range : ranges_ ) { if ( in_range_part ( range , angle )) return true ; } return false ; } std :: vector < range_pair_t > ranges () const { return ranges_ ; } private : double normalize_angle_positive ( double angle ) { return std :: fmod ( std :: fmod ( angle , 2 * PI ) + 2 * PI , 2 * PI ); } double normalize_angle ( double angle ) { double a = normalize_angle_positive ( angle ); if ( a > PI ) a -= 2 * PI ; return a ; } double shortest_angular_distance ( double from , double to ) { return normalize_angle ( to - from ); } void debug () { printf ( \"debug \\n \" ); for ( auto range : ranges_ ) { printf ( \"(%8.2f, %8.2f) \\n \" , range . first , range . second ); } printf ( \" \\n \" ); } private : std :: vector < range_pair_t > ranges_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/utility/angle_range.hpp"},{"location":"doxybook/Files/angle__range_8hpp/#includecpp_roboticsutilityangle_rangehpp","text":"","title":"include/cpp_robotics/utility/angle_range.hpp"},{"location":"doxybook/Files/angle__range_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/angle__range_8hpp/#classes","text":"Name class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b","title":"Classes"},{"location":"doxybook/Files/angle__range_8hpp/#source-code","text":"#pragma once #include <cstdio> #include <cmath> #include <utility> #include <vector> #include <algorithm> namespace cpp_robotics { class AngleRange { public : using range_pair_t = std :: pair < double , double > ; constexpr static double PI = M_PI ; AngleRange () = default ; void add_range ( const AngleRange & range ) { for ( auto r : range . ranges_ ) { add_range ( r . first , r . second ); } } void add_range ( double start , double end ) { if ( start == end ) return ; // \u4e00\u822c\u89d2\u306b\u5206\u5272\u3057\u3066\u633f\u5165\u3059\u308b if ( start > end ) std :: swap ( start , end ); double diff = end - start ; start = normalize_angle_positive ( start ); end = start + diff ; if ( diff > 2 * PI ) { // \u4e00\u5468\u56de\u3063\u3066\u308b ranges_ . push_back ({ 0 , 2 * PI }); } else { if ( end > 2 * PI ) { ranges_ . push_back ({ start , 2 * PI }); ranges_ . push_back ({ 0 , end - 2 * PI }); } else { ranges_ . push_back ({ start , end }); } } // ranges_\u306e\u7d50\u5408\u30fb\u5206\u5272 join_start : for ( size_t look = 0 ; look < ranges_ . size (); look ++ ) { for ( size_t dest = 0 ; dest < ranges_ . size (); dest ++ ) { if ( look != dest ) { // \u7bc4\u56f2\u304c\u304b\u3076\u3063\u3066\u305f\u3089\u7d50\u5408\u3059\u308b if ( in_range_part ( ranges_ [ look ], ranges_ [ dest ]. first )) { if ( ranges_ [ look ]. second < ranges_ [ dest ]. second ) ranges_ [ look ]. second = ranges_ [ dest ]. second ; ranges_ . erase ( ranges_ . begin () + dest ); goto join_start ; } if ( in_range_part ( ranges_ [ look ], ranges_ [ dest ]. second )) { if ( ranges_ [ look ]. first > ranges_ [ dest ]. first ) ranges_ [ look ]. first = ranges_ [ dest ]. first ; ranges_ . erase ( ranges_ . begin () + dest ); goto join_start ; } } } } std :: sort ( ranges_ . begin (), ranges_ . end (), []( auto a , auto b ){ return a . first < b . first ; }); } size_t size () const { return ranges_ . size (); } AngleRange invert () const { AngleRange ret ; if ( size () == 0 ) { ret . add_range ( 0.0 , 2 * PI ); return ret ; } for ( size_t i = 0 ; i < size () -1 ; i ++ ) { ret . add_range ( ranges_ [ i ]. second , ranges_ [ i + 1 ]. first ); } ret . add_range ( ranges_ . back (). second , ranges_ . front (). first + 2 * PI ); return ret ; } // \u5f15\u6570\u306e\u89d2\u5ea6\u306b\u5bfe\u3057\u7bc4\u56f2\u306e\u4e2d\u3067\u4e00\u756a\u8fd1\u3044\u89d2\u5ea6\u3092\u8a08\u7b97\u3059\u308b double most_near_by ( double angle ) { angle = normalize_angle_positive ( angle ); if ( in_range ( angle )) return angle ; auto inv_ranges = this -> invert (). ranges_ ; // 2pi\u3092\u307e\u305f\u3050\u5834\u5408\u306f\u9023\u7d50\u3055\u305b\u308b if ( inv_ranges . front (). first == 0.0 && inv_ranges . back (). second == 2 * PI ) { range_pair_t new_back = { inv_ranges . back (). first , 2 * PI + inv_ranges . front (). second }; inv_ranges . erase ( inv_ranges . begin ()); inv_ranges . back () = new_back ; if ( angle < inv_ranges . front (). first ) angle += 2 * PI ; } for ( auto & ir : inv_ranges ) { if ( in_range_part ( ir , angle )) { if ( std :: abs ( shortest_angular_distance ( angle , ir . first )) < std :: abs ( shortest_angular_distance ( angle , ir . second ))) { return normalize_angle_positive ( ir . first ); } else { return normalize_angle_positive ( ir . second ); } } } // error return normalize_angle_positive ( angle ); } inline bool in_range_part ( range_pair_t & range , double angle ) { if ( range . first <= angle && angle <= range . second ) return true ; return false ; } bool in_range ( double angle ) { angle = normalize_angle_positive ( angle ); for ( auto range : ranges_ ) { if ( in_range_part ( range , angle )) return true ; } return false ; } std :: vector < range_pair_t > ranges () const { return ranges_ ; } private : double normalize_angle_positive ( double angle ) { return std :: fmod ( std :: fmod ( angle , 2 * PI ) + 2 * PI , 2 * PI ); } double normalize_angle ( double angle ) { double a = normalize_angle_positive ( angle ); if ( a > PI ) a -= 2 * PI ; return a ; } double shortest_angular_distance ( double from , double to ) { return normalize_angle ( to - from ); } void debug () { printf ( \"debug \\n \" ); for ( auto range : ranges_ ) { printf ( \"(%8.2f, %8.2f) \\n \" , range . first , range . second ); } printf ( \" \\n \" ); } private : std :: vector < range_pair_t > ranges_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/band__pass__filter_8hpp/","text":"include/cpp_robotics/filter/band_pass_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf Source code #pragma once namespace cpp_robotics { // 2*zeta*omega // G(s) = ------------------------------ \u3092\u53cc\u4e00\u6b21\u5909\u63db // s^2 + 2*zeta*omega + omega^2 class BandPassFilter { public : BandPassFilter ( double w , double zeta , double dt ) : w_ ( w ), zeta_ ( zeta ), dt_ ( dt ) { const double ww = w * w ; const double dtdt = dt * dt ; tf_ . set_discrite ( { ( 4 * dt * zeta * w ), 0 , ( -4 * dt * zeta * w )}, {( 4 + ( 4 * dt * zeta * w ) + dtdt * ww ), ( -8 + 2 * dtdt * ww ), ( 4 - ( 4 * dt * zeta * w ) + dtdt * ww )}, dt ); } void reset () { tf_ . reset (); } double filtering ( double u ) { return tf_ . responce ( u ); } double w () const { return w_ ; } double zeta () const { return zeta_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double zeta_ ; const double dt_ ; DiscreteTransferFunction tf_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/band_pass_filter.hpp"},{"location":"doxybook/Files/band__pass__filter_8hpp/#includecpp_roboticsfilterband_pass_filterhpp","text":"","title":"include/cpp_robotics/filter/band_pass_filter.hpp"},{"location":"doxybook/Files/band__pass__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/band__pass__filter_8hpp/#classes","text":"Name class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf","title":"Classes"},{"location":"doxybook/Files/band__pass__filter_8hpp/#source-code","text":"#pragma once namespace cpp_robotics { // 2*zeta*omega // G(s) = ------------------------------ \u3092\u53cc\u4e00\u6b21\u5909\u63db // s^2 + 2*zeta*omega + omega^2 class BandPassFilter { public : BandPassFilter ( double w , double zeta , double dt ) : w_ ( w ), zeta_ ( zeta ), dt_ ( dt ) { const double ww = w * w ; const double dtdt = dt * dt ; tf_ . set_discrite ( { ( 4 * dt * zeta * w ), 0 , ( -4 * dt * zeta * w )}, {( 4 + ( 4 * dt * zeta * w ) + dtdt * ww ), ( -8 + 2 * dtdt * ww ), ( 4 - ( 4 * dt * zeta * w ) + dtdt * ww )}, dt ); } void reset () { tf_ . reset (); } double filtering ( double u ) { return tf_ . responce ( u ); } double w () const { return w_ ; } double zeta () const { return zeta_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double zeta_ ; const double dt_ ; DiscreteTransferFunction tf_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/barrier__method_8hpp/","text":"include/cpp_robotics/optimize/barrier_method.hpp Namespaces Name cpp_robotics Source code #pragma once #include <cmath> #include <functional> #include <Eigen/Dense> #include \"constraint.hpp\" #include \"derivative.hpp\" #include \"quasi_newton_method.hpp\" namespace cpp_robotics { // \u5236\u7d04\u306e\u5883\u754c\u3067\u76ee\u7684\u95a2\u6570\u304c\u767a\u6563\u3059\u308b\u305f\u3081\u7b49\u5f0f\u5236\u7d04\u306f\u4f7f\u7528\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044 // \u307e\u305f\u4e0d\u7b49\u5f0f\u5236\u7d04\u3067\u3082g(x)=0\u306e\u5883\u754c\u3092\u307e\u305f\u3050\u3053\u3068\u306f\u51fa\u6765\u306a\u3044\u306e\u3067x_init\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5185\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b static std :: tuple < bool , Eigen :: VectorXd , size_t > barrier_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 10.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; double r = r_init ; std :: function < double ( const Eigen :: VectorXd & ) > ext_f = [ & ]( const Eigen :: VectorXd & x ) { double y = f ( x ); for ( auto & con : constraint ) { switch ( con . type ) { case Constraint :: Type :: Eq : // \u7121\u8996 break ; case Constraint :: Type :: Ineq : y += r * std :: log ( std :: abs ( con . con_f ( x ))); // / std::pow(, 2); break ; } } return y ; }; auto grad = [ & ]( Eigen :: VectorXd x ) { return derivative ( ext_f , x ); }; for ( size_t i = 0 ; i < max_iter ; i ++ ) { auto [ step_result , new_x , sub_itr_cnt ] = quasi_newton_method ( ext_f , grad , x , tol , 1 ); if ( std :: abs ( r * constraint . eval_sum ( new_x )) < tol ) return { true , new_x , i }; x = new_x ; r *= 1.5 ; } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/barrier_method.hpp"},{"location":"doxybook/Files/barrier__method_8hpp/#includecpp_roboticsoptimizebarrier_methodhpp","text":"","title":"include/cpp_robotics/optimize/barrier_method.hpp"},{"location":"doxybook/Files/barrier__method_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/barrier__method_8hpp/#source-code","text":"#pragma once #include <cmath> #include <functional> #include <Eigen/Dense> #include \"constraint.hpp\" #include \"derivative.hpp\" #include \"quasi_newton_method.hpp\" namespace cpp_robotics { // \u5236\u7d04\u306e\u5883\u754c\u3067\u76ee\u7684\u95a2\u6570\u304c\u767a\u6563\u3059\u308b\u305f\u3081\u7b49\u5f0f\u5236\u7d04\u306f\u4f7f\u7528\u3059\u308b\u3053\u3068\u304c\u51fa\u6765\u306a\u3044 // \u307e\u305f\u4e0d\u7b49\u5f0f\u5236\u7d04\u3067\u3082g(x)=0\u306e\u5883\u754c\u3092\u307e\u305f\u3050\u3053\u3068\u306f\u51fa\u6765\u306a\u3044\u306e\u3067x_init\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5185\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b static std :: tuple < bool , Eigen :: VectorXd , size_t > barrier_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 10.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; double r = r_init ; std :: function < double ( const Eigen :: VectorXd & ) > ext_f = [ & ]( const Eigen :: VectorXd & x ) { double y = f ( x ); for ( auto & con : constraint ) { switch ( con . type ) { case Constraint :: Type :: Eq : // \u7121\u8996 break ; case Constraint :: Type :: Ineq : y += r * std :: log ( std :: abs ( con . con_f ( x ))); // / std::pow(, 2); break ; } } return y ; }; auto grad = [ & ]( Eigen :: VectorXd x ) { return derivative ( ext_f , x ); }; for ( size_t i = 0 ; i < max_iter ; i ++ ) { auto [ step_result , new_x , sub_itr_cnt ] = quasi_newton_method ( ext_f , grad , x , tol , 1 ); if ( std :: abs ( r * constraint . eval_sum ( new_x )) < tol ) return { true , new_x , i }; x = new_x ; r *= 1.5 ; } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/bfgs_8hpp/","text":"include/cpp_robotics/optimize/bfgs.hpp Namespaces Name cpp_robotics Source code #pragma once #include <Eigen/Dense> namespace cpp_robotics { static void bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y ) { double sy , sBs ; Eigen :: VectorXd Bs ; Bs . noalias () = hess * s ; sBs = s . dot ( Bs ); sy = s . dot ( y ); hess += - ( Bs * Bs . transpose () ) / sBs + ( y * y . transpose () ) / ( sy ); } static void powells_modified_bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y , double gamma = 0.2 ) { // y_tilde if ( s . transpose () * y < gamma * s . transpose () * hess * s ) { double sy , sBs ; Eigen :: VectorXd Bs ; Bs . noalias () = hess * s ; sBs = s . dot ( Bs ); sy = s . dot ( y ); double beta = ( 1 - gamma ) * sBs / ( sBs - sy ); y = beta * y + ( 1 - beta ) * hess * s ; } bfgs_step ( hess , s , y ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/bfgs.hpp"},{"location":"doxybook/Files/bfgs_8hpp/#includecpp_roboticsoptimizebfgshpp","text":"","title":"include/cpp_robotics/optimize/bfgs.hpp"},{"location":"doxybook/Files/bfgs_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/bfgs_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> namespace cpp_robotics { static void bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y ) { double sy , sBs ; Eigen :: VectorXd Bs ; Bs . noalias () = hess * s ; sBs = s . dot ( Bs ); sy = s . dot ( y ); hess += - ( Bs * Bs . transpose () ) / sBs + ( y * y . transpose () ) / ( sy ); } static void powells_modified_bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y , double gamma = 0.2 ) { // y_tilde if ( s . transpose () * y < gamma * s . transpose () * hess * s ) { double sy , sBs ; Eigen :: VectorXd Bs ; Bs . noalias () = hess * s ; sBs = s . dot ( Bs ); sy = s . dot ( y ); double beta = ( 1 - gamma ) * sBs / ( sBs - sy ); y = beta * y + ( 1 - beta ) * hess * s ; } bfgs_step ( hess , s , y ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/bode_8hpp/","text":"include/cpp_robotics/system/bode.hpp Namespaces Name cpp_robotics Source code #pragma once #include <vector> #include <tuple> #include \"./transfer_function.hpp\" #include \"../third_party/matplotlib-cpp/matplotlibcpp.h\" #include \"../utility/space.hpp\" #include \"../vector/vector2.hpp\" #include \"../utility/math_utils.hpp\" #include \"./polynomial.hpp\" namespace cpp_robotics { static std :: tuple < std :: vector < double > , std :: vector < double >> bode ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ), bool gain_db_mode = true , bool phase_deg_mode = true ) { size_t n = omegas . size (); std :: vector < double > gain_db ( n ), phase_deg ( n ); Vector2d num_vec , den_vec ; auto num_array = tf . num_array (); auto den_array = tf . den_array (); Polynomial num_poly ( num_array . begin (), num_array . end ()); Polynomial den_poly ( den_array . begin (), den_array . end ()); for ( size_t i = 0 ; i < n ; i ++ ) { // gain { num_vec = Vector2d :: zero (); den_vec = Vector2d :: zero (); for ( size_t n = 0 ; n < num_poly . size (); n ++ ) { size_t deg = num_poly . degree () - n ; int dir ; bool is_real ; switch ( deg % 4 ) { case 0 : dir = 1 ; is_real = true ; break ; case 1 : dir = 1 ; is_real = false ; break ; case 2 : dir = -1 ; is_real = true ; break ; case 3 : dir = -1 ; is_real = false ; break ; } if ( is_real ) num_vec . x += dir * num_poly [ n ] * std :: pow ( omegas [ i ], deg ); else num_vec . y += dir * num_poly [ n ] * std :: pow ( omegas [ i ], deg ); } for ( size_t n = 0 ; n < den_poly . size (); n ++ ) { size_t deg = den_poly . degree () - n ; int dir ; bool is_real ; switch ( deg % 4 ) { case 0 : dir = 1 ; is_real = true ; break ; case 1 : dir = 1 ; is_real = false ; break ; case 2 : dir = -1 ; is_real = true ; break ; case 3 : dir = -1 ; is_real = false ; break ; } if ( is_real ) den_vec . x += dir * den_poly [ n ] * std :: pow ( omegas [ i ], deg ); else den_vec . y += dir * den_poly [ n ] * std :: pow ( omegas [ i ], deg ); } double gain = num_vec . norm () / den_vec . norm (); if ( gain_db_mode ) gain_db [ i ] = 20 * std :: log10 ( gain ); else gain_db [ i ] = gain ; } // phase { num_vec = Vector2d :: zero (); den_vec = Vector2d :: zero (); for ( size_t didx = 0 ; didx < tf . num_array (). size (); didx ++ ) { size_t deg = tf . num_deg ( didx ); if ( deg == 0 ) { num_vec . x += tf . num_array ()[ didx ]; } else { double s = std :: pow ( omegas [ i ], deg ); num_vec . y += s * tf . num_array ()[ didx ]; } } for ( size_t didx = 0 ; didx < tf . den_array (). size (); didx ++ ) { size_t deg = tf . den_deg ( didx ); if ( deg == 0 ) { den_vec . x += tf . den_array ()[ didx ]; } else { double s = std :: pow ( omegas [ i ], deg ); den_vec . y += s * tf . den_array ()[ didx ]; } } double phase = std :: atan ( num_vec . y / num_vec . x ) - std :: atan ( den_vec . y / den_vec . x ); if ( phase_deg_mode ) phase_deg [ i ] = degrees ( phase ); else phase_deg [ i ] = phase ; } } return { gain_db , phase_deg }; } static void bode_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 )) { namespace plt = matplotlibcpp ; auto [ g , ph ] = bode ( tf , omegas ); plt :: subplot ( 2 , 1 , 1 ); plt :: ylabel ( \"Magnitude(dB)\" ); plt :: semilogx ( omegas , g ); plt :: xlim ( std :: pow ( 10 , -2 ), std :: pow ( 10 , 2 )); plt :: ylim ( -60 , 30 ); plt :: grid ( true , \"both\" ); plt :: subplot ( 2 , 1 , 2 ); plt :: xlabel ( \"Frequency(rad/s)\" ); plt :: ylabel ( \"Phase(deg)\" ); plt :: semilogx ( omegas , ph ); plt :: xlim ( std :: pow ( 10 , -2 ), std :: pow ( 10 , 2 )); plt :: ylim ( -90 , 90 ); plt :: yticks ( std :: vector < double > { -90 , -45 , 0 , 45 , 90 }); plt :: grid ( true , \"both\" ); plt :: show (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/bode.hpp"},{"location":"doxybook/Files/bode_8hpp/#includecpp_roboticssystembodehpp","text":"","title":"include/cpp_robotics/system/bode.hpp"},{"location":"doxybook/Files/bode_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/bode_8hpp/#source-code","text":"#pragma once #include <vector> #include <tuple> #include \"./transfer_function.hpp\" #include \"../third_party/matplotlib-cpp/matplotlibcpp.h\" #include \"../utility/space.hpp\" #include \"../vector/vector2.hpp\" #include \"../utility/math_utils.hpp\" #include \"./polynomial.hpp\" namespace cpp_robotics { static std :: tuple < std :: vector < double > , std :: vector < double >> bode ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ), bool gain_db_mode = true , bool phase_deg_mode = true ) { size_t n = omegas . size (); std :: vector < double > gain_db ( n ), phase_deg ( n ); Vector2d num_vec , den_vec ; auto num_array = tf . num_array (); auto den_array = tf . den_array (); Polynomial num_poly ( num_array . begin (), num_array . end ()); Polynomial den_poly ( den_array . begin (), den_array . end ()); for ( size_t i = 0 ; i < n ; i ++ ) { // gain { num_vec = Vector2d :: zero (); den_vec = Vector2d :: zero (); for ( size_t n = 0 ; n < num_poly . size (); n ++ ) { size_t deg = num_poly . degree () - n ; int dir ; bool is_real ; switch ( deg % 4 ) { case 0 : dir = 1 ; is_real = true ; break ; case 1 : dir = 1 ; is_real = false ; break ; case 2 : dir = -1 ; is_real = true ; break ; case 3 : dir = -1 ; is_real = false ; break ; } if ( is_real ) num_vec . x += dir * num_poly [ n ] * std :: pow ( omegas [ i ], deg ); else num_vec . y += dir * num_poly [ n ] * std :: pow ( omegas [ i ], deg ); } for ( size_t n = 0 ; n < den_poly . size (); n ++ ) { size_t deg = den_poly . degree () - n ; int dir ; bool is_real ; switch ( deg % 4 ) { case 0 : dir = 1 ; is_real = true ; break ; case 1 : dir = 1 ; is_real = false ; break ; case 2 : dir = -1 ; is_real = true ; break ; case 3 : dir = -1 ; is_real = false ; break ; } if ( is_real ) den_vec . x += dir * den_poly [ n ] * std :: pow ( omegas [ i ], deg ); else den_vec . y += dir * den_poly [ n ] * std :: pow ( omegas [ i ], deg ); } double gain = num_vec . norm () / den_vec . norm (); if ( gain_db_mode ) gain_db [ i ] = 20 * std :: log10 ( gain ); else gain_db [ i ] = gain ; } // phase { num_vec = Vector2d :: zero (); den_vec = Vector2d :: zero (); for ( size_t didx = 0 ; didx < tf . num_array (). size (); didx ++ ) { size_t deg = tf . num_deg ( didx ); if ( deg == 0 ) { num_vec . x += tf . num_array ()[ didx ]; } else { double s = std :: pow ( omegas [ i ], deg ); num_vec . y += s * tf . num_array ()[ didx ]; } } for ( size_t didx = 0 ; didx < tf . den_array (). size (); didx ++ ) { size_t deg = tf . den_deg ( didx ); if ( deg == 0 ) { den_vec . x += tf . den_array ()[ didx ]; } else { double s = std :: pow ( omegas [ i ], deg ); den_vec . y += s * tf . den_array ()[ didx ]; } } double phase = std :: atan ( num_vec . y / num_vec . x ) - std :: atan ( den_vec . y / den_vec . x ); if ( phase_deg_mode ) phase_deg [ i ] = degrees ( phase ); else phase_deg [ i ] = phase ; } } return { gain_db , phase_deg }; } static void bode_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 )) { namespace plt = matplotlibcpp ; auto [ g , ph ] = bode ( tf , omegas ); plt :: subplot ( 2 , 1 , 1 ); plt :: ylabel ( \"Magnitude(dB)\" ); plt :: semilogx ( omegas , g ); plt :: xlim ( std :: pow ( 10 , -2 ), std :: pow ( 10 , 2 )); plt :: ylim ( -60 , 30 ); plt :: grid ( true , \"both\" ); plt :: subplot ( 2 , 1 , 2 ); plt :: xlabel ( \"Frequency(rad/s)\" ); plt :: ylabel ( \"Phase(deg)\" ); plt :: semilogx ( omegas , ph ); plt :: xlim ( std :: pow ( 10 , -2 ), std :: pow ( 10 , 2 )); plt :: ylim ( -90 , 90 ); plt :: yticks ( std :: vector < double > { -90 , -45 , 0 , 45 , 90 }); plt :: grid ( true , \"both\" ); plt :: show (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/bracketing__serach_8hpp/","text":"include/cpp_robotics/optimize/bracketing_serach.hpp Namespaces Name cpp_robotics Source code #pragma once #include <cmath> #include <functional> #include <Eigen/Dense> namespace cpp_robotics { static double bracketing_serach ( std :: function < double ( Eigen :: VectorXd ) > func , std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > grad , const Eigen :: VectorXd & x , const Eigen :: VectorXd & d , double gamma = 0.3 , double tau = 0.9 , const size_t max_iter = 1000 ) { auto line_func = [ & ]( double v ){ return func ( x + v * d ); }; double a = 1 ; double b = grad ( x ). dot ( d ); double lf0 = line_func ( 0 ); for ( size_t i = 0 ; i < max_iter ; i ++ ){ if ( line_func ( a ) <= lf0 + gamma * a * b ){ return a ; } a = tau * a ; } return a ; } static double bracketing_serach ( std :: function < double ( double ) > func , const double init = 1.0 , const double beta = 0.9 , const size_t max_iter = 1000 ) { double a = init ; double fval = func ( a ); double new_fval ; for ( size_t i = 0 ; i < max_iter ; i ++ ) { new_fval = func ( a * beta ); if ( new_fval > fval ) return a ; a *= beta ; fval = new_fval ; } return a ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/bracketing_serach.hpp"},{"location":"doxybook/Files/bracketing__serach_8hpp/#includecpp_roboticsoptimizebracketing_serachhpp","text":"","title":"include/cpp_robotics/optimize/bracketing_serach.hpp"},{"location":"doxybook/Files/bracketing__serach_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/bracketing__serach_8hpp/#source-code","text":"#pragma once #include <cmath> #include <functional> #include <Eigen/Dense> namespace cpp_robotics { static double bracketing_serach ( std :: function < double ( Eigen :: VectorXd ) > func , std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > grad , const Eigen :: VectorXd & x , const Eigen :: VectorXd & d , double gamma = 0.3 , double tau = 0.9 , const size_t max_iter = 1000 ) { auto line_func = [ & ]( double v ){ return func ( x + v * d ); }; double a = 1 ; double b = grad ( x ). dot ( d ); double lf0 = line_func ( 0 ); for ( size_t i = 0 ; i < max_iter ; i ++ ){ if ( line_func ( a ) <= lf0 + gamma * a * b ){ return a ; } a = tau * a ; } return a ; } static double bracketing_serach ( std :: function < double ( double ) > func , const double init = 1.0 , const double beta = 0.9 , const size_t max_iter = 1000 ) { double a = init ; double fval = func ( a ); double new_fval ; for ( size_t i = 0 ; i < max_iter ; i ++ ) { new_fval = func ( a * beta ); if ( new_fval > fval ) return a ; a *= beta ; fval = new_fval ; } return a ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/chassis_8hpp/","text":"include/cpp_robotics/chassis/chassis.hpp Source code #pragma once #include \"./mecanum_ik.hpp\" #include \"./omni_ik.hpp\" #include \"./swerve_ik.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/chassis/chassis.hpp"},{"location":"doxybook/Files/chassis_8hpp/#includecpp_roboticschassischassishpp","text":"","title":"include/cpp_robotics/chassis/chassis.hpp"},{"location":"doxybook/Files/chassis_8hpp/#source-code","text":"#pragma once #include \"./mecanum_ik.hpp\" #include \"./omni_ik.hpp\" #include \"./swerve_ik.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/constraint_8hpp/","text":"include/cpp_robotics/optimize/constraint.hpp Namespaces Name cpp_robotics Classes Name struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 Source code #pragma once #include <cmath> #include <functional> #include <vector> #include <optional> #include <numeric> #include <Eigen/Dense> #include \"derivative.hpp\" namespace cpp_robotics { struct Constraint { using func_type = std :: function < double ( Eigen :: VectorXd ) > ; using grad_func_type = std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > ; using hessian_func_type = std :: function < Eigen :: MatrixXd ( Eigen :: VectorXd ) > ; enum Type : uint8_t { // g(x) = 0 Eq , // g(x) <= 0 Ineq }; Type type ; func_type con_f ; std :: optional < grad_func_type > con_grad_f ; std :: optional < hessian_func_type > con_hessian_f ; Constraint ( Type type_ , func_type con_ ) : type ( type_ ), con_f ( con_ ) {} double eval ( const Eigen :: VectorXd & x ) const { return con_f ( x ); } bool satisfy ( const Eigen :: VectorXd & x , const double tol ) const { const double val = eval ( x ); std :: cout << \"eval: \" << val << std :: endl ; if ( type == Type :: Eq ) { return std :: abs ( val ) < tol ; } else { return val < tol ; } } Eigen :: VectorXd grad ( Eigen :: VectorXd x ) { if ( con_grad_f ) return con_grad_f . value ()( x ); return derivative ( con_f , x ); } Eigen :: MatrixXd hessian ( Eigen :: VectorXd x ) { if ( con_hessian_f ) return con_hessian_f . value ()( x ); return approx_hessian ( con_f , x ); } }; class ConstraintArray : public std :: vector < Constraint > { public : // std::vector<Constraint>::size_type size() const // { // return this->size(); // } std :: vector < double > eval ( const Eigen :: VectorXd & x ) const { std :: vector < double > val ( this -> size ()); for ( size_t i = 0 ; i < this -> size (); i ++ ) { val [ i ] = this -> at ( i ). eval ( x ); } return val ; } double eval_sum ( const Eigen :: VectorXd & x ) const { auto val = eval ( x ); return std :: accumulate ( val . begin (), val . end (), 0.0 ); } bool all_satisfy ( const Eigen :: VectorXd & x , const double tol ) const { bool satisfy = true ; for ( auto & con : * this ) { if ( not con . satisfy ( x , tol )) { std :: cout << \"not satisfy\" << std :: endl ; satisfy = false ; } else { std :: cout << \"satisfy\" << std :: endl ; } } return satisfy ; } std :: vector < Constraint >:: size_type eq_constraint_size () const { std :: vector < Constraint >:: size_type num = 0 ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Eq ) num ++ ; } return num ; } std :: vector < Constraint >:: size_type ineq_constraint_size () const { std :: vector < Constraint >:: size_type num = 0 ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Ineq ) num ++ ; } return num ; } std :: vector < Constraint > gen_eq_constraint_list () const { std :: vector < Constraint > ret ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Eq ) ret . push_back ( con ); } return ret ; } std :: vector < Constraint > gen_ineq_constraint_list () const { std :: vector < Constraint > ret ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Ineq ) ret . push_back ( con ); } return ret ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/constraint.hpp"},{"location":"doxybook/Files/constraint_8hpp/#includecpp_roboticsoptimizeconstrainthpp","text":"","title":"include/cpp_robotics/optimize/constraint.hpp"},{"location":"doxybook/Files/constraint_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/constraint_8hpp/#classes","text":"Name struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408","title":"Classes"},{"location":"doxybook/Files/constraint_8hpp/#source-code","text":"#pragma once #include <cmath> #include <functional> #include <vector> #include <optional> #include <numeric> #include <Eigen/Dense> #include \"derivative.hpp\" namespace cpp_robotics { struct Constraint { using func_type = std :: function < double ( Eigen :: VectorXd ) > ; using grad_func_type = std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > ; using hessian_func_type = std :: function < Eigen :: MatrixXd ( Eigen :: VectorXd ) > ; enum Type : uint8_t { // g(x) = 0 Eq , // g(x) <= 0 Ineq }; Type type ; func_type con_f ; std :: optional < grad_func_type > con_grad_f ; std :: optional < hessian_func_type > con_hessian_f ; Constraint ( Type type_ , func_type con_ ) : type ( type_ ), con_f ( con_ ) {} double eval ( const Eigen :: VectorXd & x ) const { return con_f ( x ); } bool satisfy ( const Eigen :: VectorXd & x , const double tol ) const { const double val = eval ( x ); std :: cout << \"eval: \" << val << std :: endl ; if ( type == Type :: Eq ) { return std :: abs ( val ) < tol ; } else { return val < tol ; } } Eigen :: VectorXd grad ( Eigen :: VectorXd x ) { if ( con_grad_f ) return con_grad_f . value ()( x ); return derivative ( con_f , x ); } Eigen :: MatrixXd hessian ( Eigen :: VectorXd x ) { if ( con_hessian_f ) return con_hessian_f . value ()( x ); return approx_hessian ( con_f , x ); } }; class ConstraintArray : public std :: vector < Constraint > { public : // std::vector<Constraint>::size_type size() const // { // return this->size(); // } std :: vector < double > eval ( const Eigen :: VectorXd & x ) const { std :: vector < double > val ( this -> size ()); for ( size_t i = 0 ; i < this -> size (); i ++ ) { val [ i ] = this -> at ( i ). eval ( x ); } return val ; } double eval_sum ( const Eigen :: VectorXd & x ) const { auto val = eval ( x ); return std :: accumulate ( val . begin (), val . end (), 0.0 ); } bool all_satisfy ( const Eigen :: VectorXd & x , const double tol ) const { bool satisfy = true ; for ( auto & con : * this ) { if ( not con . satisfy ( x , tol )) { std :: cout << \"not satisfy\" << std :: endl ; satisfy = false ; } else { std :: cout << \"satisfy\" << std :: endl ; } } return satisfy ; } std :: vector < Constraint >:: size_type eq_constraint_size () const { std :: vector < Constraint >:: size_type num = 0 ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Eq ) num ++ ; } return num ; } std :: vector < Constraint >:: size_type ineq_constraint_size () const { std :: vector < Constraint >:: size_type num = 0 ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Ineq ) num ++ ; } return num ; } std :: vector < Constraint > gen_eq_constraint_list () const { std :: vector < Constraint > ret ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Eq ) ret . push_back ( con ); } return ret ; } std :: vector < Constraint > gen_ineq_constraint_list () const { std :: vector < Constraint > ret ; for ( auto & con : * this ) { if ( con . type == Constraint :: Type :: Ineq ) ret . push_back ( con ); } return ret ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/controller_8hpp/","text":"include/cpp_robotics/controller/controller.hpp Source code #include \"./pid.hpp\" #include \"./pid2.hpp\" #include \"./lqr.hpp\" #include \"./pure_pursuit.hpp\" #include \"./nctf.hpp\" #include \"./modern_control.hpp\" #include \"./pfc.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/controller.hpp"},{"location":"doxybook/Files/controller_8hpp/#includecpp_roboticscontrollercontrollerhpp","text":"","title":"include/cpp_robotics/controller/controller.hpp"},{"location":"doxybook/Files/controller_8hpp/#source-code","text":"#include \"./pid.hpp\" #include \"./pid2.hpp\" #include \"./lqr.hpp\" #include \"./pure_pursuit.hpp\" #include \"./nctf.hpp\" #include \"./modern_control.hpp\" #include \"./pfc.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/core_8hpp/","text":"include/cpp_robotics/core.hpp Source code #pragma once // utility core #include \"utility/utility.hpp\" #include \"vector/vector.hpp\" #include \"units/units.hpp\" // control core #include \"controller/controller.hpp\" #include \"filter/filter.hpp\" #include \"system/system.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/core.hpp"},{"location":"doxybook/Files/core_8hpp/#includecpp_roboticscorehpp","text":"","title":"include/cpp_robotics/core.hpp"},{"location":"doxybook/Files/core_8hpp/#source-code","text":"#pragma once // utility core #include \"utility/utility.hpp\" #include \"vector/vector.hpp\" #include \"units/units.hpp\" // control core #include \"controller/controller.hpp\" #include \"filter/filter.hpp\" #include \"system/system.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/cpp__robotics_8hpp/","text":"include/cpp_robotics/cpp_robotics.hpp Source code #pragma once #include \"core.hpp\" #include \"path_planning/path_planning.hpp\" #include \"spline/spline.hpp\" #include \"geometry/geometry.hpp\" #include \"chassis/chassis.hpp\" #include \"algorithm/algorithm.hpp\" #include \"motor/dc_motor_list.hpp\" #include \"optimize/optimize.hpp\" #include \"motor/motor_tf.hpp\" #include \"third_party/matplotlib-cpp/matplotlibcpp.h\" // #include \"robot\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/cpp_robotics.hpp"},{"location":"doxybook/Files/cpp__robotics_8hpp/#includecpp_roboticscpp_roboticshpp","text":"","title":"include/cpp_robotics/cpp_robotics.hpp"},{"location":"doxybook/Files/cpp__robotics_8hpp/#source-code","text":"#pragma once #include \"core.hpp\" #include \"path_planning/path_planning.hpp\" #include \"spline/spline.hpp\" #include \"geometry/geometry.hpp\" #include \"chassis/chassis.hpp\" #include \"algorithm/algorithm.hpp\" #include \"motor/dc_motor_list.hpp\" #include \"optimize/optimize.hpp\" #include \"motor/motor_tf.hpp\" #include \"third_party/matplotlib-cpp/matplotlibcpp.h\" // #include \"robot\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/cpp__support_8hpp/","text":"include/cpp_robotics/utility/cpp_support.hpp Namespaces Name cpp_robotics Source code #pragma once #include <string> #include <cstdio> #include <vector> // platform #if defined(linux) || defined(__linux) || defined(__linux__) # define CPP_ROBOTICS_PLATFORM_LINUX #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__) # define CPP_ROBOTICS_PLATFORM_WINDOWS #endif // C++ version #ifdef __cplusplus # if (__cplusplus >= 201103L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201103L) # define CPP_ROBOTICS_CPP11_OR_GREATER # endif # if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L) # define CPP_ROBOTICS_CPP14_OR_GREATER # endif # if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) # define CPP_ROBOTICS_CPP17_OR_GREATER # endif # if (__cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L) # define CPP_ROBOTICS_CPP20_OR_GREATER # endif #endif #ifdef CPP_ROBOTICS_CPP17_OR_GREATER #include <string_view> #endif // CPP_ROBOTICS_CPP17_OR_GREATER #ifdef CPP_ROBOTICS_CPP20_OR_GREATER #include <format> #endif namespace cpp_robotics { template < class ForwardIterator > constexpr ForwardIterator shift_left ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) { if ( n <= 0 ) return last ; if ( n >= last - first ) return first ; ForwardIterator it = first ; ForwardIterator nlast = std :: prev ( last , n ); while ( it != nlast ) { ForwardIterator nit = std :: next ( it , n ); * it = * nit ; it ++ ; } return first + ( last - first - n ); } template < class ForwardIterator > constexpr ForwardIterator shift_right ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) { if ( n <= 0 ) return first ; if ( n >= last - first ) return last ; ForwardIterator it = std :: prev ( last , n ); ForwardIterator nfirst = std :: prev ( first , 1 ); while ( it != nfirst ) { ForwardIterator nit = std :: next ( it , n ); * nit = * it ; it -- ; } return first + n ; } template < typename ... Args > std :: string c_format ( const std :: string & format , Args const & ... args ) { #pragma GCC diagnostic ignored \"-Wformat-security\" size_t len = std :: snprintf ( nullptr , 0 , format . c_str (), args ...); std :: vector < char > buf ( len + 1 ); std :: snprintf ( & buf [ 0 ], len + 1 , format . c_str (), args ...); return std :: string { & buf [ 0 ], & buf [ 0 ] + len }; #pragma GCC diagnostic warning \"-Wformat-security\" } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/utility/cpp_support.hpp"},{"location":"doxybook/Files/cpp__support_8hpp/#includecpp_roboticsutilitycpp_supporthpp","text":"","title":"include/cpp_robotics/utility/cpp_support.hpp"},{"location":"doxybook/Files/cpp__support_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/cpp__support_8hpp/#source-code","text":"#pragma once #include <string> #include <cstdio> #include <vector> // platform #if defined(linux) || defined(__linux) || defined(__linux__) # define CPP_ROBOTICS_PLATFORM_LINUX #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__) # define CPP_ROBOTICS_PLATFORM_WINDOWS #endif // C++ version #ifdef __cplusplus # if (__cplusplus >= 201103L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201103L) # define CPP_ROBOTICS_CPP11_OR_GREATER # endif # if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L) # define CPP_ROBOTICS_CPP14_OR_GREATER # endif # if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) # define CPP_ROBOTICS_CPP17_OR_GREATER # endif # if (__cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L) # define CPP_ROBOTICS_CPP20_OR_GREATER # endif #endif #ifdef CPP_ROBOTICS_CPP17_OR_GREATER #include <string_view> #endif // CPP_ROBOTICS_CPP17_OR_GREATER #ifdef CPP_ROBOTICS_CPP20_OR_GREATER #include <format> #endif namespace cpp_robotics { template < class ForwardIterator > constexpr ForwardIterator shift_left ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) { if ( n <= 0 ) return last ; if ( n >= last - first ) return first ; ForwardIterator it = first ; ForwardIterator nlast = std :: prev ( last , n ); while ( it != nlast ) { ForwardIterator nit = std :: next ( it , n ); * it = * nit ; it ++ ; } return first + ( last - first - n ); } template < class ForwardIterator > constexpr ForwardIterator shift_right ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) { if ( n <= 0 ) return first ; if ( n >= last - first ) return last ; ForwardIterator it = std :: prev ( last , n ); ForwardIterator nfirst = std :: prev ( first , 1 ); while ( it != nfirst ) { ForwardIterator nit = std :: next ( it , n ); * nit = * it ; it -- ; } return first + n ; } template < typename ... Args > std :: string c_format ( const std :: string & format , Args const & ... args ) { #pragma GCC diagnostic ignored \"-Wformat-security\" size_t len = std :: snprintf ( nullptr , 0 , format . c_str (), args ...); std :: vector < char > buf ( len + 1 ); std :: snprintf ( & buf [ 0 ], len + 1 , format . c_str (), args ...); return std :: string { & buf [ 0 ], & buf [ 0 ] + len }; #pragma GCC diagnostic warning \"-Wformat-security\" } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/dc__motor__list_8hpp/","text":"include/cpp_robotics/motor/dc_motor_list.hpp Namespaces Name cpp_robotics Source code #pragma once #include \"./dc_motor_param.hpp\" namespace cpp_robotics { inline constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param ( 18 _V , 20400 _rpm , 2.8 _A , 1265 _mmNm , 156 _A , 7.088e-5 _H , 2.46e-5 // \u9069\u5f53 ); inline constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param ( 18 _V , 18400 _rpm , 2.7 _A , 1216 _mmNm , 130 _A , 5.872e-5 _H , 2.46e-5 // \u9069\u5f53 ); inline constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param ( 12 _V , 9100 _rpm , 0.8 _A , 450 _mmNm , 36 _A , 1.820e-4 _H , 2.46e-5 // \u9069\u5f53 ); // inline constexpr DCMotorParam RS_540SH_6527 // { // 1.658e+0_ohm, // 7.371e-5_H, // 3.899e-3_Nm_per_A, // 6.239e-3_Nm, // 3.745e-2_Vs_per_rad // }; inline constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param ( 6 _V , 12500 _rpm , 0.56 _A , 77.5 _mmNm , 18 _A , 1.521e-4 _H , 2.46e-5 // \u9069\u5f53 ); inline constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param ( 18 _V , 17500 _rpm , 0.23 _A , 76.9 _mmNm , 7.91 _A , 1.521e-4 _H , 2.46e-5 // \u9069\u5f53 ); // inline constexpr DCMotorParam RS_385PH_2465 // { // 3.067e+1_ohm, // 1.128e-3_H, // 1.189e-2_Nm_per_A, // 3.219e-3_Nm, // 1.330e-1_Vs_per_rad // }; inline constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param ( 18 _V , 3520 _rpm , 755 _mA , 0.0609 _ohm , 0.0226 _mH , 46e-3 _Nm_per_A , 1.38 ); // http://suzakugiken.jp/goods/30144/catalog-IG32.pdf // http://suzakugiken.jp/goods/30335/catalog-IG36P.pdf // http://suzakugiken.jp/goods/30045/catalog-IG42C.pdf inline constexpr GearHeadParam IG42C_4 = { 1 / 4.0f , 0.8f }; inline constexpr GearHeadParam IG42C_14 = { 1 / 14.0f , 0.7f }; inline constexpr GearHeadParam IG42C_17 = { 1 / 17.0f , 0.7f }; inline constexpr GearHeadParam IG32_27 = { 1 / 27.0f , 0.7f }; inline constexpr GearHeadParam IG32_71 = { 1 / 71.0f , 0.6f }; inline constexpr GearHeadParam IG32_100 = { 1 / 100.0f , 0.6f }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/motor/dc_motor_list.hpp"},{"location":"doxybook/Files/dc__motor__list_8hpp/#includecpp_roboticsmotordc_motor_listhpp","text":"","title":"include/cpp_robotics/motor/dc_motor_list.hpp"},{"location":"doxybook/Files/dc__motor__list_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/dc__motor__list_8hpp/#source-code","text":"#pragma once #include \"./dc_motor_param.hpp\" namespace cpp_robotics { inline constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param ( 18 _V , 20400 _rpm , 2.8 _A , 1265 _mmNm , 156 _A , 7.088e-5 _H , 2.46e-5 // \u9069\u5f53 ); inline constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param ( 18 _V , 18400 _rpm , 2.7 _A , 1216 _mmNm , 130 _A , 5.872e-5 _H , 2.46e-5 // \u9069\u5f53 ); inline constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param ( 12 _V , 9100 _rpm , 0.8 _A , 450 _mmNm , 36 _A , 1.820e-4 _H , 2.46e-5 // \u9069\u5f53 ); // inline constexpr DCMotorParam RS_540SH_6527 // { // 1.658e+0_ohm, // 7.371e-5_H, // 3.899e-3_Nm_per_A, // 6.239e-3_Nm, // 3.745e-2_Vs_per_rad // }; inline constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param ( 6 _V , 12500 _rpm , 0.56 _A , 77.5 _mmNm , 18 _A , 1.521e-4 _H , 2.46e-5 // \u9069\u5f53 ); inline constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param ( 18 _V , 17500 _rpm , 0.23 _A , 76.9 _mmNm , 7.91 _A , 1.521e-4 _H , 2.46e-5 // \u9069\u5f53 ); // inline constexpr DCMotorParam RS_385PH_2465 // { // 3.067e+1_ohm, // 1.128e-3_H, // 1.189e-2_Nm_per_A, // 3.219e-3_Nm, // 1.330e-1_Vs_per_rad // }; inline constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param ( 18 _V , 3520 _rpm , 755 _mA , 0.0609 _ohm , 0.0226 _mH , 46e-3 _Nm_per_A , 1.38 ); // http://suzakugiken.jp/goods/30144/catalog-IG32.pdf // http://suzakugiken.jp/goods/30335/catalog-IG36P.pdf // http://suzakugiken.jp/goods/30045/catalog-IG42C.pdf inline constexpr GearHeadParam IG42C_4 = { 1 / 4.0f , 0.8f }; inline constexpr GearHeadParam IG42C_14 = { 1 / 14.0f , 0.7f }; inline constexpr GearHeadParam IG42C_17 = { 1 / 17.0f , 0.7f }; inline constexpr GearHeadParam IG32_27 = { 1 / 27.0f , 0.7f }; inline constexpr GearHeadParam IG32_71 = { 1 / 71.0f , 0.6f }; inline constexpr GearHeadParam IG32_100 = { 1 / 100.0f , 0.6f }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/dc__motor__param_8hpp/","text":"include/cpp_robotics/motor/dc_motor_param.hpp Namespaces Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb Classes Name struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb Source code #pragma once #include \"../units/units.hpp\" #include <cmath> namespace cpp_robotics { inline namespace unit { using TorqueConstant = unit_assem :: unit_div < Torque , Ampere >:: unit ; using BackEmfConstant = unit_assem :: unit_div < Volt , AngularVelocity >:: unit ; using FrictionConstant = unit_assem :: unit_mul < Torque , Second >:: unit ; } GENERATE_UNIT_SUFFIX ( cpp_robotics :: TorqueConstant , Nm_per_A ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: BackEmfConstant , Vs_per_rad ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: FrictionConstant , Nms ) struct DCMotorParam { const Volt nominal_voltage ; // \u516c\u79f0\u96fb\u5727[V] const Rpm free_speed ; // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm] const Ampere free_current ; // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A] const Ohm resistance ; // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm] (\u516c\u79f0\u96fb\u5727 / \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41) const Henry inductance ; // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] const TorqueConstant torque_constant ; // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A] (\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af)/(\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41 - \u7121\u8ca0\u8377\u96fb\u6d41) const BackEmfConstant back_emf_constance ; // \u9006\u6c17\u96fb\u529b\u5b9a\u6570[V/(rad/s)] (\u516c\u79f0\u96fb\u5727 - \u62b5\u6297*\u7121\u8ca0\u8377\u96fb\u6d41)/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s] const FrictionConstant friction_constant ; // \u7c98\u6027\u4fc2\u6570[Nms] (\u30c8\u30eb\u30af\u640d\u5931/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]) \u30c8\u30eb\u30af\u640d\u5931 = \u7121\u8ca0\u8377\u6642\u96fb\u6d41*\u30c8\u30eb\u30af\u5b9a\u6570 const Inertia rotor_inertia ; // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2] const Second time_constant ; // \u96fb\u6c17\u7684\u6642\u5b9a\u6570[s] (\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9/\u62b5\u6297) constexpr DCMotorParam ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Ohm Rm , Henry Lm , TorqueConstant Kt , BackEmfConstant Ke , Inertia Im , Second curr_set_time = 0.1f ) : nominal_voltage ( nominal_voltage ), free_speed ( free_speed ), free_current ( free_current ), resistance ( Rm ), inductance ( Lm ), torque_constant ( Kt ), back_emf_constance ( Ke ), friction_constant (( free_current * torque_constant ) / ( AngularVelocity )( free_speed )), rotor_inertia ( Im ), time_constant ( inductance / resistance ) { set_current_setting_time ( curr_set_time ); } constexpr DCMotorParam ( const DCMotorParam & ) = default ; constexpr void set_current_setting_time ( Second Tc ) { if (( double ) Tc > 0.0f ) current_setting_time_ = Tc ; corner_frequency_ = 3.0f / current_setting_time_ ; current_p_gain_base_ = ( inductance * corner_frequency_ ). value (); current_i_gain_base_ = ( resistance * corner_frequency_ ). value (); } constexpr Rpm calcu_steady_free_velocity ( Volt v ) const { return free_speed * (( double ) v / ( double ) nominal_voltage ); } constexpr Ampere calcu_stall_current ( Volt v ) const { return v / resistance ; } constexpr Torque calcu_stall_torque ( Volt v ) const { return calcu_stall_current ( v ) * torque_constant ; } constexpr AngularAcceleration calcu_max_free_angular_acceleration ( Volt v ) const { return calcu_stall_torque ( v ) / rotor_inertia ; } constexpr Second get_Tm () const { return time_constant ; } constexpr AngularVelocity get_Wi () const { return corner_frequency_ ; } constexpr double get_Kip ( Volt volt ) const { return current_p_gain_base_ / volt . value (); } constexpr double get_Kii ( Volt volt ) const { return current_i_gain_base_ / volt . value (); } private : Second current_setting_time_ = 0.1 _s ; AngularVelocity corner_frequency_ = 0 ; double current_p_gain_base_ = 0 ; double current_i_gain_base_ = 0 ; }; struct GearHeadParam { const double ratio ; const double efficiency ; constexpr GearHeadParam ( double ratio_ , double efficiency_ ) : ratio ( ratio_ ), efficiency ( efficiency_ ) {} }; struct DCGearedMotorParam { constexpr DCGearedMotorParam ( Volt voltage_ , DCMotorParam motor_ , GearHeadParam gear_head_ , const double optional_gear_ratio_ = 1 ) : voltage ( voltage_ ), motor ( motor_ ), gear_head ( gear_head_ ), optional_gear_ratio ( optional_gear_ratio_ ) { } constexpr Rpm calcu_gear_head_steady_free_velocity ( Volt v ) const { return motor . calcu_steady_free_velocity ( v ) * gear_head . ratio ; } constexpr Rpm calcu_endpoint_steady_free_velocity ( Volt v ) const { return calcu_gear_head_steady_free_velocity ( v ) * optional_gear_ratio ; } constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration ( Inertia optional_inertina = 0 ) const { return motor . calcu_stall_torque ( voltage ) / ( motor . rotor_inertia + ( optional_inertina * std :: pow ( gear_head . ratio * optional_gear_ratio , 2 ))) * gear_head . ratio ; } const Volt voltage ; const DCMotorParam motor ; const GearHeadParam gear_head ; const double optional_gear_ratio ; }; inline constexpr DCMotorParam generate_mabuchi_motor_param ( Volt nominal_voltage , // \u516c\u79f0\u96fb\u5727[V] Rpm free_speed , // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm] Ampere free_current , // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A] Torque stall_torque , // \u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af[Nm] Ampere stall_current , // \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41[A] Henry inductance , // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] (\u8a08\u6e2c\u3059\u308b) Inertia rotor_inertia // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8 [ kgm ^ 2 ] ( \u8a08\u6e2c\u3059\u308b ) ) { const auto R = nominal_voltage / stall_current ; return DCMotorParam ( nominal_voltage , free_speed , free_current , R , inductance , stall_torque / ( stall_current - free_current ), ( nominal_voltage - R * free_current ) / ( AngularVelocity )( free_speed ), rotor_inertia ); } inline constexpr DCMotorParam generate_maxon_brush_motor_param ( Volt nominal_voltage , // \u516c\u79f0\u96fb\u5727[V] Rpm free_speed , // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm] Ampere free_current , // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A] Ohm resistance , // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm] Henry inductance , // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] TorqueConstant Kt , // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A] Inertia rotor_inertia // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8 [ kgm ^ 2 ] ( \u8a08\u6e2c\u3059\u308b ) ) { return DCMotorParam ( nominal_voltage , free_speed , free_current , resistance , inductance , Kt , ( nominal_voltage - resistance * free_current ) / ( AngularVelocity )( free_speed ), rotor_inertia ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/motor/dc_motor_param.hpp"},{"location":"doxybook/Files/dc__motor__param_8hpp/#includecpp_roboticsmotordc_motor_paramhpp","text":"","title":"include/cpp_robotics/motor/dc_motor_param.hpp"},{"location":"doxybook/Files/dc__motor__param_8hpp/#namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb","title":"Namespaces"},{"location":"doxybook/Files/dc__motor__param_8hpp/#classes","text":"Name struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb","title":"Classes"},{"location":"doxybook/Files/dc__motor__param_8hpp/#source-code","text":"#pragma once #include \"../units/units.hpp\" #include <cmath> namespace cpp_robotics { inline namespace unit { using TorqueConstant = unit_assem :: unit_div < Torque , Ampere >:: unit ; using BackEmfConstant = unit_assem :: unit_div < Volt , AngularVelocity >:: unit ; using FrictionConstant = unit_assem :: unit_mul < Torque , Second >:: unit ; } GENERATE_UNIT_SUFFIX ( cpp_robotics :: TorqueConstant , Nm_per_A ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: BackEmfConstant , Vs_per_rad ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: FrictionConstant , Nms ) struct DCMotorParam { const Volt nominal_voltage ; // \u516c\u79f0\u96fb\u5727[V] const Rpm free_speed ; // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm] const Ampere free_current ; // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A] const Ohm resistance ; // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm] (\u516c\u79f0\u96fb\u5727 / \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41) const Henry inductance ; // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] const TorqueConstant torque_constant ; // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A] (\u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af)/(\u30b9\u30c8\u30fc\u30eb\u96fb\u6d41 - \u7121\u8ca0\u8377\u96fb\u6d41) const BackEmfConstant back_emf_constance ; // \u9006\u6c17\u96fb\u529b\u5b9a\u6570[V/(rad/s)] (\u516c\u79f0\u96fb\u5727 - \u62b5\u6297*\u7121\u8ca0\u8377\u96fb\u6d41)/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s] const FrictionConstant friction_constant ; // \u7c98\u6027\u4fc2\u6570[Nms] (\u30c8\u30eb\u30af\u640d\u5931/\u7121\u8ca0\u8377\u56de\u8ee2\u6570[rad/s]) \u30c8\u30eb\u30af\u640d\u5931 = \u7121\u8ca0\u8377\u6642\u96fb\u6d41*\u30c8\u30eb\u30af\u5b9a\u6570 const Inertia rotor_inertia ; // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8[kgm^2] const Second time_constant ; // \u96fb\u6c17\u7684\u6642\u5b9a\u6570[s] (\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9/\u62b5\u6297) constexpr DCMotorParam ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Ohm Rm , Henry Lm , TorqueConstant Kt , BackEmfConstant Ke , Inertia Im , Second curr_set_time = 0.1f ) : nominal_voltage ( nominal_voltage ), free_speed ( free_speed ), free_current ( free_current ), resistance ( Rm ), inductance ( Lm ), torque_constant ( Kt ), back_emf_constance ( Ke ), friction_constant (( free_current * torque_constant ) / ( AngularVelocity )( free_speed )), rotor_inertia ( Im ), time_constant ( inductance / resistance ) { set_current_setting_time ( curr_set_time ); } constexpr DCMotorParam ( const DCMotorParam & ) = default ; constexpr void set_current_setting_time ( Second Tc ) { if (( double ) Tc > 0.0f ) current_setting_time_ = Tc ; corner_frequency_ = 3.0f / current_setting_time_ ; current_p_gain_base_ = ( inductance * corner_frequency_ ). value (); current_i_gain_base_ = ( resistance * corner_frequency_ ). value (); } constexpr Rpm calcu_steady_free_velocity ( Volt v ) const { return free_speed * (( double ) v / ( double ) nominal_voltage ); } constexpr Ampere calcu_stall_current ( Volt v ) const { return v / resistance ; } constexpr Torque calcu_stall_torque ( Volt v ) const { return calcu_stall_current ( v ) * torque_constant ; } constexpr AngularAcceleration calcu_max_free_angular_acceleration ( Volt v ) const { return calcu_stall_torque ( v ) / rotor_inertia ; } constexpr Second get_Tm () const { return time_constant ; } constexpr AngularVelocity get_Wi () const { return corner_frequency_ ; } constexpr double get_Kip ( Volt volt ) const { return current_p_gain_base_ / volt . value (); } constexpr double get_Kii ( Volt volt ) const { return current_i_gain_base_ / volt . value (); } private : Second current_setting_time_ = 0.1 _s ; AngularVelocity corner_frequency_ = 0 ; double current_p_gain_base_ = 0 ; double current_i_gain_base_ = 0 ; }; struct GearHeadParam { const double ratio ; const double efficiency ; constexpr GearHeadParam ( double ratio_ , double efficiency_ ) : ratio ( ratio_ ), efficiency ( efficiency_ ) {} }; struct DCGearedMotorParam { constexpr DCGearedMotorParam ( Volt voltage_ , DCMotorParam motor_ , GearHeadParam gear_head_ , const double optional_gear_ratio_ = 1 ) : voltage ( voltage_ ), motor ( motor_ ), gear_head ( gear_head_ ), optional_gear_ratio ( optional_gear_ratio_ ) { } constexpr Rpm calcu_gear_head_steady_free_velocity ( Volt v ) const { return motor . calcu_steady_free_velocity ( v ) * gear_head . ratio ; } constexpr Rpm calcu_endpoint_steady_free_velocity ( Volt v ) const { return calcu_gear_head_steady_free_velocity ( v ) * optional_gear_ratio ; } constexpr AngularAcceleration calcu_endpoint_max_angular_accleleration ( Inertia optional_inertina = 0 ) const { return motor . calcu_stall_torque ( voltage ) / ( motor . rotor_inertia + ( optional_inertina * std :: pow ( gear_head . ratio * optional_gear_ratio , 2 ))) * gear_head . ratio ; } const Volt voltage ; const DCMotorParam motor ; const GearHeadParam gear_head ; const double optional_gear_ratio ; }; inline constexpr DCMotorParam generate_mabuchi_motor_param ( Volt nominal_voltage , // \u516c\u79f0\u96fb\u5727[V] Rpm free_speed , // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm] Ampere free_current , // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A] Torque stall_torque , // \u30b9\u30c8\u30fc\u30eb\u30c8\u30eb\u30af[Nm] Ampere stall_current , // \u30b9\u30c8\u30fc\u30eb\u96fb\u6d41[A] Henry inductance , // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] (\u8a08\u6e2c\u3059\u308b) Inertia rotor_inertia // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8 [ kgm ^ 2 ] ( \u8a08\u6e2c\u3059\u308b ) ) { const auto R = nominal_voltage / stall_current ; return DCMotorParam ( nominal_voltage , free_speed , free_current , R , inductance , stall_torque / ( stall_current - free_current ), ( nominal_voltage - R * free_current ) / ( AngularVelocity )( free_speed ), rotor_inertia ); } inline constexpr DCMotorParam generate_maxon_brush_motor_param ( Volt nominal_voltage , // \u516c\u79f0\u96fb\u5727[V] Rpm free_speed , // \u7121\u8ca0\u8377\u6642\u56de\u8ee2\u6570[rpm] Ampere free_current , // \u7121\u8ca0\u8377\u6642\u96fb\u6d41[A] Ohm resistance , // \u96fb\u6a5f\u5b50\u62b5\u6297[ohm] Henry inductance , // \u96fb\u6a5f\u5b50\u30a4\u30f3\u30c0\u30af\u30bf\u30f3\u30b9[H] TorqueConstant Kt , // \u30c8\u30eb\u30af\u5b9a\u6570[Nm/A] Inertia rotor_inertia // \u30ed\u30fc\u30bf\u6163\u6027\u30e2\u30fc\u30e1\u30f3\u30c8 [ kgm ^ 2 ] ( \u8a08\u6e2c\u3059\u308b ) ) { return DCMotorParam ( nominal_voltage , free_speed , free_current , resistance , inductance , Kt , ( nominal_voltage - resistance * free_current ) / ( AngularVelocity )( free_speed ), rotor_inertia ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/delay__filter_8hpp/","text":"include/cpp_robotics/filter/delay_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf Source code #pragma once #include <cmath> #include <vector> namespace cpp_robotics { class DelayFilter { public : DelayFilter ( double delay_time , double Ts ) { delay_sample_cnt_ = std :: floor ( delay_time / Ts ); delay_table_ . resize ( delay_sample_cnt_ ); } virtual void reset () { for ( auto & val : delay_table_ ) { val = 0 ; } } virtual double filtering ( double u ) { if ( delay_table_ . size () == 0 ) return u ; for ( int i = delay_table_ . size () - 2 ; i >= 0 ; i -- ) { delay_table_ [ i + 1 ] = delay_table_ [ i ]; } delay_table_ [ 0 ] = u ; return delay_table_ . back (); } private : size_t delay_sample_cnt_ ; std :: vector < double > delay_table_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/delay_filter.hpp"},{"location":"doxybook/Files/delay__filter_8hpp/#includecpp_roboticsfilterdelay_filterhpp","text":"","title":"include/cpp_robotics/filter/delay_filter.hpp"},{"location":"doxybook/Files/delay__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/delay__filter_8hpp/#classes","text":"Name class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf","title":"Classes"},{"location":"doxybook/Files/delay__filter_8hpp/#source-code","text":"#pragma once #include <cmath> #include <vector> namespace cpp_robotics { class DelayFilter { public : DelayFilter ( double delay_time , double Ts ) { delay_sample_cnt_ = std :: floor ( delay_time / Ts ); delay_table_ . resize ( delay_sample_cnt_ ); } virtual void reset () { for ( auto & val : delay_table_ ) { val = 0 ; } } virtual double filtering ( double u ) { if ( delay_table_ . size () == 0 ) return u ; for ( int i = delay_table_ . size () - 2 ; i >= 0 ; i -- ) { delay_table_ [ i + 1 ] = delay_table_ [ i ]; } delay_table_ [ 0 ] = u ; return delay_table_ . back (); } private : size_t delay_sample_cnt_ ; std :: vector < double > delay_table_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/delta__robot_8hpp/","text":"include/cpp_robotics/arm_ik/delta_robot.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 Source code #pragma once namespace cpp_robotics { class DeltaRobotIk { }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/arm_ik/delta_robot.hpp"},{"location":"doxybook/Files/delta__robot_8hpp/#includecpp_roboticsarm_ikdelta_robothpp","text":"","title":"include/cpp_robotics/arm_ik/delta_robot.hpp"},{"location":"doxybook/Files/delta__robot_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/delta__robot_8hpp/#classes","text":"Name class cpp_robotics::DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66","title":"Classes"},{"location":"doxybook/Files/delta__robot_8hpp/#source-code","text":"#pragma once namespace cpp_robotics { class DeltaRobotIk { }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/derivative_8hpp/","text":"include/cpp_robotics/optimize/derivative.hpp Namespaces Name cpp_robotics Source code #pragma once #include <cmath> #include <limits> #include <functional> #include <Eigen/Dense> namespace cpp_robotics { static double derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { // \u4e2d\u592e\u5dee\u5206 return ( f ( x + eps ) - f ( x - eps ) ) / ( 2.0 * eps ); } static Eigen :: VectorXd derivative ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { Eigen :: VectorXd der ( x . rows ()); for ( Eigen :: VectorXd :: Index i = 0 ; i < x . rows (); i ++ ) { Eigen :: VectorXd diff = Eigen :: VectorXd :: Zero ( x . rows ()); diff ( i ) = eps ; // \u4e2d\u592e\u5dee\u5206 der ( i ) = ( f ( x + diff ) - f ( x - diff ) ) / ( 2.0 * eps ); } return der ; } static Eigen :: MatrixXd derivative ( std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { Eigen :: MatrixXd der ; for ( Eigen :: VectorXd :: Index i = 0 ; i < x . rows (); i ++ ) { Eigen :: VectorXd diff = Eigen :: VectorXd :: Zero ( x . rows ()); diff ( i ) = eps ; // \u4e2d\u592e\u5dee\u5206 Eigen :: VectorXd der_col = ( f ( x + diff ) - f ( x - diff ) ) / ( 2.0 * eps ); if ( i == 0 ) { der = Eigen :: MatrixXd :: Zero ( der_col . size (), x . rows ()); } der . col ( i ) = der_col ; } return der ; } static double second_derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { // \u4e2d\u592e2\u968e\u5dee\u5206 return ( f ( x + eps ) - 2 * f ( x ) + f ( x - eps ) ) / std :: pow ( eps , 2 ); } static Eigen :: MatrixXd approx_hessian ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { auto j = derivative ( f , x , eps ); return j * j . transpose (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/derivative.hpp"},{"location":"doxybook/Files/derivative_8hpp/#includecpp_roboticsoptimizederivativehpp","text":"","title":"include/cpp_robotics/optimize/derivative.hpp"},{"location":"doxybook/Files/derivative_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/derivative_8hpp/#source-code","text":"#pragma once #include <cmath> #include <limits> #include <functional> #include <Eigen/Dense> namespace cpp_robotics { static double derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { // \u4e2d\u592e\u5dee\u5206 return ( f ( x + eps ) - f ( x - eps ) ) / ( 2.0 * eps ); } static Eigen :: VectorXd derivative ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { Eigen :: VectorXd der ( x . rows ()); for ( Eigen :: VectorXd :: Index i = 0 ; i < x . rows (); i ++ ) { Eigen :: VectorXd diff = Eigen :: VectorXd :: Zero ( x . rows ()); diff ( i ) = eps ; // \u4e2d\u592e\u5dee\u5206 der ( i ) = ( f ( x + diff ) - f ( x - diff ) ) / ( 2.0 * eps ); } return der ; } static Eigen :: MatrixXd derivative ( std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { Eigen :: MatrixXd der ; for ( Eigen :: VectorXd :: Index i = 0 ; i < x . rows (); i ++ ) { Eigen :: VectorXd diff = Eigen :: VectorXd :: Zero ( x . rows ()); diff ( i ) = eps ; // \u4e2d\u592e\u5dee\u5206 Eigen :: VectorXd der_col = ( f ( x + diff ) - f ( x - diff ) ) / ( 2.0 * eps ); if ( i == 0 ) { der = Eigen :: MatrixXd :: Zero ( der_col . size (), x . rows ()); } der . col ( i ) = der_col ; } return der ; } static double second_derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { // \u4e2d\u592e2\u968e\u5dee\u5206 return ( f ( x + eps ) - 2 * f ( x ) + f ( x - eps ) ) / std :: pow ( eps , 2 ); } static Eigen :: MatrixXd approx_hessian ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 )) { auto j = derivative ( f , x , eps ); return j * j . transpose (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/differentiator_8hpp/","text":"include/cpp_robotics/filter/differentiator.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668 Source code #pragma once #include <cmath> namespace cpp_robotics { class Differentiator { public : // bandwidth[rad/s] // sample_time[s] Differentiator ( double bandwidth , double sample_time ) : Ts_ ( sample_time ), gpd_ ( bandwidth ) { } void reset () { u1_ = y1_ = 0 ; } double filtering ( double u ) { double y ; y = ( 2.0 * gpd_ * ( u - u1_ ) + ( 2.0 - Ts_ * gpd_ ) * y1_ ) / ( 2.0 + Ts_ * gpd_ ); u1_ = u ; y1_ = y ; return y ; } private : double Ts_ ; double gpd_ ; double u1_ ; double y1_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/differentiator.hpp"},{"location":"doxybook/Files/differentiator_8hpp/#includecpp_roboticsfilterdifferentiatorhpp","text":"","title":"include/cpp_robotics/filter/differentiator.hpp"},{"location":"doxybook/Files/differentiator_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/differentiator_8hpp/#classes","text":"Name class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668","title":"Classes"},{"location":"doxybook/Files/differentiator_8hpp/#source-code","text":"#pragma once #include <cmath> namespace cpp_robotics { class Differentiator { public : // bandwidth[rad/s] // sample_time[s] Differentiator ( double bandwidth , double sample_time ) : Ts_ ( sample_time ), gpd_ ( bandwidth ) { } void reset () { u1_ = y1_ = 0 ; } double filtering ( double u ) { double y ; y = ( 2.0 * gpd_ * ( u - u1_ ) + ( 2.0 - Ts_ * gpd_ ) * y1_ ) / ( 2.0 + Ts_ * gpd_ ); u1_ = u ; y1_ = y ; return y ; } private : double Ts_ ; double gpd_ ; double u1_ ; double y1_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/dir_2ea8a390efb1067dce8bd4c72d5b1bee/","text":"include/cpp_robotics/utility Files Name include/cpp_robotics/utility/angle_range.hpp include/cpp_robotics/utility/cpp_support.hpp include/cpp_robotics/utility/math_utils.hpp include/cpp_robotics/utility/singleton.hpp include/cpp_robotics/utility/space.hpp include/cpp_robotics/utility/utility.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/utility"},{"location":"doxybook/Files/dir_2ea8a390efb1067dce8bd4c72d5b1bee/#includecpp_roboticsutility","text":"","title":"include/cpp_robotics/utility"},{"location":"doxybook/Files/dir_2ea8a390efb1067dce8bd4c72d5b1bee/#files","text":"Name include/cpp_robotics/utility/angle_range.hpp include/cpp_robotics/utility/cpp_support.hpp include/cpp_robotics/utility/math_utils.hpp include/cpp_robotics/utility/singleton.hpp include/cpp_robotics/utility/space.hpp include/cpp_robotics/utility/utility.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_36b0cd5dd5e5d52e27c3e8401d5f16d3/","text":"include/cpp_robotics/vector Files Name include/cpp_robotics/vector/quaternion.hpp include/cpp_robotics/vector/transform.hpp include/cpp_robotics/vector/vector.hpp include/cpp_robotics/vector/vector2.hpp include/cpp_robotics/vector/vector3.hpp include/cpp_robotics/vector/vector4.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/vector"},{"location":"doxybook/Files/dir_36b0cd5dd5e5d52e27c3e8401d5f16d3/#includecpp_roboticsvector","text":"","title":"include/cpp_robotics/vector"},{"location":"doxybook/Files/dir_36b0cd5dd5e5d52e27c3e8401d5f16d3/#files","text":"Name include/cpp_robotics/vector/quaternion.hpp include/cpp_robotics/vector/transform.hpp include/cpp_robotics/vector/vector.hpp include/cpp_robotics/vector/vector2.hpp include/cpp_robotics/vector/vector3.hpp include/cpp_robotics/vector/vector4.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_4247061a1141e797ef60959306008361/","text":"include/cpp_robotics/geometry Files Name include/cpp_robotics/geometry/geometry.hpp include/cpp_robotics/geometry/geometry_stream.hpp include/cpp_robotics/geometry/shape.hpp include/cpp_robotics/geometry/shape.ipp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/geometry"},{"location":"doxybook/Files/dir_4247061a1141e797ef60959306008361/#includecpp_roboticsgeometry","text":"","title":"include/cpp_robotics/geometry"},{"location":"doxybook/Files/dir_4247061a1141e797ef60959306008361/#files","text":"Name include/cpp_robotics/geometry/geometry.hpp include/cpp_robotics/geometry/geometry_stream.hpp include/cpp_robotics/geometry/shape.hpp include/cpp_robotics/geometry/shape.ipp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_48ee8a7d844e7fcc20daa8cf77f195e8/","text":"include/cpp_robotics/units Files Name include/cpp_robotics/units/si_unit.hpp include/cpp_robotics/units/unit_core.hpp include/cpp_robotics/units/units.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/units"},{"location":"doxybook/Files/dir_48ee8a7d844e7fcc20daa8cf77f195e8/#includecpp_roboticsunits","text":"","title":"include/cpp_robotics/units"},{"location":"doxybook/Files/dir_48ee8a7d844e7fcc20daa8cf77f195e8/#files","text":"Name include/cpp_robotics/units/si_unit.hpp include/cpp_robotics/units/unit_core.hpp include/cpp_robotics/units/units.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_4c1366b205e6333d17163ca64846ea5d/","text":"include/cpp_robotics/robots/quadcopter Files Name include/cpp_robotics/robots/quadcopter/interface.hpp include/cpp_robotics/robots/quadcopter/quadcopter.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/quadcopter"},{"location":"doxybook/Files/dir_4c1366b205e6333d17163ca64846ea5d/#includecpp_roboticsrobotsquadcopter","text":"","title":"include/cpp_robotics/robots/quadcopter"},{"location":"doxybook/Files/dir_4c1366b205e6333d17163ca64846ea5d/#files","text":"Name include/cpp_robotics/robots/quadcopter/interface.hpp include/cpp_robotics/robots/quadcopter/quadcopter.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_5df22cf9cb50dfe3ed59678e8c651195/","text":"include/cpp_robotics/controller Files Name include/cpp_robotics/controller/controller.hpp include/cpp_robotics/controller/lqr.hpp include/cpp_robotics/controller/modern_control.hpp include/cpp_robotics/controller/nctf.hpp include/cpp_robotics/controller/pfc.hpp include/cpp_robotics/controller/pid.hpp include/cpp_robotics/controller/pid2.hpp include/cpp_robotics/controller/pure_pursuit.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller"},{"location":"doxybook/Files/dir_5df22cf9cb50dfe3ed59678e8c651195/#includecpp_roboticscontroller","text":"","title":"include/cpp_robotics/controller"},{"location":"doxybook/Files/dir_5df22cf9cb50dfe3ed59678e8c651195/#files","text":"Name include/cpp_robotics/controller/controller.hpp include/cpp_robotics/controller/lqr.hpp include/cpp_robotics/controller/modern_control.hpp include/cpp_robotics/controller/nctf.hpp include/cpp_robotics/controller/pfc.hpp include/cpp_robotics/controller/pid.hpp include/cpp_robotics/controller/pid2.hpp include/cpp_robotics/controller/pure_pursuit.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_638b28e3ebdf4d55edeb748f267e8fbb/","text":"include/cpp_robotics/system Files Name include/cpp_robotics/system/bode.hpp include/cpp_robotics/system/discret.hpp include/cpp_robotics/system/discrete_transfer_function.hpp include/cpp_robotics/system/nyquist.hpp include/cpp_robotics/system/polynomial.hpp include/cpp_robotics/system/siso_system.hpp include/cpp_robotics/system/state_space_system.hpp include/cpp_robotics/system/system.hpp include/cpp_robotics/system/time_responce.hpp include/cpp_robotics/system/transfer_function.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system"},{"location":"doxybook/Files/dir_638b28e3ebdf4d55edeb748f267e8fbb/#includecpp_roboticssystem","text":"","title":"include/cpp_robotics/system"},{"location":"doxybook/Files/dir_638b28e3ebdf4d55edeb748f267e8fbb/#files","text":"Name include/cpp_robotics/system/bode.hpp include/cpp_robotics/system/discret.hpp include/cpp_robotics/system/discrete_transfer_function.hpp include/cpp_robotics/system/nyquist.hpp include/cpp_robotics/system/polynomial.hpp include/cpp_robotics/system/siso_system.hpp include/cpp_robotics/system/state_space_system.hpp include/cpp_robotics/system/system.hpp include/cpp_robotics/system/time_responce.hpp include/cpp_robotics/system/transfer_function.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/","text":"include/cpp_robotics Directories Name include/cpp_robotics/algorithm include/cpp_robotics/arm_ik include/cpp_robotics/chassis include/cpp_robotics/controller include/cpp_robotics/filter include/cpp_robotics/geometry include/cpp_robotics/motor include/cpp_robotics/optimize include/cpp_robotics/path_planning include/cpp_robotics/robots include/cpp_robotics/spline include/cpp_robotics/system include/cpp_robotics/units include/cpp_robotics/utility include/cpp_robotics/vector Files Name include/cpp_robotics/core.hpp include/cpp_robotics/cpp_robotics.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/#includecpp_robotics","text":"","title":"include/cpp_robotics"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/#directories","text":"Name include/cpp_robotics/algorithm include/cpp_robotics/arm_ik include/cpp_robotics/chassis include/cpp_robotics/controller include/cpp_robotics/filter include/cpp_robotics/geometry include/cpp_robotics/motor include/cpp_robotics/optimize include/cpp_robotics/path_planning include/cpp_robotics/robots include/cpp_robotics/spline include/cpp_robotics/system include/cpp_robotics/units include/cpp_robotics/utility include/cpp_robotics/vector","title":"Directories"},{"location":"doxybook/Files/dir_67dcb25ebbd06d7c104622036b0247e2/#files","text":"Name include/cpp_robotics/core.hpp include/cpp_robotics/cpp_robotics.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_7e879dbdc5c9edf53cad9d774885e9a7/","text":"include/cpp_robotics/arm_ik Files Name include/cpp_robotics/arm_ik/delta_robot.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/arm_ik"},{"location":"doxybook/Files/dir_7e879dbdc5c9edf53cad9d774885e9a7/#includecpp_roboticsarm_ik","text":"","title":"include/cpp_robotics/arm_ik"},{"location":"doxybook/Files/dir_7e879dbdc5c9edf53cad9d774885e9a7/#files","text":"Name include/cpp_robotics/arm_ik/delta_robot.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_87a81676224789efbbd31189f8c15377/","text":"include/cpp_robotics/motor Files Name include/cpp_robotics/motor/dc_motor_list.hpp include/cpp_robotics/motor/dc_motor_param.hpp include/cpp_robotics/motor/motor_tf.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/motor"},{"location":"doxybook/Files/dir_87a81676224789efbbd31189f8c15377/#includecpp_roboticsmotor","text":"","title":"include/cpp_robotics/motor"},{"location":"doxybook/Files/dir_87a81676224789efbbd31189f8c15377/#files","text":"Name include/cpp_robotics/motor/dc_motor_list.hpp include/cpp_robotics/motor/dc_motor_param.hpp include/cpp_robotics/motor/motor_tf.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_9457539b8ca8d9274a6ff8e48b503091/","text":"include/cpp_robotics/robots/robot_utils Files Name include/cpp_robotics/robots/robot_utils/robot_utils.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/robot_utils"},{"location":"doxybook/Files/dir_9457539b8ca8d9274a6ff8e48b503091/#includecpp_roboticsrobotsrobot_utils","text":"","title":"include/cpp_robotics/robots/robot_utils"},{"location":"doxybook/Files/dir_9457539b8ca8d9274a6ff8e48b503091/#files","text":"Name include/cpp_robotics/robots/robot_utils/robot_utils.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_a64767b7a8f5bac6dff05874b8e7c36e/","text":"include/cpp_robotics/spline Files Name include/cpp_robotics/spline/spline.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/spline"},{"location":"doxybook/Files/dir_a64767b7a8f5bac6dff05874b8e7c36e/#includecpp_roboticsspline","text":"","title":"include/cpp_robotics/spline"},{"location":"doxybook/Files/dir_a64767b7a8f5bac6dff05874b8e7c36e/#files","text":"Name include/cpp_robotics/spline/spline.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_b08c5c51b4051026c781f1fcc98ccd3c/","text":"include/cpp_robotics/path_planning Files Name include/cpp_robotics/path_planning/a_star.hpp include/cpp_robotics/path_planning/dubins_path.hpp include/cpp_robotics/path_planning/dwa.hpp include/cpp_robotics/path_planning/frenet_frame.hpp include/cpp_robotics/path_planning/grid_path_planning_utils.hpp include/cpp_robotics/path_planning/path_planning.hpp include/cpp_robotics/path_planning/wave_propagation.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning"},{"location":"doxybook/Files/dir_b08c5c51b4051026c781f1fcc98ccd3c/#includecpp_roboticspath_planning","text":"","title":"include/cpp_robotics/path_planning"},{"location":"doxybook/Files/dir_b08c5c51b4051026c781f1fcc98ccd3c/#files","text":"Name include/cpp_robotics/path_planning/a_star.hpp include/cpp_robotics/path_planning/dubins_path.hpp include/cpp_robotics/path_planning/dwa.hpp include/cpp_robotics/path_planning/frenet_frame.hpp include/cpp_robotics/path_planning/grid_path_planning_utils.hpp include/cpp_robotics/path_planning/path_planning.hpp include/cpp_robotics/path_planning/wave_propagation.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_b1a2e432ddc1679e5624fb0baa5764e5/","text":"include/cpp_robotics/robots/penbulum Files Name include/cpp_robotics/robots/penbulum/interface.hpp include/cpp_robotics/robots/penbulum/pendulum.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/penbulum"},{"location":"doxybook/Files/dir_b1a2e432ddc1679e5624fb0baa5764e5/#includecpp_roboticsrobotspenbulum","text":"","title":"include/cpp_robotics/robots/penbulum"},{"location":"doxybook/Files/dir_b1a2e432ddc1679e5624fb0baa5764e5/#files","text":"Name include/cpp_robotics/robots/penbulum/interface.hpp include/cpp_robotics/robots/penbulum/pendulum.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_bc9ad42d08f7b854efebf7d8aa67e9d1/","text":"include/cpp_robotics/chassis Files Name include/cpp_robotics/chassis/chassis.hpp include/cpp_robotics/chassis/mecanum_ik.hpp include/cpp_robotics/chassis/omni_ik.hpp include/cpp_robotics/chassis/swerve_ik.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/chassis"},{"location":"doxybook/Files/dir_bc9ad42d08f7b854efebf7d8aa67e9d1/#includecpp_roboticschassis","text":"","title":"include/cpp_robotics/chassis"},{"location":"doxybook/Files/dir_bc9ad42d08f7b854efebf7d8aa67e9d1/#files","text":"Name include/cpp_robotics/chassis/chassis.hpp include/cpp_robotics/chassis/mecanum_ik.hpp include/cpp_robotics/chassis/omni_ik.hpp include/cpp_robotics/chassis/swerve_ik.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_c2aadae018d07499e272ef7425a31e4f/","text":"include/cpp_robotics/algorithm Files Name include/cpp_robotics/algorithm/algorithm.hpp include/cpp_robotics/algorithm/icp.hpp include/cpp_robotics/algorithm/k_means_method.hpp include/cpp_robotics/algorithm/kdtree.hpp include/cpp_robotics/algorithm/mahalanobis.hpp include/cpp_robotics/algorithm/misc.hpp include/cpp_robotics/algorithm/ndt.hpp include/cpp_robotics/algorithm/poly_regression.hpp include/cpp_robotics/algorithm/random.hpp include/cpp_robotics/algorithm/state_machine.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm"},{"location":"doxybook/Files/dir_c2aadae018d07499e272ef7425a31e4f/#includecpp_roboticsalgorithm","text":"","title":"include/cpp_robotics/algorithm"},{"location":"doxybook/Files/dir_c2aadae018d07499e272ef7425a31e4f/#files","text":"Name include/cpp_robotics/algorithm/algorithm.hpp include/cpp_robotics/algorithm/icp.hpp include/cpp_robotics/algorithm/k_means_method.hpp include/cpp_robotics/algorithm/kdtree.hpp include/cpp_robotics/algorithm/mahalanobis.hpp include/cpp_robotics/algorithm/misc.hpp include/cpp_robotics/algorithm/ndt.hpp include/cpp_robotics/algorithm/poly_regression.hpp include/cpp_robotics/algorithm/random.hpp include/cpp_robotics/algorithm/state_machine.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_d44c64559bbebec7f509842c48db8b23/","text":"include Directories Name include/cpp_robotics Updated on 2022-09-30 at 00:12:50 +0900","title":"include"},{"location":"doxybook/Files/dir_d44c64559bbebec7f509842c48db8b23/#include","text":"","title":"include"},{"location":"doxybook/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","text":"Name include/cpp_robotics Updated on 2022-09-30 at 00:12:50 +0900","title":"Directories"},{"location":"doxybook/Files/dir_d46e09745d41c5a7827c5b81f13e5fde/","text":"include/cpp_robotics/filter Files Name include/cpp_robotics/filter/acceleration_limit_filter.hpp include/cpp_robotics/filter/band_pass_filter.hpp include/cpp_robotics/filter/delay_filter.hpp include/cpp_robotics/filter/differentiator.hpp include/cpp_robotics/filter/extended_kalman_filter.hpp include/cpp_robotics/filter/filter.hpp include/cpp_robotics/filter/filter_connector.hpp include/cpp_robotics/filter/filter_state_holder.hpp include/cpp_robotics/filter/high_pass_filter.hpp include/cpp_robotics/filter/integrator.hpp include/cpp_robotics/filter/kalman_filter.hpp include/cpp_robotics/filter/low_pass_filter.hpp include/cpp_robotics/filter/notch_filter.hpp include/cpp_robotics/filter/velocity_limit_filter.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter"},{"location":"doxybook/Files/dir_d46e09745d41c5a7827c5b81f13e5fde/#includecpp_roboticsfilter","text":"","title":"include/cpp_robotics/filter"},{"location":"doxybook/Files/dir_d46e09745d41c5a7827c5b81f13e5fde/#files","text":"Name include/cpp_robotics/filter/acceleration_limit_filter.hpp include/cpp_robotics/filter/band_pass_filter.hpp include/cpp_robotics/filter/delay_filter.hpp include/cpp_robotics/filter/differentiator.hpp include/cpp_robotics/filter/extended_kalman_filter.hpp include/cpp_robotics/filter/filter.hpp include/cpp_robotics/filter/filter_connector.hpp include/cpp_robotics/filter/filter_state_holder.hpp include/cpp_robotics/filter/high_pass_filter.hpp include/cpp_robotics/filter/integrator.hpp include/cpp_robotics/filter/kalman_filter.hpp include/cpp_robotics/filter/low_pass_filter.hpp include/cpp_robotics/filter/notch_filter.hpp include/cpp_robotics/filter/velocity_limit_filter.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_dbe6a3823a6e2aee897d3ebf7d75d548/","text":"include/cpp_robotics/optimize Files Name include/cpp_robotics/optimize/active_set_method.hpp include/cpp_robotics/optimize/barrier_method.hpp include/cpp_robotics/optimize/bfgs.hpp include/cpp_robotics/optimize/bracketing_serach.hpp include/cpp_robotics/optimize/constraint.hpp include/cpp_robotics/optimize/derivative.hpp include/cpp_robotics/optimize/golden_serach.hpp include/cpp_robotics/optimize/interior_point_method.hpp include/cpp_robotics/optimize/linprog.hpp include/cpp_robotics/optimize/newton_method.hpp include/cpp_robotics/optimize/optimize.hpp include/cpp_robotics/optimize/penalty_method.hpp include/cpp_robotics/optimize/quadprog.hpp include/cpp_robotics/optimize/quasi_newton_method.hpp include/cpp_robotics/optimize/sqp.hpp include/cpp_robotics/optimize/steepest_descent_method.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize"},{"location":"doxybook/Files/dir_dbe6a3823a6e2aee897d3ebf7d75d548/#includecpp_roboticsoptimize","text":"","title":"include/cpp_robotics/optimize"},{"location":"doxybook/Files/dir_dbe6a3823a6e2aee897d3ebf7d75d548/#files","text":"Name include/cpp_robotics/optimize/active_set_method.hpp include/cpp_robotics/optimize/barrier_method.hpp include/cpp_robotics/optimize/bfgs.hpp include/cpp_robotics/optimize/bracketing_serach.hpp include/cpp_robotics/optimize/constraint.hpp include/cpp_robotics/optimize/derivative.hpp include/cpp_robotics/optimize/golden_serach.hpp include/cpp_robotics/optimize/interior_point_method.hpp include/cpp_robotics/optimize/linprog.hpp include/cpp_robotics/optimize/newton_method.hpp include/cpp_robotics/optimize/optimize.hpp include/cpp_robotics/optimize/penalty_method.hpp include/cpp_robotics/optimize/quadprog.hpp include/cpp_robotics/optimize/quasi_newton_method.hpp include/cpp_robotics/optimize/sqp.hpp include/cpp_robotics/optimize/steepest_descent_method.hpp Updated on 2022-09-30 at 00:12:50 +0900","title":"Files"},{"location":"doxybook/Files/dir_e2fc7d9ed626f8548eab23bbcbb5e5ec/","text":"include/cpp_robotics/robots Directories Name include/cpp_robotics/robots/penbulum include/cpp_robotics/robots/quadcopter include/cpp_robotics/robots/robot_utils Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots"},{"location":"doxybook/Files/dir_e2fc7d9ed626f8548eab23bbcbb5e5ec/#includecpp_roboticsrobots","text":"","title":"include/cpp_robotics/robots"},{"location":"doxybook/Files/dir_e2fc7d9ed626f8548eab23bbcbb5e5ec/#directories","text":"Name include/cpp_robotics/robots/penbulum include/cpp_robotics/robots/quadcopter include/cpp_robotics/robots/robot_utils Updated on 2022-09-30 at 00:12:50 +0900","title":"Directories"},{"location":"doxybook/Files/discret_8hpp/","text":"include/cpp_robotics/system/discret.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b Source code #pragma once #include <Eigen/Dense> #include <tuple> namespace cpp_robotics { class Discret { private : template < typename Derived > static auto expm ( const Eigen :: MatrixBase < Derived > & A ) { assert ( A . cols () == A . rows ()); return A . exp (); } template < typename Derived > static auto integral_expm ( const Eigen :: MatrixBase < Derived > & A , const float & Ts , size_t hdiv = 1000 ) { assert ( A . cols () == A . rows ()); // \u30b7\u30f3\u30d7\u30bd\u30f3\u6cd5\u3067\u7a4d\u5206 const double h = Ts / ( double )( hdiv ); Derived S = expm ( A * 0 ) + expm ( A * Ts ); for ( size_t i = 1 ; i < hdiv ; i += 2 ) { S += 4 * expm ( A * h * i ); } for ( size_t i = 2 ; i < hdiv ; i += 2 ) { S += 2 * expm ( A * h * i ); } S *= h / 3 ; return S ; } public : template < typename Derived > static auto discretize_a ( const Eigen :: MatrixBase < Derived > & A , const float Ts ) { assert ( A . cols () == A . rows ()); return static_cast < Derived > (( A * Ts ). exp ()); } template < typename Derived1 , typename Derived2 > static auto discretize_b ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == B . rows ()); Eigen :: FullPivLU < Derived1 > lu_decomp ( A ); auto rank = lu_decomp . rank (); if ( rank == A . rows ()) { if constexpr ( Derived1 :: SizeAtCompileTime == Eigen :: Dynamic ) { Derived1 I = Derived1 :: Identity ( A . rows (), A . cols ()); return static_cast < Derived2 > ( A . inverse () * ( expm ( A * Ts ) - I ) * B ); } else { return static_cast < Derived2 > ( A . inverse () * ( expm ( A * Ts ) - Derived1 :: Identity ()) * B ); } } return static_cast < Derived2 > ( integral_expm ( A , Ts , hdiv ) * B ); } template < typename Derived1 , typename Derived2 > static auto discritize ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 ) { return std :: tuple { discretize_a ( A , Ts ), discretize_b ( A , B , Ts , hdiv ) }; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/discret.hpp"},{"location":"doxybook/Files/discret_8hpp/#includecpp_roboticssystemdiscrethpp","text":"","title":"include/cpp_robotics/system/discret.hpp"},{"location":"doxybook/Files/discret_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/discret_8hpp/#classes","text":"Name class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b","title":"Classes"},{"location":"doxybook/Files/discret_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> #include <tuple> namespace cpp_robotics { class Discret { private : template < typename Derived > static auto expm ( const Eigen :: MatrixBase < Derived > & A ) { assert ( A . cols () == A . rows ()); return A . exp (); } template < typename Derived > static auto integral_expm ( const Eigen :: MatrixBase < Derived > & A , const float & Ts , size_t hdiv = 1000 ) { assert ( A . cols () == A . rows ()); // \u30b7\u30f3\u30d7\u30bd\u30f3\u6cd5\u3067\u7a4d\u5206 const double h = Ts / ( double )( hdiv ); Derived S = expm ( A * 0 ) + expm ( A * Ts ); for ( size_t i = 1 ; i < hdiv ; i += 2 ) { S += 4 * expm ( A * h * i ); } for ( size_t i = 2 ; i < hdiv ; i += 2 ) { S += 2 * expm ( A * h * i ); } S *= h / 3 ; return S ; } public : template < typename Derived > static auto discretize_a ( const Eigen :: MatrixBase < Derived > & A , const float Ts ) { assert ( A . cols () == A . rows ()); return static_cast < Derived > (( A * Ts ). exp ()); } template < typename Derived1 , typename Derived2 > static auto discretize_b ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == B . rows ()); Eigen :: FullPivLU < Derived1 > lu_decomp ( A ); auto rank = lu_decomp . rank (); if ( rank == A . rows ()) { if constexpr ( Derived1 :: SizeAtCompileTime == Eigen :: Dynamic ) { Derived1 I = Derived1 :: Identity ( A . rows (), A . cols ()); return static_cast < Derived2 > ( A . inverse () * ( expm ( A * Ts ) - I ) * B ); } else { return static_cast < Derived2 > ( A . inverse () * ( expm ( A * Ts ) - Derived1 :: Identity ()) * B ); } } return static_cast < Derived2 > ( integral_expm ( A , Ts , hdiv ) * B ); } template < typename Derived1 , typename Derived2 > static auto discritize ( const Eigen :: MatrixBase < Derived1 > & A , const Eigen :: MatrixBase < Derived2 > & B , const float & Ts , size_t hdiv = 1000 ) { return std :: tuple { discretize_a ( A , Ts ), discretize_b ( A , B , Ts , hdiv ) }; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/discrete__transfer__function_8hpp/","text":"include/cpp_robotics/system/discrete_transfer_function.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::DiscreteTransferFunction z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570 Source code #pragma once #include <vector> namespace cpp_robotics { class DiscreteTransferFunction { public : DiscreteTransferFunction () = default ; DiscreteTransferFunction ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt ) { set_discrite ( num_disc , den_disc , dt ); } // z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306e\u5206\u5b50\u3068\u5206\u6bcd\u3092\u964d\u3079\u304d\u306e\u6e96\u306b\u4e0e\u3048\u308b void set_discrite ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt ) { assert ( num_disc . size () > 0 ); assert ( den_disc . size () > 0 ); num_ = num_disc ; den_ = den_disc ; u_ . resize ( num_ . size ()); y_ . resize ( den_ . size () -1 ); dt_ = dt ; } double Ts () const { return dt_ ; } virtual void reset ( double state = 0 ) { ( void ) state ; for ( auto & u : u_ ) u = 0 ; for ( auto & y : y_ ) y = 0 ; } double responce ( double u ) { double y = 0 ; u_ . pop_back (); u_ . insert ( u_ . begin (), u ); for ( size_t i = 0 ; i < num_ . size (); i ++ ) { y += num_ [ i ] * u_ [ u_ . size () -1 - i ]; } for ( size_t i = 0 ; i < den_ . size () -1 ; i ++ ) { y -= den_ [ i ] * y_ [ y_ . size () -1 - i ]; } y /= den_ . back (); y_ . pop_back (); y_ . insert ( y_ . begin (), y ); return y ; } private : std :: vector < double > num_ ; std :: vector < double > den_ ; std :: vector < double > u_ ; std :: vector < double > y_ ; double dt_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/discrete_transfer_function.hpp"},{"location":"doxybook/Files/discrete__transfer__function_8hpp/#includecpp_roboticssystemdiscrete_transfer_functionhpp","text":"","title":"include/cpp_robotics/system/discrete_transfer_function.hpp"},{"location":"doxybook/Files/discrete__transfer__function_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/discrete__transfer__function_8hpp/#classes","text":"Name class cpp_robotics::DiscreteTransferFunction z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570","title":"Classes"},{"location":"doxybook/Files/discrete__transfer__function_8hpp/#source-code","text":"#pragma once #include <vector> namespace cpp_robotics { class DiscreteTransferFunction { public : DiscreteTransferFunction () = default ; DiscreteTransferFunction ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt ) { set_discrite ( num_disc , den_disc , dt ); } // z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306e\u5206\u5b50\u3068\u5206\u6bcd\u3092\u964d\u3079\u304d\u306e\u6e96\u306b\u4e0e\u3048\u308b void set_discrite ( std :: vector < double > num_disc , std :: vector < double > den_disc , const double dt ) { assert ( num_disc . size () > 0 ); assert ( den_disc . size () > 0 ); num_ = num_disc ; den_ = den_disc ; u_ . resize ( num_ . size ()); y_ . resize ( den_ . size () -1 ); dt_ = dt ; } double Ts () const { return dt_ ; } virtual void reset ( double state = 0 ) { ( void ) state ; for ( auto & u : u_ ) u = 0 ; for ( auto & y : y_ ) y = 0 ; } double responce ( double u ) { double y = 0 ; u_ . pop_back (); u_ . insert ( u_ . begin (), u ); for ( size_t i = 0 ; i < num_ . size (); i ++ ) { y += num_ [ i ] * u_ [ u_ . size () -1 - i ]; } for ( size_t i = 0 ; i < den_ . size () -1 ; i ++ ) { y -= den_ [ i ] * y_ [ y_ . size () -1 - i ]; } y /= den_ . back (); y_ . pop_back (); y_ . insert ( y_ . begin (), y ); return y ; } private : std :: vector < double > num_ ; std :: vector < double > den_ ; std :: vector < double > u_ ; std :: vector < double > y_ ; double dt_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/dubins__path_8hpp/","text":"include/cpp_robotics/path_planning/dubins_path.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::DubinsPath Dubins\u30d1\u30b9 Source code #pragma once #include \"../vector/transform.hpp\" #include <functional> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { class DubinsPath { public : enum class Mode { LRL , RLR , LSL , LSR , RSL , RSR , NONE }; DubinsPath ( Transformd start , Transformd end , double cavature ) : start_ ( start ), end_ ( end ), cavature_ ( cavature ) { auto distance = ( end - start ). make_vector2 (). get_rotated ( - start . theta ); double angle_distance = shortest_angular_distance ( start . theta , end . theta ); planning_from_origin ({ distance , angle_distance }); all_length_ = plan_ . t + plan_ . p + plan_ . q ; build_pos_function (); } double length () const { return all_length_ ; } double segment_length ( size_t i ) const { assert ( i < 3 ); switch ( i ) { case 0 : return plan_ . t ; case 1 : return plan_ . p ; case 2 : return plan_ . q ; } return 0 ; } Transformd position ( double len ) const { len = std :: clamp ( len , 0.0 , all_length_ ); if ( len == 0 ) return start_ ; for ( size_t i = 0 ; i < 3 ; i ++ ) { if ( len < segment_length ( i )) { return pos_func_list_ [ i ]( len ); } len -= segment_length ( i ); } return end_ ; } std :: string path_type () const { switch ( plan_ . mode ) { case Mode :: LRL : return \"LRL\" ; case Mode :: RLR : return \"RLR\" ; case Mode :: LSL : return \"LSL\" ; case Mode :: LSR : return \"LSR\" ; case Mode :: RSL : return \"RSL\" ; case Mode :: RSR : return \"RSR\" ; default : return \"NONE\" ; } } private : struct PlanningResult { double t = 0 ; double p = 0 ; double q = 0 ; Mode mode = Mode :: NONE ; }; void planning_from_origin ( Transformd origin_to_goal ) { const auto dist = origin_to_goal . make_vector2 (); const double D = dist . norm (); const double d = D / cavature_ ; const double theta = mod2pi ( dist . angle ()); const double alpha = mod2pi ( - theta ); const double beta = mod2pi ( origin_to_goal . theta - theta ); auto planner_bind = [ this ]( auto mem_fn ) { return std :: bind ( mem_fn , this , std :: placeholders :: _1 , std :: placeholders :: _2 , std :: placeholders :: _3 ); }; std :: array planners = { planner_bind ( & DubinsPath :: LRL ), planner_bind ( & DubinsPath :: RLR ), planner_bind ( & DubinsPath :: LSL ), planner_bind ( & DubinsPath :: LSR ), planner_bind ( & DubinsPath :: RSL ), planner_bind ( & DubinsPath :: RSR ) }; double bcost = std :: numeric_limits < double >:: max (); std :: optional < PlanningResult > pret ; for ( auto & planner : planners ) { if ( auto ret = planner ( alpha , beta , d ); ret . has_value ()) { auto [ t , p , q , mode ] = ret . value (); double cost = t + p + q ; if ( cost < bcost ) { plan_ = ret . value (); bcost = cost ; } } } } std :: optional < PlanningResult > LSL ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp0 = d + sa - sb ; const double p_squared = 2 + ( d * d ) - ( 2 * c_ab ) + ( 2 * d * ( sa - sb )); if ( p_squared < 0 ) return std :: nullopt ; const double tmp1 = std :: atan2 (( cb - ca ), tmp0 ); const double t = mod2pi ( - alpha + tmp1 ); const double p = std :: sqrt ( p_squared ); const double q = mod2pi ( beta - tmp1 ); return PlanningResult { t , p , q , Mode :: LSL }; } std :: optional < PlanningResult > RSR ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp0 = d - sa + sb ; const double p_squared = 2 + ( d * d ) - ( 2 * c_ab ) + ( 2 * d * ( sb - sa )); if ( p_squared < 0 ) return std :: nullopt ; const double tmp1 = std :: atan2 (( ca - cb ), tmp0 ); const double t = mod2pi ( alpha - tmp1 ); const double p = std :: sqrt ( p_squared ); const double q = mod2pi ( - beta + tmp1 ); return PlanningResult { t , p , q , Mode :: RSR }; } std :: optional < PlanningResult > LSR ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double p_squared = -2 + ( d * d ) + ( 2 * c_ab ) + ( 2 * d * ( sa + sb )); if ( p_squared < 0 ) return std :: nullopt ; const double p = std :: sqrt ( p_squared ); const double tmp2 = std :: atan2 (( - ca - cb ), ( d + sa + sb )) - std :: atan2 ( -2.0 , p ); const double t = mod2pi ( - alpha + tmp2 ); const double q = mod2pi ( - mod2pi ( beta ) + tmp2 ); return PlanningResult { t , p , q , Mode :: LSR }; } std :: optional < PlanningResult > RSL ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double p_squared = ( d * d ) - 2 + ( 2 * c_ab ) - ( 2 * d * ( sa + sb )); if ( p_squared < 0 ) return std :: nullopt ; const double p = std :: sqrt ( p_squared ); const double tmp2 = std :: atan2 (( ca + cb ), ( d - sa - sb )) - std :: atan2 ( 2.0 , p ); const double t = mod2pi ( alpha - tmp2 ); const double q = mod2pi ( beta - tmp2 ); return PlanningResult { t , p , q , Mode :: RSL }; } std :: optional < PlanningResult > RLR ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp_rlr = ( 6.0 - d * d + 2.0 * c_ab + 2.0 * d * ( sa - sb )) / 8.0 ; if ( std :: abs ( tmp_rlr ) > 1.0 ) return std :: nullopt ; const double p = mod2pi ( 2 * M_PI - std :: acos ( tmp_rlr )); const double t = mod2pi ( alpha - std :: atan2 ( ca - cb , d - sa + sb ) + mod2pi ( p / 2.0 )); const double q = mod2pi ( alpha - beta - t + mod2pi ( p )); return PlanningResult { t , p , q , Mode :: LRL }; } std :: optional < PlanningResult > LRL ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp_lrl = ( 6.0 - d * d + 2 * c_ab + 2 * d * ( - sa + sb )) / 8.0 ; if ( std :: abs ( tmp_lrl ) > 1 ) return std :: nullopt ; const double p = mod2pi ( 2 * M_PI - std :: acos ( tmp_lrl )); const double t = mod2pi ( - alpha - std :: atan2 ( ca - cb , d + sa - sb ) + p / 2. ); const double q = mod2pi ( mod2pi ( beta ) - alpha - t + mod2pi ( p )); return PlanningResult { t , p , q , Mode :: LRL }; } double mod2pi ( double theta ) { return theta - 2.0 * M_PI * std :: floor ( theta / 2.0 / M_PI ); } enum class SegmentType { L , S , R , NONE }; void build_pos_function () { Transformd start = start_ ; for ( size_t i = 0 ; i < 3 ; i ++ ) { switch ( get_segment_type ( i )) { case SegmentType :: L : { pos_func_list_ [ i ] = [ = , this ]( double len ) { const double r = 1 / cavature_ ; const double theta = len / r ; Vector2d rot_origin = start . make_vector2 () + Vector2d ( r , 0 ). get_rotated ( start . theta + M_PI / 2 ); Transformd pos = start ; pos . rotate ( rot_origin , theta ); pos . theta += theta ; return pos ; }; } break ; case SegmentType :: R : { pos_func_list_ [ i ] = [ = , this ]( double len ) { const double r = 1 / cavature_ ; const double theta = len / r ; Vector2d rot_origin = start . make_vector2 () + Vector2d ( r , 0 ). get_rotated ( start . theta - M_PI / 2 ); Transformd pos = start ; pos . rotate ( rot_origin , - theta ); pos . theta += - theta ; return pos ; }; } break ; case SegmentType :: S : { pos_func_list_ [ i ] = [ = , this ]( double len ) { Transformd diff ( Vector2d ( len , 0 ). get_rotated ( start . theta ), 0 ); return start + diff ; }; } break ; default : pos_func_list_ [ i ] = [ = , this ]( double len ) { ( void ) len ; return start_ ; }; } start = pos_func_list_ [ i ]( segment_length ( i )); } } SegmentType get_segment_type ( size_t seg ) { switch ( seg ) { case 0 : { switch ( plan_ . mode ) { case Mode :: LRL : case Mode :: LSL : case Mode :: LSR : return SegmentType :: L ; case Mode :: RLR : case Mode :: RSL : case Mode :: RSR : return SegmentType :: R ; default : return SegmentType :: NONE ; } } break ; case 1 : { switch ( plan_ . mode ) { case Mode :: RLR : return SegmentType :: L ; case Mode :: LRL : return SegmentType :: R ; case Mode :: LSL : case Mode :: LSR : case Mode :: RSL : case Mode :: RSR : return SegmentType :: S ; default : return SegmentType :: NONE ; } } break ; case 2 : { switch ( plan_ . mode ) { case Mode :: LRL : case Mode :: LSL : case Mode :: RSL : return SegmentType :: L ; case Mode :: RLR : case Mode :: LSR : case Mode :: RSR : return SegmentType :: R ; default : return SegmentType :: NONE ; } } break ; default : return SegmentType :: NONE ; } } private : Transformd start_ , end_ ; double cavature_ ; PlanningResult plan_ ; double all_length_ = 0 ; std :: array < std :: function < Transformd ( double ) > , 3 > pos_func_list_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning/dubins_path.hpp"},{"location":"doxybook/Files/dubins__path_8hpp/#includecpp_roboticspath_planningdubins_pathhpp","text":"","title":"include/cpp_robotics/path_planning/dubins_path.hpp"},{"location":"doxybook/Files/dubins__path_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/dubins__path_8hpp/#classes","text":"Name class cpp_robotics::DubinsPath Dubins\u30d1\u30b9","title":"Classes"},{"location":"doxybook/Files/dubins__path_8hpp/#source-code","text":"#pragma once #include \"../vector/transform.hpp\" #include <functional> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { class DubinsPath { public : enum class Mode { LRL , RLR , LSL , LSR , RSL , RSR , NONE }; DubinsPath ( Transformd start , Transformd end , double cavature ) : start_ ( start ), end_ ( end ), cavature_ ( cavature ) { auto distance = ( end - start ). make_vector2 (). get_rotated ( - start . theta ); double angle_distance = shortest_angular_distance ( start . theta , end . theta ); planning_from_origin ({ distance , angle_distance }); all_length_ = plan_ . t + plan_ . p + plan_ . q ; build_pos_function (); } double length () const { return all_length_ ; } double segment_length ( size_t i ) const { assert ( i < 3 ); switch ( i ) { case 0 : return plan_ . t ; case 1 : return plan_ . p ; case 2 : return plan_ . q ; } return 0 ; } Transformd position ( double len ) const { len = std :: clamp ( len , 0.0 , all_length_ ); if ( len == 0 ) return start_ ; for ( size_t i = 0 ; i < 3 ; i ++ ) { if ( len < segment_length ( i )) { return pos_func_list_ [ i ]( len ); } len -= segment_length ( i ); } return end_ ; } std :: string path_type () const { switch ( plan_ . mode ) { case Mode :: LRL : return \"LRL\" ; case Mode :: RLR : return \"RLR\" ; case Mode :: LSL : return \"LSL\" ; case Mode :: LSR : return \"LSR\" ; case Mode :: RSL : return \"RSL\" ; case Mode :: RSR : return \"RSR\" ; default : return \"NONE\" ; } } private : struct PlanningResult { double t = 0 ; double p = 0 ; double q = 0 ; Mode mode = Mode :: NONE ; }; void planning_from_origin ( Transformd origin_to_goal ) { const auto dist = origin_to_goal . make_vector2 (); const double D = dist . norm (); const double d = D / cavature_ ; const double theta = mod2pi ( dist . angle ()); const double alpha = mod2pi ( - theta ); const double beta = mod2pi ( origin_to_goal . theta - theta ); auto planner_bind = [ this ]( auto mem_fn ) { return std :: bind ( mem_fn , this , std :: placeholders :: _1 , std :: placeholders :: _2 , std :: placeholders :: _3 ); }; std :: array planners = { planner_bind ( & DubinsPath :: LRL ), planner_bind ( & DubinsPath :: RLR ), planner_bind ( & DubinsPath :: LSL ), planner_bind ( & DubinsPath :: LSR ), planner_bind ( & DubinsPath :: RSL ), planner_bind ( & DubinsPath :: RSR ) }; double bcost = std :: numeric_limits < double >:: max (); std :: optional < PlanningResult > pret ; for ( auto & planner : planners ) { if ( auto ret = planner ( alpha , beta , d ); ret . has_value ()) { auto [ t , p , q , mode ] = ret . value (); double cost = t + p + q ; if ( cost < bcost ) { plan_ = ret . value (); bcost = cost ; } } } } std :: optional < PlanningResult > LSL ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp0 = d + sa - sb ; const double p_squared = 2 + ( d * d ) - ( 2 * c_ab ) + ( 2 * d * ( sa - sb )); if ( p_squared < 0 ) return std :: nullopt ; const double tmp1 = std :: atan2 (( cb - ca ), tmp0 ); const double t = mod2pi ( - alpha + tmp1 ); const double p = std :: sqrt ( p_squared ); const double q = mod2pi ( beta - tmp1 ); return PlanningResult { t , p , q , Mode :: LSL }; } std :: optional < PlanningResult > RSR ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp0 = d - sa + sb ; const double p_squared = 2 + ( d * d ) - ( 2 * c_ab ) + ( 2 * d * ( sb - sa )); if ( p_squared < 0 ) return std :: nullopt ; const double tmp1 = std :: atan2 (( ca - cb ), tmp0 ); const double t = mod2pi ( alpha - tmp1 ); const double p = std :: sqrt ( p_squared ); const double q = mod2pi ( - beta + tmp1 ); return PlanningResult { t , p , q , Mode :: RSR }; } std :: optional < PlanningResult > LSR ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double p_squared = -2 + ( d * d ) + ( 2 * c_ab ) + ( 2 * d * ( sa + sb )); if ( p_squared < 0 ) return std :: nullopt ; const double p = std :: sqrt ( p_squared ); const double tmp2 = std :: atan2 (( - ca - cb ), ( d + sa + sb )) - std :: atan2 ( -2.0 , p ); const double t = mod2pi ( - alpha + tmp2 ); const double q = mod2pi ( - mod2pi ( beta ) + tmp2 ); return PlanningResult { t , p , q , Mode :: LSR }; } std :: optional < PlanningResult > RSL ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double p_squared = ( d * d ) - 2 + ( 2 * c_ab ) - ( 2 * d * ( sa + sb )); if ( p_squared < 0 ) return std :: nullopt ; const double p = std :: sqrt ( p_squared ); const double tmp2 = std :: atan2 (( ca + cb ), ( d - sa - sb )) - std :: atan2 ( 2.0 , p ); const double t = mod2pi ( alpha - tmp2 ); const double q = mod2pi ( beta - tmp2 ); return PlanningResult { t , p , q , Mode :: RSL }; } std :: optional < PlanningResult > RLR ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp_rlr = ( 6.0 - d * d + 2.0 * c_ab + 2.0 * d * ( sa - sb )) / 8.0 ; if ( std :: abs ( tmp_rlr ) > 1.0 ) return std :: nullopt ; const double p = mod2pi ( 2 * M_PI - std :: acos ( tmp_rlr )); const double t = mod2pi ( alpha - std :: atan2 ( ca - cb , d - sa + sb ) + mod2pi ( p / 2.0 )); const double q = mod2pi ( alpha - beta - t + mod2pi ( p )); return PlanningResult { t , p , q , Mode :: LRL }; } std :: optional < PlanningResult > LRL ( double alpha , double beta , double d ) { const double sa = std :: sin ( alpha ); const double sb = std :: sin ( beta ); const double ca = std :: cos ( alpha ); const double cb = std :: cos ( beta ); const double c_ab = std :: cos ( alpha - beta ); const double tmp_lrl = ( 6.0 - d * d + 2 * c_ab + 2 * d * ( - sa + sb )) / 8.0 ; if ( std :: abs ( tmp_lrl ) > 1 ) return std :: nullopt ; const double p = mod2pi ( 2 * M_PI - std :: acos ( tmp_lrl )); const double t = mod2pi ( - alpha - std :: atan2 ( ca - cb , d + sa - sb ) + p / 2. ); const double q = mod2pi ( mod2pi ( beta ) - alpha - t + mod2pi ( p )); return PlanningResult { t , p , q , Mode :: LRL }; } double mod2pi ( double theta ) { return theta - 2.0 * M_PI * std :: floor ( theta / 2.0 / M_PI ); } enum class SegmentType { L , S , R , NONE }; void build_pos_function () { Transformd start = start_ ; for ( size_t i = 0 ; i < 3 ; i ++ ) { switch ( get_segment_type ( i )) { case SegmentType :: L : { pos_func_list_ [ i ] = [ = , this ]( double len ) { const double r = 1 / cavature_ ; const double theta = len / r ; Vector2d rot_origin = start . make_vector2 () + Vector2d ( r , 0 ). get_rotated ( start . theta + M_PI / 2 ); Transformd pos = start ; pos . rotate ( rot_origin , theta ); pos . theta += theta ; return pos ; }; } break ; case SegmentType :: R : { pos_func_list_ [ i ] = [ = , this ]( double len ) { const double r = 1 / cavature_ ; const double theta = len / r ; Vector2d rot_origin = start . make_vector2 () + Vector2d ( r , 0 ). get_rotated ( start . theta - M_PI / 2 ); Transformd pos = start ; pos . rotate ( rot_origin , - theta ); pos . theta += - theta ; return pos ; }; } break ; case SegmentType :: S : { pos_func_list_ [ i ] = [ = , this ]( double len ) { Transformd diff ( Vector2d ( len , 0 ). get_rotated ( start . theta ), 0 ); return start + diff ; }; } break ; default : pos_func_list_ [ i ] = [ = , this ]( double len ) { ( void ) len ; return start_ ; }; } start = pos_func_list_ [ i ]( segment_length ( i )); } } SegmentType get_segment_type ( size_t seg ) { switch ( seg ) { case 0 : { switch ( plan_ . mode ) { case Mode :: LRL : case Mode :: LSL : case Mode :: LSR : return SegmentType :: L ; case Mode :: RLR : case Mode :: RSL : case Mode :: RSR : return SegmentType :: R ; default : return SegmentType :: NONE ; } } break ; case 1 : { switch ( plan_ . mode ) { case Mode :: RLR : return SegmentType :: L ; case Mode :: LRL : return SegmentType :: R ; case Mode :: LSL : case Mode :: LSR : case Mode :: RSL : case Mode :: RSR : return SegmentType :: S ; default : return SegmentType :: NONE ; } } break ; case 2 : { switch ( plan_ . mode ) { case Mode :: LRL : case Mode :: LSL : case Mode :: RSL : return SegmentType :: L ; case Mode :: RLR : case Mode :: LSR : case Mode :: RSR : return SegmentType :: R ; default : return SegmentType :: NONE ; } } break ; default : return SegmentType :: NONE ; } } private : Transformd start_ , end_ ; double cavature_ ; PlanningResult plan_ ; double all_length_ = 0 ; std :: array < std :: function < Transformd ( double ) > , 3 > pos_func_list_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/dwa_8hpp/","text":"include/cpp_robotics/path_planning/dwa.hpp Namespaces Name cpp_robotics Source code #pragma once namespace cpp_robotics { } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning/dwa.hpp"},{"location":"doxybook/Files/dwa_8hpp/#includecpp_roboticspath_planningdwahpp","text":"","title":"include/cpp_robotics/path_planning/dwa.hpp"},{"location":"doxybook/Files/dwa_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/dwa_8hpp/#source-code","text":"#pragma once namespace cpp_robotics { } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/","text":"include/cpp_robotics/filter/extended_kalman_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::ExtendedKalmanFilter Source code #pragma once #include <Eigen/Dense> #include \"cpp_robotics/optimize/derivative.hpp\" namespace cpp_robotics { /* [\u30e2\u30c7\u30eb] x(t) = F*x(t-1) + B*u(t) + w(t) z(t) = H*x(t) + v(t) x: \u72b6\u614b\u91cf (n*1) u: \u5236\u5fa1\u91cf (r*1) z: \u89b3\u6e2c\u91cf (p*1) F: \u72b6\u614b\u9077\u79fb\u884c\u5217 (n*n) B: \u5236\u5fa1\u884c\u5217 (n*r) H: \u89b3\u6e2c\u884c\u5217 (p*n) Q: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (n*n) w: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba (n*1) N[0, Q]\u306b\u5f93\u3046 R: \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (p*p) v: \u89b3\u6e2c\u30ce\u30a4\u30ba (p*1) N[0, R]\u306b\u5f93\u3046 [\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf] - \u4e88\u6e2c \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a x = Fx + Bu \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q - \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0 \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3 K = PH^T(HPH^T + R)^-1 \u72b6\u614b\u63a8\u5b9a x = x + K(z - Hx) \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I -KH)P [\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf] - \u4e88\u6e2c \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a x = f(x, u) \u30e2\u30c7\u30eb\u7dda\u5f62\u8fd1\u4f3c F = \\partial f(x,u) / \\partial x | x=x, u=u H = \\partial h(x) / \\partial x | x=x \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q - \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0 \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3 K = PH^T(HPH^T + R)^-1 \u72b6\u614b\u63a8\u5b9a x = x + K(z - h(x)) \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I -KH)P */ class ExtendedKalmanFilter { public : Eigen :: VectorXd x ; Eigen :: MatrixXd F ; Eigen :: MatrixXd B ; Eigen :: MatrixXd H ; Eigen :: MatrixXd Q ; Eigen :: MatrixXd R ; Eigen :: MatrixXd P ; ExtendedKalmanFilter ( const double dt , size_t input_size , size_t state_size , size_t observe_size ) : dt_ ( dt ), input_size_ ( input_size ), state_size_ ( state_size ), observe_size_ ( observe_size ) { x = Eigen :: VectorXd :: Zero ( state_size_ ); F = Eigen :: MatrixXd :: Zero ( state_size , state_size ); B = Eigen :: MatrixXd :: Zero ( state_size , input_size ); H = Eigen :: MatrixXd :: Zero ( observe_size , state_size ); Q = Eigen :: MatrixXd :: Zero ( state_size , state_size ); R = Eigen :: MatrixXd :: Zero ( observe_size , observe_size ); P = Eigen :: MatrixXd :: Zero ( state_size , state_size ); }; void reset ( Eigen :: VectorXd new_x , Eigen :: MatrixXd new_P ) { x = new_x ; P = new_P ; } Eigen :: VectorXd filtering ( Eigen :: VectorXd u , Eigen :: VectorXd z ) { system_noise_conv ( Q , x , u ); observe_noise_conv ( R , x , u ); linearized_system_matrix ( F , x , u ); linearized_observe_matrix ( H , x ); // \u72b6\u614b\u4e88\u6e2c x = system ( x , u ); // \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217 P = F * P * F . transpose () + Q ; // \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97 Eigen :: MatrixXd K = P * H . transpose () * ( R + H * P * H . transpose ()). inverse (); // \u72b6\u614b\u66f4\u65b0 x += K * ( z - observe ( x )); // \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = ( Eigen :: MatrixXd :: Identity ( state_size_ , state_size_ ) - K * H ) * P ; return x ; } double dt () const { return dt_ ; } Eigen :: VectorXd get_x () const { return x ; } Eigen :: MatrixXd get_P () const { return P ; } virtual Eigen :: VectorXd system ( Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 ; virtual Eigen :: VectorXd observe ( Eigen :: VectorXd x ) = 0 ; virtual void system_noise_conv ( Eigen :: MatrixXd & Q , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 ; virtual void observe_noise_conv ( Eigen :: MatrixXd & R , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 ; virtual void linearized_system_matrix ( Eigen :: MatrixXd & F , Eigen :: VectorXd x , Eigen :: VectorXd u ) { F = derivative ([ & ]( const Eigen :: VectorXd & x_dash ){ return system ( x_dash , u ); }, x ); }; virtual void linearized_observe_matrix ( Eigen :: MatrixXd & H , Eigen :: VectorXd x ) { H = derivative ( std :: bind ( & ExtendedKalmanFilter :: observe , this , std :: placeholders :: _1 ), x ); } protected : // \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593[s] const double dt_ ; const size_t input_size_ ; const size_t state_size_ ; const size_t observe_size_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/extended_kalman_filter.hpp"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#includecpp_roboticsfilterextended_kalman_filterhpp","text":"","title":"include/cpp_robotics/filter/extended_kalman_filter.hpp"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#classes","text":"Name class cpp_robotics::ExtendedKalmanFilter","title":"Classes"},{"location":"doxybook/Files/extended__kalman__filter_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> #include \"cpp_robotics/optimize/derivative.hpp\" namespace cpp_robotics { /* [\u30e2\u30c7\u30eb] x(t) = F*x(t-1) + B*u(t) + w(t) z(t) = H*x(t) + v(t) x: \u72b6\u614b\u91cf (n*1) u: \u5236\u5fa1\u91cf (r*1) z: \u89b3\u6e2c\u91cf (p*1) F: \u72b6\u614b\u9077\u79fb\u884c\u5217 (n*n) B: \u5236\u5fa1\u884c\u5217 (n*r) H: \u89b3\u6e2c\u884c\u5217 (p*n) Q: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (n*n) w: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba (n*1) N[0, Q]\u306b\u5f93\u3046 R: \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (p*p) v: \u89b3\u6e2c\u30ce\u30a4\u30ba (p*1) N[0, R]\u306b\u5f93\u3046 [\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf] - \u4e88\u6e2c \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a x = Fx + Bu \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q - \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0 \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3 K = PH^T(HPH^T + R)^-1 \u72b6\u614b\u63a8\u5b9a x = x + K(z - Hx) \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I -KH)P [\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf] - \u4e88\u6e2c \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a x = f(x, u) \u30e2\u30c7\u30eb\u7dda\u5f62\u8fd1\u4f3c F = \\partial f(x,u) / \\partial x | x=x, u=u H = \\partial h(x) / \\partial x | x=x \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q - \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0 \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3 K = PH^T(HPH^T + R)^-1 \u72b6\u614b\u63a8\u5b9a x = x + K(z - h(x)) \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I -KH)P */ class ExtendedKalmanFilter { public : Eigen :: VectorXd x ; Eigen :: MatrixXd F ; Eigen :: MatrixXd B ; Eigen :: MatrixXd H ; Eigen :: MatrixXd Q ; Eigen :: MatrixXd R ; Eigen :: MatrixXd P ; ExtendedKalmanFilter ( const double dt , size_t input_size , size_t state_size , size_t observe_size ) : dt_ ( dt ), input_size_ ( input_size ), state_size_ ( state_size ), observe_size_ ( observe_size ) { x = Eigen :: VectorXd :: Zero ( state_size_ ); F = Eigen :: MatrixXd :: Zero ( state_size , state_size ); B = Eigen :: MatrixXd :: Zero ( state_size , input_size ); H = Eigen :: MatrixXd :: Zero ( observe_size , state_size ); Q = Eigen :: MatrixXd :: Zero ( state_size , state_size ); R = Eigen :: MatrixXd :: Zero ( observe_size , observe_size ); P = Eigen :: MatrixXd :: Zero ( state_size , state_size ); }; void reset ( Eigen :: VectorXd new_x , Eigen :: MatrixXd new_P ) { x = new_x ; P = new_P ; } Eigen :: VectorXd filtering ( Eigen :: VectorXd u , Eigen :: VectorXd z ) { system_noise_conv ( Q , x , u ); observe_noise_conv ( R , x , u ); linearized_system_matrix ( F , x , u ); linearized_observe_matrix ( H , x ); // \u72b6\u614b\u4e88\u6e2c x = system ( x , u ); // \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217 P = F * P * F . transpose () + Q ; // \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97 Eigen :: MatrixXd K = P * H . transpose () * ( R + H * P * H . transpose ()). inverse (); // \u72b6\u614b\u66f4\u65b0 x += K * ( z - observe ( x )); // \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = ( Eigen :: MatrixXd :: Identity ( state_size_ , state_size_ ) - K * H ) * P ; return x ; } double dt () const { return dt_ ; } Eigen :: VectorXd get_x () const { return x ; } Eigen :: MatrixXd get_P () const { return P ; } virtual Eigen :: VectorXd system ( Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 ; virtual Eigen :: VectorXd observe ( Eigen :: VectorXd x ) = 0 ; virtual void system_noise_conv ( Eigen :: MatrixXd & Q , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 ; virtual void observe_noise_conv ( Eigen :: MatrixXd & R , Eigen :: VectorXd x , Eigen :: VectorXd u ) = 0 ; virtual void linearized_system_matrix ( Eigen :: MatrixXd & F , Eigen :: VectorXd x , Eigen :: VectorXd u ) { F = derivative ([ & ]( const Eigen :: VectorXd & x_dash ){ return system ( x_dash , u ); }, x ); }; virtual void linearized_observe_matrix ( Eigen :: MatrixXd & H , Eigen :: VectorXd x ) { H = derivative ( std :: bind ( & ExtendedKalmanFilter :: observe , this , std :: placeholders :: _1 ), x ); } protected : // \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u6642\u9593[s] const double dt_ ; const size_t input_size_ ; const size_t state_size_ ; const size_t observe_size_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/filter_8hpp/","text":"include/cpp_robotics/filter/filter.hpp Source code #include \"./low_pass_filter.hpp\" #include \"./differentiator.hpp\" #include \"./integrator.hpp\" #include \"./low_pass_filter.hpp\" #include \"./high_pass_filter.hpp\" #include \"./notch_filter.hpp\" #include \"./band_pass_filter.hpp\" #include \"./delay_filter.hpp\" #include \"./velocity_limit_filter.hpp\" #include \"./acceleration_limit_filter.hpp\" #include \"./filter_state_holder.hpp\" #include \"./kalman_filter.hpp\" #include \"./extended_kalman_filter.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/filter.hpp"},{"location":"doxybook/Files/filter_8hpp/#includecpp_roboticsfilterfilterhpp","text":"","title":"include/cpp_robotics/filter/filter.hpp"},{"location":"doxybook/Files/filter_8hpp/#source-code","text":"#include \"./low_pass_filter.hpp\" #include \"./differentiator.hpp\" #include \"./integrator.hpp\" #include \"./low_pass_filter.hpp\" #include \"./high_pass_filter.hpp\" #include \"./notch_filter.hpp\" #include \"./band_pass_filter.hpp\" #include \"./delay_filter.hpp\" #include \"./velocity_limit_filter.hpp\" #include \"./acceleration_limit_filter.hpp\" #include \"./filter_state_holder.hpp\" #include \"./kalman_filter.hpp\" #include \"./extended_kalman_filter.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/filter__connector_8hpp/","text":"include/cpp_robotics/filter/filter_connector.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::FilterConnector Source code #pragma once #include <cmath> #include <array> #include <variant> namespace cpp_robotics { template < class ... FILTER_TYPE > class FilterConnector { public : static constexpr size_t filter_count = sizeof ...( FILTER_TYPE ); using variant_type = std :: variant < FILTER_TYPE ... > ; FilterConnector () { } private : std :: array < variant_type , filter_count > filters_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/filter_connector.hpp"},{"location":"doxybook/Files/filter__connector_8hpp/#includecpp_roboticsfilterfilter_connectorhpp","text":"","title":"include/cpp_robotics/filter/filter_connector.hpp"},{"location":"doxybook/Files/filter__connector_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/filter__connector_8hpp/#classes","text":"Name class cpp_robotics::FilterConnector","title":"Classes"},{"location":"doxybook/Files/filter__connector_8hpp/#source-code","text":"#pragma once #include <cmath> #include <array> #include <variant> namespace cpp_robotics { template < class ... FILTER_TYPE > class FilterConnector { public : static constexpr size_t filter_count = sizeof ...( FILTER_TYPE ); using variant_type = std :: variant < FILTER_TYPE ... > ; FilterConnector () { } private : std :: array < variant_type , filter_count > filters_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/filter__state__holder_8hpp/","text":"include/cpp_robotics/filter/filter_state_holder.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 Source code #pragma once #include <tuple> #include <optional> #include <algorithm> namespace cpp_robotics { template < class BASE_FILTER_TYPE > class FilterStateHolder : public BASE_FILTER_TYPE { public : using BASE_FILTER_TYPE :: BASE_FILTER_TYPE ; void set_input ( double u ) { u_ = u ; } double filtering () { y_ = BASE_FILTER_TYPE :: filtering ( u ); return y_ ; } double u () const { return u_ ; } double y () const { return y_ ; } private : double u_ = 0 , y_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/filter_state_holder.hpp"},{"location":"doxybook/Files/filter__state__holder_8hpp/#includecpp_roboticsfilterfilter_state_holderhpp","text":"","title":"include/cpp_robotics/filter/filter_state_holder.hpp"},{"location":"doxybook/Files/filter__state__holder_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/filter__state__holder_8hpp/#classes","text":"Name class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9","title":"Classes"},{"location":"doxybook/Files/filter__state__holder_8hpp/#source-code","text":"#pragma once #include <tuple> #include <optional> #include <algorithm> namespace cpp_robotics { template < class BASE_FILTER_TYPE > class FilterStateHolder : public BASE_FILTER_TYPE { public : using BASE_FILTER_TYPE :: BASE_FILTER_TYPE ; void set_input ( double u ) { u_ = u ; } double filtering () { y_ = BASE_FILTER_TYPE :: filtering ( u ); return y_ ; } double u () const { return u_ ; } double y () const { return y_ ; } private : double u_ = 0 , y_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/frenet__frame_8hpp/","text":"include/cpp_robotics/path_planning/frenet_frame.hpp Source code // #pragma once // // #include \"Polynomial.hpp\" // // #include \"../../Control/Trajectory/Trajectory2/Trajectory2.hpp\" // #include <cstdio> // #include <string> // #include <limits> // #include <tuple> // namespace cpp_robotics // { // // template <typename double> // // void d_print_vector(const std::string name, const std::vector<double> &vec, // // std::string fmt = \"%8.3f\") // // { // // std::cout << name << \" =\" << std::endl; // // printf(\"[\"); // // for (auto &val : vec) printf(fmt.c_str(), val); // // printf(\"]\\n\"); // // } // /** // * @brief 4\u6b21\u5f0f\u88dc\u9593 // * // * @param x0 \u59cb\u70b9\u4f4d\u7f6e // * @param v0 \u59cb\u70b9\u901f\u5ea6 // * @param a0 \u59cb\u70b9\u52a0\u901f\u5ea6 // * @param v1 \u7d42\u70b9\u901f\u5ea6 // * @param a1 \u7d42\u70b9\u52a0\u901f\u5ea6 // * @param Time \u533a\u9593\u9577\u3055 // */ // Polynomial<double> quartic_poly(double x0, double v0, double a0, double v1, double a1, double Time) // { // std::vector<double> coeff; // coeff.resize(5); // const double T2 = sq(Time); // const double T3 = T2 * Time; // coeff[0] = x0; // coeff[1] = v0; // coeff[2] = 0.5 * a0; // coeff[3] = (3*(v1 - v0) - Time*(a1 + 2*a0)) / (3*T2); // coeff[4] = (-2*(v1 - v0) + Time*(a1 + a0)) / (4*T3); // return Polynomial<double>(coeff); // } // /** // * @brief 5\u6b21\u88dc\u9593 // * // * @tparam double // * @param x0 \u59cb\u70b9\u4f4d\u7f6e // * @param v0 \u59cb\u70b9\u901f\u5ea6 // * @param a0 \u59cb\u70b9\u52a0\u901f\u5ea6 // * @param x1 \u7d42\u70b9\u4f4d\u7f6e // * @param v1 \u7d42\u70b9\u901f\u5ea6 // * @param a1 \u7d42\u70b9\u52a0\u901f\u5ea6 // * @param Time \u533a\u9593\u9577\u3055 // * @return Polynomial<double> // */ // template <typename double> // Polynomial<double> quintic_poly(double x0, double v0, double a0, double x1, double v1, double a1, double Time) // { // std::vector<double> coeff; // coeff.resize(6); // const double T2 = sq(Time); // const double T3 = T2 * Time; // const double T4 = T3 * Time; // const double T5 = T4 * Time; // coeff[0] = x0; // coeff[1] = v0; // coeff[2] = 0.5 * a0; // coeff[3] = ( 20*(x1 - x0) - Time*( 8*v1 + 12*v0) + T2*(a1 - 3*a0)) / (2*T3); // coeff[4] = (-30*(x1 - x0) + Time*(14*v1 + 16*v0) - T2*(a1 - 3*a0)) / (2*T4); // coeff[5] = ( 12*(x1 - x0) - 6*Time*( v1 + v0) + T2*(a1 - a0)) / (2*T5); // return Polynomial<double>(coeff); // } // /** // * @brief \u63a2\u7d22\u7bc4\u56f2\u7528\u8a2d\u5b9a // * // * @tparam double // */ // struct frenet_path_config_t // { // double dt; // double width; // size_t width_num; // double length_min, length_max; // size_t length_num; // double target_speed; // double speed_interval; // size_t speed_num; // double K_J, K_T, K_D, K_LAT, K_LON; // }; // struct frenet_path_point_t // { // double t; // double d, d_d, d_dd, d_ddd; // double s, s_d, s_dd, s_ddd; // Vector2<double> pos; // double theta; // double ds; // double curvature; // }; // struct frenet_path_t : public std::vector<frenet_path_point_t<double>> // { // double cd, cv, cf; // }; // struct frenet_path_state_t // { // double c_speed; // double c_d; // double c_d_d; // double c_d_dd; // double s0; // }; // template <typename double> // struct frenet_path_th_t // { // double max_speed; // double max_accel; // double max_curvature; // double radius; // }; // std::vector<frenet_path_t<double>> frenet_path( // const frenet_path_config_t<double>& config, // const frenet_path_state_t<double>& state) // { // double c_speed = state.c_speed; // double c_d = state.c_d; // double c_d_d = state.c_d_d; // double c_d_dd = state.c_d_dd; // double s0 = state.s0; // auto dt = config.dt; // std::vector<frenet_path_t<double>> paths; // // \u5074\u65b9\u8ddd\u96e2\u5909\u5316 // for(size_t di_idx = 0; di_idx < config.width_num; di_idx++) // { // //printf(\"di, %ld, %ld, %lf, %lf\\n\", di_idx, config.width_num-1, -config.width, config.width); // double di = map<double>(di_idx, 0, config.width_num-1, -config.width, config.width); // // \u8ddd\u96e2\u5909\u5316 // for(size_t Ti_idx = 0; Ti_idx < config.length_num; Ti_idx++) // { // double Ti = map<double>(Ti_idx, 0, config.length_num-1, config.length_min, config.length_max); // //printf(\"%lf, %lf, %lf, %lf, %lf\\n\", c_d, c_d_d, c_d_dd, di, Ti); // auto d_func = quintic_poly<double>(c_d, c_d_d, c_d_dd, di, 0, 0, Ti); // frenet_path_t<double> fp; // fp.resize(static_cast<size_t>(Ti/dt)); // //d_print_vector(\"d_func\", d_func.coeff()); // for(size_t t_idx = 0; t_idx < fp.size(); t_idx++) // { // auto &fpp = fp[t_idx]; // fpp.t = t_idx * dt; // fpp.d = d_func(fpp.t); // //printf(\"fpp.t = %lf, d = %lf\\n\", fpp.t, fpp.d); // fpp.d_d = d_func.polyder(1)(fpp.t); // fpp.d_dd = d_func.polyder(2)(fpp.t); // fpp.d_ddd = d_func.polyder(3)(fpp.t); // } // // \u901f\u5ea6\u5909\u5316 // for(size_t tv_idx = 0; tv_idx < config.speed_num; tv_idx++) // { // double tv = map<double>(tv_idx, 0, config.speed_num-1, config.target_speed - config.speed_interval, config.target_speed + config.speed_interval); // frenet_path_t<double> tfp = fp; // auto s_func = quartic_poly<double>(s0, c_speed, 0, tv, 0, Ti); // double Jp = 0, Js = 0; // for(size_t t_idx = 0; t_idx < tfp.size(); t_idx++) // { // auto &tfpp = tfp[t_idx]; // tfpp.t = t_idx * dt; // tfpp.s = s_func(tfpp.t); // tfpp.s_d = s_func.polyder(1)(tfpp.t); // tfpp.s_dd = s_func.polyder(2)(tfpp.t); // tfpp.s_ddd = s_func.polyder(3)(tfpp.t); // Jp += sq(tfpp.d_ddd); // Js += sq(tfpp.s_ddd); // } // double ds = sq(config.target_speed - tfp.back().s_d); // tfp.cd = config.K_J * Jp + config.K_T * Ti + config.K_D * sq(tfp.back().d); // tfp.cv = config.K_J * Js + config.K_T * Ti + config.K_D * ds; // tfp.cf = config.K_LAT * tfp.cd + config.K_LON * tfp.cv; // paths.push_back(tfp); // } // } // } // return paths; // } // void frenet_path_to_global_path(std::vector<frenet_path_t<double>> &fpath, const Trajectory2 &ref_path) // { // // \u30d1\u30b9\u3054\u3068 // for(auto &fp : fpath) // { // // \u70b9\u3054\u3068 // for(auto &fpp : fp) // { // auto patht = min<double>(fpp.s, ref_path.length()); // //printf(\"patht: %lfm %lf\\n\", patht, fpp.s); // auto ref_idx = ref_path.linear_index(patht); // Vec2F pos = ref_path.position(ref_idx); // Vec2F vel = ref_path.velocity(ref_idx); // vel.normalize(); // double yaw = vel.angle(); // fpp.pos.x = pos.x + fpp.d * cos(yaw + HALF_PI); // fpp.pos.y = pos.y + fpp.d * sin(yaw + HALF_PI); // } // for(size_t i = 0; i < fp.size()-1; i++) // { // auto dpos = fp[i+1].pos - fp[i].pos; // if(!dpos.is_zero()) // { // fp[i].theta = dpos.angle(); // fp[i].ds = hypot(dpos.x, dpos.y); // } // else // { // fp[i].theta = fp[i].ds = 0; // } // } // for(size_t i = 0; i < fp.size()-1; i++) // { // fp[i].curvature = (fp[i+1].theta - fp[i].theta) / fp[i].ds; // } // fp.back().curvature = 0; // } // } // bool check_collision(const Vector2<double> &pos, double r, const std::vector<Vector2<double>>& obstacles) // { // const double r2 = sq(r); // for(auto & ob : obstacles) // { // if(r2 > (ob-pos).norm_sq()) // return true; // \u885d\u7a81\u3059\u308b\u5224\u5b9a // } // return false; // } // void check_path(std::vector< // frenet_path_t<double>> &fpath, // const frenet_path_th_t<double>& ths, // const std::vector<Vector2<double>>& obstacles) // { // auto pit = fpath.begin(); // while(pit != fpath.end()) // { // bool path_delete = false; // for(auto &fpp : (*pit)) // { // if(fpp.s_d > ths.max_speed) // path_delete = true; // if(abs(fpp.s_dd) > ths.max_accel) // path_delete = true; // // if(abs(fpp.curvature) > ths.max_curvature) // // path_delete = true; // if(check_collision<double>(fpp.pos, ths.radius, obstacles)) // path_delete = true; // } // if (path_delete == true) // { // //printf(\"erase\\n\"); // pit = fpath.erase(pit); // } // else // { // //printf(\"pit++;\\n\"); // pit++; // } // } // } // std::tuple<frenet_path_t<double>, std::vector<frenet_path_t<double>>> frenet_optimal_planning( // const frenet_path_config_t<double>& config, // const frenet_path_state_t<double>& state, // const Trajectory2 &ref_path, // const frenet_path_th_t<double>& ths, // const std::vector<Vector2<double>>& obstacles) // { // auto frenet_paths = frenet_path(config, state); // //printf(\"opt 1\\n\"); // frenet_path_to_global_path(frenet_paths, ref_path); // //printf(\"opt 2\\n\"); // check_path<double>(frenet_paths, ths, obstacles); // //printf(\"opt 3\\n\"); // auto it = frenet_paths.begin(); // double min_cost = (*it).cf; // for(auto cit = frenet_paths.begin()+1; cit < frenet_paths.end(); cit++) // { // if (min_cost > (*cit).cf) // { // min_cost = (*cit).cf; // it = cit; // } // } // return {*it, frenet_paths}; // } // } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning/frenet_frame.hpp"},{"location":"doxybook/Files/frenet__frame_8hpp/#includecpp_roboticspath_planningfrenet_framehpp","text":"","title":"include/cpp_robotics/path_planning/frenet_frame.hpp"},{"location":"doxybook/Files/frenet__frame_8hpp/#source-code","text":"// #pragma once // // #include \"Polynomial.hpp\" // // #include \"../../Control/Trajectory/Trajectory2/Trajectory2.hpp\" // #include <cstdio> // #include <string> // #include <limits> // #include <tuple> // namespace cpp_robotics // { // // template <typename double> // // void d_print_vector(const std::string name, const std::vector<double> &vec, // // std::string fmt = \"%8.3f\") // // { // // std::cout << name << \" =\" << std::endl; // // printf(\"[\"); // // for (auto &val : vec) printf(fmt.c_str(), val); // // printf(\"]\\n\"); // // } // /** // * @brief 4\u6b21\u5f0f\u88dc\u9593 // * // * @param x0 \u59cb\u70b9\u4f4d\u7f6e // * @param v0 \u59cb\u70b9\u901f\u5ea6 // * @param a0 \u59cb\u70b9\u52a0\u901f\u5ea6 // * @param v1 \u7d42\u70b9\u901f\u5ea6 // * @param a1 \u7d42\u70b9\u52a0\u901f\u5ea6 // * @param Time \u533a\u9593\u9577\u3055 // */ // Polynomial<double> quartic_poly(double x0, double v0, double a0, double v1, double a1, double Time) // { // std::vector<double> coeff; // coeff.resize(5); // const double T2 = sq(Time); // const double T3 = T2 * Time; // coeff[0] = x0; // coeff[1] = v0; // coeff[2] = 0.5 * a0; // coeff[3] = (3*(v1 - v0) - Time*(a1 + 2*a0)) / (3*T2); // coeff[4] = (-2*(v1 - v0) + Time*(a1 + a0)) / (4*T3); // return Polynomial<double>(coeff); // } // /** // * @brief 5\u6b21\u88dc\u9593 // * // * @tparam double // * @param x0 \u59cb\u70b9\u4f4d\u7f6e // * @param v0 \u59cb\u70b9\u901f\u5ea6 // * @param a0 \u59cb\u70b9\u52a0\u901f\u5ea6 // * @param x1 \u7d42\u70b9\u4f4d\u7f6e // * @param v1 \u7d42\u70b9\u901f\u5ea6 // * @param a1 \u7d42\u70b9\u52a0\u901f\u5ea6 // * @param Time \u533a\u9593\u9577\u3055 // * @return Polynomial<double> // */ // template <typename double> // Polynomial<double> quintic_poly(double x0, double v0, double a0, double x1, double v1, double a1, double Time) // { // std::vector<double> coeff; // coeff.resize(6); // const double T2 = sq(Time); // const double T3 = T2 * Time; // const double T4 = T3 * Time; // const double T5 = T4 * Time; // coeff[0] = x0; // coeff[1] = v0; // coeff[2] = 0.5 * a0; // coeff[3] = ( 20*(x1 - x0) - Time*( 8*v1 + 12*v0) + T2*(a1 - 3*a0)) / (2*T3); // coeff[4] = (-30*(x1 - x0) + Time*(14*v1 + 16*v0) - T2*(a1 - 3*a0)) / (2*T4); // coeff[5] = ( 12*(x1 - x0) - 6*Time*( v1 + v0) + T2*(a1 - a0)) / (2*T5); // return Polynomial<double>(coeff); // } // /** // * @brief \u63a2\u7d22\u7bc4\u56f2\u7528\u8a2d\u5b9a // * // * @tparam double // */ // struct frenet_path_config_t // { // double dt; // double width; // size_t width_num; // double length_min, length_max; // size_t length_num; // double target_speed; // double speed_interval; // size_t speed_num; // double K_J, K_T, K_D, K_LAT, K_LON; // }; // struct frenet_path_point_t // { // double t; // double d, d_d, d_dd, d_ddd; // double s, s_d, s_dd, s_ddd; // Vector2<double> pos; // double theta; // double ds; // double curvature; // }; // struct frenet_path_t : public std::vector<frenet_path_point_t<double>> // { // double cd, cv, cf; // }; // struct frenet_path_state_t // { // double c_speed; // double c_d; // double c_d_d; // double c_d_dd; // double s0; // }; // template <typename double> // struct frenet_path_th_t // { // double max_speed; // double max_accel; // double max_curvature; // double radius; // }; // std::vector<frenet_path_t<double>> frenet_path( // const frenet_path_config_t<double>& config, // const frenet_path_state_t<double>& state) // { // double c_speed = state.c_speed; // double c_d = state.c_d; // double c_d_d = state.c_d_d; // double c_d_dd = state.c_d_dd; // double s0 = state.s0; // auto dt = config.dt; // std::vector<frenet_path_t<double>> paths; // // \u5074\u65b9\u8ddd\u96e2\u5909\u5316 // for(size_t di_idx = 0; di_idx < config.width_num; di_idx++) // { // //printf(\"di, %ld, %ld, %lf, %lf\\n\", di_idx, config.width_num-1, -config.width, config.width); // double di = map<double>(di_idx, 0, config.width_num-1, -config.width, config.width); // // \u8ddd\u96e2\u5909\u5316 // for(size_t Ti_idx = 0; Ti_idx < config.length_num; Ti_idx++) // { // double Ti = map<double>(Ti_idx, 0, config.length_num-1, config.length_min, config.length_max); // //printf(\"%lf, %lf, %lf, %lf, %lf\\n\", c_d, c_d_d, c_d_dd, di, Ti); // auto d_func = quintic_poly<double>(c_d, c_d_d, c_d_dd, di, 0, 0, Ti); // frenet_path_t<double> fp; // fp.resize(static_cast<size_t>(Ti/dt)); // //d_print_vector(\"d_func\", d_func.coeff()); // for(size_t t_idx = 0; t_idx < fp.size(); t_idx++) // { // auto &fpp = fp[t_idx]; // fpp.t = t_idx * dt; // fpp.d = d_func(fpp.t); // //printf(\"fpp.t = %lf, d = %lf\\n\", fpp.t, fpp.d); // fpp.d_d = d_func.polyder(1)(fpp.t); // fpp.d_dd = d_func.polyder(2)(fpp.t); // fpp.d_ddd = d_func.polyder(3)(fpp.t); // } // // \u901f\u5ea6\u5909\u5316 // for(size_t tv_idx = 0; tv_idx < config.speed_num; tv_idx++) // { // double tv = map<double>(tv_idx, 0, config.speed_num-1, config.target_speed - config.speed_interval, config.target_speed + config.speed_interval); // frenet_path_t<double> tfp = fp; // auto s_func = quartic_poly<double>(s0, c_speed, 0, tv, 0, Ti); // double Jp = 0, Js = 0; // for(size_t t_idx = 0; t_idx < tfp.size(); t_idx++) // { // auto &tfpp = tfp[t_idx]; // tfpp.t = t_idx * dt; // tfpp.s = s_func(tfpp.t); // tfpp.s_d = s_func.polyder(1)(tfpp.t); // tfpp.s_dd = s_func.polyder(2)(tfpp.t); // tfpp.s_ddd = s_func.polyder(3)(tfpp.t); // Jp += sq(tfpp.d_ddd); // Js += sq(tfpp.s_ddd); // } // double ds = sq(config.target_speed - tfp.back().s_d); // tfp.cd = config.K_J * Jp + config.K_T * Ti + config.K_D * sq(tfp.back().d); // tfp.cv = config.K_J * Js + config.K_T * Ti + config.K_D * ds; // tfp.cf = config.K_LAT * tfp.cd + config.K_LON * tfp.cv; // paths.push_back(tfp); // } // } // } // return paths; // } // void frenet_path_to_global_path(std::vector<frenet_path_t<double>> &fpath, const Trajectory2 &ref_path) // { // // \u30d1\u30b9\u3054\u3068 // for(auto &fp : fpath) // { // // \u70b9\u3054\u3068 // for(auto &fpp : fp) // { // auto patht = min<double>(fpp.s, ref_path.length()); // //printf(\"patht: %lfm %lf\\n\", patht, fpp.s); // auto ref_idx = ref_path.linear_index(patht); // Vec2F pos = ref_path.position(ref_idx); // Vec2F vel = ref_path.velocity(ref_idx); // vel.normalize(); // double yaw = vel.angle(); // fpp.pos.x = pos.x + fpp.d * cos(yaw + HALF_PI); // fpp.pos.y = pos.y + fpp.d * sin(yaw + HALF_PI); // } // for(size_t i = 0; i < fp.size()-1; i++) // { // auto dpos = fp[i+1].pos - fp[i].pos; // if(!dpos.is_zero()) // { // fp[i].theta = dpos.angle(); // fp[i].ds = hypot(dpos.x, dpos.y); // } // else // { // fp[i].theta = fp[i].ds = 0; // } // } // for(size_t i = 0; i < fp.size()-1; i++) // { // fp[i].curvature = (fp[i+1].theta - fp[i].theta) / fp[i].ds; // } // fp.back().curvature = 0; // } // } // bool check_collision(const Vector2<double> &pos, double r, const std::vector<Vector2<double>>& obstacles) // { // const double r2 = sq(r); // for(auto & ob : obstacles) // { // if(r2 > (ob-pos).norm_sq()) // return true; // \u885d\u7a81\u3059\u308b\u5224\u5b9a // } // return false; // } // void check_path(std::vector< // frenet_path_t<double>> &fpath, // const frenet_path_th_t<double>& ths, // const std::vector<Vector2<double>>& obstacles) // { // auto pit = fpath.begin(); // while(pit != fpath.end()) // { // bool path_delete = false; // for(auto &fpp : (*pit)) // { // if(fpp.s_d > ths.max_speed) // path_delete = true; // if(abs(fpp.s_dd) > ths.max_accel) // path_delete = true; // // if(abs(fpp.curvature) > ths.max_curvature) // // path_delete = true; // if(check_collision<double>(fpp.pos, ths.radius, obstacles)) // path_delete = true; // } // if (path_delete == true) // { // //printf(\"erase\\n\"); // pit = fpath.erase(pit); // } // else // { // //printf(\"pit++;\\n\"); // pit++; // } // } // } // std::tuple<frenet_path_t<double>, std::vector<frenet_path_t<double>>> frenet_optimal_planning( // const frenet_path_config_t<double>& config, // const frenet_path_state_t<double>& state, // const Trajectory2 &ref_path, // const frenet_path_th_t<double>& ths, // const std::vector<Vector2<double>>& obstacles) // { // auto frenet_paths = frenet_path(config, state); // //printf(\"opt 1\\n\"); // frenet_path_to_global_path(frenet_paths, ref_path); // //printf(\"opt 2\\n\"); // check_path<double>(frenet_paths, ths, obstacles); // //printf(\"opt 3\\n\"); // auto it = frenet_paths.begin(); // double min_cost = (*it).cf; // for(auto cit = frenet_paths.begin()+1; cit < frenet_paths.end(); cit++) // { // if (min_cost > (*cit).cf) // { // min_cost = (*cit).cf; // it = cit; // } // } // return {*it, frenet_paths}; // } // } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/geometry_8hpp/","text":"include/cpp_robotics/geometry/geometry.hpp Namespaces Name cpp_robotics Source code #pragma once #include <vector> #include \"./shape.hpp\" namespace cpp_robotics { // Vector2d vs bool intersect ( const Vector2d & a , const Vector2d & b ); bool intersect ( const Vector2d & a , const Line & b ); bool intersect ( const Vector2d & a , const Rect & b ); bool intersect ( const Vector2d & a , const Circle & b ); // Line vs bool intersect ( const Line & a , const Vector2d & b ); bool intersect ( const Line & a , const Line & b ); bool intersect ( const Line & a , const Circle & b ); // Rect vs bool intersect ( const Rect & a , const Vector2d & b ); // Ciecle vs bool intersect ( const Circle & a , const Vector2d & b ); bool intersect ( const Circle & a , const Line & b ); // Vector2d vs std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Vector2d & b ); std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Line & b ); std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Rect & b ); std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Circle & b ); // Line vs std :: vector < Vector2d > intersect_at ( const Line & a , const Vector2d & b ); std :: vector < Vector2d > intersect_at ( const Line & a , const Line & b ); std :: vector < Vector2d > intersect_at ( const Line & a , const Circle & b ); // Rect vs std :: vector < Vector2d > intersect_at ( const Rect & a , const Vector2d & b ); // Ciecle vs std :: vector < Vector2d > intersect_at ( const Circle & a , const Vector2d & b ); std :: vector < Vector2d > intersect_at ( const Circle & a , const Line & b ); bool contain ( const Vector2d & range , const Vector2d & target ); bool contain ( const Rect & range , const Vector2d & target ); } #include \"geometry_stream.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/geometry/geometry.hpp"},{"location":"doxybook/Files/geometry_8hpp/#includecpp_roboticsgeometrygeometryhpp","text":"","title":"include/cpp_robotics/geometry/geometry.hpp"},{"location":"doxybook/Files/geometry_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/geometry_8hpp/#source-code","text":"#pragma once #include <vector> #include \"./shape.hpp\" namespace cpp_robotics { // Vector2d vs bool intersect ( const Vector2d & a , const Vector2d & b ); bool intersect ( const Vector2d & a , const Line & b ); bool intersect ( const Vector2d & a , const Rect & b ); bool intersect ( const Vector2d & a , const Circle & b ); // Line vs bool intersect ( const Line & a , const Vector2d & b ); bool intersect ( const Line & a , const Line & b ); bool intersect ( const Line & a , const Circle & b ); // Rect vs bool intersect ( const Rect & a , const Vector2d & b ); // Ciecle vs bool intersect ( const Circle & a , const Vector2d & b ); bool intersect ( const Circle & a , const Line & b ); // Vector2d vs std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Vector2d & b ); std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Line & b ); std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Rect & b ); std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Circle & b ); // Line vs std :: vector < Vector2d > intersect_at ( const Line & a , const Vector2d & b ); std :: vector < Vector2d > intersect_at ( const Line & a , const Line & b ); std :: vector < Vector2d > intersect_at ( const Line & a , const Circle & b ); // Rect vs std :: vector < Vector2d > intersect_at ( const Rect & a , const Vector2d & b ); // Ciecle vs std :: vector < Vector2d > intersect_at ( const Circle & a , const Vector2d & b ); std :: vector < Vector2d > intersect_at ( const Circle & a , const Line & b ); bool contain ( const Vector2d & range , const Vector2d & target ); bool contain ( const Rect & range , const Vector2d & target ); } #include \"geometry_stream.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/geometry__stream_8hpp/","text":"include/cpp_robotics/geometry/geometry_stream.hpp Namespaces Name cpp_robotics Source code #pragma once #include <iostream> #include \"../vector/vector2.hpp\" #include \"../vector/vector3.hpp\" #include \"../vector/vector4.hpp\" #include \"../vector/transform.hpp\" namespace cpp_robotics { std :: ostream & operator << ( std :: ostream & os , const Vector2d & v ) { os << \"(\" << v . x << \", \" << v . y << \")\" ; return os ; } std :: ostream & operator << ( std :: ostream & os , const Vector3d & v ) { os << \"(\" << v . x << \", \" << v . y << \", \" << v . z << \")\" ; return os ; } std :: ostream & operator << ( std :: ostream & os , const Vector4d & v ) { os << \"(\" << v . x << \", \" << v . y << \", \" << v . z << \", \" << v . w << \")\" ; return os ; } std :: ostream & operator << ( std :: ostream & os , const Transformd & v ) { os << \"(\" << v . x << \", \" << v . y << \", \" << v . theta << \")\" ; return os ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/geometry/geometry_stream.hpp"},{"location":"doxybook/Files/geometry__stream_8hpp/#includecpp_roboticsgeometrygeometry_streamhpp","text":"","title":"include/cpp_robotics/geometry/geometry_stream.hpp"},{"location":"doxybook/Files/geometry__stream_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/geometry__stream_8hpp/#source-code","text":"#pragma once #include <iostream> #include \"../vector/vector2.hpp\" #include \"../vector/vector3.hpp\" #include \"../vector/vector4.hpp\" #include \"../vector/transform.hpp\" namespace cpp_robotics { std :: ostream & operator << ( std :: ostream & os , const Vector2d & v ) { os << \"(\" << v . x << \", \" << v . y << \")\" ; return os ; } std :: ostream & operator << ( std :: ostream & os , const Vector3d & v ) { os << \"(\" << v . x << \", \" << v . y << \", \" << v . z << \")\" ; return os ; } std :: ostream & operator << ( std :: ostream & os , const Vector4d & v ) { os << \"(\" << v . x << \", \" << v . y << \", \" << v . z << \", \" << v . w << \")\" ; return os ; } std :: ostream & operator << ( std :: ostream & os , const Transformd & v ) { os << \"(\" << v . x << \", \" << v . y << \", \" << v . theta << \")\" ; return os ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/golden__serach_8hpp/","text":"include/cpp_robotics/optimize/golden_serach.hpp Namespaces Name cpp_robotics Source code #pragma once #include <functional> #include <cmath> namespace cpp_robotics { static double golden_search ( std :: function < double ( double ) > f , double low , double high , const double tol = 1e-6 , const size_t max_iter = 100 ) { constexpr double r = ( -1.0 + std :: sqrt ( 5 )) / 2.0 ; double a1 = low + ( 1.0 - r ) * ( high - low ); double a2 = low + ( r ) * ( high - low ); double f1 = f ( a1 ); double f2 = f ( a2 ); for ( size_t i = 0 ; i < max_iter ; i ++ ) { if ( std :: abs ( high - low ) < tol ) return 0.5 * ( low + high ); if ( f1 < f2 ) { high = a2 ; a2 = a1 ; a1 = low + ( 1.0 - r ) * ( high - low ); f2 = f1 ; f1 = f ( a1 ); } else { low = a1 ; a1 = a2 ; a2 = low + ( r ) * ( high - low ); f1 = f2 ; f2 = f ( a2 ); } } return 0.5 * ( low + high ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/golden_serach.hpp"},{"location":"doxybook/Files/golden__serach_8hpp/#includecpp_roboticsoptimizegolden_serachhpp","text":"","title":"include/cpp_robotics/optimize/golden_serach.hpp"},{"location":"doxybook/Files/golden__serach_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/golden__serach_8hpp/#source-code","text":"#pragma once #include <functional> #include <cmath> namespace cpp_robotics { static double golden_search ( std :: function < double ( double ) > f , double low , double high , const double tol = 1e-6 , const size_t max_iter = 100 ) { constexpr double r = ( -1.0 + std :: sqrt ( 5 )) / 2.0 ; double a1 = low + ( 1.0 - r ) * ( high - low ); double a2 = low + ( r ) * ( high - low ); double f1 = f ( a1 ); double f2 = f ( a2 ); for ( size_t i = 0 ; i < max_iter ; i ++ ) { if ( std :: abs ( high - low ) < tol ) return 0.5 * ( low + high ); if ( f1 < f2 ) { high = a2 ; a2 = a1 ; a1 = low + ( 1.0 - r ) * ( high - low ); f2 = f1 ; f1 = f ( a1 ); } else { low = a1 ; a1 = a2 ; a2 = low + ( r ) * ( high - low ); f1 = f2 ; f2 = f ( a2 ); } } return 0.5 * ( low + high ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/","text":"include/cpp_robotics/path_planning/grid_path_planning_utils.hpp Namespaces Name cpp_robotics cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 Classes Name struct cpp_robotics::grid_path_planning_utils::GridNode Source code #pragma once #include <vector> #include <list> #include <Eigen/Dense> namespace cpp_robotics :: grid_path_planning_utils { struct GridNode { bool operator == ( const GridNode & o ) { return pos == o . pos ; } bool operator == ( const Eigen :: Vector2i & o ) { return pos == o ; } bool operator < ( const GridNode & o ) { return hcost + cost < o . hcost + o . cost ; } Eigen :: Vector2i pos , parent ; int cost , hcost ; int score () { return cost + hcost ; } }; static bool contain_in_map ( const Eigen :: MatrixXi & map , const Eigen :: Vector2i & p ) { if ( 0 <= p ( 0 ) && p ( 0 ) < map . rows () && 0 <= p ( 1 ) && p ( 1 ) < map . cols ()) return true ; return false ; } static int dist ( const Eigen :: Vector2i & pos , const Eigen :: Vector2i & end ) { const Eigen :: Vector2i d = end - pos ; return std :: min ( std :: abs ( d ( 0 )) , std :: abs ( d ( 0 ))); // 8\u65b9\u5411\u79fb\u52d5\u3092\u60f3\u5b9a https://qiita.com/2dgames_jp/items/f29e915357c1decbc4b7#%E6%8E%A2%E7%B4%A2%E3%82%92%E9%96%8B%E5%A7%8B } template < typename T > bool in_range_open ( T x , T min , T max ) { return (( min < x && x < max ) ? true : false ); } bool is_valid ( const Eigen :: Vector2i & pos , size_t row , size_t col ) { if ( in_range_open < int > ( pos ( 0 ), -1 , row ) && in_range_open < int > ( pos ( 1 ), -1 , col )) return true ; return false ; } bool is_wall ( const Eigen :: Vector2i & pos , size_t row , size_t col ) { if ( in_range_open < int > ( pos ( 0 ), -1 , row ) && in_range_open < int > ( pos ( 1 ), -1 , col )) return true ; return false ; } bool is_correct_step ( const Eigen :: Vector2i & pos , const Eigen :: MatrixXi & map ) { if ( is_valid ( pos , map . rows (), map . cols ())) { if ( not map ( pos ( 0 ), pos ( 1 ))) return true ; } return false ; } bool exist ( std :: list < GridNode > & open , std :: list < GridNode > & closed , const Eigen :: Vector2i & p , int cost ) { std :: list < GridNode >:: iterator i ; i = std :: find ( closed . begin (), closed . end (), p ); if ( i != closed . end () ) { // \u65e2\u306bclosed\u5185\u306b\u5b58\u5728\u3059\u308b if ( ( * i ). cost + ( * i ). hcost < cost ) return true ; // \u5b58\u5728\u3059\u308b\u306e\u3067true\u3092\u8fd4\u3059 else { closed . erase ( i ); return false ; } // \u5b58\u5728\u3059\u308b\u304c\u65b0\u3057\u304f\u898b\u3064\u304b\u3063\u305f\u307b\u3046\u304c\u30b3\u30b9\u30c8\u304c\u5c0f\u3055\u3044\u306e\u3067\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u306b\u6d88\u3057\u3066\u3001false\u3092\u8fd4\u3059 } i = std :: find ( open . begin (), open . end (), p ); if ( i != open . end () ) { // open\u5185\u306b\u5b58\u5728\u3059\u308b if ( ( * i ). cost + ( * i ). hcost < cost ) return true ; // \u4e0a\u306b\u540c\u3058 else { open . erase ( i ); return false ; } } return false ; // \u5b58\u5728\u3057\u306a\u3044 } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning/grid_path_planning_utils.hpp"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#includecpp_roboticspath_planninggrid_path_planning_utilshpp","text":"","title":"include/cpp_robotics/path_planning/grid_path_planning_utils.hpp"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#namespaces","text":"Name cpp_robotics cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1","title":"Namespaces"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#classes","text":"Name struct cpp_robotics::grid_path_planning_utils::GridNode","title":"Classes"},{"location":"doxybook/Files/grid__path__planning__utils_8hpp/#source-code","text":"#pragma once #include <vector> #include <list> #include <Eigen/Dense> namespace cpp_robotics :: grid_path_planning_utils { struct GridNode { bool operator == ( const GridNode & o ) { return pos == o . pos ; } bool operator == ( const Eigen :: Vector2i & o ) { return pos == o ; } bool operator < ( const GridNode & o ) { return hcost + cost < o . hcost + o . cost ; } Eigen :: Vector2i pos , parent ; int cost , hcost ; int score () { return cost + hcost ; } }; static bool contain_in_map ( const Eigen :: MatrixXi & map , const Eigen :: Vector2i & p ) { if ( 0 <= p ( 0 ) && p ( 0 ) < map . rows () && 0 <= p ( 1 ) && p ( 1 ) < map . cols ()) return true ; return false ; } static int dist ( const Eigen :: Vector2i & pos , const Eigen :: Vector2i & end ) { const Eigen :: Vector2i d = end - pos ; return std :: min ( std :: abs ( d ( 0 )) , std :: abs ( d ( 0 ))); // 8\u65b9\u5411\u79fb\u52d5\u3092\u60f3\u5b9a https://qiita.com/2dgames_jp/items/f29e915357c1decbc4b7#%E6%8E%A2%E7%B4%A2%E3%82%92%E9%96%8B%E5%A7%8B } template < typename T > bool in_range_open ( T x , T min , T max ) { return (( min < x && x < max ) ? true : false ); } bool is_valid ( const Eigen :: Vector2i & pos , size_t row , size_t col ) { if ( in_range_open < int > ( pos ( 0 ), -1 , row ) && in_range_open < int > ( pos ( 1 ), -1 , col )) return true ; return false ; } bool is_wall ( const Eigen :: Vector2i & pos , size_t row , size_t col ) { if ( in_range_open < int > ( pos ( 0 ), -1 , row ) && in_range_open < int > ( pos ( 1 ), -1 , col )) return true ; return false ; } bool is_correct_step ( const Eigen :: Vector2i & pos , const Eigen :: MatrixXi & map ) { if ( is_valid ( pos , map . rows (), map . cols ())) { if ( not map ( pos ( 0 ), pos ( 1 ))) return true ; } return false ; } bool exist ( std :: list < GridNode > & open , std :: list < GridNode > & closed , const Eigen :: Vector2i & p , int cost ) { std :: list < GridNode >:: iterator i ; i = std :: find ( closed . begin (), closed . end (), p ); if ( i != closed . end () ) { // \u65e2\u306bclosed\u5185\u306b\u5b58\u5728\u3059\u308b if ( ( * i ). cost + ( * i ). hcost < cost ) return true ; // \u5b58\u5728\u3059\u308b\u306e\u3067true\u3092\u8fd4\u3059 else { closed . erase ( i ); return false ; } // \u5b58\u5728\u3059\u308b\u304c\u65b0\u3057\u304f\u898b\u3064\u304b\u3063\u305f\u307b\u3046\u304c\u30b3\u30b9\u30c8\u304c\u5c0f\u3055\u3044\u306e\u3067\u66f8\u304d\u63db\u3048\u308b\u305f\u3081\u306b\u6d88\u3057\u3066\u3001false\u3092\u8fd4\u3059 } i = std :: find ( open . begin (), open . end (), p ); if ( i != open . end () ) { // open\u5185\u306b\u5b58\u5728\u3059\u308b if ( ( * i ). cost + ( * i ). hcost < cost ) return true ; // \u4e0a\u306b\u540c\u3058 else { open . erase ( i ); return false ; } } return false ; // \u5b58\u5728\u3057\u306a\u3044 } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/high__pass__filter_8hpp/","text":"include/cpp_robotics/filter/high_pass_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf Source code #pragma once #include <cmath> namespace cpp_robotics { // G(s) = 1 / (Ts + 1) // \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e class HighPassFilter { public : HighPassFilter ( double w , double dt ) : w_ ( w ), T_ ( 1 / w ), dt_ ( dt ) { } void reset ( double val = 0 ) { y1_ = val ; u1_ = val ; } double filtering ( double u ) { double y = ( ( 2 * T_ - dt_ ) * y1_ + 2 * T_ * ( u - u1_ ) ) / ( 2 * T_ + dt_ ); y1_ = y ; u1_ = u ; return y ; } double w () const { return w_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double T_ ; const double dt_ ; double y1_ , u1_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/high_pass_filter.hpp"},{"location":"doxybook/Files/high__pass__filter_8hpp/#includecpp_roboticsfilterhigh_pass_filterhpp","text":"","title":"include/cpp_robotics/filter/high_pass_filter.hpp"},{"location":"doxybook/Files/high__pass__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/high__pass__filter_8hpp/#classes","text":"Name class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf","title":"Classes"},{"location":"doxybook/Files/high__pass__filter_8hpp/#source-code","text":"#pragma once #include <cmath> namespace cpp_robotics { // G(s) = 1 / (Ts + 1) // \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e class HighPassFilter { public : HighPassFilter ( double w , double dt ) : w_ ( w ), T_ ( 1 / w ), dt_ ( dt ) { } void reset ( double val = 0 ) { y1_ = val ; u1_ = val ; } double filtering ( double u ) { double y = ( ( 2 * T_ - dt_ ) * y1_ + 2 * T_ * ( u - u1_ ) ) / ( 2 * T_ + dt_ ); y1_ = y ; u1_ = u ; return y ; } double w () const { return w_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double T_ ; const double dt_ ; double y1_ , u1_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/icp_8hpp/","text":"include/cpp_robotics/algorithm/icp.hpp Namespaces Name cpp_robotics Source code // https://clientver2.hatenablog.com/entry/2015/11/27/160814 // http://nghiaho.com/?page_id=671 #pragma once #include <Eigen/Dense> #include \"./kdtree.hpp\" namespace cpp_robotics { // dest\u3092\u56de\u8ee2\u3055\u305b\u3066src\u306b\u91cd\u306d\u308b\u6642\u306e\u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u8a08\u7b97\u3059\u308b template < size_t DIM > static std :: pair < Eigen :: Matrix < double , DIM , DIM > , Eigen :: Matrix < double , DIM , 1 >> calcu_transformatoin ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed ) { assert ( fixed . size () == dest . size ()); using vector_type = Eigen :: Matrix < double , DIM , 1 > ; using matrix_type = Eigen :: Matrix < double , DIM , DIM > ; const size_t len = fixed . size (); // detrend vector_type mean_fixed = vector_type :: Zero (); vector_type mean_dest = vector_type :: Zero (); for ( auto & v : fixed ) mean_fixed += v / static_cast < double > ( len ); for ( auto & v : fixed ) v -= mean_fixed ; for ( auto & v : dest ) mean_dest += v / static_cast < double > ( len ); for ( auto & v : dest ) v -= mean_dest ; // std::cout << \"mean_fixed\" << std::endl; // std::cout << mean_fixed.transpose() << std::endl; // std::cout << \"mean_dest\" << std::endl; // std::cout << mean_dest.transpose() << std::endl; // for(size_t i = 0; i < len; i++) // { // std::cout << fixed[i].transpose() << std::endl; // } // for(size_t i = 0; i < len; i++) // { // std::cout << dest[i].transpose() << std::endl; // } // \u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u6c42\u3081\u308b Eigen :: Matrix < double , DIM , DIM > H = Eigen :: Matrix < double , DIM , DIM >:: Zero (); for ( size_t i = 0 ; i < len ; i ++ ) { H += dest [ i ] * fixed [ i ]. transpose (); } Eigen :: JacobiSVD svd ( H , Eigen :: ComputeFullU | Eigen :: ComputeFullV ); matrix_type R = svd . matrixV () * svd . matrixU (). transpose (); vector_type T = ( - R * mean_dest ) + mean_fixed ; return { R , T }; } // Todo: R, T\u3092\u8fd4\u3059\u3088\u3046\u306b\u3059\u308b // Todo: \u7d42\u4e86\u6761\u4ef6\u3064\u3051\u308b template < size_t DIM > static std :: tuple < std :: vector < Eigen :: Matrix < double , DIM , 1 >> , size_t > icp ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed , size_t max_iter = 100 ) { KDTree < Eigen :: Matrix < double , DIM , 1 > , DIM > kdtree ( fixed ); auto old_dest = dest ; size_t i = 0 ; for (; i < max_iter ; i ++ ) { auto nerghbor_idx = kdtree . nn_search ( dest ); decltype ( fixed ) target ( nerghbor_idx . size ()); for ( size_t j = 0 ; j < nerghbor_idx . size (); j ++ ) { target [ j ] = fixed [ nerghbor_idx [ j ]]; // std::cout << dest[j].transpose() << \", \" << target[j].transpose() << std::endl; // std::cout << j << \" -> \" << nerghbor_idx[j] << std::endl; } auto [ R , T ] = calcu_transformatoin < DIM > ( dest , target ); std :: cout << \"R = \" << std :: endl ; std :: cout << R << std :: endl << std :: endl ; std :: cout << \"T = \" << std :: endl ; std :: cout << T << std :: endl << std :: endl ; for ( size_t j = 0 ; j < dest . size (); j ++ ) { dest [ j ] = R * dest [ j ] + T ; } if ( 0 ) break ; old_dest = dest ; } return { dest , i }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/icp.hpp"},{"location":"doxybook/Files/icp_8hpp/#includecpp_roboticsalgorithmicphpp","text":"","title":"include/cpp_robotics/algorithm/icp.hpp"},{"location":"doxybook/Files/icp_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/icp_8hpp/#source-code","text":"// https://clientver2.hatenablog.com/entry/2015/11/27/160814 // http://nghiaho.com/?page_id=671 #pragma once #include <Eigen/Dense> #include \"./kdtree.hpp\" namespace cpp_robotics { // dest\u3092\u56de\u8ee2\u3055\u305b\u3066src\u306b\u91cd\u306d\u308b\u6642\u306e\u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u8a08\u7b97\u3059\u308b template < size_t DIM > static std :: pair < Eigen :: Matrix < double , DIM , DIM > , Eigen :: Matrix < double , DIM , 1 >> calcu_transformatoin ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed ) { assert ( fixed . size () == dest . size ()); using vector_type = Eigen :: Matrix < double , DIM , 1 > ; using matrix_type = Eigen :: Matrix < double , DIM , DIM > ; const size_t len = fixed . size (); // detrend vector_type mean_fixed = vector_type :: Zero (); vector_type mean_dest = vector_type :: Zero (); for ( auto & v : fixed ) mean_fixed += v / static_cast < double > ( len ); for ( auto & v : fixed ) v -= mean_fixed ; for ( auto & v : dest ) mean_dest += v / static_cast < double > ( len ); for ( auto & v : dest ) v -= mean_dest ; // std::cout << \"mean_fixed\" << std::endl; // std::cout << mean_fixed.transpose() << std::endl; // std::cout << \"mean_dest\" << std::endl; // std::cout << mean_dest.transpose() << std::endl; // for(size_t i = 0; i < len; i++) // { // std::cout << fixed[i].transpose() << std::endl; // } // for(size_t i = 0; i < len; i++) // { // std::cout << dest[i].transpose() << std::endl; // } // \u56de\u8ee2\u91cf\u3068\u79fb\u52d5\u91cf\u3092\u6c42\u3081\u308b Eigen :: Matrix < double , DIM , DIM > H = Eigen :: Matrix < double , DIM , DIM >:: Zero (); for ( size_t i = 0 ; i < len ; i ++ ) { H += dest [ i ] * fixed [ i ]. transpose (); } Eigen :: JacobiSVD svd ( H , Eigen :: ComputeFullU | Eigen :: ComputeFullV ); matrix_type R = svd . matrixV () * svd . matrixU (). transpose (); vector_type T = ( - R * mean_dest ) + mean_fixed ; return { R , T }; } // Todo: R, T\u3092\u8fd4\u3059\u3088\u3046\u306b\u3059\u308b // Todo: \u7d42\u4e86\u6761\u4ef6\u3064\u3051\u308b template < size_t DIM > static std :: tuple < std :: vector < Eigen :: Matrix < double , DIM , 1 >> , size_t > icp ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed , size_t max_iter = 100 ) { KDTree < Eigen :: Matrix < double , DIM , 1 > , DIM > kdtree ( fixed ); auto old_dest = dest ; size_t i = 0 ; for (; i < max_iter ; i ++ ) { auto nerghbor_idx = kdtree . nn_search ( dest ); decltype ( fixed ) target ( nerghbor_idx . size ()); for ( size_t j = 0 ; j < nerghbor_idx . size (); j ++ ) { target [ j ] = fixed [ nerghbor_idx [ j ]]; // std::cout << dest[j].transpose() << \", \" << target[j].transpose() << std::endl; // std::cout << j << \" -> \" << nerghbor_idx[j] << std::endl; } auto [ R , T ] = calcu_transformatoin < DIM > ( dest , target ); std :: cout << \"R = \" << std :: endl ; std :: cout << R << std :: endl << std :: endl ; std :: cout << \"T = \" << std :: endl ; std :: cout << T << std :: endl << std :: endl ; for ( size_t j = 0 ; j < dest . size (); j ++ ) { dest [ j ] = R * dest [ j ] + T ; } if ( 0 ) break ; old_dest = dest ; } return { dest , i }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/integrator_8hpp/","text":"include/cpp_robotics/filter/integrator.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::Integrator \u7a4d\u5206\u5668 Source code #pragma once #include <cmath> namespace cpp_robotics { // G(s) = 1 / s // \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e class Integrator { public : Integrator ( double Ts ) : Ts_ ( Ts ) { } void reset ( double val = 0 ) { val_ = val ; u1_ = val ; } double filtering ( double u ) { val_ += ( u1_ + u ) * Ts_ * 0.5 ; u1_ = u ; return val_ ; } private : double Ts_ ; double val_ , u1_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/integrator.hpp"},{"location":"doxybook/Files/integrator_8hpp/#includecpp_roboticsfilterintegratorhpp","text":"","title":"include/cpp_robotics/filter/integrator.hpp"},{"location":"doxybook/Files/integrator_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/integrator_8hpp/#classes","text":"Name class cpp_robotics::Integrator \u7a4d\u5206\u5668","title":"Classes"},{"location":"doxybook/Files/integrator_8hpp/#source-code","text":"#pragma once #include <cmath> namespace cpp_robotics { // G(s) = 1 / s // \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e class Integrator { public : Integrator ( double Ts ) : Ts_ ( Ts ) { } void reset ( double val = 0 ) { val_ = val ; u1_ = val ; } double filtering ( double u ) { val_ += ( u1_ + u ) * Ts_ * 0.5 ; u1_ = u ; return val_ ; } private : double Ts_ ; double val_ , u1_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/interior__point__method_8hpp/","text":"include/cpp_robotics/optimize/interior_point_method.hpp Source code // #pragma once // #include \"./derivative.hpp\" // #include \"./constraint.hpp\" // namespace cpp_robotics // { // // \u5185\u70b9\u6cd5 // class InteriorPointMethod // { // public: // InteriorPointMethod() = default; // struct Problem // { // std::function<double(const Eigen::VectorXd &)> f; // ConstraintArray constraint; // Eigen::VectorXd x_init; // const double rho_tol = 1e-3; // const size_t max_iter = 1000; // const double constraint_merit_gain = 0.1; // double slack_gain_init = 1.0; // }; // struct Result // { // bool is_solved; // Eigen::VectorXd x; // size_t iter_count; // }; // Result solve(Problem prob) // { // auto [f, constraint, x_init, rho_tol, max_iter, eta, rho] = prob; // size_t x_dim = x_init.rows(); // size_t eq_cnt = constraint.eq_constraint_size(); // size_t ineq_cnt = constraint.ineq_constraint_size(); // size_t con_cnt = constraint.size(); // auto eq_con_func = constraint.gen_eq_constraint_list(); // auto ineq_con_func = constraint.gen_ineq_constraint_list(); // auto x = x_init; // auto s = Eigen::VectorXd::Ones(ineq_cnt).eval(); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u305f\u3081\u306e\u30b9\u30e9\u30c3\u30af\u5909\u6570 // auto u = Eigen::VectorXd::Zero(con_cnt).eval(); // \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u5b9a\u6570 // // Todo: \u7b49\u5f0f\u5236\u7d04\u3068\u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u5206\u3051\u3066\u8003\u3048\u76f4\u3059 // // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570 // auto merit_func = [&](const Eigen::VectorXd &x, const Eigen::VectorXd &s, const Eigen::VectorXd &u) // { // double val = f(x); // for(size_t i = 0; i < ineq_cnt; i++) // { // val += -rho * std::log(s(i)); // } // for(size_t i = 0; i < ineq_cnt; i++) // { // val += -eta * std::abs( ineq_con_func[i].eval(x) + s(i) ); // } // for(size_t i = 0; i < eq_cnt; i++) // { // val += -eta * std::abs( eq_con_func[i].eval(x) ); // } // return val; // }; // size_t i = 0; // for(; i < max_iter; i++) // { // // \u7d42\u4e86\u6761\u4ef6\u30c1\u30a7\u30c3\u30af // if(std::abs(rho) < rho_tol) // break; // // Todo: \u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u7acb\u3066\u3066\u89e3\u304d\u3001\u305d\u308c\u305e\u308c\u306e\u66f4\u65b0\u65b9\u5411\u3092\u6c42\u3081\u308b // Eigen::MatrixXd A = Eigen::MatrixXd::Zero(4, x_dim + ineq_cnt + con_cnt); // Eigen::VectorXd b = Eigen::VectorXd::Zero(4, 1); // // A.block(0,0, x_dim, x_dim) = Eigen::MatrixXd::Zero(x_dim, x_dim); // // b(0) = 1; // // b(1) = 1; // // b(2) = 1; // // b(3) = 1; // auto dstate = A.partialPivLu().solve(b); // auto dx = dstate.segment(0, x_dim); // auto ds = dstate.segment(x_dim, ineq_cnt); // auto du = dstate.segment(x_dim+ineq_cnt, con_cnt); // // \u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b // // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306b\u5bfe\u3057\u3066\u63a2\u7d22\u65b9\u5411\u3092\u9069\u5fdc\u3057\u305f\u6642\u306b\u8a55\u4fa1\u5024\u304c\u6700\u5c0f\u306b\u306a\u308b\u3088\u3046\u306a\u30b9\u30c6\u30c3\u30d7\u3092\u6c42\u3081\u308b // double alpha = bracketing_serach([&](double v){ return merit_func(x+v*dx, s+v*ds, u+v*du); }); // // \u72b6\u614b\u91cf\u3092\u66f4\u65b0\u3059\u308b // x += alpha * dx; // s += alpha * ds; // u += alpha * du; // // Todo: rho\u3092\u66f4\u65b0\u3059\u308b // // rho = gamma * (1) / static_cast<double>(ineq_cnt); // } // } // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/interior_point_method.hpp"},{"location":"doxybook/Files/interior__point__method_8hpp/#includecpp_roboticsoptimizeinterior_point_methodhpp","text":"","title":"include/cpp_robotics/optimize/interior_point_method.hpp"},{"location":"doxybook/Files/interior__point__method_8hpp/#source-code","text":"// #pragma once // #include \"./derivative.hpp\" // #include \"./constraint.hpp\" // namespace cpp_robotics // { // // \u5185\u70b9\u6cd5 // class InteriorPointMethod // { // public: // InteriorPointMethod() = default; // struct Problem // { // std::function<double(const Eigen::VectorXd &)> f; // ConstraintArray constraint; // Eigen::VectorXd x_init; // const double rho_tol = 1e-3; // const size_t max_iter = 1000; // const double constraint_merit_gain = 0.1; // double slack_gain_init = 1.0; // }; // struct Result // { // bool is_solved; // Eigen::VectorXd x; // size_t iter_count; // }; // Result solve(Problem prob) // { // auto [f, constraint, x_init, rho_tol, max_iter, eta, rho] = prob; // size_t x_dim = x_init.rows(); // size_t eq_cnt = constraint.eq_constraint_size(); // size_t ineq_cnt = constraint.ineq_constraint_size(); // size_t con_cnt = constraint.size(); // auto eq_con_func = constraint.gen_eq_constraint_list(); // auto ineq_con_func = constraint.gen_ineq_constraint_list(); // auto x = x_init; // auto s = Eigen::VectorXd::Ones(ineq_cnt).eval(); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u305f\u3081\u306e\u30b9\u30e9\u30c3\u30af\u5909\u6570 // auto u = Eigen::VectorXd::Zero(con_cnt).eval(); // \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u5b9a\u6570 // // Todo: \u7b49\u5f0f\u5236\u7d04\u3068\u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u5206\u3051\u3066\u8003\u3048\u76f4\u3059 // // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570 // auto merit_func = [&](const Eigen::VectorXd &x, const Eigen::VectorXd &s, const Eigen::VectorXd &u) // { // double val = f(x); // for(size_t i = 0; i < ineq_cnt; i++) // { // val += -rho * std::log(s(i)); // } // for(size_t i = 0; i < ineq_cnt; i++) // { // val += -eta * std::abs( ineq_con_func[i].eval(x) + s(i) ); // } // for(size_t i = 0; i < eq_cnt; i++) // { // val += -eta * std::abs( eq_con_func[i].eval(x) ); // } // return val; // }; // size_t i = 0; // for(; i < max_iter; i++) // { // // \u7d42\u4e86\u6761\u4ef6\u30c1\u30a7\u30c3\u30af // if(std::abs(rho) < rho_tol) // break; // // Todo: \u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u7acb\u3066\u3066\u89e3\u304d\u3001\u305d\u308c\u305e\u308c\u306e\u66f4\u65b0\u65b9\u5411\u3092\u6c42\u3081\u308b // Eigen::MatrixXd A = Eigen::MatrixXd::Zero(4, x_dim + ineq_cnt + con_cnt); // Eigen::VectorXd b = Eigen::VectorXd::Zero(4, 1); // // A.block(0,0, x_dim, x_dim) = Eigen::MatrixXd::Zero(x_dim, x_dim); // // b(0) = 1; // // b(1) = 1; // // b(2) = 1; // // b(3) = 1; // auto dstate = A.partialPivLu().solve(b); // auto dx = dstate.segment(0, x_dim); // auto ds = dstate.segment(x_dim, ineq_cnt); // auto du = dstate.segment(x_dim+ineq_cnt, con_cnt); // // \u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b // // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306b\u5bfe\u3057\u3066\u63a2\u7d22\u65b9\u5411\u3092\u9069\u5fdc\u3057\u305f\u6642\u306b\u8a55\u4fa1\u5024\u304c\u6700\u5c0f\u306b\u306a\u308b\u3088\u3046\u306a\u30b9\u30c6\u30c3\u30d7\u3092\u6c42\u3081\u308b // double alpha = bracketing_serach([&](double v){ return merit_func(x+v*dx, s+v*ds, u+v*du); }); // // \u72b6\u614b\u91cf\u3092\u66f4\u65b0\u3059\u308b // x += alpha * dx; // s += alpha * ds; // u += alpha * du; // // Todo: rho\u3092\u66f4\u65b0\u3059\u308b // // rho = gamma * (1) / static_cast<double>(ineq_cnt); // } // } // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/k__means__method_8hpp/","text":"include/cpp_robotics/algorithm/k_means_method.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::KMeansMethod K-means\u6cd5 Source code #pragma once #include <cpp_robotics/algorithm/kdtree.hpp> #include <numeric> #include <algorithm> namespace cpp_robotics { template < class PointType > class KMeansMethod { public : using point_t = PointType ; KMeansMethod () = default ; std :: vector < size_t > fit ( std :: vector < point_t > & data_set , size_t cluster_size , size_t max_iter = 1000 ) { cluster_size_ = cluster_size ; point_t zero_point = get_zero_point ( data_set [ 0 ]); label_ . resize ( data_set . size ()); std :: vector < size_t > prev_label ( data_set . size (), 0 ); // \u30e9\u30d9\u30eb\u306e\u521d\u671f\u5024\u751f\u6210 for ( size_t cnt = 0 ; auto & label : label_ ) { label = cnt ++ ; cnt %= cluster_size_ ; } cluster_center_ . resize ( cluster_size_ ); for ( size_t i = 0 ; i < max_iter ; i ++ ) { // \u30af\u30e9\u30b9\u30bf\u306e\u91cd\u5fc3\u3092\u8a08\u7b97 std :: vector < std :: vector < point_t >> dist_ ( cluster_size_ ); for ( auto & dist_item : dist_ ) { dist_item . reserve ( data_set . size () / cluster_size_ ); } for ( size_t p_idx = 0 ; p_idx < data_set . size (); p_idx ++ ) { dist_ [ label_ [ p_idx ]]. push_back ( data_set [ p_idx ]); } for ( size_t c_idx = 0 ; c_idx < cluster_size_ ; c_idx ++ ) { cluster_center_ [ c_idx ] = std :: accumulate ( dist_ [ c_idx ]. begin (), dist_ [ c_idx ]. end (), zero_point ) / ( double ) dist_ [ c_idx ]. size (); } // \u7dcf\u5f53\u308a\u3067\u30e9\u30d9\u30eb\u3092\u5404\u30af\u30e9\u30b9\u30bf\u91cd\u5fc3\u306b\u8fd1\u3044\u3082\u306e\u306b\u5909\u66f4\u3059\u308b for ( size_t p_idx = 0 ; p_idx < data_set . size (); p_idx ++ ) { label_ [ p_idx ] = predict ( data_set [ p_idx ]); } // \u30e9\u30d9\u30eb\u304c\u5909\u5316\u3057\u306a\u304b\u3063\u305f\u3089\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3092\u7d42\u4e86 if ( prev_label == label_ ) break ; } return label_ ; } size_t predict ( const point_t & x ) { auto min_itr = std :: min_element ( cluster_center_ . begin (), cluster_center_ . end (), [ & ]( auto & a , auto & b ){ return ( a - x ). norm () < ( b - x ). norm (); }); return std :: distance ( cluster_center_ . begin (), min_itr ); } private : point_t get_zero_point ( const point_t & tmp ) { ( void ) tmp ; return point_t (); } private : std :: vector < size_t > label_ ; std :: vector < point_t > cluster_center_ ; size_t cluster_size_ ; }; // \u52d5\u7684\u306aEigen\u306e\u30d9\u30af\u30c8\u30eb\u306f\u521d\u671f\u5316\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5b9f\u614b\u3092\u6301\u305f\u306a\u3044\u306e\u3067\u7279\u6b8a\u5316 template <> Eigen :: VectorXd KMeansMethod < Eigen :: VectorXd >:: get_zero_point ( const Eigen :: VectorXd & tmp ) { return Eigen :: VectorXd :: Zero ( tmp . size ()); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/k_means_method.hpp"},{"location":"doxybook/Files/k__means__method_8hpp/#includecpp_roboticsalgorithmk_means_methodhpp","text":"","title":"include/cpp_robotics/algorithm/k_means_method.hpp"},{"location":"doxybook/Files/k__means__method_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/k__means__method_8hpp/#classes","text":"Name class cpp_robotics::KMeansMethod K-means\u6cd5","title":"Classes"},{"location":"doxybook/Files/k__means__method_8hpp/#source-code","text":"#pragma once #include <cpp_robotics/algorithm/kdtree.hpp> #include <numeric> #include <algorithm> namespace cpp_robotics { template < class PointType > class KMeansMethod { public : using point_t = PointType ; KMeansMethod () = default ; std :: vector < size_t > fit ( std :: vector < point_t > & data_set , size_t cluster_size , size_t max_iter = 1000 ) { cluster_size_ = cluster_size ; point_t zero_point = get_zero_point ( data_set [ 0 ]); label_ . resize ( data_set . size ()); std :: vector < size_t > prev_label ( data_set . size (), 0 ); // \u30e9\u30d9\u30eb\u306e\u521d\u671f\u5024\u751f\u6210 for ( size_t cnt = 0 ; auto & label : label_ ) { label = cnt ++ ; cnt %= cluster_size_ ; } cluster_center_ . resize ( cluster_size_ ); for ( size_t i = 0 ; i < max_iter ; i ++ ) { // \u30af\u30e9\u30b9\u30bf\u306e\u91cd\u5fc3\u3092\u8a08\u7b97 std :: vector < std :: vector < point_t >> dist_ ( cluster_size_ ); for ( auto & dist_item : dist_ ) { dist_item . reserve ( data_set . size () / cluster_size_ ); } for ( size_t p_idx = 0 ; p_idx < data_set . size (); p_idx ++ ) { dist_ [ label_ [ p_idx ]]. push_back ( data_set [ p_idx ]); } for ( size_t c_idx = 0 ; c_idx < cluster_size_ ; c_idx ++ ) { cluster_center_ [ c_idx ] = std :: accumulate ( dist_ [ c_idx ]. begin (), dist_ [ c_idx ]. end (), zero_point ) / ( double ) dist_ [ c_idx ]. size (); } // \u7dcf\u5f53\u308a\u3067\u30e9\u30d9\u30eb\u3092\u5404\u30af\u30e9\u30b9\u30bf\u91cd\u5fc3\u306b\u8fd1\u3044\u3082\u306e\u306b\u5909\u66f4\u3059\u308b for ( size_t p_idx = 0 ; p_idx < data_set . size (); p_idx ++ ) { label_ [ p_idx ] = predict ( data_set [ p_idx ]); } // \u30e9\u30d9\u30eb\u304c\u5909\u5316\u3057\u306a\u304b\u3063\u305f\u3089\u30af\u30e9\u30b9\u30bf\u30ea\u30f3\u30b0\u3092\u7d42\u4e86 if ( prev_label == label_ ) break ; } return label_ ; } size_t predict ( const point_t & x ) { auto min_itr = std :: min_element ( cluster_center_ . begin (), cluster_center_ . end (), [ & ]( auto & a , auto & b ){ return ( a - x ). norm () < ( b - x ). norm (); }); return std :: distance ( cluster_center_ . begin (), min_itr ); } private : point_t get_zero_point ( const point_t & tmp ) { ( void ) tmp ; return point_t (); } private : std :: vector < size_t > label_ ; std :: vector < point_t > cluster_center_ ; size_t cluster_size_ ; }; // \u52d5\u7684\u306aEigen\u306e\u30d9\u30af\u30c8\u30eb\u306f\u521d\u671f\u5316\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5b9f\u614b\u3092\u6301\u305f\u306a\u3044\u306e\u3067\u7279\u6b8a\u5316 template <> Eigen :: VectorXd KMeansMethod < Eigen :: VectorXd >:: get_zero_point ( const Eigen :: VectorXd & tmp ) { return Eigen :: VectorXd :: Zero ( tmp . size ()); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/kalman__filter_8hpp/","text":"include/cpp_robotics/filter/kalman_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf Source code #pragma once #include <Eigen/Dense> namespace cpp_robotics { /* [\u30e2\u30c7\u30eb] x(t) = F*x(t-1) + G*u(t) + w(t) z(t) = H*x(t) + v(t) x: \u72b6\u614b\u91cf (n*1) u: \u5236\u5fa1\u91cf (r*1) z: \u89b3\u6e2c\u91cf (p*1) F: \u72b6\u614b\u9077\u79fb\u884c\u5217 (n*n) G: \u5236\u5fa1\u884c\u5217 (n*r) H: \u89b3\u6e2c\u884c\u5217 (p*n) Q: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (n*n) w: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba (n*1) N[0, Q]\u306b\u5f93\u3046 R: \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (p*p) v: \u89b3\u6e2c\u30ce\u30a4\u30ba (p*1) N[0, R]\u306b\u5f93\u3046 [\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf] - \u4e88\u6e2c \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a x = Fx + Gu \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q - \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0 \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3 K = PH^T(HPH^T + R)^-1 \u72b6\u614b\u63a8\u5b9a x = x + K(z - Hx) \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I -KH)P */ template < typename FLOATING_TYPE , size_t STATE_SIZE , size_t INPUT_SIZE , size_t OBSERVE_SIZE > class KalmanFilter { public : using value_type = FLOATING_TYPE ; static constexpr size_t state_size = STATE_SIZE ; static constexpr size_t input_size = INPUT_SIZE ; static constexpr size_t observe_size = OBSERVE_SIZE ; using x_vec_t = Eigen :: Matrix < value_type , state_size , 1 > ; using u_vec_t = Eigen :: Matrix < value_type , input_size , 1 > ; using z_vec_t = Eigen :: Matrix < value_type , observe_size , 1 > ; using f_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; using g_mat_t = Eigen :: Matrix < value_type , state_size , input_size > ; using h_mat_t = Eigen :: Matrix < value_type , observe_size , state_size > ; using q_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; using r_mat_t = Eigen :: Matrix < value_type , observe_size , observe_size > ; using p_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; f_mat_t F ; g_mat_t G ; h_mat_t H ; q_mat_t Q ; r_mat_t R ; KalmanFilter () = default ; void reset ( x_vec_t x , p_mat_t P ) { x_ = x ; P_ = P ; } x_vec_t filtering ( u_vec_t u , z_vec_t z ) { // \u72b6\u614b\u4e88\u6e2c x = Fx + Bu x_ = F * x_ + G * u ; // \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q P_ = F * P_ * ( F . transpose ()) + Q ; // \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97 K = PH^T(HPH^T + R)^-1 auto K = P_ * H . transpose () * ( R + H * P_ * H . transpose ()). inverse (); // \u72b6\u614b\u66f4\u65b0 x = x + K(z - Hx) x_ += K * ( z - H * x_ ); // \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I - KH)P auto I = Eigen :: Matrix < value_type , state_size , state_size >:: Identity (); P_ = ( I - K * H ) * P_ ; return x_ ; } x_vec_t get_x () { return x_ ; } // \u63a8\u5b9a\u3057\u305f\u72b6\u614b p_mat_t get_P () { return P_ ; } // \u5171\u5206\u6563\u884c\u5217 private : // \u72b6\u614b\u91cf x_vec_t x_ ; // \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 p_mat_t P_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/kalman_filter.hpp"},{"location":"doxybook/Files/kalman__filter_8hpp/#includecpp_roboticsfilterkalman_filterhpp","text":"","title":"include/cpp_robotics/filter/kalman_filter.hpp"},{"location":"doxybook/Files/kalman__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/kalman__filter_8hpp/#classes","text":"Name class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf","title":"Classes"},{"location":"doxybook/Files/kalman__filter_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> namespace cpp_robotics { /* [\u30e2\u30c7\u30eb] x(t) = F*x(t-1) + G*u(t) + w(t) z(t) = H*x(t) + v(t) x: \u72b6\u614b\u91cf (n*1) u: \u5236\u5fa1\u91cf (r*1) z: \u89b3\u6e2c\u91cf (p*1) F: \u72b6\u614b\u9077\u79fb\u884c\u5217 (n*n) G: \u5236\u5fa1\u884c\u5217 (n*r) H: \u89b3\u6e2c\u884c\u5217 (p*n) Q: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (n*n) w: \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba (n*1) N[0, Q]\u306b\u5f93\u3046 R: \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 (p*p) v: \u89b3\u6e2c\u30ce\u30a4\u30ba (p*1) N[0, R]\u306b\u5f93\u3046 [\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf] - \u4e88\u6e2c \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a x = Fx + Gu \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q - \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0 \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3 K = PH^T(HPH^T + R)^-1 \u72b6\u614b\u63a8\u5b9a x = x + K(z - Hx) \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I -KH)P */ template < typename FLOATING_TYPE , size_t STATE_SIZE , size_t INPUT_SIZE , size_t OBSERVE_SIZE > class KalmanFilter { public : using value_type = FLOATING_TYPE ; static constexpr size_t state_size = STATE_SIZE ; static constexpr size_t input_size = INPUT_SIZE ; static constexpr size_t observe_size = OBSERVE_SIZE ; using x_vec_t = Eigen :: Matrix < value_type , state_size , 1 > ; using u_vec_t = Eigen :: Matrix < value_type , input_size , 1 > ; using z_vec_t = Eigen :: Matrix < value_type , observe_size , 1 > ; using f_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; using g_mat_t = Eigen :: Matrix < value_type , state_size , input_size > ; using h_mat_t = Eigen :: Matrix < value_type , observe_size , state_size > ; using q_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; using r_mat_t = Eigen :: Matrix < value_type , observe_size , observe_size > ; using p_mat_t = Eigen :: Matrix < value_type , state_size , state_size > ; f_mat_t F ; g_mat_t G ; h_mat_t H ; q_mat_t Q ; r_mat_t R ; KalmanFilter () = default ; void reset ( x_vec_t x , p_mat_t P ) { x_ = x ; P_ = P ; } x_vec_t filtering ( u_vec_t u , z_vec_t z ) { // \u72b6\u614b\u4e88\u6e2c x = Fx + Bu x_ = F * x_ + G * u ; // \u4e8b\u524d\u5171\u5206\u6563\u884c\u5217 P = FPF^T + Q P_ = F * P_ * ( F . transpose ()) + Q ; // \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u8a08\u7b97 K = PH^T(HPH^T + R)^-1 auto K = P_ * H . transpose () * ( R + H * P_ * H . transpose ()). inverse (); // \u72b6\u614b\u66f4\u65b0 x = x + K(z - Hx) x_ += K * ( z - H * x_ ); // \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 P = (I - KH)P auto I = Eigen :: Matrix < value_type , state_size , state_size >:: Identity (); P_ = ( I - K * H ) * P_ ; return x_ ; } x_vec_t get_x () { return x_ ; } // \u63a8\u5b9a\u3057\u305f\u72b6\u614b p_mat_t get_P () { return P_ ; } // \u5171\u5206\u6563\u884c\u5217 private : // \u72b6\u614b\u91cf x_vec_t x_ ; // \u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217 p_mat_t P_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/kdtree_8hpp/","text":"include/cpp_robotics/algorithm/kdtree.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::KDTree k-d\u6728 Source code #pragma once #include <vector> #include <numeric> #include <memory> #include <algorithm> #include <cmath> namespace cpp_robotics { template < class POINT_T , int DIM > class KDTree { public : using point_type = POINT_T ; static constexpr size_t dimention = DIM ; KDTree () = default ; KDTree ( std :: vector < point_type > point ) { build ( point ); } void clear () { root_ . reset (); } void build ( std :: vector < point_type > point ) { points_ = point ; pidx_ . resize ( points_ . size ()); std :: iota ( pidx_ . begin (), pidx_ . end (), 0 ); root_ = build_recursive ( pidx_ . begin (), pidx_ . end (), 0 ); } size_t nn_search ( const point_type & point ) const { size_t ret = 0 ; double min_dist = std :: numeric_limits < double >:: max (); nn_search_recursive ( root_ , point , ret , min_dist ); return ret ; } std :: vector < size_t > nn_search ( const std :: vector < point_type > & point ) const { std :: vector < size_t > ret ( point . size ()); for ( size_t i = 0 ; i < point . size (); i ++ ) { ret [ i ] = nn_search ( point [ i ]); } return ret ; } std :: vector < size_t > knn_search ( const point_type & point , size_t k ) const { std :: vector < std :: pair < size_t , double >> pair_ret ; pair_ret . reserve ( k + 1 ); knn_search_recursive ( root_ , point , k , pair_ret ); std :: vector < size_t > ret ( pair_ret . size ()); for ( size_t i = 0 ; i < pair_ret . size (); i ++ ) { ret [ i ] = pair_ret [ i ]. first ; } return ret ; } std :: vector < size_t > radius_search ( const point_type & point , double radius ) const { std :: vector < size_t > ret ; radius_search_recursive ( root_ , point , radius , ret ); return ret ; } std :: vector < point_type > get_points ( const std :: vector < size_t > & idx ) const { std :: vector < point_type > ret ( idx . size ()); for ( size_t i = 0 ; i < idx . size (); i ++ ) { ret [ i ] = points_ [ idx [ i ]]; } return ret ; } std :: vector < point_type > knn_search_points ( const point_type & point , size_t k ) const { auto idx = knn_search ( point , k ); return get_points ( idx ); } std :: vector < point_type > radius_search_points ( const point_type & point , double radius ) const { auto idx = radius_search ( point , radius ); return get_points ( idx ); } void debug_node () { debug_node_recursive ( root_ , 0 ); } private : struct Node { // \u5143\u306e\u70b9\u7fa4\u3067\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 int idx = -1 ; // \u5206\u5272\u8ef8\u65b9\u5411 int axis = -1 ; // \u5b50\u30ce\u30fc\u30c9 std :: unique_ptr < Node > child [ 2 ] = { nullptr , nullptr }; }; std :: unique_ptr < Node > build_recursive ( std :: vector < size_t >:: iterator start , std :: vector < size_t >:: iterator end , size_t depth ) { if ( start == end ) return nullptr ; const size_t axis = depth % dimention ; const size_t mid = ( std :: distance ( start , end ) -1 ) / 2 ; std :: nth_element ( start , start + mid , end , [ & ]( size_t a , size_t b ){ return points_ [ a ][ axis ] < points_ [ b ][ axis ]; }); std :: unique_ptr < Node > node_ = std :: make_unique < Node > (); node_ -> idx = * ( start + mid ); node_ -> axis = axis ; node_ -> child [ 0 ] = build_recursive ( start , start + mid , depth + 1 ); node_ -> child [ 1 ] = build_recursive ( start + mid + 1 , end , depth + 1 ); return node_ ; } void nn_search_recursive ( const std :: unique_ptr < Node > & node , const point_type & point , size_t & guess , double & min_dist ) const { if ( node == nullptr ) return ; auto p = points_ [ node -> idx ]; const double dist = distance ( point , p ); if ( dist < min_dist ) { min_dist = dist ; guess = node -> idx ; } const int axis = node -> axis ; const int dir = point [ axis ] < p [ axis ] ? 0 : 1 ; nn_search_recursive ( node -> child [ dir ], point , guess , min_dist ); if ( dist < min_dist ) nn_search_recursive ( node -> child [ dir ], point , guess , min_dist ); } void knn_search_recursive ( const std :: unique_ptr < Node > & node , const point_type & point , size_t k , std :: vector < std :: pair < size_t , double >> & result ) const { if ( node == nullptr ) return ; auto p = points_ [ node -> idx ]; const double dist = distance ( point , p ); auto val = std :: make_pair ( node -> idx , dist ); // dist\u3067\u6607\u9806\u30bd\u30fc\u30c8\u3057\u3066\u5e38\u306bk\u500b\u4ee5\u4e0b\u3092\u4fdd\u6301\u3059\u308b auto it = std :: find_if ( std :: begin ( result ), std :: end ( result ), [ & ]( const auto & elem ){ return val . second < elem . second ; }); result . insert ( it , val ); if ( result . size () > k ) result . resize ( k ); const int axis = node -> axis ; const int dir = point [ axis ] < p [ axis ] ? 0 : 1 ; knn_search_recursive ( node -> child [ dir ], point , k , result ); const double diff = fabs ( point [ axis ] - p [ axis ]); if ( result . size () < k || diff < result . back (). second ) knn_search_recursive ( node -> child [ ! dir ], point , k , result ); } void radius_search_recursive ( const std :: unique_ptr < Node > & node , const point_type & point , double radius , std :: vector < size_t > & result ) const { if ( node == nullptr ) return ; auto p = points_ [ node -> idx ]; double dist = distance ( p , point ); if ( dist < radius ) { result . push_back ( node -> idx ); } const int axis = node -> axis ; const int dir = point [ axis ] < p [ axis ] ? 0 : 1 ; radius_search_recursive ( node -> child [ dir ], point , radius , result ); const double diff = fabs ( point [ axis ] - p [ axis ]); if ( diff < radius ) radius_search_recursive ( node -> child [ ! dir ], point , radius , result ); } void debug_node_recursive ( const std :: unique_ptr < Node > & node , size_t depth ) { if ( node == nullptr ) return ; for ( size_t i = 0 ; i < depth ; i ++ ) printf ( \" \" ); printf ( \"%d \\n \" , node -> idx ); debug_node_recursive ( node -> child [ 0 ], depth + 1 ); debug_node_recursive ( node -> child [ 1 ], depth + 1 ); } double distance ( const point_type & a , const point_type & b ) const { double len_sq = 0 ; for ( size_t i = 0 ; i < dimention ; i ++ ) { len_sq += std :: pow ( a [ i ] - b [ i ], 2 ); } return std :: sqrt ( len_sq ); } std :: vector < point_type > points_ ; std :: vector < size_t > pidx_ ; std :: unique_ptr < Node > root_ = nullptr ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/kdtree.hpp"},{"location":"doxybook/Files/kdtree_8hpp/#includecpp_roboticsalgorithmkdtreehpp","text":"","title":"include/cpp_robotics/algorithm/kdtree.hpp"},{"location":"doxybook/Files/kdtree_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/kdtree_8hpp/#classes","text":"Name class cpp_robotics::KDTree k-d\u6728","title":"Classes"},{"location":"doxybook/Files/kdtree_8hpp/#source-code","text":"#pragma once #include <vector> #include <numeric> #include <memory> #include <algorithm> #include <cmath> namespace cpp_robotics { template < class POINT_T , int DIM > class KDTree { public : using point_type = POINT_T ; static constexpr size_t dimention = DIM ; KDTree () = default ; KDTree ( std :: vector < point_type > point ) { build ( point ); } void clear () { root_ . reset (); } void build ( std :: vector < point_type > point ) { points_ = point ; pidx_ . resize ( points_ . size ()); std :: iota ( pidx_ . begin (), pidx_ . end (), 0 ); root_ = build_recursive ( pidx_ . begin (), pidx_ . end (), 0 ); } size_t nn_search ( const point_type & point ) const { size_t ret = 0 ; double min_dist = std :: numeric_limits < double >:: max (); nn_search_recursive ( root_ , point , ret , min_dist ); return ret ; } std :: vector < size_t > nn_search ( const std :: vector < point_type > & point ) const { std :: vector < size_t > ret ( point . size ()); for ( size_t i = 0 ; i < point . size (); i ++ ) { ret [ i ] = nn_search ( point [ i ]); } return ret ; } std :: vector < size_t > knn_search ( const point_type & point , size_t k ) const { std :: vector < std :: pair < size_t , double >> pair_ret ; pair_ret . reserve ( k + 1 ); knn_search_recursive ( root_ , point , k , pair_ret ); std :: vector < size_t > ret ( pair_ret . size ()); for ( size_t i = 0 ; i < pair_ret . size (); i ++ ) { ret [ i ] = pair_ret [ i ]. first ; } return ret ; } std :: vector < size_t > radius_search ( const point_type & point , double radius ) const { std :: vector < size_t > ret ; radius_search_recursive ( root_ , point , radius , ret ); return ret ; } std :: vector < point_type > get_points ( const std :: vector < size_t > & idx ) const { std :: vector < point_type > ret ( idx . size ()); for ( size_t i = 0 ; i < idx . size (); i ++ ) { ret [ i ] = points_ [ idx [ i ]]; } return ret ; } std :: vector < point_type > knn_search_points ( const point_type & point , size_t k ) const { auto idx = knn_search ( point , k ); return get_points ( idx ); } std :: vector < point_type > radius_search_points ( const point_type & point , double radius ) const { auto idx = radius_search ( point , radius ); return get_points ( idx ); } void debug_node () { debug_node_recursive ( root_ , 0 ); } private : struct Node { // \u5143\u306e\u70b9\u7fa4\u3067\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9 int idx = -1 ; // \u5206\u5272\u8ef8\u65b9\u5411 int axis = -1 ; // \u5b50\u30ce\u30fc\u30c9 std :: unique_ptr < Node > child [ 2 ] = { nullptr , nullptr }; }; std :: unique_ptr < Node > build_recursive ( std :: vector < size_t >:: iterator start , std :: vector < size_t >:: iterator end , size_t depth ) { if ( start == end ) return nullptr ; const size_t axis = depth % dimention ; const size_t mid = ( std :: distance ( start , end ) -1 ) / 2 ; std :: nth_element ( start , start + mid , end , [ & ]( size_t a , size_t b ){ return points_ [ a ][ axis ] < points_ [ b ][ axis ]; }); std :: unique_ptr < Node > node_ = std :: make_unique < Node > (); node_ -> idx = * ( start + mid ); node_ -> axis = axis ; node_ -> child [ 0 ] = build_recursive ( start , start + mid , depth + 1 ); node_ -> child [ 1 ] = build_recursive ( start + mid + 1 , end , depth + 1 ); return node_ ; } void nn_search_recursive ( const std :: unique_ptr < Node > & node , const point_type & point , size_t & guess , double & min_dist ) const { if ( node == nullptr ) return ; auto p = points_ [ node -> idx ]; const double dist = distance ( point , p ); if ( dist < min_dist ) { min_dist = dist ; guess = node -> idx ; } const int axis = node -> axis ; const int dir = point [ axis ] < p [ axis ] ? 0 : 1 ; nn_search_recursive ( node -> child [ dir ], point , guess , min_dist ); if ( dist < min_dist ) nn_search_recursive ( node -> child [ dir ], point , guess , min_dist ); } void knn_search_recursive ( const std :: unique_ptr < Node > & node , const point_type & point , size_t k , std :: vector < std :: pair < size_t , double >> & result ) const { if ( node == nullptr ) return ; auto p = points_ [ node -> idx ]; const double dist = distance ( point , p ); auto val = std :: make_pair ( node -> idx , dist ); // dist\u3067\u6607\u9806\u30bd\u30fc\u30c8\u3057\u3066\u5e38\u306bk\u500b\u4ee5\u4e0b\u3092\u4fdd\u6301\u3059\u308b auto it = std :: find_if ( std :: begin ( result ), std :: end ( result ), [ & ]( const auto & elem ){ return val . second < elem . second ; }); result . insert ( it , val ); if ( result . size () > k ) result . resize ( k ); const int axis = node -> axis ; const int dir = point [ axis ] < p [ axis ] ? 0 : 1 ; knn_search_recursive ( node -> child [ dir ], point , k , result ); const double diff = fabs ( point [ axis ] - p [ axis ]); if ( result . size () < k || diff < result . back (). second ) knn_search_recursive ( node -> child [ ! dir ], point , k , result ); } void radius_search_recursive ( const std :: unique_ptr < Node > & node , const point_type & point , double radius , std :: vector < size_t > & result ) const { if ( node == nullptr ) return ; auto p = points_ [ node -> idx ]; double dist = distance ( p , point ); if ( dist < radius ) { result . push_back ( node -> idx ); } const int axis = node -> axis ; const int dir = point [ axis ] < p [ axis ] ? 0 : 1 ; radius_search_recursive ( node -> child [ dir ], point , radius , result ); const double diff = fabs ( point [ axis ] - p [ axis ]); if ( diff < radius ) radius_search_recursive ( node -> child [ ! dir ], point , radius , result ); } void debug_node_recursive ( const std :: unique_ptr < Node > & node , size_t depth ) { if ( node == nullptr ) return ; for ( size_t i = 0 ; i < depth ; i ++ ) printf ( \" \" ); printf ( \"%d \\n \" , node -> idx ); debug_node_recursive ( node -> child [ 0 ], depth + 1 ); debug_node_recursive ( node -> child [ 1 ], depth + 1 ); } double distance ( const point_type & a , const point_type & b ) const { double len_sq = 0 ; for ( size_t i = 0 ; i < dimention ; i ++ ) { len_sq += std :: pow ( a [ i ] - b [ i ], 2 ); } return std :: sqrt ( len_sq ); } std :: vector < point_type > points_ ; std :: vector < size_t > pidx_ ; std :: unique_ptr < Node > root_ = nullptr ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/linprog_8hpp/","text":"include/cpp_robotics/optimize/linprog.hpp Source code // #pragma once // #include <tuple> // #include <functional> // #include <Eigen/Dense> // namespace cpp_robotics // { // // \u7dda\u5f62\u8a08\u753b\u6cd5 // // min f^T x // // sub A x < b // // (Aeq x = beq) // // (l <= x <= u) // class LinProgSolver // { // Eigen::MatrixXd f; // Eigen::MatrixXd A; // Eigen::VectorXd b; // std::tuple<bool, Eigen::VectorXd, size_t> solve(Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000) // { // } // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/linprog.hpp"},{"location":"doxybook/Files/linprog_8hpp/#includecpp_roboticsoptimizelinproghpp","text":"","title":"include/cpp_robotics/optimize/linprog.hpp"},{"location":"doxybook/Files/linprog_8hpp/#source-code","text":"// #pragma once // #include <tuple> // #include <functional> // #include <Eigen/Dense> // namespace cpp_robotics // { // // \u7dda\u5f62\u8a08\u753b\u6cd5 // // min f^T x // // sub A x < b // // (Aeq x = beq) // // (l <= x <= u) // class LinProgSolver // { // Eigen::MatrixXd f; // Eigen::MatrixXd A; // Eigen::VectorXd b; // std::tuple<bool, Eigen::VectorXd, size_t> solve(Eigen::VectorXd x_init, const double tol = 1e-6, const size_t max_iter = 1000) // { // } // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/low__pass__filter_8hpp/","text":"include/cpp_robotics/filter/low_pass_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc Source code #pragma once #include <cmath> namespace cpp_robotics { // G(s) = Ts / (Ts + 1) // \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e class LowPassFilter { public : LowPassFilter ( double w , double dt ) : w_ ( w ), T_ ( 1 / w ), dt_ ( dt ) { } void reset ( double val = 0 ) { y1_ = val ; u1_ = val ; } double filtering ( double u ) { double y = ( ( 2 * T_ - dt_ ) * y1_ + dt_ * ( u + u1_ ) ) / ( 2 * T_ + dt_ ); y1_ = y ; u1_ = u ; return y ; } double w () const { return w_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double T_ ; const double dt_ ; double y1_ , u1_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/low_pass_filter.hpp"},{"location":"doxybook/Files/low__pass__filter_8hpp/#includecpp_roboticsfilterlow_pass_filterhpp","text":"","title":"include/cpp_robotics/filter/low_pass_filter.hpp"},{"location":"doxybook/Files/low__pass__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/low__pass__filter_8hpp/#classes","text":"Name class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc","title":"Classes"},{"location":"doxybook/Files/low__pass__filter_8hpp/#source-code","text":"#pragma once #include <cmath> namespace cpp_robotics { // G(s) = Ts / (Ts + 1) // \u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3057\u305f\u3082\u306e class LowPassFilter { public : LowPassFilter ( double w , double dt ) : w_ ( w ), T_ ( 1 / w ), dt_ ( dt ) { } void reset ( double val = 0 ) { y1_ = val ; u1_ = val ; } double filtering ( double u ) { double y = ( ( 2 * T_ - dt_ ) * y1_ + dt_ * ( u + u1_ ) ) / ( 2 * T_ + dt_ ); y1_ = y ; u1_ = u ; return y ; } double w () const { return w_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double T_ ; const double dt_ ; double y1_ , u1_ = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/lqr_8hpp/","text":"include/cpp_robotics/controller/lqr.hpp Namespaces Name cpp_robotics Source code #pragma once #include <Eigen/Dense> #include <optional> namespace cpp_robotics { static std :: optional < Eigen :: MatrixXd > solve_riccati_arimoto_potter ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R ) { const uint dim_x = A . rows (); const uint dim_u = B . cols (); Eigen :: MatrixXd Ham = Eigen :: MatrixXd :: Zero ( 2 * dim_x , 2 * dim_x ); Ham << A , - B * R . inverse () * B . transpose (), - Q , - A . transpose (); Eigen :: EigenSolver < Eigen :: MatrixXd > Eigs ( Ham ); Eigen :: MatrixXcd eigvec = Eigen :: MatrixXcd :: Zero ( 2 * dim_x , dim_x ); int j = 0 ; for ( size_t i = 0 ; i < 2 * dim_x ; ++ i ) { if ( Eigs . eigenvalues ()[ i ]. real () < 0.0 ) { eigvec . col ( j ) = Eigs . eigenvectors (). block ( 0 , i , 2 * dim_x , 1 ); j ++ ; } } Eigen :: MatrixXcd Vs_1 , Vs_2 ; Vs_1 = eigvec . block ( 0 , 0 , dim_x , dim_x ); Vs_2 = eigvec . block ( dim_x , 0 , dim_x , dim_x ); return ( Vs_2 * Vs_1 . inverse ()). real (); } // \u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306e\u884c\u5217\u3068\u30d9\u30af\u30c8\u30eb\u3068\u91cd\u307f\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b static Eigen :: MatrixXd lqr ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R ) { auto P = solve_riccati_arimoto_potter ( A , B , Q , R ); return R . inverse () * B . transpose () * P . value (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/lqr.hpp"},{"location":"doxybook/Files/lqr_8hpp/#includecpp_roboticscontrollerlqrhpp","text":"","title":"include/cpp_robotics/controller/lqr.hpp"},{"location":"doxybook/Files/lqr_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/lqr_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> #include <optional> namespace cpp_robotics { static std :: optional < Eigen :: MatrixXd > solve_riccati_arimoto_potter ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R ) { const uint dim_x = A . rows (); const uint dim_u = B . cols (); Eigen :: MatrixXd Ham = Eigen :: MatrixXd :: Zero ( 2 * dim_x , 2 * dim_x ); Ham << A , - B * R . inverse () * B . transpose (), - Q , - A . transpose (); Eigen :: EigenSolver < Eigen :: MatrixXd > Eigs ( Ham ); Eigen :: MatrixXcd eigvec = Eigen :: MatrixXcd :: Zero ( 2 * dim_x , dim_x ); int j = 0 ; for ( size_t i = 0 ; i < 2 * dim_x ; ++ i ) { if ( Eigs . eigenvalues ()[ i ]. real () < 0.0 ) { eigvec . col ( j ) = Eigs . eigenvectors (). block ( 0 , i , 2 * dim_x , 1 ); j ++ ; } } Eigen :: MatrixXcd Vs_1 , Vs_2 ; Vs_1 = eigvec . block ( 0 , 0 , dim_x , dim_x ); Vs_2 = eigvec . block ( dim_x , 0 , dim_x , dim_x ); return ( Vs_2 * Vs_1 . inverse ()). real (); } // \u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306e\u884c\u5217\u3068\u30d9\u30af\u30c8\u30eb\u3068\u91cd\u307f\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b static Eigen :: MatrixXd lqr ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R ) { auto P = solve_riccati_arimoto_potter ( A , B , Q , R ); return R . inverse () * B . transpose () * P . value (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/mahalanobis_8hpp/","text":"include/cpp_robotics/algorithm/mahalanobis.hpp Namespaces Name cpp_robotics Source code #pragma once #include <cmath> #include <Eigen/Dense> namespace cpp_robotics { double mahalanobis ( const Eigen :: VectorXd & a , const Eigen :: VectorXd & b , const Eigen :: MatrixXd cov_inv ) { auto diff = a - b ; return std :: sqrt ( diff . dot ( cov_inv * diff ) ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/mahalanobis.hpp"},{"location":"doxybook/Files/mahalanobis_8hpp/#includecpp_roboticsalgorithmmahalanobishpp","text":"","title":"include/cpp_robotics/algorithm/mahalanobis.hpp"},{"location":"doxybook/Files/mahalanobis_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/mahalanobis_8hpp/#source-code","text":"#pragma once #include <cmath> #include <Eigen/Dense> namespace cpp_robotics { double mahalanobis ( const Eigen :: VectorXd & a , const Eigen :: VectorXd & b , const Eigen :: MatrixXd cov_inv ) { auto diff = a - b ; return std :: sqrt ( diff . dot ( cov_inv * diff ) ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/math__utils_8hpp/","text":"include/cpp_robotics/utility/math_utils.hpp Namespaces Name cpp_robotics cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 Defines Name M_PI Macros Documentation define M_PI #define M_PI 3.141592653589793238462643383279 Source code #pragma once #include <cmath> #include <cassert> #ifndef M_PI #define M_PI 3.141592653589793238462643383279 #endif namespace cpp_robotics { inline namespace constants { constexpr float PI = 3.1415926535897932384626433832795 ; constexpr float HALF_PI = PI / 2.0 ; constexpr float TWO_PI = PI * 2.0 ; constexpr float DEG_TO_RAD = PI / 180.0 ; constexpr float RAD_TO_DEG = 180.0 / PI ; constexpr float EULER = 2.718281828459045235360287471352 ; constexpr float GRAVITY = 9.807 ; constexpr float Nm2gfm = ( 1 / GRAVITY ); constexpr float gfm2Nm = GRAVITY ; constexpr float mNm2gfcm = ( Nm2gfm * 100 ); constexpr float gfcm2mNm = ( gfm2Nm / 100 ); } template < typename T > static constexpr bool in_range_open ( T x , T min , T max ) { return (( min < x && x < max ) ? true : false ); } template < typename T > static constexpr bool in_range ( T x , T min , T max ) { return (( min <= x && x <= max ) ? true : false ); } template < typename T > static constexpr int sgn ( T x ) { return ( x > 0 ? 1 : x < 0 ? -1 : 0 ); } template < typename T > static constexpr float radians ( T deg ) { return ( deg * DEG_TO_RAD ); } template < typename T > static constexpr float degrees ( T rad ) { return ( rad * RAD_TO_DEG ); } static inline float normalize_angle_positive ( float angle ) { return std :: fmod ( std :: fmod ( angle , TWO_PI ) + TWO_PI , TWO_PI ); } static inline float normalize_angle ( float angle ) { float a = normalize_angle_positive ( angle ); if ( a > PI ) a -= TWO_PI ; return a ; } static inline float shortest_angular_distance ( float from , float to ) { return normalize_angle ( to - from ); } static inline float nearest_angle ( float from , float to ) { return from + normalize_angle ( to - from ); } constexpr inline float square ( const float x ) { return x * x ; } constexpr inline float cubic ( const float x ) { return x * x * x ; } constexpr inline float lerp ( const float a , const float b , const float t ) { return a + ( b - a ) * t ; } constexpr inline float approx_eq ( const float a , const float b ) { return ( std :: abs ( a - b ) < 1e-12 ); } constexpr inline float approx_zero ( const float a ) { return ( std :: abs ( a ) < 1e-12 ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/utility/math_utils.hpp"},{"location":"doxybook/Files/math__utils_8hpp/#includecpp_roboticsutilitymath_utilshpp","text":"","title":"include/cpp_robotics/utility/math_utils.hpp"},{"location":"doxybook/Files/math__utils_8hpp/#namespaces","text":"Name cpp_robotics cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570","title":"Namespaces"},{"location":"doxybook/Files/math__utils_8hpp/#defines","text":"Name M_PI","title":"Defines"},{"location":"doxybook/Files/math__utils_8hpp/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"doxybook/Files/math__utils_8hpp/#define-m_pi","text":"#define M_PI 3.141592653589793238462643383279","title":"define M_PI"},{"location":"doxybook/Files/math__utils_8hpp/#source-code","text":"#pragma once #include <cmath> #include <cassert> #ifndef M_PI #define M_PI 3.141592653589793238462643383279 #endif namespace cpp_robotics { inline namespace constants { constexpr float PI = 3.1415926535897932384626433832795 ; constexpr float HALF_PI = PI / 2.0 ; constexpr float TWO_PI = PI * 2.0 ; constexpr float DEG_TO_RAD = PI / 180.0 ; constexpr float RAD_TO_DEG = 180.0 / PI ; constexpr float EULER = 2.718281828459045235360287471352 ; constexpr float GRAVITY = 9.807 ; constexpr float Nm2gfm = ( 1 / GRAVITY ); constexpr float gfm2Nm = GRAVITY ; constexpr float mNm2gfcm = ( Nm2gfm * 100 ); constexpr float gfcm2mNm = ( gfm2Nm / 100 ); } template < typename T > static constexpr bool in_range_open ( T x , T min , T max ) { return (( min < x && x < max ) ? true : false ); } template < typename T > static constexpr bool in_range ( T x , T min , T max ) { return (( min <= x && x <= max ) ? true : false ); } template < typename T > static constexpr int sgn ( T x ) { return ( x > 0 ? 1 : x < 0 ? -1 : 0 ); } template < typename T > static constexpr float radians ( T deg ) { return ( deg * DEG_TO_RAD ); } template < typename T > static constexpr float degrees ( T rad ) { return ( rad * RAD_TO_DEG ); } static inline float normalize_angle_positive ( float angle ) { return std :: fmod ( std :: fmod ( angle , TWO_PI ) + TWO_PI , TWO_PI ); } static inline float normalize_angle ( float angle ) { float a = normalize_angle_positive ( angle ); if ( a > PI ) a -= TWO_PI ; return a ; } static inline float shortest_angular_distance ( float from , float to ) { return normalize_angle ( to - from ); } static inline float nearest_angle ( float from , float to ) { return from + normalize_angle ( to - from ); } constexpr inline float square ( const float x ) { return x * x ; } constexpr inline float cubic ( const float x ) { return x * x * x ; } constexpr inline float lerp ( const float a , const float b , const float t ) { return a + ( b - a ) * t ; } constexpr inline float approx_eq ( const float a , const float b ) { return ( std :: abs ( a - b ) < 1e-12 ); } constexpr inline float approx_zero ( const float a ) { return ( std :: abs ( a ) < 1e-12 ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/mecanum__ik_8hpp/","text":"include/cpp_robotics/chassis/mecanum_ik.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::MecanumIk::Config Source code #pragma once #include <array> #include <Eigen/Dense> #include \"cpp_robotics/vector/transform.hpp\" namespace cpp_robotics { class MecanumIk { public : struct Config { double width ; double length ; }; MecanumIk ( double width , double length ) : MecanumIk ( Config { width , length }) {} MecanumIk ( Config config ) : config_ ( config ) { const double norm = ( config_ . width + config_ . length ) / 2.0 ; conv_mat_ << -1 , 1 , norm , -1 , -1 , norm , 1 , -1 , norm , 1 , 1 , norm ; } std :: array < double , 4 > calculate ( Transformd velocity ) { std :: array < double , 4 > wv ; Eigen :: Map < Eigen :: Vector4d > wv_vec ( wv . data ()); Eigen :: Vector3d v ( velocity . x , velocity . y , velocity . theta ); wv_vec = conv_mat_ * v ; return wv ; } Config config () const { return config_ ; } private : Config config_ ; Eigen :: Matrix < double , 4 , 3 > conv_mat_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/chassis/mecanum_ik.hpp"},{"location":"doxybook/Files/mecanum__ik_8hpp/#includecpp_roboticschassismecanum_ikhpp","text":"","title":"include/cpp_robotics/chassis/mecanum_ik.hpp"},{"location":"doxybook/Files/mecanum__ik_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/mecanum__ik_8hpp/#classes","text":"Name class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::MecanumIk::Config","title":"Classes"},{"location":"doxybook/Files/mecanum__ik_8hpp/#source-code","text":"#pragma once #include <array> #include <Eigen/Dense> #include \"cpp_robotics/vector/transform.hpp\" namespace cpp_robotics { class MecanumIk { public : struct Config { double width ; double length ; }; MecanumIk ( double width , double length ) : MecanumIk ( Config { width , length }) {} MecanumIk ( Config config ) : config_ ( config ) { const double norm = ( config_ . width + config_ . length ) / 2.0 ; conv_mat_ << -1 , 1 , norm , -1 , -1 , norm , 1 , -1 , norm , 1 , 1 , norm ; } std :: array < double , 4 > calculate ( Transformd velocity ) { std :: array < double , 4 > wv ; Eigen :: Map < Eigen :: Vector4d > wv_vec ( wv . data ()); Eigen :: Vector3d v ( velocity . x , velocity . y , velocity . theta ); wv_vec = conv_mat_ * v ; return wv ; } Config config () const { return config_ ; } private : Config config_ ; Eigen :: Matrix < double , 4 , 3 > conv_mat_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/misc_8hpp/","text":"include/cpp_robotics/algorithm/misc.hpp Namespaces Name cpp_robotics Source code #pragma once namespace cpp_robotics { // constexpr unsigned long fact(const unsigned long n) // { // if(n == 0) // return 1; // return n * fact(n-1); // } // constexpr unsigned long combination(const unsigned long n, const unsigned long r) // { // if (n == 0) // return 1; // else if (r == 0) // return 1; // else if (n == r) // return 1; // else // return combination(n - 1, r) + combination(n - 1, r - 1); // } // template<int N, int R, typename Callable> // constexpr void combi_call_impl(int num, size_t K[R], int p, int w, int n, int r, Callable && f) // { // std::array<size_t, R> comb = {}; // if (p > 0) // { // for (int i = 0; i <= w; i++) // { // K[p] = i; // combi_call_impl(num, K, p - 1, w - i, n, r, f); // } // } // else // { // int m = 0, pick = 0; // for (int i = 1; i <= r; i++) // { // for (int j = 0; j < K[i]; j++, m++) // pick++; // comb[m] = pick; // m++; // } // f(num, p); // num++; // } // } // template<int N, int R, typename Callable> // constexpr void combi_call(Callable && f) // { // size_t K[R] = {}; // size_t num = 0; // combi_call_impl(num, K, R, N-R, N, R, f); // // auto combi_impl = [&f, &comb, &K, &num, &combi_impl](int p, int w, int n, int r) { // // if (p > 0) // // { // // for (int i = 0; i <= w; i++) // // { // // K[p] = i; // // combi_impl(p - 1, w - i, n, r); // // } // // } // // else // // { // // int m = 0, pick = 0; // // for (int i = 1; i <= r; i++) // // { // // for (int j = 0; j < K[i]; j++, m++) // // pick++; // // comb[m] = pick; // // m++; // // }); // // f(num, p); // // num++; // // } // // }(R, N - R, N, R); // } // template<int N = 5, int R = 3> // constexpr auto combi_call_test() // { // std::array<std::array<size_t, R>, combination(N, R)> re = {}; // combi_call<N, R>([&re](size_t num, auto p){ // //re[num] = p; // }); // return re; // } // template<size_t conum> // using twcoeff = std::array<size_t, conum>; // template<> // using twcoeff = std::array<size_t, 3>{1, 2, 1}; // template<> // using twcoeff = std::array<size_t, 4>{1, 3, 3, 1}; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/misc.hpp"},{"location":"doxybook/Files/misc_8hpp/#includecpp_roboticsalgorithmmischpp","text":"","title":"include/cpp_robotics/algorithm/misc.hpp"},{"location":"doxybook/Files/misc_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/misc_8hpp/#source-code","text":"#pragma once namespace cpp_robotics { // constexpr unsigned long fact(const unsigned long n) // { // if(n == 0) // return 1; // return n * fact(n-1); // } // constexpr unsigned long combination(const unsigned long n, const unsigned long r) // { // if (n == 0) // return 1; // else if (r == 0) // return 1; // else if (n == r) // return 1; // else // return combination(n - 1, r) + combination(n - 1, r - 1); // } // template<int N, int R, typename Callable> // constexpr void combi_call_impl(int num, size_t K[R], int p, int w, int n, int r, Callable && f) // { // std::array<size_t, R> comb = {}; // if (p > 0) // { // for (int i = 0; i <= w; i++) // { // K[p] = i; // combi_call_impl(num, K, p - 1, w - i, n, r, f); // } // } // else // { // int m = 0, pick = 0; // for (int i = 1; i <= r; i++) // { // for (int j = 0; j < K[i]; j++, m++) // pick++; // comb[m] = pick; // m++; // } // f(num, p); // num++; // } // } // template<int N, int R, typename Callable> // constexpr void combi_call(Callable && f) // { // size_t K[R] = {}; // size_t num = 0; // combi_call_impl(num, K, R, N-R, N, R, f); // // auto combi_impl = [&f, &comb, &K, &num, &combi_impl](int p, int w, int n, int r) { // // if (p > 0) // // { // // for (int i = 0; i <= w; i++) // // { // // K[p] = i; // // combi_impl(p - 1, w - i, n, r); // // } // // } // // else // // { // // int m = 0, pick = 0; // // for (int i = 1; i <= r; i++) // // { // // for (int j = 0; j < K[i]; j++, m++) // // pick++; // // comb[m] = pick; // // m++; // // }); // // f(num, p); // // num++; // // } // // }(R, N - R, N, R); // } // template<int N = 5, int R = 3> // constexpr auto combi_call_test() // { // std::array<std::array<size_t, R>, combination(N, R)> re = {}; // combi_call<N, R>([&re](size_t num, auto p){ // //re[num] = p; // }); // return re; // } // template<size_t conum> // using twcoeff = std::array<size_t, conum>; // template<> // using twcoeff = std::array<size_t, 3>{1, 2, 1}; // template<> // using twcoeff = std::array<size_t, 4>{1, 3, 3, 1}; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/modern__control_8hpp/","text":"include/cpp_robotics/controller/modern_control.hpp Namespaces Name cpp_robotics Source code #pragma once #include <array> #include <Eigen/Dense> #include \"../system/state_space_system.hpp\" #include \"../system/polynomial.hpp\" namespace cpp_robotics { static Eigen :: MatrixXd controllability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == B . size ()); const int dim = A . rows (); Eigen :: MatrixXd Uc ( dim , dim ); Eigen :: VectorXd colv = B ; for ( int i = 0 ; i < dim ; i ++ ) { Uc . col ( i ) = colv ; colv = A * colv ; } return Uc ; } static bool is_controllable ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) { const int dim = A . rows (); Eigen :: FullPivLU < Eigen :: MatrixXd > lu ( controllability_matrix ( A , B )); return ( lu . rank () == dim ); } static bool is_controllable ( const StateSpaceSystem & sys ) { return is_controllable ( sys . A (). value (), sys . B (). value ()); } static Eigen :: MatrixXd observability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == C . size ()); const int dim = A . rows (); Eigen :: MatrixXd Uo ( dim , dim ); Eigen :: RowVectorXd colv = C ; for ( int i = 0 ; i < dim ; i ++ ) { Uo . row ( i ) = colv ; colv = colv * A ; } return Uo ; } static bool is_observable ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) { const int dim = A . rows (); Eigen :: FullPivLU < Eigen :: MatrixXd > lu ( observability_matrix ( A , C )); return ( lu . rank () == dim ); } static bool is_observable ( const StateSpaceSystem & sys ) { return is_observable ( sys . A (). value (), sys . C ()); } enum class CanonicalizeMode { // MODEL, COMPANION , OBSERBAVLE , CONTROLLABLE }; // https://www.mathworks.com/help/control/ug/canonical-state-space-realizations.html static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , const Eigen :: MatrixXd & D , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) { // if(mode == MODEL) // else if ( mode == CanonicalizeMode :: CONTROLLABLE || mode == CanonicalizeMode :: COMPANION || mode == CanonicalizeMode :: OBSERBAVLE ) { Eigen :: MatrixXd Uc = controllability_matrix ( A , B ); Eigen :: MatrixXd Ucinv = Uc . inverse (); if ( mode == CanonicalizeMode :: CONTROLLABLE ) { auto [ A_tilda , B_tilda , C_tilda , D_tilda ] = canonicalize_system ( A , B , C , D , CanonicalizeMode :: COMPANION ); return { A_tilda . transpose (), C_tilda . transpose (), B_tilda . transpose (), D_tilda }; } else { return { Ucinv * A * Uc , Ucinv * B , C * Uc , D }; } } return canonicalize_system ( A , B , C , D , CanonicalizeMode :: COMPANION ); } static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) { const size_t input_size = B . cols (); const size_t output_size = C . rows (); return canonicalize_system ( A , B , C , Eigen :: MatrixXd :: Zero ( output_size , input_size ), mode ); } static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const StateSpaceSystem & sys , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) { return canonicalize_system ( sys . A (). value (), sys . B (). value (), sys . C (), sys . D (), mode ); } // https://ossyaritoori.hatenablog.com/entry/2018/05/16/%E6%A5%B5%E9%85%8D%E7%BD%AE%E3%81%AE%E5%AE%9F%E8%A3%85%EF%BC%9A%E3%82%A2%E3%83%83%E3%82%AB%E3%83%BC%E3%83%9E%E3%83%B3%E6%B3%95%E3%81%AEMATLAB%E5%AE%9F%E8%A3%85#Outline static Eigen :: VectorXd place ( const StateSpaceSystem & sys , std :: vector < double > poles ) { assert ( sys . state_size () == poles . size ()); assert ( sys . is_siso_model ()); auto pole_poly = Polynomial :: expand ( poles ); auto Uc = controllability_matrix ( sys . A (). value (), sys . B (). value ()); Eigen :: MatrixXd tmp = Eigen :: MatrixXd :: Zero ( sys . state_size (), sys . state_size ()); Eigen :: MatrixXd An = Eigen :: MatrixXd :: Identity ( sys . state_size (), sys . state_size ()); for ( size_t i = 0 ; i < sys . state_size (); i ++ ) { tmp += pole_poly . at_degree ( i ) * An ; An *= sys . A (). value (); } tmp += An ; return ( Uc . inverse () * tmp ). row ( sys . state_size () -1 ); } // \u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\\tilda{A}\u306e\u4fc2\u6570\u6bd4\u8f03\u306b\u3088\u308a\u6975\u914d\u7f6e\u3092\u884c\u3046 // https://www.youtube.com/watch?v=yiFgI6Oos88 // static Eigen::VectorXd place(const StateSpaceSystem& sys, std::vector<double> poles) // { // } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/modern_control.hpp"},{"location":"doxybook/Files/modern__control_8hpp/#includecpp_roboticscontrollermodern_controlhpp","text":"","title":"include/cpp_robotics/controller/modern_control.hpp"},{"location":"doxybook/Files/modern__control_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/modern__control_8hpp/#source-code","text":"#pragma once #include <array> #include <Eigen/Dense> #include \"../system/state_space_system.hpp\" #include \"../system/polynomial.hpp\" namespace cpp_robotics { static Eigen :: MatrixXd controllability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == B . size ()); const int dim = A . rows (); Eigen :: MatrixXd Uc ( dim , dim ); Eigen :: VectorXd colv = B ; for ( int i = 0 ; i < dim ; i ++ ) { Uc . col ( i ) = colv ; colv = A * colv ; } return Uc ; } static bool is_controllable ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) { const int dim = A . rows (); Eigen :: FullPivLU < Eigen :: MatrixXd > lu ( controllability_matrix ( A , B )); return ( lu . rank () == dim ); } static bool is_controllable ( const StateSpaceSystem & sys ) { return is_controllable ( sys . A (). value (), sys . B (). value ()); } static Eigen :: MatrixXd observability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == C . size ()); const int dim = A . rows (); Eigen :: MatrixXd Uo ( dim , dim ); Eigen :: RowVectorXd colv = C ; for ( int i = 0 ; i < dim ; i ++ ) { Uo . row ( i ) = colv ; colv = colv * A ; } return Uo ; } static bool is_observable ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) { const int dim = A . rows (); Eigen :: FullPivLU < Eigen :: MatrixXd > lu ( observability_matrix ( A , C )); return ( lu . rank () == dim ); } static bool is_observable ( const StateSpaceSystem & sys ) { return is_observable ( sys . A (). value (), sys . C ()); } enum class CanonicalizeMode { // MODEL, COMPANION , OBSERBAVLE , CONTROLLABLE }; // https://www.mathworks.com/help/control/ug/canonical-state-space-realizations.html static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , const Eigen :: MatrixXd & D , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) { // if(mode == MODEL) // else if ( mode == CanonicalizeMode :: CONTROLLABLE || mode == CanonicalizeMode :: COMPANION || mode == CanonicalizeMode :: OBSERBAVLE ) { Eigen :: MatrixXd Uc = controllability_matrix ( A , B ); Eigen :: MatrixXd Ucinv = Uc . inverse (); if ( mode == CanonicalizeMode :: CONTROLLABLE ) { auto [ A_tilda , B_tilda , C_tilda , D_tilda ] = canonicalize_system ( A , B , C , D , CanonicalizeMode :: COMPANION ); return { A_tilda . transpose (), C_tilda . transpose (), B_tilda . transpose (), D_tilda }; } else { return { Ucinv * A * Uc , Ucinv * B , C * Uc , D }; } } return canonicalize_system ( A , B , C , D , CanonicalizeMode :: COMPANION ); } static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) { const size_t input_size = B . cols (); const size_t output_size = C . rows (); return canonicalize_system ( A , B , C , Eigen :: MatrixXd :: Zero ( output_size , input_size ), mode ); } static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const StateSpaceSystem & sys , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) { return canonicalize_system ( sys . A (). value (), sys . B (). value (), sys . C (), sys . D (), mode ); } // https://ossyaritoori.hatenablog.com/entry/2018/05/16/%E6%A5%B5%E9%85%8D%E7%BD%AE%E3%81%AE%E5%AE%9F%E8%A3%85%EF%BC%9A%E3%82%A2%E3%83%83%E3%82%AB%E3%83%BC%E3%83%9E%E3%83%B3%E6%B3%95%E3%81%AEMATLAB%E5%AE%9F%E8%A3%85#Outline static Eigen :: VectorXd place ( const StateSpaceSystem & sys , std :: vector < double > poles ) { assert ( sys . state_size () == poles . size ()); assert ( sys . is_siso_model ()); auto pole_poly = Polynomial :: expand ( poles ); auto Uc = controllability_matrix ( sys . A (). value (), sys . B (). value ()); Eigen :: MatrixXd tmp = Eigen :: MatrixXd :: Zero ( sys . state_size (), sys . state_size ()); Eigen :: MatrixXd An = Eigen :: MatrixXd :: Identity ( sys . state_size (), sys . state_size ()); for ( size_t i = 0 ; i < sys . state_size (); i ++ ) { tmp += pole_poly . at_degree ( i ) * An ; An *= sys . A (). value (); } tmp += An ; return ( Uc . inverse () * tmp ). row ( sys . state_size () -1 ); } // \u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\\tilda{A}\u306e\u4fc2\u6570\u6bd4\u8f03\u306b\u3088\u308a\u6975\u914d\u7f6e\u3092\u884c\u3046 // https://www.youtube.com/watch?v=yiFgI6Oos88 // static Eigen::VectorXd place(const StateSpaceSystem& sys, std::vector<double> poles) // { // } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/motor__tf_8hpp/","text":"include/cpp_robotics/motor/motor_tf.hpp Namespaces Name cpp_robotics Source code #pragma once #include \"./dc_motor_param.hpp\" #include \"../system/transfer_function.hpp\" namespace cpp_robotics { static TransferFunction make_motor_vel_tf ( const DCMotorParam & motor , const double dt ) { return TransferFunction ({ motor . torque_constant }, { motor . inductance * motor . rotor_inertia , motor . resistance * motor . rotor_inertia , motor . torque_constant * motor . back_emf_constance }, dt ); } static TransferFunction make_motor_pos_tf ( const DCMotorParam & motor , const double dt ) { auto vel_tf = make_motor_vel_tf ( motor , dt ); auto new_den = vel_tf . den_array (); new_den . push_back ( 0 ); return TransferFunction ( vel_tf . num_array (), new_den , dt ); } static TransferFunction make_geared_motor_vel_tf ( const DCGearedMotorParam & geared_motor , const double dt ) { auto & motor = geared_motor . motor ; auto & gear_head = geared_motor . gear_head ; return TransferFunction ({ motor . torque_constant * gear_head . ratio }, { motor . inductance * motor . rotor_inertia , motor . resistance * motor . rotor_inertia , motor . torque_constant * motor . back_emf_constance }, dt ); } static TransferFunction make_geared_motor_pos_tf ( const DCGearedMotorParam & geared_motor , const double dt ) { auto vel_tf = make_geared_motor_vel_tf ( geared_motor , dt ); auto new_den = vel_tf . den_array (); new_den . push_back ( 0 ); return TransferFunction ( vel_tf . num_array (), new_den , dt ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/motor/motor_tf.hpp"},{"location":"doxybook/Files/motor__tf_8hpp/#includecpp_roboticsmotormotor_tfhpp","text":"","title":"include/cpp_robotics/motor/motor_tf.hpp"},{"location":"doxybook/Files/motor__tf_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/motor__tf_8hpp/#source-code","text":"#pragma once #include \"./dc_motor_param.hpp\" #include \"../system/transfer_function.hpp\" namespace cpp_robotics { static TransferFunction make_motor_vel_tf ( const DCMotorParam & motor , const double dt ) { return TransferFunction ({ motor . torque_constant }, { motor . inductance * motor . rotor_inertia , motor . resistance * motor . rotor_inertia , motor . torque_constant * motor . back_emf_constance }, dt ); } static TransferFunction make_motor_pos_tf ( const DCMotorParam & motor , const double dt ) { auto vel_tf = make_motor_vel_tf ( motor , dt ); auto new_den = vel_tf . den_array (); new_den . push_back ( 0 ); return TransferFunction ( vel_tf . num_array (), new_den , dt ); } static TransferFunction make_geared_motor_vel_tf ( const DCGearedMotorParam & geared_motor , const double dt ) { auto & motor = geared_motor . motor ; auto & gear_head = geared_motor . gear_head ; return TransferFunction ({ motor . torque_constant * gear_head . ratio }, { motor . inductance * motor . rotor_inertia , motor . resistance * motor . rotor_inertia , motor . torque_constant * motor . back_emf_constance }, dt ); } static TransferFunction make_geared_motor_pos_tf ( const DCGearedMotorParam & geared_motor , const double dt ) { auto vel_tf = make_geared_motor_vel_tf ( geared_motor , dt ); auto new_den = vel_tf . den_array (); new_den . push_back ( 0 ); return TransferFunction ( vel_tf . num_array (), new_den , dt ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/nctf_8hpp/","text":"include/cpp_robotics/controller/nctf.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668 Source code #pragma once #include <functional> #include \"./pid.hpp\" #include \"../filter/differentiator.hpp\" namespace cpp_robotics { class NctfController { public : static std :: function < double ( double ) > make_simple_nct ( double max_velocity , double slope ) { return [ = ]( double e ){ return - max_velocity * std :: tanh ( e * slope / max_velocity ); }; } NctfController ( double max_velocity , double nct_slope , PIDController :: pid_param_t pid_param , double dt ) : NctfController ( make_simple_nct ( max_velocity , nct_slope ), pid_param , dt ) { } NctfController ( std :: function < double ( double ) > nct , PIDController :: pid_param_t pid_param , double dt ) : nct_ ( nct ), diff_ ( 0.5 / dt , dt ), pid_ ( pid_param ) { } void reset () { diff_ . reset (); pid_ . reset (); } double control ( double target , double state ) { return control ( target - state ); } double control ( double e ) { double state_e_dot = diff_ . filtering ( e ); double nct_e_dot = nct_ ( e ); return pid_ . calculate ( - ( nct_e_dot - state_e_dot )); } std :: function < double ( double ) > nct () const { return nct_ ; } private : std :: function < double ( double ) > nct_ ; Differentiator diff_ ; PIDController pid_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/nctf.hpp"},{"location":"doxybook/Files/nctf_8hpp/#includecpp_roboticscontrollernctfhpp","text":"","title":"include/cpp_robotics/controller/nctf.hpp"},{"location":"doxybook/Files/nctf_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/nctf_8hpp/#classes","text":"Name class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668","title":"Classes"},{"location":"doxybook/Files/nctf_8hpp/#source-code","text":"#pragma once #include <functional> #include \"./pid.hpp\" #include \"../filter/differentiator.hpp\" namespace cpp_robotics { class NctfController { public : static std :: function < double ( double ) > make_simple_nct ( double max_velocity , double slope ) { return [ = ]( double e ){ return - max_velocity * std :: tanh ( e * slope / max_velocity ); }; } NctfController ( double max_velocity , double nct_slope , PIDController :: pid_param_t pid_param , double dt ) : NctfController ( make_simple_nct ( max_velocity , nct_slope ), pid_param , dt ) { } NctfController ( std :: function < double ( double ) > nct , PIDController :: pid_param_t pid_param , double dt ) : nct_ ( nct ), diff_ ( 0.5 / dt , dt ), pid_ ( pid_param ) { } void reset () { diff_ . reset (); pid_ . reset (); } double control ( double target , double state ) { return control ( target - state ); } double control ( double e ) { double state_e_dot = diff_ . filtering ( e ); double nct_e_dot = nct_ ( e ); return pid_ . calculate ( - ( nct_e_dot - state_e_dot )); } std :: function < double ( double ) > nct () const { return nct_ ; } private : std :: function < double ( double ) > nct_ ; Differentiator diff_ ; PIDController pid_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/ndt_8hpp/","text":"include/cpp_robotics/algorithm/ndt.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 Source code #pragma once #include \"./kdtree.hpp\" namespace cpp_robotics { class NDT2d { public : NDT2d () = default ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/ndt.hpp"},{"location":"doxybook/Files/ndt_8hpp/#includecpp_roboticsalgorithmndthpp","text":"","title":"include/cpp_robotics/algorithm/ndt.hpp"},{"location":"doxybook/Files/ndt_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/ndt_8hpp/#classes","text":"Name class cpp_robotics::NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9","title":"Classes"},{"location":"doxybook/Files/ndt_8hpp/#source-code","text":"#pragma once #include \"./kdtree.hpp\" namespace cpp_robotics { class NDT2d { public : NDT2d () = default ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/newton__method_8hpp/","text":"include/cpp_robotics/optimize/newton_method.hpp Namespaces Name cpp_robotics Source code #pragma once #include <tuple> #include <functional> #include <Eigen/Dense> #include \"bracketing_serach.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > newton_method ( std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , std :: function < Eigen :: MatrixXd ( const Eigen :: VectorXd & ) > hesse , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; Eigen :: VectorXd dx ; for ( size_t i = 0 ; i < max_iter ; i ++ ) { dx = grad ( x ); if ( dx . norm () < tol ) { return { true , x , i }; } x -= ( hesse ( x ). inverse () * dx ); } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/newton_method.hpp"},{"location":"doxybook/Files/newton__method_8hpp/#includecpp_roboticsoptimizenewton_methodhpp","text":"","title":"include/cpp_robotics/optimize/newton_method.hpp"},{"location":"doxybook/Files/newton__method_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/newton__method_8hpp/#source-code","text":"#pragma once #include <tuple> #include <functional> #include <Eigen/Dense> #include \"bracketing_serach.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > newton_method ( std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , std :: function < Eigen :: MatrixXd ( const Eigen :: VectorXd & ) > hesse , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; Eigen :: VectorXd dx ; for ( size_t i = 0 ; i < max_iter ; i ++ ) { dx = grad ( x ); if ( dx . norm () < tol ) { return { true , x , i }; } x -= ( hesse ( x ). inverse () * dx ); } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/notch__filter_8hpp/","text":"include/cpp_robotics/filter/notch_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf Source code #pragma once #include \"cpp_robotics/system/discrete_transfer_function.hpp\" namespace cpp_robotics { // s^2 + d*2*zeta*omega + omega^2 // G(s) = -------------------------------- \u3092\u53cc\u4e00\u6b21\u5909\u63db // s^2 + 2*zeta*omega + omega^2 class NotchFilter { public : NotchFilter ( double w , double zeta , double d , double dt ) : w_ ( w ), zeta_ ( zeta ), d_ ( d ), dt_ ( dt ) { const double ww = w * w ; const double dtdt = dt * dt ; tf_ . set_discrite ( {( 4 + d * ( 4 * dt * zeta * w ) + dtdt * ww ), ( -8 + 2 * dtdt * ww ), ( 4 - d * ( 4 * dt * zeta * w ) + dtdt * ww )}, {( 4 + ( 4 * dt * zeta * w ) + dtdt * ww ), ( -8 + 2 * dtdt * ww ), ( 4 - ( 4 * dt * zeta * w ) + dtdt * ww )}, dt ); } void reset () { tf_ . reset (); } double filtering ( double u ) { return tf_ . responce ( u ); } double w () const { return w_ ; } double zeta () const { return zeta_ ; } double d () const { return d_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double zeta_ ; const double d_ ; const double dt_ ; DiscreteTransferFunction tf_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/notch_filter.hpp"},{"location":"doxybook/Files/notch__filter_8hpp/#includecpp_roboticsfilternotch_filterhpp","text":"","title":"include/cpp_robotics/filter/notch_filter.hpp"},{"location":"doxybook/Files/notch__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/notch__filter_8hpp/#classes","text":"Name class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf","title":"Classes"},{"location":"doxybook/Files/notch__filter_8hpp/#source-code","text":"#pragma once #include \"cpp_robotics/system/discrete_transfer_function.hpp\" namespace cpp_robotics { // s^2 + d*2*zeta*omega + omega^2 // G(s) = -------------------------------- \u3092\u53cc\u4e00\u6b21\u5909\u63db // s^2 + 2*zeta*omega + omega^2 class NotchFilter { public : NotchFilter ( double w , double zeta , double d , double dt ) : w_ ( w ), zeta_ ( zeta ), d_ ( d ), dt_ ( dt ) { const double ww = w * w ; const double dtdt = dt * dt ; tf_ . set_discrite ( {( 4 + d * ( 4 * dt * zeta * w ) + dtdt * ww ), ( -8 + 2 * dtdt * ww ), ( 4 - d * ( 4 * dt * zeta * w ) + dtdt * ww )}, {( 4 + ( 4 * dt * zeta * w ) + dtdt * ww ), ( -8 + 2 * dtdt * ww ), ( 4 - ( 4 * dt * zeta * w ) + dtdt * ww )}, dt ); } void reset () { tf_ . reset (); } double filtering ( double u ) { return tf_ . responce ( u ); } double w () const { return w_ ; } double zeta () const { return zeta_ ; } double d () const { return d_ ; } double dt () const { return dt_ ; } private : const double w_ ; const double zeta_ ; const double d_ ; const double dt_ ; DiscreteTransferFunction tf_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/nyquist_8hpp/","text":"include/cpp_robotics/system/nyquist.hpp Namespaces Name cpp_robotics Source code #pragma once #include <vector> #include <tuple> #include \"./transfer_function.hpp\" #include \"../third_party/matplotlib-cpp/matplotlibcpp.h\" #include \"../utility/space.hpp\" #include \"../vector/vector2.hpp\" #include \"../utility/math_utils.hpp\" #include \"./bode.hpp\" namespace cpp_robotics { static std :: tuple < std :: vector < double > , std :: vector < double >> nyquist ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 )) { size_t n = omegas . size (); std :: vector < double > Re ( n ), Im ( n ); auto [ g , ph ] = bode ( tf , omegas , false , false ); Vector2d tmp ; for ( size_t i = 0 ; i < n ; i ++ ) { tmp . x = g [ i ]; tmp . y = 0 ; tmp . rotate ( ph [ i ]); Re [ i ] = tmp . x ; Im [ i ] = tmp . y ; } return { Re , Im }; } static void nyquist_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 )) { namespace plt = matplotlibcpp ; auto [ Re , Im ] = nyquist ( tf , omegas ); plt :: plot ( Re , Im ); plt :: set_aspect ( 1.0 ); plt :: xlabel ( \"Re\" ); plt :: ylabel ( \"Im\" ); plt :: xlim ( -1.3 * Re [ 0 ], 1.3 * Re [ 0 ]); plt :: ylim ( -1.3 * Re [ 0 ], 1.3 * Re [ 0 ]); plt :: grid ( true , \"both\" ); plt :: show (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/nyquist.hpp"},{"location":"doxybook/Files/nyquist_8hpp/#includecpp_roboticssystemnyquisthpp","text":"","title":"include/cpp_robotics/system/nyquist.hpp"},{"location":"doxybook/Files/nyquist_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/nyquist_8hpp/#source-code","text":"#pragma once #include <vector> #include <tuple> #include \"./transfer_function.hpp\" #include \"../third_party/matplotlib-cpp/matplotlibcpp.h\" #include \"../utility/space.hpp\" #include \"../vector/vector2.hpp\" #include \"../utility/math_utils.hpp\" #include \"./bode.hpp\" namespace cpp_robotics { static std :: tuple < std :: vector < double > , std :: vector < double >> nyquist ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 )) { size_t n = omegas . size (); std :: vector < double > Re ( n ), Im ( n ); auto [ g , ph ] = bode ( tf , omegas , false , false ); Vector2d tmp ; for ( size_t i = 0 ; i < n ; i ++ ) { tmp . x = g [ i ]; tmp . y = 0 ; tmp . rotate ( ph [ i ]); Re [ i ] = tmp . x ; Im [ i ] = tmp . y ; } return { Re , Im }; } static void nyquist_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 )) { namespace plt = matplotlibcpp ; auto [ Re , Im ] = nyquist ( tf , omegas ); plt :: plot ( Re , Im ); plt :: set_aspect ( 1.0 ); plt :: xlabel ( \"Re\" ); plt :: ylabel ( \"Im\" ); plt :: xlim ( -1.3 * Re [ 0 ], 1.3 * Re [ 0 ]); plt :: ylim ( -1.3 * Re [ 0 ], 1.3 * Re [ 0 ]); plt :: grid ( true , \"both\" ); plt :: show (); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/omni__ik_8hpp/","text":"include/cpp_robotics/chassis/omni_ik.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni3Ik::Config class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni4Ik::Config Source code #pragma once #include <array> #include <Eigen/Dense> #include \"cpp_robotics/vector/transform.hpp\" namespace cpp_robotics { class Omni3Ik { public : struct Config { double radius ; double first_wheel_angle = M_PI / 6 ; }; Omni3Ik ( double radius , double first_wheel_angle = M_PI / 6 ) : Omni3Ik ( Config { radius , first_wheel_angle }) {} Omni3Ik ( Config config ) : config_ ( config ) { for ( size_t i = 0 ; i < 3 ; i ++ ) { const double wheel_angle = config_ . first_wheel_angle + ( i * 2 * M_PI / 3 ); conv_mat_ ( i , 0 ) = - std :: sin ( wheel_angle ); conv_mat_ ( i , 1 ) = std :: cos ( wheel_angle ); conv_mat_ ( i , 2 ) = config_ . radius ; } } std :: array < double , 3 > calculate ( Transformd velocity ) { std :: array < double , 3 > wv ; Eigen :: Map < Eigen :: Vector3d > wv_vec ( wv . data ()); Eigen :: Vector3d v ( velocity . x , velocity . y , velocity . theta ); wv_vec = conv_mat_ * v ; return wv ; } Config config () const { return config_ ; } private : Config config_ ; Eigen :: Matrix < double , 3 , 3 > conv_mat_ ; }; class Omni4Ik { public : struct Config { double radius ; double first_wheel_angle = M_PI / 4 ; }; Omni4Ik ( double radius , double first_wheel_angle = M_PI / 4 ) : Omni4Ik ( Config { radius , first_wheel_angle }) {} Omni4Ik ( Config config ) : config_ ( config ) { for ( size_t i = 0 ; i < 4 ; i ++ ) { const double wheel_angle = config_ . first_wheel_angle + ( i * M_PI / 2 ); conv_mat_ ( i , 0 ) = - std :: sin ( wheel_angle ); conv_mat_ ( i , 1 ) = std :: cos ( wheel_angle ); conv_mat_ ( i , 2 ) = config_ . radius ; } } std :: array < double , 4 > calculate ( Transformd velocity ) { std :: array < double , 4 > wv ; Eigen :: Map < Eigen :: Vector4d > wv_vec ( wv . data ()); Eigen :: Vector3d v ( velocity . x , velocity . y , velocity . theta ); wv_vec = conv_mat_ * v ; return wv ; } Config config () const { return config_ ; } private : Config config_ ; Eigen :: Matrix < double , 4 , 3 > conv_mat_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/chassis/omni_ik.hpp"},{"location":"doxybook/Files/omni__ik_8hpp/#includecpp_roboticschassisomni_ikhpp","text":"","title":"include/cpp_robotics/chassis/omni_ik.hpp"},{"location":"doxybook/Files/omni__ik_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/omni__ik_8hpp/#classes","text":"Name class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni3Ik::Config class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb struct cpp_robotics::Omni4Ik::Config","title":"Classes"},{"location":"doxybook/Files/omni__ik_8hpp/#source-code","text":"#pragma once #include <array> #include <Eigen/Dense> #include \"cpp_robotics/vector/transform.hpp\" namespace cpp_robotics { class Omni3Ik { public : struct Config { double radius ; double first_wheel_angle = M_PI / 6 ; }; Omni3Ik ( double radius , double first_wheel_angle = M_PI / 6 ) : Omni3Ik ( Config { radius , first_wheel_angle }) {} Omni3Ik ( Config config ) : config_ ( config ) { for ( size_t i = 0 ; i < 3 ; i ++ ) { const double wheel_angle = config_ . first_wheel_angle + ( i * 2 * M_PI / 3 ); conv_mat_ ( i , 0 ) = - std :: sin ( wheel_angle ); conv_mat_ ( i , 1 ) = std :: cos ( wheel_angle ); conv_mat_ ( i , 2 ) = config_ . radius ; } } std :: array < double , 3 > calculate ( Transformd velocity ) { std :: array < double , 3 > wv ; Eigen :: Map < Eigen :: Vector3d > wv_vec ( wv . data ()); Eigen :: Vector3d v ( velocity . x , velocity . y , velocity . theta ); wv_vec = conv_mat_ * v ; return wv ; } Config config () const { return config_ ; } private : Config config_ ; Eigen :: Matrix < double , 3 , 3 > conv_mat_ ; }; class Omni4Ik { public : struct Config { double radius ; double first_wheel_angle = M_PI / 4 ; }; Omni4Ik ( double radius , double first_wheel_angle = M_PI / 4 ) : Omni4Ik ( Config { radius , first_wheel_angle }) {} Omni4Ik ( Config config ) : config_ ( config ) { for ( size_t i = 0 ; i < 4 ; i ++ ) { const double wheel_angle = config_ . first_wheel_angle + ( i * M_PI / 2 ); conv_mat_ ( i , 0 ) = - std :: sin ( wheel_angle ); conv_mat_ ( i , 1 ) = std :: cos ( wheel_angle ); conv_mat_ ( i , 2 ) = config_ . radius ; } } std :: array < double , 4 > calculate ( Transformd velocity ) { std :: array < double , 4 > wv ; Eigen :: Map < Eigen :: Vector4d > wv_vec ( wv . data ()); Eigen :: Vector3d v ( velocity . x , velocity . y , velocity . theta ); wv_vec = conv_mat_ * v ; return wv ; } Config config () const { return config_ ; } private : Config config_ ; Eigen :: Matrix < double , 4 , 3 > conv_mat_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/optimize_8hpp/","text":"include/cpp_robotics/optimize/optimize.hpp Source code #include \"./constraint.hpp\" #include \"./derivative.hpp\" #include \"./bracketing_serach.hpp\" #include \"./golden_serach.hpp\" #include \"./steepest_descent_method.hpp\" #include \"./newton_method.hpp\" #include \"./quasi_newton_method.hpp\" #include \"./penalty_method.hpp\" #include \"./barrier_method.hpp\" #include \"./linprog.hpp\" #include \"./quadprog.hpp\" #include \"./sqp.hpp\" #include \"./interior_point_method.hpp\" #include \"./active_set_method.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/optimize.hpp"},{"location":"doxybook/Files/optimize_8hpp/#includecpp_roboticsoptimizeoptimizehpp","text":"","title":"include/cpp_robotics/optimize/optimize.hpp"},{"location":"doxybook/Files/optimize_8hpp/#source-code","text":"#include \"./constraint.hpp\" #include \"./derivative.hpp\" #include \"./bracketing_serach.hpp\" #include \"./golden_serach.hpp\" #include \"./steepest_descent_method.hpp\" #include \"./newton_method.hpp\" #include \"./quasi_newton_method.hpp\" #include \"./penalty_method.hpp\" #include \"./barrier_method.hpp\" #include \"./linprog.hpp\" #include \"./quadprog.hpp\" #include \"./sqp.hpp\" #include \"./interior_point_method.hpp\" #include \"./active_set_method.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/path__planning_8hpp/","text":"include/cpp_robotics/path_planning/path_planning.hpp Source code #include \"./grid_path_planning_utils.hpp\" #include \"./a_star.hpp\" #include \"./wave_propagation.hpp\" #include \"./dubins_path.hpp\" #include \"./frenet_frame.hpp\" #include \"./dwa.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning/path_planning.hpp"},{"location":"doxybook/Files/path__planning_8hpp/#includecpp_roboticspath_planningpath_planninghpp","text":"","title":"include/cpp_robotics/path_planning/path_planning.hpp"},{"location":"doxybook/Files/path__planning_8hpp/#source-code","text":"#include \"./grid_path_planning_utils.hpp\" #include \"./a_star.hpp\" #include \"./wave_propagation.hpp\" #include \"./dubins_path.hpp\" #include \"./frenet_frame.hpp\" #include \"./dwa.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/penalty__method_8hpp/","text":"include/cpp_robotics/optimize/penalty_method.hpp Namespaces Name cpp_robotics Source code #pragma once #include <cmath> #include <functional> #include <Eigen/Dense> #include \"constraint.hpp\" #include \"derivative.hpp\" #include \"quasi_newton_method.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > penalty_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 1.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; double r = r_init ; std :: function < double ( const Eigen :: VectorXd & ) > ext_f = [ & ]( const Eigen :: VectorXd & x ) { double y = f ( x ); for ( auto & con : constraint ) { switch ( con . type ) { case Constraint :: Type :: Eq : y += r * std :: pow ( con . con_f ( x ), 2 ); break ; case Constraint :: Type :: Ineq : y += r * std :: pow ( std :: max ( 0.0 , con . con_f ( x )), 2 ); break ; } } return y ; }; auto ext_grad = [ & ]( Eigen :: VectorXd x ) { return derivative ( ext_f , x ); }; for ( size_t i = 0 ; i < max_iter ; i ++ ) { auto [ step_result , new_x , sub_itr_cnt ] = quasi_newton_method ( ext_f , ext_grad , x , tol , 1 ); if ( std :: abs ( r * constraint . eval_sum ( new_x )) < tol ) return { true , new_x , i }; x = new_x ; r += 1 ; } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/penalty_method.hpp"},{"location":"doxybook/Files/penalty__method_8hpp/#includecpp_roboticsoptimizepenalty_methodhpp","text":"","title":"include/cpp_robotics/optimize/penalty_method.hpp"},{"location":"doxybook/Files/penalty__method_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/penalty__method_8hpp/#source-code","text":"#pragma once #include <cmath> #include <functional> #include <Eigen/Dense> #include \"constraint.hpp\" #include \"derivative.hpp\" #include \"quasi_newton_method.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > penalty_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 1.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; double r = r_init ; std :: function < double ( const Eigen :: VectorXd & ) > ext_f = [ & ]( const Eigen :: VectorXd & x ) { double y = f ( x ); for ( auto & con : constraint ) { switch ( con . type ) { case Constraint :: Type :: Eq : y += r * std :: pow ( con . con_f ( x ), 2 ); break ; case Constraint :: Type :: Ineq : y += r * std :: pow ( std :: max ( 0.0 , con . con_f ( x )), 2 ); break ; } } return y ; }; auto ext_grad = [ & ]( Eigen :: VectorXd x ) { return derivative ( ext_f , x ); }; for ( size_t i = 0 ; i < max_iter ; i ++ ) { auto [ step_result , new_x , sub_itr_cnt ] = quasi_newton_method ( ext_f , ext_grad , x , tol , 1 ); if ( std :: abs ( r * constraint . eval_sum ( new_x )) < tol ) return { true , new_x , i }; x = new_x ; r += 1 ; } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/penbulum_2interface_8hpp/","text":"include/cpp_robotics/robots/penbulum/interface.hpp Namespaces Name cpp_robotics Source code #pragma once #include \"../robot_utils/robot_utils.hpp\" namespace cpp_robotics { // State\u3068Input\u306f\u3053\u3053\u3067\u5b9a\u7fa9\u3059\u308b\u3093\u3058\u3083\u306a\u304f\u3066\u30e6\u30fc\u30b6\u30fc\u5074\u3067\u5b9a\u7fa9\u3067\u304d\u308b\u3079\u304d? class PendulumInterface { public : PendulumInterface () = default ; struct State { double angle ; double omega ; double domega ; double pos ; double vel ; double acc ; std :: shared_ptr < void > arg ; }; struct Input { double input ; std :: shared_ptr < void > arg ; }; virtual State get_state () = 0 ; virtual void control ( const Input & input ) = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/penbulum/interface.hpp"},{"location":"doxybook/Files/penbulum_2interface_8hpp/#includecpp_roboticsrobotspenbuluminterfacehpp","text":"","title":"include/cpp_robotics/robots/penbulum/interface.hpp"},{"location":"doxybook/Files/penbulum_2interface_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/penbulum_2interface_8hpp/#source-code","text":"#pragma once #include \"../robot_utils/robot_utils.hpp\" namespace cpp_robotics { // State\u3068Input\u306f\u3053\u3053\u3067\u5b9a\u7fa9\u3059\u308b\u3093\u3058\u3083\u306a\u304f\u3066\u30e6\u30fc\u30b6\u30fc\u5074\u3067\u5b9a\u7fa9\u3067\u304d\u308b\u3079\u304d? class PendulumInterface { public : PendulumInterface () = default ; struct State { double angle ; double omega ; double domega ; double pos ; double vel ; double acc ; std :: shared_ptr < void > arg ; }; struct Input { double input ; std :: shared_ptr < void > arg ; }; virtual State get_state () = 0 ; virtual void control ( const Input & input ) = 0 ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/pendulum_8hpp/","text":"include/cpp_robotics/robots/penbulum/pendulum.hpp Namespaces Name cpp_robotics Source code #pragma once #include \"./interface.hpp\" namespace cpp_robotics { template < class Interface > class PendulumController { public : static_assert ( is_base_of_robot_if_v < PendulumInterface , Interface > , \"\" ); PendulumController () = default ; void control () { } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/penbulum/pendulum.hpp"},{"location":"doxybook/Files/pendulum_8hpp/#includecpp_roboticsrobotspenbulumpendulumhpp","text":"","title":"include/cpp_robotics/robots/penbulum/pendulum.hpp"},{"location":"doxybook/Files/pendulum_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/pendulum_8hpp/#source-code","text":"#pragma once #include \"./interface.hpp\" namespace cpp_robotics { template < class Interface > class PendulumController { public : static_assert ( is_base_of_robot_if_v < PendulumInterface , Interface > , \"\" ); PendulumController () = default ; void control () { } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/pfc_8hpp/","text":"include/cpp_robotics/controller/pfc.hpp Source code // #pragma once // // https://hamachannel.hatenablog.com/entry/2018/01/13/233521 // #include \"../../Matrix/Matrix.hpp\" // #include <functional> // //#include <iostream> // namespace STB // { // template<typename Scalar, size_t Dim> // class SISOPFC; // using SISOPFC2f = SISOPFC<float, 2>; // template<typename Scalar, size_t Dim> // class SISOPFC // { // public: // using value_type = Scalar; // using A_type = Matrix<value_type, Dim, Dim>; // using b_type = Matrix<value_type, Dim, 1>; // using c_type = Matrix<value_type, 1, Dim>; // using vec_type = Matrix<value_type, Dim, 1>; // using svec_type = Matrix<value_type, 3, 1>; // SISOPFC(const A_type& Am, const b_type& Bm, const c_type& Cm, const value_type delay, const value_type TCLRT, const value_type Ts): // A(Am), B(Bm), C(Cm), _TCLRT(TCLRT), _Ts(Ts), _prev_input(0) // { // //using namespace Eigen; // // setup // h1 = ceil(_TCLRT / (_Ts * 3)); // h2 = ceil(_TCLRT / (_Ts * 2)); // h3 = ceil(_TCLRT / (_Ts * 1)); // hl = ceil(delay / _Ts); // lh = { // (1 - exp(-3 * h1 * _Ts / _TCLRT)), // (1 - exp(-3 * h2 * _Ts / _TCLRT)), // (1 - exp(-3 * h3 * _Ts / _TCLRT))}; // CAh1 = CAh2 = CAh3 = C; // for(int i = 0; i < h1; i++) // CAh1 *= A; // for (int i = 0; i < h2; i++) // CAh2 *= A; // for (int i = 0; i < h3; i++) // CAh3 *= A; // G_inv = Matrix<value_type, 3, 3>::Zero(); // c_type tmp = C; // for (int i = 0; i < h1; i++) // { // if(i > 0) // tmp *= A; // value_type ele = (tmp * B); // value_type t1 = _Ts * (h1-1-i); // value_type t2 = t1 * t1; // G_inv(0, 0) += ele; // G_inv(0, 1) += ele * t1; // G_inv(0, 2) += ele * t2; // } // tmp = C; // for (int i = 0; i < h2; i++) // { // if (i > 0) // tmp *= A; // value_type ele = (tmp * B); // value_type t1 = _Ts * (h2-1-i); // value_type t2 = t1 * t1; // G_inv(1, 0) += ele; // G_inv(1, 1) += ele * t1; // G_inv(1, 2) += ele * t2; // } // tmp = C; // for (int i = 0; i < h3; i++) // { // if (i > 0) // tmp *= A; // value_type ele = (tmp * B); // value_type t1 = _Ts * (h3-1 - i); // value_type t2 = t1 * t1; // G_inv(2, 0) += ele; // G_inv(2, 1) += ele * t1; // G_inv(2, 2) += ele * t2; // } // G_inv = G_inv.inverse(); // xm = vec_type::Zero(); // } // value_type calculate(std::function<value_type(value_type)> refTarget, value_type nowState) // { // return calculate(refTarget, nowState, prev_input()); // } // value_type calculate(std::function<value_type(value_type)> refTarget, value_type nowState, value_type prev_input) // { // // using namespace Eigen; // svec_type SV_future; // svec_type SF; // xm = A * xm + B * prev_input; // value_type y = C * xm; // value_type nowTarget = refTarget(hl); // SV_future = { // refTarget(hl + h1 * _Ts) - nowTarget, // refTarget(hl + h2 * _Ts) - nowTarget, // refTarget(hl + h3 * _Ts) - nowTarget}; // SF = { // CAh1 * xm, // CAh2 * xm, // CAh3 * xm}; // auto buf = G_inv * (SV_future + (nowTarget - nowState) * lh - SF + svec_type::Constant(y)); // _prev_input = clamp<value_type>(buf(0), -12, 12); // return _prev_input; // } // value_type prev_input() { return _prev_input; } // private: // Matrix<value_type, 3, 3> G_inv; // A_type A; // b_type B, xm, /*ym, */MV_pre; // c_type CAh1, CAh2, CAh3, C; // svec_type lh; // size_t h1, h2, h3, hl; // value_type _TCLRT, _Ts; // value_type _prev_input; // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/pfc.hpp"},{"location":"doxybook/Files/pfc_8hpp/#includecpp_roboticscontrollerpfchpp","text":"","title":"include/cpp_robotics/controller/pfc.hpp"},{"location":"doxybook/Files/pfc_8hpp/#source-code","text":"// #pragma once // // https://hamachannel.hatenablog.com/entry/2018/01/13/233521 // #include \"../../Matrix/Matrix.hpp\" // #include <functional> // //#include <iostream> // namespace STB // { // template<typename Scalar, size_t Dim> // class SISOPFC; // using SISOPFC2f = SISOPFC<float, 2>; // template<typename Scalar, size_t Dim> // class SISOPFC // { // public: // using value_type = Scalar; // using A_type = Matrix<value_type, Dim, Dim>; // using b_type = Matrix<value_type, Dim, 1>; // using c_type = Matrix<value_type, 1, Dim>; // using vec_type = Matrix<value_type, Dim, 1>; // using svec_type = Matrix<value_type, 3, 1>; // SISOPFC(const A_type& Am, const b_type& Bm, const c_type& Cm, const value_type delay, const value_type TCLRT, const value_type Ts): // A(Am), B(Bm), C(Cm), _TCLRT(TCLRT), _Ts(Ts), _prev_input(0) // { // //using namespace Eigen; // // setup // h1 = ceil(_TCLRT / (_Ts * 3)); // h2 = ceil(_TCLRT / (_Ts * 2)); // h3 = ceil(_TCLRT / (_Ts * 1)); // hl = ceil(delay / _Ts); // lh = { // (1 - exp(-3 * h1 * _Ts / _TCLRT)), // (1 - exp(-3 * h2 * _Ts / _TCLRT)), // (1 - exp(-3 * h3 * _Ts / _TCLRT))}; // CAh1 = CAh2 = CAh3 = C; // for(int i = 0; i < h1; i++) // CAh1 *= A; // for (int i = 0; i < h2; i++) // CAh2 *= A; // for (int i = 0; i < h3; i++) // CAh3 *= A; // G_inv = Matrix<value_type, 3, 3>::Zero(); // c_type tmp = C; // for (int i = 0; i < h1; i++) // { // if(i > 0) // tmp *= A; // value_type ele = (tmp * B); // value_type t1 = _Ts * (h1-1-i); // value_type t2 = t1 * t1; // G_inv(0, 0) += ele; // G_inv(0, 1) += ele * t1; // G_inv(0, 2) += ele * t2; // } // tmp = C; // for (int i = 0; i < h2; i++) // { // if (i > 0) // tmp *= A; // value_type ele = (tmp * B); // value_type t1 = _Ts * (h2-1-i); // value_type t2 = t1 * t1; // G_inv(1, 0) += ele; // G_inv(1, 1) += ele * t1; // G_inv(1, 2) += ele * t2; // } // tmp = C; // for (int i = 0; i < h3; i++) // { // if (i > 0) // tmp *= A; // value_type ele = (tmp * B); // value_type t1 = _Ts * (h3-1 - i); // value_type t2 = t1 * t1; // G_inv(2, 0) += ele; // G_inv(2, 1) += ele * t1; // G_inv(2, 2) += ele * t2; // } // G_inv = G_inv.inverse(); // xm = vec_type::Zero(); // } // value_type calculate(std::function<value_type(value_type)> refTarget, value_type nowState) // { // return calculate(refTarget, nowState, prev_input()); // } // value_type calculate(std::function<value_type(value_type)> refTarget, value_type nowState, value_type prev_input) // { // // using namespace Eigen; // svec_type SV_future; // svec_type SF; // xm = A * xm + B * prev_input; // value_type y = C * xm; // value_type nowTarget = refTarget(hl); // SV_future = { // refTarget(hl + h1 * _Ts) - nowTarget, // refTarget(hl + h2 * _Ts) - nowTarget, // refTarget(hl + h3 * _Ts) - nowTarget}; // SF = { // CAh1 * xm, // CAh2 * xm, // CAh3 * xm}; // auto buf = G_inv * (SV_future + (nowTarget - nowState) * lh - SF + svec_type::Constant(y)); // _prev_input = clamp<value_type>(buf(0), -12, 12); // return _prev_input; // } // value_type prev_input() { return _prev_input; } // private: // Matrix<value_type, 3, 3> G_inv; // A_type A; // b_type B, xm, /*ym, */MV_pre; // c_type CAh1, CAh2, CAh3, C; // svec_type lh; // size_t h1, h2, h3, hl; // value_type _TCLRT, _Ts; // value_type _prev_input; // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/pid2_8hpp/","text":"include/cpp_robotics/controller/pid2.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::PID2Controller 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 struct cpp_robotics::PID2Controller::pid_param_t Source code #pragma once namespace cpp_robotics { class PID2Controller { public : struct pid_param_t { double Ts ; double gpd ; double Kp , Ki , Kd ; double b , c ; }; PID2Controller ( pid_param_t param ) { set_param ( param ); reset (); } void setParam ( pid_param_t param ) { set_param ( param ); } void set_param ( pid_param_t param ) { param_ = param ; } void reset () { u1_ = 0 ; u2_ = 0 ; r1_ = 0 ; r2_ = 0 ; y1_ = 0 ; y2_ = 0 ; } double calculate ( double target , double present , double dt ) { ( void ) dt ; return calculate ( target , present ); } double calculate ( double target , double present ) { double & r = target ; double & y = present ; auto [ Ts , gpd , Kp , Ki , Kd , b , c ] = param_ ; double u = ( Kp * ( ( 4.0 + 2.0 * gpd * Ts ) * ( b * r - y ) - 8.0 * ( b * r1_ - y1_ ) + ( 4.0-2.0 * gpd * Ts ) * ( b * r2_ - y2_ ) ) + Ki * Ts * ( ( 2.0 + gpd * Ts ) * ( r - y ) + 2.0 * gpd * Ts * ( r1_ - y1_ ) - ( 2.0 - gpd * Ts ) * ( r2_ - y2_ ) ) + 4.0 * Kd * gpd * ( ( c * r - y ) - 2.0 * ( c * r1_ - y1_ ) + ( c * r2_ - y2_ ) ) + 8.0 * u1_ - ( 4.0-2.0 * gpd * Ts ) * u2_ ) / ( 4.0 + 2.0 * gpd * Ts ); r2_ = r1_ ; r1_ = r ; y2_ = y1_ ; y1_ = y ; u2_ = u1_ ; u1_ = u ; return u ; } private : pid_param_t param_ ; double u1_ , u2_ ; double r1_ , r2_ ; double y1_ , y2_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/pid2.hpp"},{"location":"doxybook/Files/pid2_8hpp/#includecpp_roboticscontrollerpid2hpp","text":"","title":"include/cpp_robotics/controller/pid2.hpp"},{"location":"doxybook/Files/pid2_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/pid2_8hpp/#classes","text":"Name class cpp_robotics::PID2Controller 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 struct cpp_robotics::PID2Controller::pid_param_t","title":"Classes"},{"location":"doxybook/Files/pid2_8hpp/#source-code","text":"#pragma once namespace cpp_robotics { class PID2Controller { public : struct pid_param_t { double Ts ; double gpd ; double Kp , Ki , Kd ; double b , c ; }; PID2Controller ( pid_param_t param ) { set_param ( param ); reset (); } void setParam ( pid_param_t param ) { set_param ( param ); } void set_param ( pid_param_t param ) { param_ = param ; } void reset () { u1_ = 0 ; u2_ = 0 ; r1_ = 0 ; r2_ = 0 ; y1_ = 0 ; y2_ = 0 ; } double calculate ( double target , double present , double dt ) { ( void ) dt ; return calculate ( target , present ); } double calculate ( double target , double present ) { double & r = target ; double & y = present ; auto [ Ts , gpd , Kp , Ki , Kd , b , c ] = param_ ; double u = ( Kp * ( ( 4.0 + 2.0 * gpd * Ts ) * ( b * r - y ) - 8.0 * ( b * r1_ - y1_ ) + ( 4.0-2.0 * gpd * Ts ) * ( b * r2_ - y2_ ) ) + Ki * Ts * ( ( 2.0 + gpd * Ts ) * ( r - y ) + 2.0 * gpd * Ts * ( r1_ - y1_ ) - ( 2.0 - gpd * Ts ) * ( r2_ - y2_ ) ) + 4.0 * Kd * gpd * ( ( c * r - y ) - 2.0 * ( c * r1_ - y1_ ) + ( c * r2_ - y2_ ) ) + 8.0 * u1_ - ( 4.0-2.0 * gpd * Ts ) * u2_ ) / ( 4.0 + 2.0 * gpd * Ts ); r2_ = r1_ ; r1_ = r ; y2_ = y1_ ; y1_ = y ; u2_ = u1_ ; u1_ = u ; return u ; } private : pid_param_t param_ ; double u1_ , u2_ ; double r1_ , r2_ ; double y1_ , y2_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/pid_8hpp/","text":"include/cpp_robotics/controller/pid.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::PIDController PID\u5236\u5fa1\u5668 struct cpp_robotics::PIDController::pid_param_t Source code #pragma once #include <optional> #include <utility> #include <algorithm> namespace cpp_robotics { class PIDController { public : struct pid_param_t { double Ts ; double gpd ; double Kp , Ki , Kd ; std :: optional < std :: pair < double , double >> output_limit ; }; PIDController ( pid_param_t param ) { set_param ( param ); reset (); } void set_param ( pid_param_t param ) { param_ = param ; } void reset () { u1_ = 0 ; u2_ = 0 ; e1_ = 0 ; e2_ = 0 ; } double calculate ( double error ) { auto [ Ts , gpd , Kp , Ki , Kd , output_limit ] = param_ ; double u = ( 2.0 * Ts * ( Ki + Kp * gpd ) * ( error - e2_ ) + Ki * gpd * Ts * Ts * ( error + 2.0 * e1_ + e2_ ) + 4.0 * ( Kd * gpd + Kp ) * ( error -2.0 * e1_ + e2_ ) - ( 4.0-2.0 * gpd * Ts ) * u2_ + 8.0 * u1_ ) / ( 4.0 + 2.0 * gpd * Ts ); e2_ = e1_ ; e1_ = error ; u2_ = u1_ ; u1_ = u ; if ( output_limit ) { u = std :: clamp ( u , output_limit . value (). first , output_limit . value (). second ); } return u ; } private : pid_param_t param_ ; double u1_ , u2_ ; double e1_ , e2_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/pid.hpp"},{"location":"doxybook/Files/pid_8hpp/#includecpp_roboticscontrollerpidhpp","text":"","title":"include/cpp_robotics/controller/pid.hpp"},{"location":"doxybook/Files/pid_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/pid_8hpp/#classes","text":"Name class cpp_robotics::PIDController PID\u5236\u5fa1\u5668 struct cpp_robotics::PIDController::pid_param_t","title":"Classes"},{"location":"doxybook/Files/pid_8hpp/#source-code","text":"#pragma once #include <optional> #include <utility> #include <algorithm> namespace cpp_robotics { class PIDController { public : struct pid_param_t { double Ts ; double gpd ; double Kp , Ki , Kd ; std :: optional < std :: pair < double , double >> output_limit ; }; PIDController ( pid_param_t param ) { set_param ( param ); reset (); } void set_param ( pid_param_t param ) { param_ = param ; } void reset () { u1_ = 0 ; u2_ = 0 ; e1_ = 0 ; e2_ = 0 ; } double calculate ( double error ) { auto [ Ts , gpd , Kp , Ki , Kd , output_limit ] = param_ ; double u = ( 2.0 * Ts * ( Ki + Kp * gpd ) * ( error - e2_ ) + Ki * gpd * Ts * Ts * ( error + 2.0 * e1_ + e2_ ) + 4.0 * ( Kd * gpd + Kp ) * ( error -2.0 * e1_ + e2_ ) - ( 4.0-2.0 * gpd * Ts ) * u2_ + 8.0 * u1_ ) / ( 4.0 + 2.0 * gpd * Ts ); e2_ = e1_ ; e1_ = error ; u2_ = u1_ ; u1_ = u ; if ( output_limit ) { u = std :: clamp ( u , output_limit . value (). first , output_limit . value (). second ); } return u ; } private : pid_param_t param_ ; double u1_ , u2_ ; double e1_ , e2_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/poly__regression_8hpp/","text":"include/cpp_robotics/algorithm/poly_regression.hpp Namespaces Name cpp_robotics Source code #pragma once #include <array> #include <vector> #include <Eigen/Dense> #include \"cpp_robotics/system/polynomial.hpp\" namespace cpp_robotics { Polynomial poly_regression ( const std :: vector < double > & x , const std :: vector < double > & y , const size_t degree ) { Eigen :: MatrixXd XT , Y ; assert ( x . size () == y . size ()); const size_t data_num = x . size (); XT . resize ( degree + 1 , data_num ); Y . resize ( data_num , 1 ); for ( size_t j = 0 ; j < x . size (); j ++ ) { XT ( 0 , j ) = 1 ; for ( size_t i = 0 ; i < degree ; i ++ ) { XT ( i + 1 , j ) = XT ( i , j ) * x [ j ]; } } for ( size_t i = 0 ; i < y . size (); i ++ ) { Y ( i ) = y [ i ]; } std :: vector < double > coeff ( degree + 1 ); Eigen :: Map < Eigen :: VectorXd > coeff_vec ( coeff . data (), degree + 1 ); coeff_vec = ( XT * XT . transpose ()). inverse () * ( XT * Y ); return Polynomial ( coeff ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/poly_regression.hpp"},{"location":"doxybook/Files/poly__regression_8hpp/#includecpp_roboticsalgorithmpoly_regressionhpp","text":"","title":"include/cpp_robotics/algorithm/poly_regression.hpp"},{"location":"doxybook/Files/poly__regression_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/poly__regression_8hpp/#source-code","text":"#pragma once #include <array> #include <vector> #include <Eigen/Dense> #include \"cpp_robotics/system/polynomial.hpp\" namespace cpp_robotics { Polynomial poly_regression ( const std :: vector < double > & x , const std :: vector < double > & y , const size_t degree ) { Eigen :: MatrixXd XT , Y ; assert ( x . size () == y . size ()); const size_t data_num = x . size (); XT . resize ( degree + 1 , data_num ); Y . resize ( data_num , 1 ); for ( size_t j = 0 ; j < x . size (); j ++ ) { XT ( 0 , j ) = 1 ; for ( size_t i = 0 ; i < degree ; i ++ ) { XT ( i + 1 , j ) = XT ( i , j ) * x [ j ]; } } for ( size_t i = 0 ; i < y . size (); i ++ ) { Y ( i ) = y [ i ]; } std :: vector < double > coeff ( degree + 1 ); Eigen :: Map < Eigen :: VectorXd > coeff_vec ( coeff . data (), degree + 1 ); coeff_vec = ( XT * XT . transpose ()). inverse () * ( XT * Y ); return Polynomial ( coeff ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/polynomial_8hpp/","text":"include/cpp_robotics/system/polynomial.hpp Namespaces Name cpp_robotics Classes Name struct cpp_robotics::Polynomial \u591a\u9805\u5f0f Source code #pragma once #include <vector> // #include <initializer_list> #include <cassert> #include \"../utility/cpp_support.hpp\" namespace cpp_robotics { // _coeff.front()\u304c\u6700\u9ad8\u6b21\u6570 // _coeff.back()\u304c\u6b21\u65700 struct Polynomial { Polynomial ( std :: initializer_list < double > coeff ) : _coeff ( coeff . begin (), coeff . end ()) {} Polynomial ( const std :: vector < double > & coeff ) : _coeff ( coeff ) {} template < class IteratorType > Polynomial ( IteratorType begin , IteratorType end ) : _coeff ( begin , end ) {} // (x-a1)(x-a2)...(x-aN)\u306e{a...aN}\u3092\u5f15\u6570\u306b\u3068\u308a\u5c55\u958b\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 static Polynomial expand ( std :: vector < double > roots ) { std :: vector < double > coeff , buf ; coeff . reserve ( roots . size () + 1 ); buf . reserve ( roots . size ()); coeff . resize ( 1 ); coeff [ 0 ] = 1 ; for ( auto & c : roots ) { // (x^m+a*x^m-1 ... c) * x\u3092\u8a08\u7b97\u3059\u308b buf = coeff ; coeff . push_back ( 0 ); // (x^m+a*x^m-1 ... c) * d\u3092\u8a08\u7b97\u3059\u308b for ( auto & bval : buf ) bval *= - c ; // (x^m+a*x^m-1 ... c) * d\u3092\u52a0\u7b97\u3059\u308b for ( size_t i = 0 ; i < buf . size (); i ++ ) { coeff [ i + 1 ] += buf [ i ]; } } return Polynomial { coeff }; } void set_degree ( size_t deg ) { _coeff . resize ( deg + 1 ); } size_t size () const { return _coeff . size (); } size_t degree () const { return size () ? ( size () - 1 ) : 0 ; } //size_t degree_at(size_t i) const { return size() ? (degree() - i) : 0; } std :: vector < double > coeff () const { return _coeff ; } double & at ( size_t i ) { return _coeff [ i ]; } double at ( size_t i ) const { return _coeff [ i ]; } double & at_degree ( size_t i ) { return _coeff [ degree () - i ]; } double at_degree ( size_t i ) const { return _coeff [ degree () - i ]; } double & operator []( size_t i ) { return at ( i ); } double operator []( size_t i ) const { return at ( i ); } void check_degree () { while ( size ()) { if ( at ( degree ()) != 0 ) return ; _coeff . erase ( _coeff . begin () + _coeff . size () -1 ); } } double evalute ( double x ) const { assert ( _coeff . size () != 0 ); double xn = 1 ; double y = _coeff . back (); for ( auto it = _coeff . rbegin () + 1 ; it != _coeff . rend (); it ++ ) { y = y * x + ( * it ); } return y ; } Polynomial polyder ( size_t i ) const { assert ( degree () > 0 ); if ( i == 0 ) return * this ; if ( i > degree ()) return { 0 }; Polynomial dpol = * this ; for ( size_t c = 0 ; c < dpol . size (); c ++ ) { if ( c >= i ) { size_t nc = 1 ; for ( size_t r = 0 ; r < i ; r ++ ) { nc *= ( c - r ); } dpol [ c ] *= static_cast < double > ( nc ); } } dpol . _coeff . erase ( dpol . _coeff . begin (), dpol . _coeff . begin () + i ); // size_t deg = dpol.degree(); // dpol._coeff.resize(dpol.size() - i); // for(size_t c = 0; c < dpol.size(); c++) // { // size_t nc = 1; // for(size_t r = 0; r < i; r++) // { // nc *= (deg - c - r); // } // dpol[c] *= static_cast<double>(nc); // } return dpol ; } Polynomial polyint ( double C = 0 ) const { Polynomial ipol = * this ; for ( size_t i = 0 ; i < ipol . size (); i ++ ) { double ndeg = static_cast < double > ( i + 1 ); ipol [ i ] /= ndeg ; } ipol . _coeff . insert ( ipol . _coeff . begin (), C ); return ipol ; } void swap ( Polynomial & poly ) { Polynomial tmp = * this ; * this = poly ; poly = tmp ; } double operator ()( double x ) const { return evalute ( x ); } Polynomial operator + () const { return * this ; } Polynomial operator - () const { Polynomial ret = * this ; for ( auto & c : ret . _coeff ) c *= -1 ; return ret ; } Polynomial operator + ( double s ) const { Polynomial ret = * this ; ret [ ret . degree ()] += s ; ret . check_degree (); return ret ; } Polynomial operator - ( double s ) const { Polynomial ret = * this ; ret [ ret . degree ()] -= s ; ret . check_degree (); return ret ; } Polynomial operator * ( double s ) const { Polynomial ret = * this ; for ( auto & c : ret . _coeff ) c *= s ; ret . check_degree (); return ret ; } friend Polynomial operator * ( double s , const Polynomial & poly ) { return poly * s ; } Polynomial operator / ( double s ) const { Polynomial ret = * this ; for ( auto & c : ret . _coeff ) c /= s ; ret . check_degree (); return ret ; } Polynomial operator * ( const Polynomial & p ) const { std :: vector < double > new_coeff ( this -> degree () + p . degree () + 1 ); size_t new_deg = new_coeff . size () -1 ; std :: vector < double > c0 = this -> coeff (); std :: vector < double > c1 = p . coeff (); for ( size_t i0 = 0 ; i0 < c0 . size (); i0 ++ ) { for ( size_t i1 = 0 ; i1 < c1 . size (); i1 ++ ) { size_t deg0 = this -> degree () - i0 ; size_t deg1 = p . degree () - i1 ; size_t deg = new_deg - ( deg0 + deg1 ); new_coeff [ deg ] += c0 [ i0 ] * c1 [ i1 ]; } } Polynomial new_p ( new_coeff ); return new_p ; } // Polynomial operator +(Polynomial poly) const // { // Polynomial ret = *this; // if(ret.degree() < poly.degree()) // { // ret.swap(poly); // } // for (auto [it, rit] = // std::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()}; // it != poly._coeff.rend(); it++, rit++) // { // *rit += *it; // } // ret.check_degree(); // return ret; // } // Polynomial operator -(Polynomial poly) const // { // Polynomial ret = *this; // int pm = 1; // if(ret.degree() < poly.degree()) // { // ret.swap(poly); // pm = -1; // } // for (auto [it, rit] = // std::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()}; // it != poly._coeff.rend(); it++, rit++) // { // *rit -= *it; // } // ret.check_degree(); // return pm*ret; // } friend bool operator == ( const Polynomial & lhs , const Polynomial & rhs ) { return lhs . _coeff == rhs . _coeff ; } friend bool operator != ( const Polynomial & lhs , const Polynomial & rhs ) { return lhs . _coeff != rhs . _coeff ; } private : std :: vector < double > _coeff ; }; std :: ostream & operator << ( std :: ostream & os , const Polynomial & v ) { os << \"( \" ; bool is_outputed = false ; for ( size_t i = 0 ; i < v . size (); i ++ ) { double coeff = v . coeff ()[ i ]; size_t deg = v . degree () - i ; if ( coeff != 0 ) { if ( is_outputed ) { if ( coeff >= 0 ) os << \" + \" ; else os << \" - \" ; } os << std :: abs ( coeff ); if ( deg > 0 ) os << \"x^\" + std :: to_string ( deg ); is_outputed = true ; } } os << \" )\" ; return os ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/polynomial.hpp"},{"location":"doxybook/Files/polynomial_8hpp/#includecpp_roboticssystempolynomialhpp","text":"","title":"include/cpp_robotics/system/polynomial.hpp"},{"location":"doxybook/Files/polynomial_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/polynomial_8hpp/#classes","text":"Name struct cpp_robotics::Polynomial \u591a\u9805\u5f0f","title":"Classes"},{"location":"doxybook/Files/polynomial_8hpp/#source-code","text":"#pragma once #include <vector> // #include <initializer_list> #include <cassert> #include \"../utility/cpp_support.hpp\" namespace cpp_robotics { // _coeff.front()\u304c\u6700\u9ad8\u6b21\u6570 // _coeff.back()\u304c\u6b21\u65700 struct Polynomial { Polynomial ( std :: initializer_list < double > coeff ) : _coeff ( coeff . begin (), coeff . end ()) {} Polynomial ( const std :: vector < double > & coeff ) : _coeff ( coeff ) {} template < class IteratorType > Polynomial ( IteratorType begin , IteratorType end ) : _coeff ( begin , end ) {} // (x-a1)(x-a2)...(x-aN)\u306e{a...aN}\u3092\u5f15\u6570\u306b\u3068\u308a\u5c55\u958b\u3057\u305f\u591a\u9805\u5f0f\u3092\u8fd4\u3059 static Polynomial expand ( std :: vector < double > roots ) { std :: vector < double > coeff , buf ; coeff . reserve ( roots . size () + 1 ); buf . reserve ( roots . size ()); coeff . resize ( 1 ); coeff [ 0 ] = 1 ; for ( auto & c : roots ) { // (x^m+a*x^m-1 ... c) * x\u3092\u8a08\u7b97\u3059\u308b buf = coeff ; coeff . push_back ( 0 ); // (x^m+a*x^m-1 ... c) * d\u3092\u8a08\u7b97\u3059\u308b for ( auto & bval : buf ) bval *= - c ; // (x^m+a*x^m-1 ... c) * d\u3092\u52a0\u7b97\u3059\u308b for ( size_t i = 0 ; i < buf . size (); i ++ ) { coeff [ i + 1 ] += buf [ i ]; } } return Polynomial { coeff }; } void set_degree ( size_t deg ) { _coeff . resize ( deg + 1 ); } size_t size () const { return _coeff . size (); } size_t degree () const { return size () ? ( size () - 1 ) : 0 ; } //size_t degree_at(size_t i) const { return size() ? (degree() - i) : 0; } std :: vector < double > coeff () const { return _coeff ; } double & at ( size_t i ) { return _coeff [ i ]; } double at ( size_t i ) const { return _coeff [ i ]; } double & at_degree ( size_t i ) { return _coeff [ degree () - i ]; } double at_degree ( size_t i ) const { return _coeff [ degree () - i ]; } double & operator []( size_t i ) { return at ( i ); } double operator []( size_t i ) const { return at ( i ); } void check_degree () { while ( size ()) { if ( at ( degree ()) != 0 ) return ; _coeff . erase ( _coeff . begin () + _coeff . size () -1 ); } } double evalute ( double x ) const { assert ( _coeff . size () != 0 ); double xn = 1 ; double y = _coeff . back (); for ( auto it = _coeff . rbegin () + 1 ; it != _coeff . rend (); it ++ ) { y = y * x + ( * it ); } return y ; } Polynomial polyder ( size_t i ) const { assert ( degree () > 0 ); if ( i == 0 ) return * this ; if ( i > degree ()) return { 0 }; Polynomial dpol = * this ; for ( size_t c = 0 ; c < dpol . size (); c ++ ) { if ( c >= i ) { size_t nc = 1 ; for ( size_t r = 0 ; r < i ; r ++ ) { nc *= ( c - r ); } dpol [ c ] *= static_cast < double > ( nc ); } } dpol . _coeff . erase ( dpol . _coeff . begin (), dpol . _coeff . begin () + i ); // size_t deg = dpol.degree(); // dpol._coeff.resize(dpol.size() - i); // for(size_t c = 0; c < dpol.size(); c++) // { // size_t nc = 1; // for(size_t r = 0; r < i; r++) // { // nc *= (deg - c - r); // } // dpol[c] *= static_cast<double>(nc); // } return dpol ; } Polynomial polyint ( double C = 0 ) const { Polynomial ipol = * this ; for ( size_t i = 0 ; i < ipol . size (); i ++ ) { double ndeg = static_cast < double > ( i + 1 ); ipol [ i ] /= ndeg ; } ipol . _coeff . insert ( ipol . _coeff . begin (), C ); return ipol ; } void swap ( Polynomial & poly ) { Polynomial tmp = * this ; * this = poly ; poly = tmp ; } double operator ()( double x ) const { return evalute ( x ); } Polynomial operator + () const { return * this ; } Polynomial operator - () const { Polynomial ret = * this ; for ( auto & c : ret . _coeff ) c *= -1 ; return ret ; } Polynomial operator + ( double s ) const { Polynomial ret = * this ; ret [ ret . degree ()] += s ; ret . check_degree (); return ret ; } Polynomial operator - ( double s ) const { Polynomial ret = * this ; ret [ ret . degree ()] -= s ; ret . check_degree (); return ret ; } Polynomial operator * ( double s ) const { Polynomial ret = * this ; for ( auto & c : ret . _coeff ) c *= s ; ret . check_degree (); return ret ; } friend Polynomial operator * ( double s , const Polynomial & poly ) { return poly * s ; } Polynomial operator / ( double s ) const { Polynomial ret = * this ; for ( auto & c : ret . _coeff ) c /= s ; ret . check_degree (); return ret ; } Polynomial operator * ( const Polynomial & p ) const { std :: vector < double > new_coeff ( this -> degree () + p . degree () + 1 ); size_t new_deg = new_coeff . size () -1 ; std :: vector < double > c0 = this -> coeff (); std :: vector < double > c1 = p . coeff (); for ( size_t i0 = 0 ; i0 < c0 . size (); i0 ++ ) { for ( size_t i1 = 0 ; i1 < c1 . size (); i1 ++ ) { size_t deg0 = this -> degree () - i0 ; size_t deg1 = p . degree () - i1 ; size_t deg = new_deg - ( deg0 + deg1 ); new_coeff [ deg ] += c0 [ i0 ] * c1 [ i1 ]; } } Polynomial new_p ( new_coeff ); return new_p ; } // Polynomial operator +(Polynomial poly) const // { // Polynomial ret = *this; // if(ret.degree() < poly.degree()) // { // ret.swap(poly); // } // for (auto [it, rit] = // std::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()}; // it != poly._coeff.rend(); it++, rit++) // { // *rit += *it; // } // ret.check_degree(); // return ret; // } // Polynomial operator -(Polynomial poly) const // { // Polynomial ret = *this; // int pm = 1; // if(ret.degree() < poly.degree()) // { // ret.swap(poly); // pm = -1; // } // for (auto [it, rit] = // std::tuple{poly._coeff.rbegin(), ret._coeff.rbegin()}; // it != poly._coeff.rend(); it++, rit++) // { // *rit -= *it; // } // ret.check_degree(); // return pm*ret; // } friend bool operator == ( const Polynomial & lhs , const Polynomial & rhs ) { return lhs . _coeff == rhs . _coeff ; } friend bool operator != ( const Polynomial & lhs , const Polynomial & rhs ) { return lhs . _coeff != rhs . _coeff ; } private : std :: vector < double > _coeff ; }; std :: ostream & operator << ( std :: ostream & os , const Polynomial & v ) { os << \"( \" ; bool is_outputed = false ; for ( size_t i = 0 ; i < v . size (); i ++ ) { double coeff = v . coeff ()[ i ]; size_t deg = v . degree () - i ; if ( coeff != 0 ) { if ( is_outputed ) { if ( coeff >= 0 ) os << \" + \" ; else os << \" - \" ; } os << std :: abs ( coeff ); if ( deg > 0 ) os << \"x^\" + std :: to_string ( deg ); is_outputed = true ; } } os << \" )\" ; return os ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/pure__pursuit_8hpp/","text":"include/cpp_robotics/controller/pure_pursuit.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668 Source code #pragma once #include <tuple> #include \"../vector/vector2.hpp\" namespace cpp_robotics { // https://myenigma.hatenablog.com/entry/2017/06/05/111007 // https://sd08419ttic.hatenablog.com/entry/2020/03/22/152044 // https://www.youtube.com/watch?v=zMdoLO4kRKg // https://www.coursera.org/lecture/intro-self-driving-cars/lesson-2-geometric-lateral-control-pure-pursuit-44N7x // https://www.youtube.com/watch?v=34CSRIlHMNk class PurePursuit { public : // K\u306f\u6b63\u306e\u5b9f\u6570\u30010\u306b\u8fd1\u3044\u307b\u3069\u30ed\u30d0\u30b9\u30c8\u6027\u304c\u843d\u3061\u308b PurePursuit ( double K ) : K_ ( K ) {} void set_K ( double K ) { K_ = K ; } std :: tuple < bool , double > control ( std :: function < Vector2d ( double ) > traj_ref , double traj_progress , Vector2d pos_present , double vel , double angle_present ) { vel = std :: abs ( vel ); // lookahead double L = K_ * vel ; // lookahead\u5ea7\u6a19 Vector2d pos_ref = traj_ref ( traj_progress + L ); double omega = 0.0f ; const double pos_diff = ( pos_ref - pos_present ). norm (); if ( std :: abs ( vel ) > 1e-2 && pos_diff > 0.001f ) { // Yaw\u65b9\u5411\u30a8\u30e9\u30fc double raw_dir_err = (( pos_ref - pos_present ). angle ()) - angle_present ; double dir_err = raw_dir_err ; // Yaw\u65b9\u5411\u5236\u5fa1\u91cf omega = ( 2.0f * vel * std :: sin ( dir_err )) / L ; return { true , omega }; } return { false , 0.0f }; } private : double K_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/controller/pure_pursuit.hpp"},{"location":"doxybook/Files/pure__pursuit_8hpp/#includecpp_roboticscontrollerpure_pursuithpp","text":"","title":"include/cpp_robotics/controller/pure_pursuit.hpp"},{"location":"doxybook/Files/pure__pursuit_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/pure__pursuit_8hpp/#classes","text":"Name class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668","title":"Classes"},{"location":"doxybook/Files/pure__pursuit_8hpp/#source-code","text":"#pragma once #include <tuple> #include \"../vector/vector2.hpp\" namespace cpp_robotics { // https://myenigma.hatenablog.com/entry/2017/06/05/111007 // https://sd08419ttic.hatenablog.com/entry/2020/03/22/152044 // https://www.youtube.com/watch?v=zMdoLO4kRKg // https://www.coursera.org/lecture/intro-self-driving-cars/lesson-2-geometric-lateral-control-pure-pursuit-44N7x // https://www.youtube.com/watch?v=34CSRIlHMNk class PurePursuit { public : // K\u306f\u6b63\u306e\u5b9f\u6570\u30010\u306b\u8fd1\u3044\u307b\u3069\u30ed\u30d0\u30b9\u30c8\u6027\u304c\u843d\u3061\u308b PurePursuit ( double K ) : K_ ( K ) {} void set_K ( double K ) { K_ = K ; } std :: tuple < bool , double > control ( std :: function < Vector2d ( double ) > traj_ref , double traj_progress , Vector2d pos_present , double vel , double angle_present ) { vel = std :: abs ( vel ); // lookahead double L = K_ * vel ; // lookahead\u5ea7\u6a19 Vector2d pos_ref = traj_ref ( traj_progress + L ); double omega = 0.0f ; const double pos_diff = ( pos_ref - pos_present ). norm (); if ( std :: abs ( vel ) > 1e-2 && pos_diff > 0.001f ) { // Yaw\u65b9\u5411\u30a8\u30e9\u30fc double raw_dir_err = (( pos_ref - pos_present ). angle ()) - angle_present ; double dir_err = raw_dir_err ; // Yaw\u65b9\u5411\u5236\u5fa1\u91cf omega = ( 2.0f * vel * std :: sin ( dir_err )) / L ; return { true , omega }; } return { false , 0.0f }; } private : double K_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/quadcopter_2interface_8hpp/","text":"include/cpp_robotics/robots/quadcopter/interface.hpp Namespaces Name cpp_robotics Source code #pragma once namespace cpp_robotics { class QuadCopterInterface { }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/quadcopter/interface.hpp"},{"location":"doxybook/Files/quadcopter_2interface_8hpp/#includecpp_roboticsrobotsquadcopterinterfacehpp","text":"","title":"include/cpp_robotics/robots/quadcopter/interface.hpp"},{"location":"doxybook/Files/quadcopter_2interface_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/quadcopter_2interface_8hpp/#source-code","text":"#pragma once namespace cpp_robotics { class QuadCopterInterface { }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/quadcopter_8hpp/","text":"include/cpp_robotics/robots/quadcopter/quadcopter.hpp Namespaces Name cpp_robotics Source code #pragma once namespace cpp_robotics { class QuadCopterController { }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/quadcopter/quadcopter.hpp"},{"location":"doxybook/Files/quadcopter_8hpp/#includecpp_roboticsrobotsquadcopterquadcopterhpp","text":"","title":"include/cpp_robotics/robots/quadcopter/quadcopter.hpp"},{"location":"doxybook/Files/quadcopter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/quadcopter_8hpp/#source-code","text":"#pragma once namespace cpp_robotics { class QuadCopterController { }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/quadprog_8hpp/","text":"include/cpp_robotics/optimize/quadprog.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 struct cpp_robotics::QuadProg::Param struct cpp_robotics::QuadProg::Result Source code #pragma once #include <cmath> #include <tuple> #include <functional> #include <Eigen/Dense> #include <cassert> #include \"constraint.hpp\" #include \"derivative.hpp\" #include \"bracketing_serach.hpp\" namespace cpp_robotics { // min 1/2 x^T Q x + c^T x // s.t. Aeq x = b, Ax <= b class QuadProg { public : Eigen :: MatrixXd Q ; Eigen :: VectorXd c ; Eigen :: MatrixXd Aeq ; Eigen :: VectorXd beq ; Eigen :: MatrixXd A ; Eigen :: VectorXd b ; struct Param { // \u30b9\u30c6\u30c3\u30d7\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6 double tol_step = 1e-6 ; // \u5236\u7d04\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6 double tol_con = 1e-6 ; // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5236\u7d04\u306b\u304b\u304b\u308b\u91cd\u307f double eta = 0.1 ; // \u76f4\u7dda\u63a2\u7d22\u306e\u56f2\u3044\u8fbc\u307f\u6cd5\u306b\u304a\u3051\u308b\u30b9\u30c6\u30c3\u30d7\u3054\u3068\u306e\u66f4\u65b0\u500d\u7387 double beta = 0.9 ; // rho\u30b2\u30a4\u30f3 double t = 0.5 ; // \u6700\u5927\u53cd\u5fa9\u56de\u6570 size_t max_iter = 100 ; }; Param param ; struct Result { bool is_solved = false ; Eigen :: VectorXd x ; Eigen :: VectorXd lambda_ineq ; Eigen :: VectorXd lambda_eq ; size_t iter_cnt = 0 ; }; void set_problem_size ( const size_t valiable_size , const size_t ineq_constraint_size , const size_t eq_constraint_size ) { Q . conservativeResize ( valiable_size , valiable_size ); c . conservativeResize ( valiable_size ); Aeq . conservativeResize ( eq_constraint_size , valiable_size ); beq . conservativeResize ( eq_constraint_size ); A . conservativeResize ( ineq_constraint_size , valiable_size ); b . conservativeResize ( ineq_constraint_size ); } void debug_prog () { std :: cout << \"///// debug /////\" << std :: endl ; std :: cout << \"Q\" << std :: endl ; std :: cout << Q << std :: endl ; std :: cout << \"c\" << std :: endl ; std :: cout << c << std :: endl ; std :: cout << \"Aeq\" << std :: endl ; std :: cout << Aeq << std :: endl ; std :: cout << \"beq\" << std :: endl ; std :: cout << beq << std :: endl ; std :: cout << \"A\" << std :: endl ; std :: cout << A << std :: endl ; std :: cout << \"b\" << std :: endl ; std :: cout << b << std :: endl ; } Result solve ( Eigen :: VectorXd x_init ) { const auto [ tol_step , tol_con , eta , beta , t , max_iter ] = param ; Result result ; // Size check assert ( Q . rows () == Q . cols ()); assert ( c . rows () == Q . rows ()); assert ( x_init . size () == Q . rows ()); // \u5909\u6570\u306e\u30b5\u30a4\u30ba const size_t n = Q . rows (); if ( Aeq . rows () != 0 ) { assert ( Aeq . cols () == ( int ) n ); assert ( Aeq . rows () == beq . rows ()); } const size_t m = Aeq . rows (); if ( A . rows () != 0 ) { assert ( A . cols () == ( int ) n ); assert ( A . rows () == b . rows ()); } const size_t l = A . rows (); Eigen :: VectorXd x ( n ); double rho = 1 ; // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u4f7f\u7528\u3059\u308b Eigen :: VectorXd s = Eigen :: VectorXd :: Ones ( l ); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30b9\u30e9\u30c3\u30af\u5909\u6570 Eigen :: VectorXd u = Eigen :: VectorXd :: Ones ( l ); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570 Eigen :: VectorXd v = Eigen :: VectorXd :: Zero ( m ); // \u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570 Eigen :: VectorXd foom = grad_lagrange ( x , u , v ); // KKT\u6761\u4ef61\u6b21\u306e\u6700\u9069\u6027 for ( size_t i = 0 ; i < max_iter ; i ++ ) { Eigen :: MatrixXd P = Eigen :: MatrixXd :: Zero ( n + 2 * l + m , n + 2 * l + m ); Eigen :: VectorXd r = Eigen :: VectorXd :: Zero ( n + 2 * l + m ); P . block ( 0 , 0 , n , n ) = Q ; r . segment ( 0 , n ) = Q * x + c ; // \u4e0d\u7b49\u5f0f\u5236\u7d04 if ( l > 0 ) { P . block ( 0 , n + l , n , l ) = A . transpose (); P . block ( n , 0 , l , n ) = A ; P . block ( n , n , l , l ) = Eigen :: MatrixXd :: Identity ( l , l ); P . block ( n + l , n , l , l ) = u . asDiagonal (); P . block ( n + l , n + l , l , l ) = s . asDiagonal (); r . segment ( n , l ) = A * x - b + s ; r . segment ( n + l , l ) = - rho * Eigen :: VectorXd :: Ones ( l ) + Eigen :: VectorXd ( u . array () * s . array ()); } // \u7b49\u5f0f\u5236\u7d04 if ( m > 0 ) { P . block ( n + 2 * l , 0 , m , n ) = Aeq ; P . block ( 0 , n + 2 * l , n , m ) = Aeq . transpose (); r . segment ( n + 2 * l , m ) = Aeq * x - beq ; } // \u9023\u7acb\u4e00\u6b21\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f Eigen :: VectorXd delta = P . fullPivLu (). solve ( - r ); Eigen :: VectorXd dx = delta . segment ( 0 , n ); Eigen :: VectorXd ds = delta . segment ( n , l ); Eigen :: VectorXd du = delta . segment ( n + l , l ); Eigen :: VectorXd dv = delta . segment ( n + 2 * l , m ); // \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u6c7a\u5b9a // Todo: \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u521d\u671f\u5024\u3092\u7d5e\u308b const double max_alpha = std :: min ({ 1.0 , 1.0 }); double alpha = bracketing_serach ([ & ]( double alpha ) { return evaluate_merit ( x + alpha * dx , s + alpha * ds , rho , eta ); }, max_alpha , beta ); // \u66f4\u65b0 x += dx ; if ( l > 0 ) { s += ds ; u += du ; } if ( m > 0 ) { v += dv ; } // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u66f4\u65b0 if ( l > 0 ) { rho = t * ( u . dot ( s )) / l ; } // Todo \u6700\u9069\u6027\u3068\u5236\u7d04\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b Eigen :: VectorXd new_foom = grad_lagrange ( x , u , v ); if ( dx . norm () <= tol_step * ( 1.0 + x . norm ())) // && (new_foom - foom).norm() <= tol_con*(1.0+foom.norm())) { result . is_solved = true ; result . x = x ; result . lambda_ineq = u ; result . lambda_eq = v ; result . iter_cnt = i ; return result ; } foom = new_foom ; } result . is_solved = false ; result . x = x ; result . lambda_ineq = u ; result . lambda_eq = v ; result . iter_cnt = max_iter ; return result ; } double evaluate ( const Eigen :: VectorXd & x ) { return 0.5 * ( x . transpose () * Q ). dot ( x ) + c . dot ( x ); } double evaluate_merit ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & s , const double rho , const double eta ) { double val = evaluate ( x ); for ( int i = 0 ; i < s . rows (); i ++ ) { val += rho * std :: log ( s ( i )); } Eigen :: VectorXd v = A * x - b + s ; for ( int i = 0 ; i < v . rows (); i ++ ) { val += eta * std :: log ( std :: abs ( v ( i ))); } Eigen :: VectorXd veq = Aeq * x - beq ; for ( int i = 0 ; i < veq . rows (); i ++ ) { val += eta * std :: log ( std :: abs ( veq ( i ))); } return val ; } Eigen :: VectorXd grad_lagrange ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & u , const Eigen :: VectorXd & v ) { Eigen :: VectorXd gl ; gl = Q * x + c ; if ( u . size () > 0 ) gl += A . transpose () * u ; if ( v . size () > 0 ) gl += Aeq . transpose () * v ; return gl ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/quadprog.hpp"},{"location":"doxybook/Files/quadprog_8hpp/#includecpp_roboticsoptimizequadproghpp","text":"","title":"include/cpp_robotics/optimize/quadprog.hpp"},{"location":"doxybook/Files/quadprog_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/quadprog_8hpp/#classes","text":"Name class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 struct cpp_robotics::QuadProg::Param struct cpp_robotics::QuadProg::Result","title":"Classes"},{"location":"doxybook/Files/quadprog_8hpp/#source-code","text":"#pragma once #include <cmath> #include <tuple> #include <functional> #include <Eigen/Dense> #include <cassert> #include \"constraint.hpp\" #include \"derivative.hpp\" #include \"bracketing_serach.hpp\" namespace cpp_robotics { // min 1/2 x^T Q x + c^T x // s.t. Aeq x = b, Ax <= b class QuadProg { public : Eigen :: MatrixXd Q ; Eigen :: VectorXd c ; Eigen :: MatrixXd Aeq ; Eigen :: VectorXd beq ; Eigen :: MatrixXd A ; Eigen :: VectorXd b ; struct Param { // \u30b9\u30c6\u30c3\u30d7\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6 double tol_step = 1e-6 ; // \u5236\u7d04\u306b\u5bfe\u3059\u308b\u53ce\u675f\u6761\u4ef6 double tol_con = 1e-6 ; // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5236\u7d04\u306b\u304b\u304b\u308b\u91cd\u307f double eta = 0.1 ; // \u76f4\u7dda\u63a2\u7d22\u306e\u56f2\u3044\u8fbc\u307f\u6cd5\u306b\u304a\u3051\u308b\u30b9\u30c6\u30c3\u30d7\u3054\u3068\u306e\u66f4\u65b0\u500d\u7387 double beta = 0.9 ; // rho\u30b2\u30a4\u30f3 double t = 0.5 ; // \u6700\u5927\u53cd\u5fa9\u56de\u6570 size_t max_iter = 100 ; }; Param param ; struct Result { bool is_solved = false ; Eigen :: VectorXd x ; Eigen :: VectorXd lambda_ineq ; Eigen :: VectorXd lambda_eq ; size_t iter_cnt = 0 ; }; void set_problem_size ( const size_t valiable_size , const size_t ineq_constraint_size , const size_t eq_constraint_size ) { Q . conservativeResize ( valiable_size , valiable_size ); c . conservativeResize ( valiable_size ); Aeq . conservativeResize ( eq_constraint_size , valiable_size ); beq . conservativeResize ( eq_constraint_size ); A . conservativeResize ( ineq_constraint_size , valiable_size ); b . conservativeResize ( ineq_constraint_size ); } void debug_prog () { std :: cout << \"///// debug /////\" << std :: endl ; std :: cout << \"Q\" << std :: endl ; std :: cout << Q << std :: endl ; std :: cout << \"c\" << std :: endl ; std :: cout << c << std :: endl ; std :: cout << \"Aeq\" << std :: endl ; std :: cout << Aeq << std :: endl ; std :: cout << \"beq\" << std :: endl ; std :: cout << beq << std :: endl ; std :: cout << \"A\" << std :: endl ; std :: cout << A << std :: endl ; std :: cout << \"b\" << std :: endl ; std :: cout << b << std :: endl ; } Result solve ( Eigen :: VectorXd x_init ) { const auto [ tol_step , tol_con , eta , beta , t , max_iter ] = param ; Result result ; // Size check assert ( Q . rows () == Q . cols ()); assert ( c . rows () == Q . rows ()); assert ( x_init . size () == Q . rows ()); // \u5909\u6570\u306e\u30b5\u30a4\u30ba const size_t n = Q . rows (); if ( Aeq . rows () != 0 ) { assert ( Aeq . cols () == ( int ) n ); assert ( Aeq . rows () == beq . rows ()); } const size_t m = Aeq . rows (); if ( A . rows () != 0 ) { assert ( A . cols () == ( int ) n ); assert ( A . rows () == b . rows ()); } const size_t l = A . rows (); Eigen :: VectorXd x ( n ); double rho = 1 ; // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306b\u4f7f\u7528\u3059\u308b Eigen :: VectorXd s = Eigen :: VectorXd :: Ones ( l ); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30b9\u30e9\u30c3\u30af\u5909\u6570 Eigen :: VectorXd u = Eigen :: VectorXd :: Ones ( l ); // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570 Eigen :: VectorXd v = Eigen :: VectorXd :: Zero ( m ); // \u7b49\u5f0f\u5236\u7d04\u306e\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u4e57\u6570 Eigen :: VectorXd foom = grad_lagrange ( x , u , v ); // KKT\u6761\u4ef61\u6b21\u306e\u6700\u9069\u6027 for ( size_t i = 0 ; i < max_iter ; i ++ ) { Eigen :: MatrixXd P = Eigen :: MatrixXd :: Zero ( n + 2 * l + m , n + 2 * l + m ); Eigen :: VectorXd r = Eigen :: VectorXd :: Zero ( n + 2 * l + m ); P . block ( 0 , 0 , n , n ) = Q ; r . segment ( 0 , n ) = Q * x + c ; // \u4e0d\u7b49\u5f0f\u5236\u7d04 if ( l > 0 ) { P . block ( 0 , n + l , n , l ) = A . transpose (); P . block ( n , 0 , l , n ) = A ; P . block ( n , n , l , l ) = Eigen :: MatrixXd :: Identity ( l , l ); P . block ( n + l , n , l , l ) = u . asDiagonal (); P . block ( n + l , n + l , l , l ) = s . asDiagonal (); r . segment ( n , l ) = A * x - b + s ; r . segment ( n + l , l ) = - rho * Eigen :: VectorXd :: Ones ( l ) + Eigen :: VectorXd ( u . array () * s . array ()); } // \u7b49\u5f0f\u5236\u7d04 if ( m > 0 ) { P . block ( n + 2 * l , 0 , m , n ) = Aeq ; P . block ( 0 , n + 2 * l , n , m ) = Aeq . transpose (); r . segment ( n + 2 * l , m ) = Aeq * x - beq ; } // \u9023\u7acb\u4e00\u6b21\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f Eigen :: VectorXd delta = P . fullPivLu (). solve ( - r ); Eigen :: VectorXd dx = delta . segment ( 0 , n ); Eigen :: VectorXd ds = delta . segment ( n , l ); Eigen :: VectorXd du = delta . segment ( n + l , l ); Eigen :: VectorXd dv = delta . segment ( n + 2 * l , m ); // \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u6c7a\u5b9a // Todo: \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u521d\u671f\u5024\u3092\u7d5e\u308b const double max_alpha = std :: min ({ 1.0 , 1.0 }); double alpha = bracketing_serach ([ & ]( double alpha ) { return evaluate_merit ( x + alpha * dx , s + alpha * ds , rho , eta ); }, max_alpha , beta ); // \u66f4\u65b0 x += dx ; if ( l > 0 ) { s += ds ; u += du ; } if ( m > 0 ) { v += dv ; } // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u66f4\u65b0 if ( l > 0 ) { rho = t * ( u . dot ( s )) / l ; } // Todo \u6700\u9069\u6027\u3068\u5236\u7d04\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b Eigen :: VectorXd new_foom = grad_lagrange ( x , u , v ); if ( dx . norm () <= tol_step * ( 1.0 + x . norm ())) // && (new_foom - foom).norm() <= tol_con*(1.0+foom.norm())) { result . is_solved = true ; result . x = x ; result . lambda_ineq = u ; result . lambda_eq = v ; result . iter_cnt = i ; return result ; } foom = new_foom ; } result . is_solved = false ; result . x = x ; result . lambda_ineq = u ; result . lambda_eq = v ; result . iter_cnt = max_iter ; return result ; } double evaluate ( const Eigen :: VectorXd & x ) { return 0.5 * ( x . transpose () * Q ). dot ( x ) + c . dot ( x ); } double evaluate_merit ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & s , const double rho , const double eta ) { double val = evaluate ( x ); for ( int i = 0 ; i < s . rows (); i ++ ) { val += rho * std :: log ( s ( i )); } Eigen :: VectorXd v = A * x - b + s ; for ( int i = 0 ; i < v . rows (); i ++ ) { val += eta * std :: log ( std :: abs ( v ( i ))); } Eigen :: VectorXd veq = Aeq * x - beq ; for ( int i = 0 ; i < veq . rows (); i ++ ) { val += eta * std :: log ( std :: abs ( veq ( i ))); } return val ; } Eigen :: VectorXd grad_lagrange ( const Eigen :: VectorXd & x , const Eigen :: VectorXd & u , const Eigen :: VectorXd & v ) { Eigen :: VectorXd gl ; gl = Q * x + c ; if ( u . size () > 0 ) gl += A . transpose () * u ; if ( v . size () > 0 ) gl += Aeq . transpose () * v ; return gl ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/quasi__newton__method_8hpp/","text":"include/cpp_robotics/optimize/quasi_newton_method.hpp Namespaces Name cpp_robotics Source code #pragma once #include <Eigen/Dense> #include \"./bfgs.hpp\" #include \"./bracketing_serach.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > quasi_newton_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) { size_t n = x_init . rows (); Eigen :: VectorXd x = x_init ; Eigen :: VectorXd dx , gx , y ; Eigen :: MatrixXd B = Eigen :: MatrixXd :: Identity ( n , n ); gx = grad ( x ); for ( size_t i = 0 ; i < max_iter ; i ++ ) { dx = - B . inverse () * grad ( x ); if ( dx . norm () < tol ) { return { true , x , i }; } // \u7591\u4f3c\u30d8\u30c3\u30bb\u884c\u5217\u306e\u66f4\u65b0 // BFGS\u6cd5 double a = bracketing_serach ([ & ]( double v ){ return f ( x + v * dx ); }); // \u76f4\u7dda\u63a2\u7d22 x += a * dx ; y = - gx ; gx = grad ( x ); y += gx ; powells_modified_bfgs_step ( B , a * dx , y ); } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/quasi_newton_method.hpp"},{"location":"doxybook/Files/quasi__newton__method_8hpp/#includecpp_roboticsoptimizequasi_newton_methodhpp","text":"","title":"include/cpp_robotics/optimize/quasi_newton_method.hpp"},{"location":"doxybook/Files/quasi__newton__method_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/quasi__newton__method_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> #include \"./bfgs.hpp\" #include \"./bracketing_serach.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > quasi_newton_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) { size_t n = x_init . rows (); Eigen :: VectorXd x = x_init ; Eigen :: VectorXd dx , gx , y ; Eigen :: MatrixXd B = Eigen :: MatrixXd :: Identity ( n , n ); gx = grad ( x ); for ( size_t i = 0 ; i < max_iter ; i ++ ) { dx = - B . inverse () * grad ( x ); if ( dx . norm () < tol ) { return { true , x , i }; } // \u7591\u4f3c\u30d8\u30c3\u30bb\u884c\u5217\u306e\u66f4\u65b0 // BFGS\u6cd5 double a = bracketing_serach ([ & ]( double v ){ return f ( x + v * dx ); }); // \u76f4\u7dda\u63a2\u7d22 x += a * dx ; y = - gx ; gx = grad ( x ); y += gx ; powells_modified_bfgs_step ( B , a * dx , y ); } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/quaternion_8hpp/","text":"include/cpp_robotics/vector/quaternion.hpp More... Namespaces Name cpp_robotics Classes Name class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 Detailed Description Author : Takumi Odashima ( Kotakkucu@gmail.com ) Version : 0.1 Date : 2021-10-10 Copyright : Copyright (c) 2021 Source code #pragma once #include \"./vector3.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Quaternion ; using Quaternionf = Quaternion < float > ; using Quaterniond = Quaternion < double > ; template < typename FLOATING_TYPE > class Quaternion { public : using value_type = FLOATING_TYPE ; value_type x ; value_type y ; value_type z ; value_type w ; constexpr Quaternion () : x ( 0.0f ), y ( 0.0f ), z ( 0.0f ), w ( 1.0f ) { } constexpr Quaternion ( value_type nx , value_type ny , value_type nz , value_type nw ) : x ( nx ), y ( ny ), z ( nz ), w ( nw ) { } Quaternion get_product ( Quaternion q ) { return Quaternion ( w * q . w - x * q . x - y * q . y - z * q . z , // new w w * q . x + x * q . w + y * q . z - z * q . y , // new x w * q . y - x * q . z + y * q . w + z * q . x , // new y w * q . z + x * q . y - y * q . x + z * q . w ); // new z } constexpr Quaternion conjugate () const { return Quaternion ( w , - x , - y , - z ); } constexpr value_type norm () const { return sqrt ( w * w + x * x + y * y + z * z ); } constexpr void normalize () { value_type m = norm (); w /= m ; x /= m ; y /= m ; z /= m ; } constexpr Quaternion get_normalized () const { Quaternion r ( w , x , y , z ); r . normalize (); return r ; } constexpr void set_rpy ( value_type roll , value_type pitch , value_type yaw ) { double cos_roll = cos ( roll / 2.0 ); double sin_roll = sin ( roll / 2.0 ); double cos_pitch = cos ( pitch / 2.0 ); double sin_pitch = sin ( pitch / 2.0 ); double cos_yaw = cos ( yaw / 2.0 ); double sin_yaw = sin ( yaw / 2.0 ); w = cos_roll * cos_pitch * cos_yaw + sin_roll * sin_pitch * sin_yaw ; x = sin_roll * cos_pitch * cos_yaw - cos_roll * sin_pitch * sin_yaw ; y = cos_roll * sin_pitch * cos_yaw + sin_roll * cos_pitch * sin_yaw ; z = cos_roll * cos_pitch * sin_yaw - sin_roll * sin_pitch * cos_yaw ; } constexpr Vector3d get_rpy () const { value_type xx = x * x ; value_type xy = x * y ; value_type xz = x * z ; value_type xw = x * w ; value_type yy = y * y ; value_type yz = y * z ; value_type yw = y * w ; value_type zz = z * z ; value_type zw = z * w ; value_type ww = w * w ; return Vector3d { std :: atan2 ( 2.0f * ( zw + xy ), xx - yy - zz + ww ), std :: asin ( 2.0f * ( xz - yw )), std :: atan2 ( 2.0f * ( yz + xw ), xx + yy - zz - ww )}; } constexpr value_type operator []( const int index ) const { assert ( 0 <= index && index < 4 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; if ( index == 2 ) return z ; return w ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/vector/quaternion.hpp"},{"location":"doxybook/Files/quaternion_8hpp/#includecpp_roboticsvectorquaternionhpp","text":"More...","title":"include/cpp_robotics/vector/quaternion.hpp"},{"location":"doxybook/Files/quaternion_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/quaternion_8hpp/#classes","text":"Name class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9","title":"Classes"},{"location":"doxybook/Files/quaternion_8hpp/#detailed-description","text":"Author : Takumi Odashima ( Kotakkucu@gmail.com ) Version : 0.1 Date : 2021-10-10 Copyright : Copyright (c) 2021","title":"Detailed Description"},{"location":"doxybook/Files/quaternion_8hpp/#source-code","text":"#pragma once #include \"./vector3.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Quaternion ; using Quaternionf = Quaternion < float > ; using Quaterniond = Quaternion < double > ; template < typename FLOATING_TYPE > class Quaternion { public : using value_type = FLOATING_TYPE ; value_type x ; value_type y ; value_type z ; value_type w ; constexpr Quaternion () : x ( 0.0f ), y ( 0.0f ), z ( 0.0f ), w ( 1.0f ) { } constexpr Quaternion ( value_type nx , value_type ny , value_type nz , value_type nw ) : x ( nx ), y ( ny ), z ( nz ), w ( nw ) { } Quaternion get_product ( Quaternion q ) { return Quaternion ( w * q . w - x * q . x - y * q . y - z * q . z , // new w w * q . x + x * q . w + y * q . z - z * q . y , // new x w * q . y - x * q . z + y * q . w + z * q . x , // new y w * q . z + x * q . y - y * q . x + z * q . w ); // new z } constexpr Quaternion conjugate () const { return Quaternion ( w , - x , - y , - z ); } constexpr value_type norm () const { return sqrt ( w * w + x * x + y * y + z * z ); } constexpr void normalize () { value_type m = norm (); w /= m ; x /= m ; y /= m ; z /= m ; } constexpr Quaternion get_normalized () const { Quaternion r ( w , x , y , z ); r . normalize (); return r ; } constexpr void set_rpy ( value_type roll , value_type pitch , value_type yaw ) { double cos_roll = cos ( roll / 2.0 ); double sin_roll = sin ( roll / 2.0 ); double cos_pitch = cos ( pitch / 2.0 ); double sin_pitch = sin ( pitch / 2.0 ); double cos_yaw = cos ( yaw / 2.0 ); double sin_yaw = sin ( yaw / 2.0 ); w = cos_roll * cos_pitch * cos_yaw + sin_roll * sin_pitch * sin_yaw ; x = sin_roll * cos_pitch * cos_yaw - cos_roll * sin_pitch * sin_yaw ; y = cos_roll * sin_pitch * cos_yaw + sin_roll * cos_pitch * sin_yaw ; z = cos_roll * cos_pitch * sin_yaw - sin_roll * sin_pitch * cos_yaw ; } constexpr Vector3d get_rpy () const { value_type xx = x * x ; value_type xy = x * y ; value_type xz = x * z ; value_type xw = x * w ; value_type yy = y * y ; value_type yz = y * z ; value_type yw = y * w ; value_type zz = z * z ; value_type zw = z * w ; value_type ww = w * w ; return Vector3d { std :: atan2 ( 2.0f * ( zw + xy ), xx - yy - zz + ww ), std :: asin ( 2.0f * ( xz - yw )), std :: atan2 ( 2.0f * ( yz + xw ), xx + yy - zz - ww )}; } constexpr value_type operator []( const int index ) const { assert ( 0 <= index && index < 4 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; if ( index == 2 ) return z ; return w ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/random_8hpp/","text":"include/cpp_robotics/algorithm/random.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 Source code # pragma once #include <cmath> #include <random> #include \"../utility/singleton.hpp\" namespace cpp_robotics { namespace internal { template < class Method > class RandomEngineWrapper { public : using engine_method_t = Method ; RandomEngineWrapper () : engine_ (( * Singleton < std :: random_device >:: get_shared_instance ())()){} engine_method_t & get_engine () { return engine_ ; } private : engine_method_t engine_ ; }; } template < class Distribution , class EngineMethod = std :: mt19937 > class RandomGenerator : public Distribution { public : using distribution_t = Distribution ; using engine_method_t = EngineMethod ; template < typename ... Arg > RandomGenerator ( Arg ... arg ) : distribution_t ( arg ...) { engine_wrapper_ = Singleton < engine_t >:: get_shared_instance (); } typename distribution_t :: result_type value () { auto & dist = * ( distribution_t * )( this ); return dist ( engine_wrapper_ -> get_engine ()); } private : using engine_t = internal :: RandomEngineWrapper < engine_method_t > ; typename Singleton < engine_t >:: shared_t engine_wrapper_ ; }; using UniformIntRandomEngine = RandomGenerator < std :: uniform_int_distribution <>> ; using UniformRealRandomEngine = RandomGenerator < std :: uniform_real_distribution <>> ; using BernoulliRandomEngine = RandomGenerator < std :: bernoulli_distribution > ; using BinomialRandomEngine = RandomGenerator < std :: binomial_distribution <>> ; using GeometricRandomEngine = RandomGenerator < std :: geometric_distribution <>> ; using NegativeBinomialRandomEngine = RandomGenerator < std :: negative_binomial_distribution <>> ; using PoissonRandomEngine = RandomGenerator < std :: poisson_distribution <>> ; using ExponentialRandomEngine = RandomGenerator < std :: exponential_distribution <>> ; using GammaRandomEngine = RandomGenerator < std :: gamma_distribution <>> ; using WeibullRandomEngine = RandomGenerator < std :: weibull_distribution <>> ; using ExtremeValueRandomEngine = RandomGenerator < std :: extreme_value_distribution <>> ; using NormalRandomEngine = RandomGenerator < std :: normal_distribution <>> ; using LognormalRandomEngine = RandomGenerator < std :: lognormal_distribution <>> ; using ChiSquaredRandomEngine = RandomGenerator < std :: chi_squared_distribution <>> ; using CauchyRandomEngine = RandomGenerator < std :: cauchy_distribution <>> ; using FisherFRandomEngine = RandomGenerator < std :: fisher_f_distribution <>> ; using StudentTRandomEngine = RandomGenerator < std :: student_t_distribution <>> ; using DiscreteRandomEngine = RandomGenerator < std :: discrete_distribution <>> ; using PiecewiseConstantRandomEngine = RandomGenerator < std :: piecewise_constant_distribution <>> ; using PiecewiseLinearRandomEngine = RandomGenerator < std :: piecewise_linear_distribution <>> ; template < typename Real = double > static Real gererate_random () { using engine_t = internal :: RandomEngineWrapper < std :: mt19937 > ; auto engine_wrapper = Singleton < engine_t >:: get_shared_instance (); constexpr std :: size_t bits = std :: numeric_limits < Real >:: digits ; return std :: generate_canonical < Real , bits > ( engine_wrapper -> get_engine ()); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/random.hpp"},{"location":"doxybook/Files/random_8hpp/#includecpp_roboticsalgorithmrandomhpp","text":"","title":"include/cpp_robotics/algorithm/random.hpp"},{"location":"doxybook/Files/random_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/random_8hpp/#classes","text":"Name class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668","title":"Classes"},{"location":"doxybook/Files/random_8hpp/#source-code","text":"# pragma once #include <cmath> #include <random> #include \"../utility/singleton.hpp\" namespace cpp_robotics { namespace internal { template < class Method > class RandomEngineWrapper { public : using engine_method_t = Method ; RandomEngineWrapper () : engine_ (( * Singleton < std :: random_device >:: get_shared_instance ())()){} engine_method_t & get_engine () { return engine_ ; } private : engine_method_t engine_ ; }; } template < class Distribution , class EngineMethod = std :: mt19937 > class RandomGenerator : public Distribution { public : using distribution_t = Distribution ; using engine_method_t = EngineMethod ; template < typename ... Arg > RandomGenerator ( Arg ... arg ) : distribution_t ( arg ...) { engine_wrapper_ = Singleton < engine_t >:: get_shared_instance (); } typename distribution_t :: result_type value () { auto & dist = * ( distribution_t * )( this ); return dist ( engine_wrapper_ -> get_engine ()); } private : using engine_t = internal :: RandomEngineWrapper < engine_method_t > ; typename Singleton < engine_t >:: shared_t engine_wrapper_ ; }; using UniformIntRandomEngine = RandomGenerator < std :: uniform_int_distribution <>> ; using UniformRealRandomEngine = RandomGenerator < std :: uniform_real_distribution <>> ; using BernoulliRandomEngine = RandomGenerator < std :: bernoulli_distribution > ; using BinomialRandomEngine = RandomGenerator < std :: binomial_distribution <>> ; using GeometricRandomEngine = RandomGenerator < std :: geometric_distribution <>> ; using NegativeBinomialRandomEngine = RandomGenerator < std :: negative_binomial_distribution <>> ; using PoissonRandomEngine = RandomGenerator < std :: poisson_distribution <>> ; using ExponentialRandomEngine = RandomGenerator < std :: exponential_distribution <>> ; using GammaRandomEngine = RandomGenerator < std :: gamma_distribution <>> ; using WeibullRandomEngine = RandomGenerator < std :: weibull_distribution <>> ; using ExtremeValueRandomEngine = RandomGenerator < std :: extreme_value_distribution <>> ; using NormalRandomEngine = RandomGenerator < std :: normal_distribution <>> ; using LognormalRandomEngine = RandomGenerator < std :: lognormal_distribution <>> ; using ChiSquaredRandomEngine = RandomGenerator < std :: chi_squared_distribution <>> ; using CauchyRandomEngine = RandomGenerator < std :: cauchy_distribution <>> ; using FisherFRandomEngine = RandomGenerator < std :: fisher_f_distribution <>> ; using StudentTRandomEngine = RandomGenerator < std :: student_t_distribution <>> ; using DiscreteRandomEngine = RandomGenerator < std :: discrete_distribution <>> ; using PiecewiseConstantRandomEngine = RandomGenerator < std :: piecewise_constant_distribution <>> ; using PiecewiseLinearRandomEngine = RandomGenerator < std :: piecewise_linear_distribution <>> ; template < typename Real = double > static Real gererate_random () { using engine_t = internal :: RandomEngineWrapper < std :: mt19937 > ; auto engine_wrapper = Singleton < engine_t >:: get_shared_instance (); constexpr std :: size_t bits = std :: numeric_limits < Real >:: digits ; return std :: generate_canonical < Real , bits > ( engine_wrapper -> get_engine ()); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/robot__utils_8hpp/","text":"include/cpp_robotics/robots/robot_utils/robot_utils.hpp Namespaces Name cpp_robotics Source code #pragma once #include <type_traits> #include <memory> namespace cpp_robotics { template < class Interface , class UserInterface > struct is_base_of_robot_if { static constexpr bool value = std :: is_base_of < Interface , UserInterface >:: value ; }; template < class Interface , class UserInterface > static constexpr bool is_base_of_robot_if_v = is_base_of_robot_if < Interface , UserInterface >:: value ; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/robots/robot_utils/robot_utils.hpp"},{"location":"doxybook/Files/robot__utils_8hpp/#includecpp_roboticsrobotsrobot_utilsrobot_utilshpp","text":"","title":"include/cpp_robotics/robots/robot_utils/robot_utils.hpp"},{"location":"doxybook/Files/robot__utils_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/robot__utils_8hpp/#source-code","text":"#pragma once #include <type_traits> #include <memory> namespace cpp_robotics { template < class Interface , class UserInterface > struct is_base_of_robot_if { static constexpr bool value = std :: is_base_of < Interface , UserInterface >:: value ; }; template < class Interface , class UserInterface > static constexpr bool is_base_of_robot_if_v = is_base_of_robot_if < Interface , UserInterface >:: value ; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/shape_8hpp/","text":"include/cpp_robotics/geometry/shape.hpp Namespaces Name cpp_robotics Classes Name struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9 Source code #pragma once #include <array> #include \"../vector/vector2.hpp\" namespace cpp_robotics { struct Line ; struct Rect ; struct Quad ; struct Triangle ; struct Circle ; struct Line { Vector2d p0 , p1 ; Line () = default ; constexpr Line ( const Vector2d & p0 , const Vector2d & p1 ) : p0 ( p0 ), p1 ( p1 ) {} void set ( const Vector2d & p0_ , const Vector2d & p1_ ) { p0 = p0_ ; p1 = p1_ ;} constexpr float length () const { return ( p1 - p0 ). norm (); } constexpr float angle () const { return ( p1 - p0 ). angle (); } constexpr Vector2d lerp ( const float t ) const { return Vector2d :: lerp ( p0 , p1 , t ); } }; struct Rect { Vector2d pos ; // \u539f\u70b9\u5074\u306e\u9802\u70b9\u5ea7\u6a19 Vector2d size ; Rect () = default ; constexpr Rect ( const Vector2d & pos , const Vector2d & size ) : pos ( pos ), size ( size ) {} static constexpr Rect gen_center ( const Vector2d & center_pos , const Vector2d & size ) { return Rect ( center_pos - size / 2 , size ); } void set ( const Vector2d & pos_ , const Vector2d & size_ ) { pos = pos_ ; size = size_ ; } void set_center ( const Vector2d & pos_ , const Vector2d & size_ ) { pos = pos_ - size_ / 2 ; size = size_ ; } constexpr Vector2d center () const { return pos + 0.5f * size ; } constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { return size . x * size . y ; } constexpr std :: array < Vector2d , 4 > vertex () const { Vector2d tv ( size . x / 2 , size . y / 2 ); return { center () + tv , center () + tv . nxy (), center () - tv , center () + tv . xny () }; } constexpr std :: array < Line , 4 > outline () const { const auto vtx = vertex (); return { Line { vtx [ 0 ], vtx [ 1 ]}, Line { vtx [ 1 ], vtx [ 2 ]}, Line { vtx [ 2 ], vtx [ 3 ]}, Line { vtx [ 3 ], vtx [ 0 ]} }; } constexpr Quad as_quad () const ; constexpr Quad get_rotated ( float angle ) const ; }; struct Quad { Vector2d p0 , p1 , p2 , p3 ; Quad () = default ; constexpr Quad ( const std :: array < Vector2d , 4 > & points ) : p0 ( points [ 0 ]), p1 ( points [ 1 ]), p2 ( points [ 2 ]), p3 ( points [ 3 ]) {} constexpr Quad ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) : p0 ( p0 ), p1 ( p1 ), p2 ( p2 ), p3 ( p3 ) {} void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ , const Vector2d & p3_ ) { p0 = p0_ ; p1 = p1_ ; p2 = p2_ ; p3 = p3_ ; } constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { // \u4e09\u89d2\u5f62\u306e\u9762\u7a4d2\u500b // 01 02 const float a1 = std :: abs (( p2 . x - p0 . x ) * ( p1 . y - p0 . y ) - ( p1 . x - p0 . x ) * ( p2 . y - p0 . y )); // 31 32 const float a2 = std :: abs (( p2 . x - p3 . x ) * ( p1 . y - p3 . y ) - ( p1 . x - p3 . x ) * ( p2 . y - p3 . y )); return 0.5 * ( a1 + a2 ); } constexpr std :: array < Vector2d , 4 > vertex () const { return { p0 , p1 , p2 , p3 }; } constexpr std :: array < Line , 4 > outline () const { const auto vtx = vertex (); return { Line { vtx [ 0 ], vtx [ 1 ]}, Line { vtx [ 1 ], vtx [ 2 ]}, Line { vtx [ 2 ], vtx [ 3 ]}, Line { vtx [ 3 ], vtx [ 0 ]} }; } }; struct Triangle { Vector2d p0 , p1 , p2 ; Triangle () = default ; // constexpr Triangle(const std::array<Vector2d, 3> &points): points(points) {} constexpr Triangle ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 ) : p0 ( p0 ), p1 ( p1 ), p2 ( p2 ) {} void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ ) { p0 = p0_ ; p1 = p1_ ; p2 = p2_ ; } constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { return std :: abs (( p2 . x - p0 . x ) * ( p1 . y - p0 . y ) - ( p1 . x - p0 . x ) * ( p2 . y - p0 . y )) * 0.5 ; } constexpr std :: array < Vector2d , 3 > vertex () const { return { p0 , p1 , p2 }; } constexpr std :: array < Line , 3 > outline () const { const auto vtx = vertex (); return { Line { vtx [ 0 ], vtx [ 1 ]}, Line { vtx [ 1 ], vtx [ 2 ]}, Line { vtx [ 2 ], vtx [ 0 ]} }; } }; struct Circle { Vector2d center ; float r ; Circle () = default ; constexpr Circle ( const Vector2d & center , const float r ) : center ( center ), r ( r ) {} constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { return square ( r ) * PI ; } constexpr Vector2d angle_pos ( const float theta ) const { return center + Vector2d ( r * std :: cos ( theta ), r * std :: sin ( theta )); } }; } #include \"./shape.ipp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/geometry/shape.hpp"},{"location":"doxybook/Files/shape_8hpp/#includecpp_roboticsgeometryshapehpp","text":"","title":"include/cpp_robotics/geometry/shape.hpp"},{"location":"doxybook/Files/shape_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/shape_8hpp/#classes","text":"Name struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9","title":"Classes"},{"location":"doxybook/Files/shape_8hpp/#source-code","text":"#pragma once #include <array> #include \"../vector/vector2.hpp\" namespace cpp_robotics { struct Line ; struct Rect ; struct Quad ; struct Triangle ; struct Circle ; struct Line { Vector2d p0 , p1 ; Line () = default ; constexpr Line ( const Vector2d & p0 , const Vector2d & p1 ) : p0 ( p0 ), p1 ( p1 ) {} void set ( const Vector2d & p0_ , const Vector2d & p1_ ) { p0 = p0_ ; p1 = p1_ ;} constexpr float length () const { return ( p1 - p0 ). norm (); } constexpr float angle () const { return ( p1 - p0 ). angle (); } constexpr Vector2d lerp ( const float t ) const { return Vector2d :: lerp ( p0 , p1 , t ); } }; struct Rect { Vector2d pos ; // \u539f\u70b9\u5074\u306e\u9802\u70b9\u5ea7\u6a19 Vector2d size ; Rect () = default ; constexpr Rect ( const Vector2d & pos , const Vector2d & size ) : pos ( pos ), size ( size ) {} static constexpr Rect gen_center ( const Vector2d & center_pos , const Vector2d & size ) { return Rect ( center_pos - size / 2 , size ); } void set ( const Vector2d & pos_ , const Vector2d & size_ ) { pos = pos_ ; size = size_ ; } void set_center ( const Vector2d & pos_ , const Vector2d & size_ ) { pos = pos_ - size_ / 2 ; size = size_ ; } constexpr Vector2d center () const { return pos + 0.5f * size ; } constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { return size . x * size . y ; } constexpr std :: array < Vector2d , 4 > vertex () const { Vector2d tv ( size . x / 2 , size . y / 2 ); return { center () + tv , center () + tv . nxy (), center () - tv , center () + tv . xny () }; } constexpr std :: array < Line , 4 > outline () const { const auto vtx = vertex (); return { Line { vtx [ 0 ], vtx [ 1 ]}, Line { vtx [ 1 ], vtx [ 2 ]}, Line { vtx [ 2 ], vtx [ 3 ]}, Line { vtx [ 3 ], vtx [ 0 ]} }; } constexpr Quad as_quad () const ; constexpr Quad get_rotated ( float angle ) const ; }; struct Quad { Vector2d p0 , p1 , p2 , p3 ; Quad () = default ; constexpr Quad ( const std :: array < Vector2d , 4 > & points ) : p0 ( points [ 0 ]), p1 ( points [ 1 ]), p2 ( points [ 2 ]), p3 ( points [ 3 ]) {} constexpr Quad ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) : p0 ( p0 ), p1 ( p1 ), p2 ( p2 ), p3 ( p3 ) {} void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ , const Vector2d & p3_ ) { p0 = p0_ ; p1 = p1_ ; p2 = p2_ ; p3 = p3_ ; } constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { // \u4e09\u89d2\u5f62\u306e\u9762\u7a4d2\u500b // 01 02 const float a1 = std :: abs (( p2 . x - p0 . x ) * ( p1 . y - p0 . y ) - ( p1 . x - p0 . x ) * ( p2 . y - p0 . y )); // 31 32 const float a2 = std :: abs (( p2 . x - p3 . x ) * ( p1 . y - p3 . y ) - ( p1 . x - p3 . x ) * ( p2 . y - p3 . y )); return 0.5 * ( a1 + a2 ); } constexpr std :: array < Vector2d , 4 > vertex () const { return { p0 , p1 , p2 , p3 }; } constexpr std :: array < Line , 4 > outline () const { const auto vtx = vertex (); return { Line { vtx [ 0 ], vtx [ 1 ]}, Line { vtx [ 1 ], vtx [ 2 ]}, Line { vtx [ 2 ], vtx [ 3 ]}, Line { vtx [ 3 ], vtx [ 0 ]} }; } }; struct Triangle { Vector2d p0 , p1 , p2 ; Triangle () = default ; // constexpr Triangle(const std::array<Vector2d, 3> &points): points(points) {} constexpr Triangle ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 ) : p0 ( p0 ), p1 ( p1 ), p2 ( p2 ) {} void set ( const Vector2d & p0_ , const Vector2d & p1_ , const Vector2d & p2_ ) { p0 = p0_ ; p1 = p1_ ; p2 = p2_ ; } constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { return std :: abs (( p2 . x - p0 . x ) * ( p1 . y - p0 . y ) - ( p1 . x - p0 . x ) * ( p2 . y - p0 . y )) * 0.5 ; } constexpr std :: array < Vector2d , 3 > vertex () const { return { p0 , p1 , p2 }; } constexpr std :: array < Line , 3 > outline () const { const auto vtx = vertex (); return { Line { vtx [ 0 ], vtx [ 1 ]}, Line { vtx [ 1 ], vtx [ 2 ]}, Line { vtx [ 2 ], vtx [ 0 ]} }; } }; struct Circle { Vector2d center ; float r ; Circle () = default ; constexpr Circle ( const Vector2d & center , const float r ) : center ( center ), r ( r ) {} constexpr bool has_area () const { return ! approx_zero ( area ()); } constexpr float area () const { return square ( r ) * PI ; } constexpr Vector2d angle_pos ( const float theta ) const { return center + Vector2d ( r * std :: cos ( theta ), r * std :: sin ( theta )); } }; } #include \"./shape.ipp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/shape_8ipp/","text":"include/cpp_robotics/geometry/shape.ipp Namespaces Name cpp_robotics Source code namespace cpp_robotics { constexpr Quad Rect::as_quad () const { return Quad { vertex ()}; } constexpr Quad Rect::get_rotated ( float angle ) const { const Vector2d tv ( size . x / 2 , size . y / 2 ); return Quad { center () + tv . get_rotated ( angle ), center () + tv . nxy (). get_rotated ( angle ), center () + - tv . get_rotated ( angle ), center () + tv . xny (). get_rotated ( angle ) }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/geometry/shape.ipp"},{"location":"doxybook/Files/shape_8ipp/#includecpp_roboticsgeometryshapeipp","text":"","title":"include/cpp_robotics/geometry/shape.ipp"},{"location":"doxybook/Files/shape_8ipp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/shape_8ipp/#source-code","text":"namespace cpp_robotics { constexpr Quad Rect::as_quad () const { return Quad { vertex ()}; } constexpr Quad Rect::get_rotated ( float angle ) const { const Vector2d tv ( size . x / 2 , size . y / 2 ); return Quad { center () + tv . get_rotated ( angle ), center () + tv . nxy (). get_rotated ( angle ), center () + - tv . get_rotated ( angle ), center () + tv . xny (). get_rotated ( angle ) }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/si__unit_8hpp/","text":"include/cpp_robotics/units/si_unit.hpp Namespaces Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::unit_dimention unit_dim_assem Source code #pragma once #include \"./unit_core.hpp\" namespace cpp_robotics { inline namespace unit { namespace unit_dimention { using no_dimention = UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 0 > ; // \u57fa\u672c\u5358\u4f4d using metere = UnitType < 1 , 0 , 0 , 0 , 0 , 0 , 0 > ; using kilogram = UnitType < 0 , 1 , 0 , 0 , 0 , 0 , 0 > ; using second = UnitType < 0 , 0 , 1 , 0 , 0 , 0 , 0 > ; using ampere = UnitType < 0 , 0 , 0 , 1 , 0 , 0 , 0 > ; using kelvin = UnitType < 0 , 0 , 0 , 0 , 1 , 0 , 0 > ; using mole = UnitType < 0 , 0 , 0 , 0 , 0 , 1 , 0 > ; using candela = UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 1 > ; using namespace unit_dim_assem ; // \u7d44\u7acb\u5358\u4f4d using area = udim_pow < metere , 2 >:: unit ; using volume = udim_pow < metere , 3 >:: unit ; using velocity = udim_div < metere , second >:: unit ; using acceleration = udim_div < velocity , second >:: unit ; using dencity = udim_div < kilogram , volume >:: unit ; using angle = udim_div < metere , metere >:: unit ; using hertz = udim_inv < second >:: unit ; using newton = udim_div < udim_mul < metere , kilogram >:: unit , udim_pow < second , 2 >:: unit >:: unit ; using pascal = udim_div < newton , area >:: unit ; using viscosity = udim_mul < pascal , second >:: unit ; using joule = udim_mul < newton , metere >:: unit ; using watt = udim_div < joule , second >:: unit ; using volt = udim_div < watt , ampere >:: unit ; using coulomb = udim_mul < second , ampere >:: unit ; using farad = udim_div < coulomb , volt >:: unit ; using ohm = udim_div < volt , ampere >:: unit ; using weber = udim_mul < volt , second >:: unit ; using henry = udim_div < weber , ampere >:: unit ; using torque = udim_mul < newton , metere >:: unit ; using inertia = udim_mul < kilogram , area >:: unit ; using angular_velocity = udim_div < angle , second >:: unit ; using angular_acceleration = udim_div < angular_velocity , second >:: unit ; } using Second = Unit < double , unit_dimention :: second , prefix :: none > ; using MilliSecond = Unit < double , unit_dimention :: second , prefix :: milli > ; using MicroSecond = Unit < double , unit_dimention :: second , prefix :: micro > ; using Meter = Unit < double , unit_dimention :: metere , prefix :: none > ; using MilliMeter = Unit < double , unit_dimention :: metere , prefix :: milli > ; using MicroMeter = Unit < double , unit_dimention :: metere , prefix :: micro > ; using CentiMeter = Unit < double , unit_dimention :: metere , prefix :: centi > ; using KiloGram = Unit < double , unit_dimention :: kilogram , prefix :: none > ; using Gram = Unit < double , unit_dimention :: kilogram , prefix :: milli > ; using Watt = Unit < double , unit_dimention :: watt , prefix :: none > ; using KiloWatt = Unit < double , unit_dimention :: watt , prefix :: kilo > ; using Newton = Unit < double , unit_dimention :: newton , prefix :: none > ; using KiloNewton = Unit < double , unit_dimention :: newton , prefix :: kilo > ; using Pascal = Unit < double , unit_dimention :: pascal , prefix :: none > ; using KiloPascal = Unit < double , unit_dimention :: pascal , prefix :: kilo > ; using Hertz = Unit < double , unit_dimention :: hertz , prefix :: none > ; // using Area = Unit < double , unit_dimention :: area , prefix :: none > ; using Volume = Unit < double , unit_dimention :: volume , prefix :: none > ; using Velocity = Unit < double , unit_dimention :: velocity , prefix :: none > ; using Acceleration = Unit < double , unit_dimention :: acceleration , prefix :: none > ; using Dencity = Unit < double , unit_dimention :: dencity , prefix :: none > ; using Torque = Unit < double , unit_dimention :: torque , prefix :: none > ; using Inertia = Unit < double , unit_dimention :: inertia , prefix :: none > ; // \u96fb\u6c17\u7cfb using Ampere = Unit < double , unit_dimention :: ampere , prefix :: none > ; using MilliAmpere = Unit < double , unit_dimention :: ampere , prefix :: milli > ; using Volt = Unit < double , unit_dimention :: volt , prefix :: none > ; using MilliVolt = Unit < double , unit_dimention :: volt , prefix :: milli > ; using Ohm = Unit < double , unit_dimention :: ohm , prefix :: none > ; using MilliOhm = Unit < double , unit_dimention :: ohm , prefix :: milli > ; using Henry = Unit < double , unit_dimention :: henry , prefix :: none > ; using MilliHenry = Unit < double , unit_dimention :: henry , prefix :: milli > ; using Farad = Unit < double , unit_dimention :: farad , prefix :: none > ; using MilliFarad = Unit < double , unit_dimention :: farad , prefix :: milli > ; using MicroFarad = Unit < double , unit_dimention :: farad , prefix :: micro > ; using NanoFarad = Unit < double , unit_dimention :: farad , prefix :: nano > ; // \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6 using Radian = Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: radian > ; using Degree = Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: degree > ; using AngularVelocity = Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rad_per_sec > ; using Rps = Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rps > ; using Rpm = Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rpm > ; using AngularAcceleration = Unit < double , unit_dimention :: angular_acceleration , prefix :: none > ; GENERATE_CONV_FACTOR ( unit_dimention :: angle , tag :: angle :: radian , tag :: angle :: degree , 180.0f / M_PI ) GENERATE_CONV_FACTOR ( unit_dimention :: angle , tag :: angle :: degree , tag :: angle :: radian , M_PI / 180.0f ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rad_per_sec , tag :: angular_vel :: rps , 1.0f / ( 2 * M_PI )) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rad_per_sec , tag :: angular_vel :: rpm , 30.0f / M_PI ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rps , tag :: angular_vel :: rad_per_sec , ( 2 * M_PI )) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rps , tag :: angular_vel :: rpm , 60.0f ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rpm , tag :: angular_vel :: rps , 1 / 60.0f ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rpm , tag :: angular_vel :: rad_per_sec , M_PI / 30.0f ) } } // suffix GENERATE_UNIT_SUFFIX ( cpp_robotics :: Second , s ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliSecond , ms ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MicroSecond , us ) GENERATE_UNIT_PFX_SUFFIX ( cpp_robotics :: Meter , prefix :: kilo , km ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Meter , m ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: CentiMeter , cm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliMeter , mm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloGram , kg ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Gram , g ) // GENERATE_UNIT_SUFFIX ( cpp_robotics :: Watt , W ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloWatt , kW ) #ifdef UNIT_NEWTON_ENABLE // \"_N\"\u3063\u3066\u540d\u524d\u306e\u30de\u30af\u30ed\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u308b\u306e\u3067\u305d\u306e\u307e\u307e\u3060\u3068\u4f7f\u3048\u306a\u3044 #undef _N GENERATE_UNIT_SUFFIX ( cpp_robotics :: Newton , N ) #endif // UNIT_NEWTON_ENABLE GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloNewton , kN ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Pascal , Pa ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloPascal , kPa ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Torque , Nm ) GENERATE_UNIT_PFX_SUFFIX ( cpp_robotics :: Torque , prefix :: milli , mmNm ) // \u56de\u8def GENERATE_UNIT_SUFFIX ( cpp_robotics :: Ampere , A ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliAmpere , mA ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Volt , V ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliVolt , mV ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Ohm , ohm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliOhm , mohm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Henry , H ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliHenry , mH ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Farad , F ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliFarad , mF ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MicroFarad , uF ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: NanoFarad , nF ) // \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6 GENERATE_UNIT_SUFFIX ( cpp_robotics :: Radian , rad ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Degree , deg ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: AngularVelocity , rad_per_sec ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Rpm , rpm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Rps , rps ) Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/units/si_unit.hpp"},{"location":"doxybook/Files/si__unit_8hpp/#includecpp_roboticsunitssi_unithpp","text":"","title":"include/cpp_robotics/units/si_unit.hpp"},{"location":"doxybook/Files/si__unit_8hpp/#namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::unit_dimention unit_dim_assem","title":"Namespaces"},{"location":"doxybook/Files/si__unit_8hpp/#source-code","text":"#pragma once #include \"./unit_core.hpp\" namespace cpp_robotics { inline namespace unit { namespace unit_dimention { using no_dimention = UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 0 > ; // \u57fa\u672c\u5358\u4f4d using metere = UnitType < 1 , 0 , 0 , 0 , 0 , 0 , 0 > ; using kilogram = UnitType < 0 , 1 , 0 , 0 , 0 , 0 , 0 > ; using second = UnitType < 0 , 0 , 1 , 0 , 0 , 0 , 0 > ; using ampere = UnitType < 0 , 0 , 0 , 1 , 0 , 0 , 0 > ; using kelvin = UnitType < 0 , 0 , 0 , 0 , 1 , 0 , 0 > ; using mole = UnitType < 0 , 0 , 0 , 0 , 0 , 1 , 0 > ; using candela = UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 1 > ; using namespace unit_dim_assem ; // \u7d44\u7acb\u5358\u4f4d using area = udim_pow < metere , 2 >:: unit ; using volume = udim_pow < metere , 3 >:: unit ; using velocity = udim_div < metere , second >:: unit ; using acceleration = udim_div < velocity , second >:: unit ; using dencity = udim_div < kilogram , volume >:: unit ; using angle = udim_div < metere , metere >:: unit ; using hertz = udim_inv < second >:: unit ; using newton = udim_div < udim_mul < metere , kilogram >:: unit , udim_pow < second , 2 >:: unit >:: unit ; using pascal = udim_div < newton , area >:: unit ; using viscosity = udim_mul < pascal , second >:: unit ; using joule = udim_mul < newton , metere >:: unit ; using watt = udim_div < joule , second >:: unit ; using volt = udim_div < watt , ampere >:: unit ; using coulomb = udim_mul < second , ampere >:: unit ; using farad = udim_div < coulomb , volt >:: unit ; using ohm = udim_div < volt , ampere >:: unit ; using weber = udim_mul < volt , second >:: unit ; using henry = udim_div < weber , ampere >:: unit ; using torque = udim_mul < newton , metere >:: unit ; using inertia = udim_mul < kilogram , area >:: unit ; using angular_velocity = udim_div < angle , second >:: unit ; using angular_acceleration = udim_div < angular_velocity , second >:: unit ; } using Second = Unit < double , unit_dimention :: second , prefix :: none > ; using MilliSecond = Unit < double , unit_dimention :: second , prefix :: milli > ; using MicroSecond = Unit < double , unit_dimention :: second , prefix :: micro > ; using Meter = Unit < double , unit_dimention :: metere , prefix :: none > ; using MilliMeter = Unit < double , unit_dimention :: metere , prefix :: milli > ; using MicroMeter = Unit < double , unit_dimention :: metere , prefix :: micro > ; using CentiMeter = Unit < double , unit_dimention :: metere , prefix :: centi > ; using KiloGram = Unit < double , unit_dimention :: kilogram , prefix :: none > ; using Gram = Unit < double , unit_dimention :: kilogram , prefix :: milli > ; using Watt = Unit < double , unit_dimention :: watt , prefix :: none > ; using KiloWatt = Unit < double , unit_dimention :: watt , prefix :: kilo > ; using Newton = Unit < double , unit_dimention :: newton , prefix :: none > ; using KiloNewton = Unit < double , unit_dimention :: newton , prefix :: kilo > ; using Pascal = Unit < double , unit_dimention :: pascal , prefix :: none > ; using KiloPascal = Unit < double , unit_dimention :: pascal , prefix :: kilo > ; using Hertz = Unit < double , unit_dimention :: hertz , prefix :: none > ; // using Area = Unit < double , unit_dimention :: area , prefix :: none > ; using Volume = Unit < double , unit_dimention :: volume , prefix :: none > ; using Velocity = Unit < double , unit_dimention :: velocity , prefix :: none > ; using Acceleration = Unit < double , unit_dimention :: acceleration , prefix :: none > ; using Dencity = Unit < double , unit_dimention :: dencity , prefix :: none > ; using Torque = Unit < double , unit_dimention :: torque , prefix :: none > ; using Inertia = Unit < double , unit_dimention :: inertia , prefix :: none > ; // \u96fb\u6c17\u7cfb using Ampere = Unit < double , unit_dimention :: ampere , prefix :: none > ; using MilliAmpere = Unit < double , unit_dimention :: ampere , prefix :: milli > ; using Volt = Unit < double , unit_dimention :: volt , prefix :: none > ; using MilliVolt = Unit < double , unit_dimention :: volt , prefix :: milli > ; using Ohm = Unit < double , unit_dimention :: ohm , prefix :: none > ; using MilliOhm = Unit < double , unit_dimention :: ohm , prefix :: milli > ; using Henry = Unit < double , unit_dimention :: henry , prefix :: none > ; using MilliHenry = Unit < double , unit_dimention :: henry , prefix :: milli > ; using Farad = Unit < double , unit_dimention :: farad , prefix :: none > ; using MilliFarad = Unit < double , unit_dimention :: farad , prefix :: milli > ; using MicroFarad = Unit < double , unit_dimention :: farad , prefix :: micro > ; using NanoFarad = Unit < double , unit_dimention :: farad , prefix :: nano > ; // \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6 using Radian = Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: radian > ; using Degree = Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: degree > ; using AngularVelocity = Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rad_per_sec > ; using Rps = Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rps > ; using Rpm = Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rpm > ; using AngularAcceleration = Unit < double , unit_dimention :: angular_acceleration , prefix :: none > ; GENERATE_CONV_FACTOR ( unit_dimention :: angle , tag :: angle :: radian , tag :: angle :: degree , 180.0f / M_PI ) GENERATE_CONV_FACTOR ( unit_dimention :: angle , tag :: angle :: degree , tag :: angle :: radian , M_PI / 180.0f ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rad_per_sec , tag :: angular_vel :: rps , 1.0f / ( 2 * M_PI )) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rad_per_sec , tag :: angular_vel :: rpm , 30.0f / M_PI ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rps , tag :: angular_vel :: rad_per_sec , ( 2 * M_PI )) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rps , tag :: angular_vel :: rpm , 60.0f ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rpm , tag :: angular_vel :: rps , 1 / 60.0f ) GENERATE_CONV_FACTOR ( unit_dimention :: angular_velocity , tag :: angular_vel :: rpm , tag :: angular_vel :: rad_per_sec , M_PI / 30.0f ) } } // suffix GENERATE_UNIT_SUFFIX ( cpp_robotics :: Second , s ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliSecond , ms ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MicroSecond , us ) GENERATE_UNIT_PFX_SUFFIX ( cpp_robotics :: Meter , prefix :: kilo , km ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Meter , m ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: CentiMeter , cm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliMeter , mm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloGram , kg ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Gram , g ) // GENERATE_UNIT_SUFFIX ( cpp_robotics :: Watt , W ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloWatt , kW ) #ifdef UNIT_NEWTON_ENABLE // \"_N\"\u3063\u3066\u540d\u524d\u306e\u30de\u30af\u30ed\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u308b\u306e\u3067\u305d\u306e\u307e\u307e\u3060\u3068\u4f7f\u3048\u306a\u3044 #undef _N GENERATE_UNIT_SUFFIX ( cpp_robotics :: Newton , N ) #endif // UNIT_NEWTON_ENABLE GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloNewton , kN ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Pascal , Pa ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: KiloPascal , kPa ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Torque , Nm ) GENERATE_UNIT_PFX_SUFFIX ( cpp_robotics :: Torque , prefix :: milli , mmNm ) // \u56de\u8def GENERATE_UNIT_SUFFIX ( cpp_robotics :: Ampere , A ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliAmpere , mA ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Volt , V ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliVolt , mV ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Ohm , ohm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliOhm , mohm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Henry , H ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliHenry , mH ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Farad , F ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MilliFarad , mF ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: MicroFarad , uF ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: NanoFarad , nF ) // \u89d2\u5ea6\u3001\u89d2\u901f\u5ea6 GENERATE_UNIT_SUFFIX ( cpp_robotics :: Radian , rad ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Degree , deg ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: AngularVelocity , rad_per_sec ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Rpm , rpm ) GENERATE_UNIT_SUFFIX ( cpp_robotics :: Rps , rps ) Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/singleton_8hpp/","text":"include/cpp_robotics/utility/singleton.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b Source code #pragma once #include <memory> namespace cpp_robotics { template < class T > class Singleton { private : Singleton () = default ; public : using class_t = T ; using shared_t = std :: shared_ptr < class_t > ; static shared_t get_shared_instance () { static shared_t instance = std :: make_shared < class_t > (); return instance ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/utility/singleton.hpp"},{"location":"doxybook/Files/singleton_8hpp/#includecpp_roboticsutilitysingletonhpp","text":"","title":"include/cpp_robotics/utility/singleton.hpp"},{"location":"doxybook/Files/singleton_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/singleton_8hpp/#classes","text":"Name class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b","title":"Classes"},{"location":"doxybook/Files/singleton_8hpp/#source-code","text":"#pragma once #include <memory> namespace cpp_robotics { template < class T > class Singleton { private : Singleton () = default ; public : using class_t = T ; using shared_t = std :: shared_ptr < class_t > ; static shared_t get_shared_instance () { static shared_t instance = std :: make_shared < class_t > (); return instance ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/siso__system_8hpp/","text":"include/cpp_robotics/system/siso_system.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 struct cpp_robotics::SisoFeedbackSystem::func_list_t Source code #pragma once #include <functional> #include <any> #include \"../controller/pid.hpp\" #include \"../controller/nctf.hpp\" #include \"./transfer_function.hpp\" /* x_r + x ----->*-->| C |-->| G |---*---> -| | ---------<----------- x_r: \u76ee\u6a19\u5024 x: \u72b6\u614b C: \u5236\u5fa1\u5668 G: \u30d7\u30e9\u30f3\u30c8 */ namespace cpp_robotics { class SisoFeedbackSystem { public : struct func_list_t { // C std :: function < void ( void ) > controller_reset ; std :: function < double ( double ) > controller ; // std::any controller_obj; // G std :: function < void ( void ) > system_reset ; std :: function < double ( double ) > system ; // std::any system_obj; }; SisoFeedbackSystem () = default ; SisoFeedbackSystem ( func_list_t fn ) : func_list_ ( fn ) {} void reset () { u_ = 0 ; y_ = 0 ; func_list_ . controller_reset (); func_list_ . system_reset (); } double control ( double target ) { u_ = func_list_ . controller ( target - y_ ); y_ = func_list_ . system ( u_ ); return y_ ; } double u () const { return u_ ; } double y () const { return y_ ; } std :: function < double ( double ) > make_control_function () { return [ this ]( double target ){ return control ( target ); }; } operator std :: function < double ( double ) > () { return make_control_function (); } private : double u_ = 0 ; double y_ = 0 ; func_list_t func_list_ ; }; template < class CONTROLLER_T , class SYSTEM_T > static SisoFeedbackSystem make_feedback_system ( CONTROLLER_T & controller , SYSTEM_T & system ) { SisoFeedbackSystem :: func_list_t fn ; set_controller ( fn , controller ); set_system ( fn , system ); return SisoFeedbackSystem ( fn ); } static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , PIDController & controller ) { // fn.controller_obj = controller; fn . controller_reset = [ & ](){ controller . reset (); }; fn . controller = [ & ]( double e ){ return controller . calculate ( e ); }; } static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , NctfController & controller ) { // fn.controller_obj = controller; fn . controller_reset = [ & ](){ controller . reset (); }; fn . controller = [ & ]( double e ){ return controller . control ( e ); }; } static void set_system ( SisoFeedbackSystem :: func_list_t & fn , TransferFunction & system ) { // fn.system_obj = system; fn . system_reset = [ & ](){ return system . set_state_zero (); }; fn . system = [ & ]( double u ){ return system . responce ( u ); }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/siso_system.hpp"},{"location":"doxybook/Files/siso__system_8hpp/#includecpp_roboticssystemsiso_systemhpp","text":"","title":"include/cpp_robotics/system/siso_system.hpp"},{"location":"doxybook/Files/siso__system_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/siso__system_8hpp/#classes","text":"Name class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 struct cpp_robotics::SisoFeedbackSystem::func_list_t","title":"Classes"},{"location":"doxybook/Files/siso__system_8hpp/#source-code","text":"#pragma once #include <functional> #include <any> #include \"../controller/pid.hpp\" #include \"../controller/nctf.hpp\" #include \"./transfer_function.hpp\" /* x_r + x ----->*-->| C |-->| G |---*---> -| | ---------<----------- x_r: \u76ee\u6a19\u5024 x: \u72b6\u614b C: \u5236\u5fa1\u5668 G: \u30d7\u30e9\u30f3\u30c8 */ namespace cpp_robotics { class SisoFeedbackSystem { public : struct func_list_t { // C std :: function < void ( void ) > controller_reset ; std :: function < double ( double ) > controller ; // std::any controller_obj; // G std :: function < void ( void ) > system_reset ; std :: function < double ( double ) > system ; // std::any system_obj; }; SisoFeedbackSystem () = default ; SisoFeedbackSystem ( func_list_t fn ) : func_list_ ( fn ) {} void reset () { u_ = 0 ; y_ = 0 ; func_list_ . controller_reset (); func_list_ . system_reset (); } double control ( double target ) { u_ = func_list_ . controller ( target - y_ ); y_ = func_list_ . system ( u_ ); return y_ ; } double u () const { return u_ ; } double y () const { return y_ ; } std :: function < double ( double ) > make_control_function () { return [ this ]( double target ){ return control ( target ); }; } operator std :: function < double ( double ) > () { return make_control_function (); } private : double u_ = 0 ; double y_ = 0 ; func_list_t func_list_ ; }; template < class CONTROLLER_T , class SYSTEM_T > static SisoFeedbackSystem make_feedback_system ( CONTROLLER_T & controller , SYSTEM_T & system ) { SisoFeedbackSystem :: func_list_t fn ; set_controller ( fn , controller ); set_system ( fn , system ); return SisoFeedbackSystem ( fn ); } static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , PIDController & controller ) { // fn.controller_obj = controller; fn . controller_reset = [ & ](){ controller . reset (); }; fn . controller = [ & ]( double e ){ return controller . calculate ( e ); }; } static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , NctfController & controller ) { // fn.controller_obj = controller; fn . controller_reset = [ & ](){ controller . reset (); }; fn . controller = [ & ]( double e ){ return controller . control ( e ); }; } static void set_system ( SisoFeedbackSystem :: func_list_t & fn , TransferFunction & system ) { // fn.system_obj = system; fn . system_reset = [ & ](){ return system . set_state_zero (); }; fn . system = [ & ]( double u ){ return system . responce ( u ); }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/space_8hpp/","text":"include/cpp_robotics/utility/space.hpp Namespaces Name cpp_robotics Source code #pragma once #include <cmath> #include <vector> #include <functional> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { static std :: vector < double > arrange ( double start , double end , double step = 1.0 ) { std :: vector < double > vec ( std :: floor ( ( end - start ) / step )); for ( size_t i = 0 ; i < vec . size (); i ++ ) { vec [ i ] = start + step * i ; } return vec ; } static std :: vector < double > linspace ( double start , double end , size_t n = 100 ) { std :: vector < double > vec ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vec [ i ] = lerp ( start , end , static_cast < double > ( i ) / ( n -1 )); } return vec ; } static std :: vector < double > logspace ( double start , double end , size_t n = 100 ) { std :: vector < double > vec ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vec [ i ] = std :: pow ( 10.0 , lerp ( start , end , static_cast < double > ( i ) / ( n -1 ))); } return vec ; } static std :: vector < double > funcspace ( std :: function < double ( size_t , size_t ) > f , size_t n = 100 ) { std :: vector < double > vec ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vec [ i ] = f ( i , n ); } return vec ; } // \u4ed5\u69d8\u304c\u66d6\u6627\u3059\u304e\u308b static std :: vector < double > sinspace ( double a , double b , size_t n = 100 ) { return funcspace ([ a , b ]( size_t i , size_t n_ ){ ( void ) n_ ; return a * std::sin ( b * i ); }, n ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/utility/space.hpp"},{"location":"doxybook/Files/space_8hpp/#includecpp_roboticsutilityspacehpp","text":"","title":"include/cpp_robotics/utility/space.hpp"},{"location":"doxybook/Files/space_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/space_8hpp/#source-code","text":"#pragma once #include <cmath> #include <vector> #include <functional> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { static std :: vector < double > arrange ( double start , double end , double step = 1.0 ) { std :: vector < double > vec ( std :: floor ( ( end - start ) / step )); for ( size_t i = 0 ; i < vec . size (); i ++ ) { vec [ i ] = start + step * i ; } return vec ; } static std :: vector < double > linspace ( double start , double end , size_t n = 100 ) { std :: vector < double > vec ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vec [ i ] = lerp ( start , end , static_cast < double > ( i ) / ( n -1 )); } return vec ; } static std :: vector < double > logspace ( double start , double end , size_t n = 100 ) { std :: vector < double > vec ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vec [ i ] = std :: pow ( 10.0 , lerp ( start , end , static_cast < double > ( i ) / ( n -1 ))); } return vec ; } static std :: vector < double > funcspace ( std :: function < double ( size_t , size_t ) > f , size_t n = 100 ) { std :: vector < double > vec ( n ); for ( size_t i = 0 ; i < n ; i ++ ) { vec [ i ] = f ( i , n ); } return vec ; } // \u4ed5\u69d8\u304c\u66d6\u6627\u3059\u304e\u308b static std :: vector < double > sinspace ( double a , double b , size_t n = 100 ) { return funcspace ([ a , b ]( size_t i , size_t n_ ){ ( void ) n_ ; return a * std::sin ( b * i ); }, n ); } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/spline_8hpp/","text":"include/cpp_robotics/spline/spline.hpp Namespaces Name cpp_robotics cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 Classes Name struct cpp_robotics::spline::spline_c class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda Source code #include <iostream> #include <cstdlib> #include <cassert> #include <string> #include <cmath> #include <vector> #include \"../utility/math_utils.hpp\" #include \"../vector/vector2.hpp\" #include \"../vector/vector4.hpp\" namespace cpp_robotics { namespace spline { struct spline_c { Vector4d xb , yb ; }; spline_c bezier_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) { return { Vector4d { p0 . x , p1 . x , p2 . x , p3 . x }, Vector4d { p0 . y , p1 . y , p2 . y , p3 . y }}; } spline_c hermite_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & v0 , const Vector2d & v1 ) { Vector2d bp1 = p0 + ( 1.0 / 3.0 ) * v0 ; Vector2d bp2 = p1 - ( 1.0 / 3.0 ) * v1 ; return bezier_spline ( p0 , bp1 , bp2 , p1 ); } spline_c catumull_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) { Vector2d bp1 = p1 + ( 1.0 / 6.0 ) * ( p2 - p0 ); Vector2d bp2 = p2 - ( 1.0 / 6.0 ) * ( p3 - p1 ); return bezier_spline ( p1 , bp1 , bp2 , p2 ); } // f(t) = a t^3 + b t^2 + c t + d -> bezier spline_c cubic_function_to_bezier ( const Vector2d & a , const Vector2d & b , const Vector2d & c , const Vector2d & d ) { Vector2d bp1 = d + ( 1.0 / 3.0 ) * c ; Vector2d bp2 = ( 1.0 / 3.0 ) * b + ( 2.0 / 3.0 ) * c + d ; Vector2d bp3 = a + b + c + d ; return bezier_spline ( d , bp1 , bp2 , bp3 ); } Vector4d bezier_weight ( const double t ) { double s = 1.0 - t ; double t2 = t * t ; double t3 = t2 * t ; double s2 = s * s ; double s3 = s2 * s ; return Vector4d ( s3 , 3.0 * s2 * t , 3.0 * s * t2 , t3 ); } Vector4d bezier_weight ( const Vector4d t ) { return Vector4d ( t . x - 3.0 * t . y + 3.0 * t . z - t . w , 3.0 * t . y - 6.0 * t . z + 3.0 * t . w , 3.0 * t . z - 3.0 * t . w , t . w ); } inline Vector2d evaluate ( const spline_c & spline , const Vector4d & w ) { return { Vector4d :: dot ( spline . xb , w ), Vector4d :: dot ( spline . yb , w )}; } Vector2d position ( const spline_c & spline , double t ) { return evaluate ( spline , bezier_weight ( t )); } Vector2d velocity ( const spline_c & spline , double t ) { Vector4d dt ( 0.0 , 1.0 , 2.0 * t , 3.0 * t * t ); return evaluate ( spline , bezier_weight ( dt )); } Vector2d acceleration ( const spline_c & spline , double t ) { Vector4d dt ( 0.0 , 0.0 , 2.0 , 6.0 * t ); return evaluate ( spline , bezier_weight ( t )); } inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 , double t ) { // assumption: seg = (P0, P1, P2, P3) double q0 = lerp ( spline . x , spline . y , t ); double q1 = lerp ( spline . y , spline . z , t ); double q2 = lerp ( spline . z , spline . w , t ); double r0 = lerp ( q0 , q1 , t ); double r1 = lerp ( q1 , q2 , t ); double s0 = lerp ( r0 , r1 , t ); double sx = spline . x ; // support aliasing double sw = spline . w ; spline0 = Vector4d ( sx , q0 , r0 , s0 ); spline1 = Vector4d ( s0 , r1 , q2 , sw ); } // Optimised for t=0.5 inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 ) { double q0 = ( spline . x + spline . y ) * 0.5 ; // x + y / 2 double q1 = ( spline . y + spline . z ) * 0.5 ; // y + z / 2 double q2 = ( spline . z + spline . w ) * 0.5 ; // z + w / 2 double r0 = ( q0 + q1 ) * 0.5 ; // x + 2y + z / 4 double r1 = ( q1 + q2 ) * 0.5 ; // y + 2z + w / 4 double s0 = ( r0 + r1 ) * 0.5 ; // q0 + 2q1 + q2 / 4 = x+y + 2(y+z) + z+w / 8 = x + 3y + 3z + w double sx = spline . x ; // support aliasing double sw = spline . w ; spline0 = Vector4d ( sx , q0 , r0 , s0 ); spline1 = Vector4d ( s0 , r1 , q2 , sw ); } void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 ) { split ( spline . xb , spline0 . xb , spline1 . xb ); split ( spline . yb , spline0 . yb , spline1 . yb ); } void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 , double t ) { split ( spline . xb , spline0 . xb , spline1 . xb , t ); split ( spline . yb , spline0 . yb , spline1 . yb , t ); } double length_estimate ( const spline_c & s , double * error ) { // Our convex hull is p0, p1, p2, p3, so p0_p3 is our minimum possible length, and p0_p1 + p1_p2 + p2_p3 our maximum. double d03 = square ( s . xb . x - s . xb . w ) + square ( s . yb . x - s . yb . w ); double d01 = square ( s . xb . x - s . xb . y ) + square ( s . yb . x - s . yb . y ); double d12 = square ( s . xb . y - s . xb . z ) + square ( s . yb . y - s . yb . z ); double d23 = square ( s . xb . z - s . xb . w ) + square ( s . yb . z - s . yb . w ); double minLength = std :: sqrt ( d03 ); double maxLength = std :: sqrt ( d01 ) + std :: sqrt ( d12 ) + std :: sqrt ( d23 ); minLength *= 0.5 ; maxLength *= 0.5 ; * error = maxLength - minLength ; return minLength + maxLength ; } double length ( const spline_c & s , double maxError ) { double error ; double len = length_estimate ( s , & error ); if ( error > maxError ) { spline_c s0 ; spline_c s1 ; split ( s , s0 , s1 ); return length ( s0 , maxError ) + length ( s1 , maxError ); } return len ; } double length ( const spline_c & s , double t0 , double t1 , double maxError ) { assert ( t0 >= 0.0 && t0 < 1.0 ); assert ( t1 >= 0.0 && t1 <= 1.0 ); assert ( t0 <= t1 ); spline_c s0 , s1 ; if ( t0 == 0.0 ) { if ( t1 == 1.0 ) return length ( s , maxError ); split ( s , s0 , s1 , t1 ); return length ( s0 , maxError ); } else { split ( s , s0 , s1 , t0 ); if ( t1 == 1.0 ) return length ( s1 , maxError ); split ( s1 , s0 , s1 , ( t1 - t0 ) / ( 1.0 - t0 )); return length ( s0 , maxError ); } } double curvature ( const spline_c & spline , double t ) { Vector2d v = velocity ( spline , t ); Vector2d a = acceleration ( spline , t ); double avCrossLen = std :: abs ( v . x * a . y - v . y * a . x ); double vLen = v . norm (); if ( vLen == 0.0 ) return 1e10 ; return avCrossLen / ( vLen * vLen * vLen ); } } // namespace spline class Spline2D { public : Spline2D () = default ; bool is_empty () { return _is_empty ; } size_t size () { return _size ; } size_t point_num () { return size () + 1 ; } double length () { return _all_length ; } double length ( size_t i ) { if ( i >= size ()) return 0 ; return _spline [ i ]. length ; } Vector2d position ( double t ) { assert ( _is_empty == false ); assert ( t >= 0 ); assert ( t <= static_cast < double > ( size ())); segment_info_t segment = get_segmet_idx ( t ); return spline :: position ( _spline [ segment . i ]. coeff , segment . t ); } Vector2d velocity ( double t ) { assert ( _is_empty == false ); assert ( t >= 0 ); assert ( t <= static_cast < double > ( size ())); size_t i = std :: floor ( t ); t -= static_cast < double > ( i ); return spline :: velocity ( _spline [ i ]. coeff , t ); } Vector2d acceleration ( double t ) { assert ( _is_empty == false ); assert ( t >= 0 ); assert ( t <= static_cast < double > ( size ())); size_t i = std :: floor ( t ); t -= static_cast < double > ( i ); return spline :: acceleration ( _spline [ i ]. coeff , t ); } protected : struct segment_t { spline :: spline_c coeff ; double length ; }; struct segment_info_t { size_t i ; double t ; }; segment_info_t get_segmet_idx ( const double t ) { segment_info_t result ; result . i = std :: min ( static_cast < size_t > ( std :: floor ( t )), size () -1 ); result . t = t - static_cast < double > ( result . i ); return result ; } std :: vector < segment_t > _spline ; bool _is_empty ; size_t _size ; double _all_length ; }; class CatumullRom2D : public Spline2D { public : CatumullRom2D ( std :: vector < Vector2d >& points , const double error = 0.1 ) { const size_t p_size = points . size (); _is_empty = false ; switch ( p_size ) { case 0 : _is_empty = true ; return ; case 1 : { Vector2d & p0 = points [ 0 ]; _spline . push_back ({ spline :: catumull_spline ( p0 , p0 , p0 , p0 ), 0 }); return ; } case 2 : _size = 1 ; _spline . resize ( _size ); calcu_segment ( _spline [ 0 ], points , error , 0 , 0 , 0 , 1 , 1 ); _all_length = _spline [ 0 ]. length ; return ; } _size = p_size - 1 ; _spline . resize ( _size ); calcu_segment ( _spline [ 0 ], points , error , 0 , 0 , 0 , 1 , 2 ); for ( size_t i = 0 ; i < p_size - 3 ; i ++ ) { calcu_segment ( _spline [ i + 1 ], points , error , i , 0 , 1 , 2 , 3 ); } calcu_segment ( _spline [ _size -1 ], points , error , p_size -3 , 0 , 1 , 2 , 2 ); _all_length = 0 ; for ( auto & seg : _spline ) { _all_length += seg . length ; } } private : void calcu_segment ( segment_t & seg , std :: vector < Vector2d >& points , const double error , const size_t start , const size_t i0 = 0 , const size_t i1 = 1 , const size_t i2 = 2 , const size_t i3 = 3 ) { Vector2d & p0 = points [ start + i0 ]; Vector2d & p1 = points [ start + i1 ]; Vector2d & p2 = points [ start + i2 ]; Vector2d & p3 = points [ start + i3 ]; seg . coeff = spline :: catumull_spline ( p0 , p1 , p2 , p3 ); seg . length = spline :: length ( seg . coeff , error ); } }; class CubicSpline : public Spline2D { public : CubicSpline ( std :: vector < Vector2d >& points , const double error = 0.1 ) { const size_t p_size = points . size (); std :: vector < double > w ; _is_empty = false ; if ( p_size < 2 ) { _is_empty = true ; return ; } _size = p_size - 1 ; _spline . resize ( p_size ); w . resize ( p_size ); for ( size_t xy = 0 ; xy < 2 ; xy ++ ) { // 0\u6b21\u306e\u4fc2\u6570 for ( size_t i = 0 ; i <= _size ; i ++ ) { spline ( i , xy ). x = p ( points , i , xy ); } // 2\u6b21\u306e\u4fc2\u6570 spline ( 0 , xy ). z = spline ( _size , xy ). z = 0.0 ; for ( size_t i = 1 ; i < _size ; i ++ ) { spline ( i , xy ). z = 3.0 * ( spline ( i -1 , xy ). x - 2.0 * spline ( i , xy ). x + spline ( i + 1 , xy ). x ); } // \u5de6\u4e0b\u6d88\u53bb w [ 0 ] = 0.0 ; for ( size_t i = 1 ; i < _size ; i ++ ) { double temp = 4.0 - w [ i -1 ]; spline ( i , xy ). z = ( spline ( i , xy ). z - spline ( i -1 , xy ). z ) / temp ; w [ i ] = 1.0 / temp ; } // \u53f3\u4e0b\u6d88\u53bb for ( size_t i = _size -1 ; i > 0 ; i -- ) { spline ( i , xy ). z = spline ( i , xy ). z - spline ( i + 1 , xy ). z * w [ i ]; } // 1\u6b21\u30683\u6b21\u306e\u4fc2\u6570 spline ( _size , xy ). y = spline ( _size , xy ). w = 0.0 ; for ( size_t i = 0 ; i < _size ; i ++ ) { spline ( i , xy ). w = ( spline ( i + 1 , xy ). z - spline ( i , xy ). z ) / 3.0 ; spline ( i , xy ). y = spline ( i + 1 , xy ). x - spline ( i , xy ). x - spline ( i , xy ). z - spline ( i , xy ). w ; } } // \u6700\u5f8c\u306e\u30bb\u30b0\u30e1\u30f3\u30c8\u306f\u6700\u5f8c\u306e\u5236\u5fa1\u70b9\u4e00\u70b9\u3088\u3046\u306a\u306e\u3067\u6d88\u3057\u3066\u304a\u304f _spline . erase ( _spline . begin () + _spline . size () -1 ); _all_length = 0 ; for ( auto & seg : _spline ) { auto c = seg . coeff ; seg . coeff = spline :: cubic_function_to_bezier ( Vector2d ( c . xb . w , c . yb . w ), Vector2d ( c . xb . z , c . yb . z ), Vector2d ( c . xb . y , c . yb . y ), Vector2d ( c . xb . x , c . yb . x ) ); seg . length = spline :: length ( seg . coeff , error ); _all_length += seg . length ; } } private : Vector4d & spline ( size_t i , size_t xy ) { if ( xy == 0 ) return _spline [ i ]. coeff . xb ; else return _spline [ i ]. coeff . yb ; } double & p ( std :: vector < Vector2d >& points , size_t i , size_t xy ) { if ( xy == 0 ) return points [ i ]. x ; else return points [ i ]. y ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/spline/spline.hpp"},{"location":"doxybook/Files/spline_8hpp/#includecpp_roboticssplinesplinehpp","text":"","title":"include/cpp_robotics/spline/spline.hpp"},{"location":"doxybook/Files/spline_8hpp/#namespaces","text":"Name cpp_robotics cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1","title":"Namespaces"},{"location":"doxybook/Files/spline_8hpp/#classes","text":"Name struct cpp_robotics::spline::spline_c class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda","title":"Classes"},{"location":"doxybook/Files/spline_8hpp/#source-code","text":"#include <iostream> #include <cstdlib> #include <cassert> #include <string> #include <cmath> #include <vector> #include \"../utility/math_utils.hpp\" #include \"../vector/vector2.hpp\" #include \"../vector/vector4.hpp\" namespace cpp_robotics { namespace spline { struct spline_c { Vector4d xb , yb ; }; spline_c bezier_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) { return { Vector4d { p0 . x , p1 . x , p2 . x , p3 . x }, Vector4d { p0 . y , p1 . y , p2 . y , p3 . y }}; } spline_c hermite_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & v0 , const Vector2d & v1 ) { Vector2d bp1 = p0 + ( 1.0 / 3.0 ) * v0 ; Vector2d bp2 = p1 - ( 1.0 / 3.0 ) * v1 ; return bezier_spline ( p0 , bp1 , bp2 , p1 ); } spline_c catumull_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) { Vector2d bp1 = p1 + ( 1.0 / 6.0 ) * ( p2 - p0 ); Vector2d bp2 = p2 - ( 1.0 / 6.0 ) * ( p3 - p1 ); return bezier_spline ( p1 , bp1 , bp2 , p2 ); } // f(t) = a t^3 + b t^2 + c t + d -> bezier spline_c cubic_function_to_bezier ( const Vector2d & a , const Vector2d & b , const Vector2d & c , const Vector2d & d ) { Vector2d bp1 = d + ( 1.0 / 3.0 ) * c ; Vector2d bp2 = ( 1.0 / 3.0 ) * b + ( 2.0 / 3.0 ) * c + d ; Vector2d bp3 = a + b + c + d ; return bezier_spline ( d , bp1 , bp2 , bp3 ); } Vector4d bezier_weight ( const double t ) { double s = 1.0 - t ; double t2 = t * t ; double t3 = t2 * t ; double s2 = s * s ; double s3 = s2 * s ; return Vector4d ( s3 , 3.0 * s2 * t , 3.0 * s * t2 , t3 ); } Vector4d bezier_weight ( const Vector4d t ) { return Vector4d ( t . x - 3.0 * t . y + 3.0 * t . z - t . w , 3.0 * t . y - 6.0 * t . z + 3.0 * t . w , 3.0 * t . z - 3.0 * t . w , t . w ); } inline Vector2d evaluate ( const spline_c & spline , const Vector4d & w ) { return { Vector4d :: dot ( spline . xb , w ), Vector4d :: dot ( spline . yb , w )}; } Vector2d position ( const spline_c & spline , double t ) { return evaluate ( spline , bezier_weight ( t )); } Vector2d velocity ( const spline_c & spline , double t ) { Vector4d dt ( 0.0 , 1.0 , 2.0 * t , 3.0 * t * t ); return evaluate ( spline , bezier_weight ( dt )); } Vector2d acceleration ( const spline_c & spline , double t ) { Vector4d dt ( 0.0 , 0.0 , 2.0 , 6.0 * t ); return evaluate ( spline , bezier_weight ( t )); } inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 , double t ) { // assumption: seg = (P0, P1, P2, P3) double q0 = lerp ( spline . x , spline . y , t ); double q1 = lerp ( spline . y , spline . z , t ); double q2 = lerp ( spline . z , spline . w , t ); double r0 = lerp ( q0 , q1 , t ); double r1 = lerp ( q1 , q2 , t ); double s0 = lerp ( r0 , r1 , t ); double sx = spline . x ; // support aliasing double sw = spline . w ; spline0 = Vector4d ( sx , q0 , r0 , s0 ); spline1 = Vector4d ( s0 , r1 , q2 , sw ); } // Optimised for t=0.5 inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 ) { double q0 = ( spline . x + spline . y ) * 0.5 ; // x + y / 2 double q1 = ( spline . y + spline . z ) * 0.5 ; // y + z / 2 double q2 = ( spline . z + spline . w ) * 0.5 ; // z + w / 2 double r0 = ( q0 + q1 ) * 0.5 ; // x + 2y + z / 4 double r1 = ( q1 + q2 ) * 0.5 ; // y + 2z + w / 4 double s0 = ( r0 + r1 ) * 0.5 ; // q0 + 2q1 + q2 / 4 = x+y + 2(y+z) + z+w / 8 = x + 3y + 3z + w double sx = spline . x ; // support aliasing double sw = spline . w ; spline0 = Vector4d ( sx , q0 , r0 , s0 ); spline1 = Vector4d ( s0 , r1 , q2 , sw ); } void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 ) { split ( spline . xb , spline0 . xb , spline1 . xb ); split ( spline . yb , spline0 . yb , spline1 . yb ); } void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 , double t ) { split ( spline . xb , spline0 . xb , spline1 . xb , t ); split ( spline . yb , spline0 . yb , spline1 . yb , t ); } double length_estimate ( const spline_c & s , double * error ) { // Our convex hull is p0, p1, p2, p3, so p0_p3 is our minimum possible length, and p0_p1 + p1_p2 + p2_p3 our maximum. double d03 = square ( s . xb . x - s . xb . w ) + square ( s . yb . x - s . yb . w ); double d01 = square ( s . xb . x - s . xb . y ) + square ( s . yb . x - s . yb . y ); double d12 = square ( s . xb . y - s . xb . z ) + square ( s . yb . y - s . yb . z ); double d23 = square ( s . xb . z - s . xb . w ) + square ( s . yb . z - s . yb . w ); double minLength = std :: sqrt ( d03 ); double maxLength = std :: sqrt ( d01 ) + std :: sqrt ( d12 ) + std :: sqrt ( d23 ); minLength *= 0.5 ; maxLength *= 0.5 ; * error = maxLength - minLength ; return minLength + maxLength ; } double length ( const spline_c & s , double maxError ) { double error ; double len = length_estimate ( s , & error ); if ( error > maxError ) { spline_c s0 ; spline_c s1 ; split ( s , s0 , s1 ); return length ( s0 , maxError ) + length ( s1 , maxError ); } return len ; } double length ( const spline_c & s , double t0 , double t1 , double maxError ) { assert ( t0 >= 0.0 && t0 < 1.0 ); assert ( t1 >= 0.0 && t1 <= 1.0 ); assert ( t0 <= t1 ); spline_c s0 , s1 ; if ( t0 == 0.0 ) { if ( t1 == 1.0 ) return length ( s , maxError ); split ( s , s0 , s1 , t1 ); return length ( s0 , maxError ); } else { split ( s , s0 , s1 , t0 ); if ( t1 == 1.0 ) return length ( s1 , maxError ); split ( s1 , s0 , s1 , ( t1 - t0 ) / ( 1.0 - t0 )); return length ( s0 , maxError ); } } double curvature ( const spline_c & spline , double t ) { Vector2d v = velocity ( spline , t ); Vector2d a = acceleration ( spline , t ); double avCrossLen = std :: abs ( v . x * a . y - v . y * a . x ); double vLen = v . norm (); if ( vLen == 0.0 ) return 1e10 ; return avCrossLen / ( vLen * vLen * vLen ); } } // namespace spline class Spline2D { public : Spline2D () = default ; bool is_empty () { return _is_empty ; } size_t size () { return _size ; } size_t point_num () { return size () + 1 ; } double length () { return _all_length ; } double length ( size_t i ) { if ( i >= size ()) return 0 ; return _spline [ i ]. length ; } Vector2d position ( double t ) { assert ( _is_empty == false ); assert ( t >= 0 ); assert ( t <= static_cast < double > ( size ())); segment_info_t segment = get_segmet_idx ( t ); return spline :: position ( _spline [ segment . i ]. coeff , segment . t ); } Vector2d velocity ( double t ) { assert ( _is_empty == false ); assert ( t >= 0 ); assert ( t <= static_cast < double > ( size ())); size_t i = std :: floor ( t ); t -= static_cast < double > ( i ); return spline :: velocity ( _spline [ i ]. coeff , t ); } Vector2d acceleration ( double t ) { assert ( _is_empty == false ); assert ( t >= 0 ); assert ( t <= static_cast < double > ( size ())); size_t i = std :: floor ( t ); t -= static_cast < double > ( i ); return spline :: acceleration ( _spline [ i ]. coeff , t ); } protected : struct segment_t { spline :: spline_c coeff ; double length ; }; struct segment_info_t { size_t i ; double t ; }; segment_info_t get_segmet_idx ( const double t ) { segment_info_t result ; result . i = std :: min ( static_cast < size_t > ( std :: floor ( t )), size () -1 ); result . t = t - static_cast < double > ( result . i ); return result ; } std :: vector < segment_t > _spline ; bool _is_empty ; size_t _size ; double _all_length ; }; class CatumullRom2D : public Spline2D { public : CatumullRom2D ( std :: vector < Vector2d >& points , const double error = 0.1 ) { const size_t p_size = points . size (); _is_empty = false ; switch ( p_size ) { case 0 : _is_empty = true ; return ; case 1 : { Vector2d & p0 = points [ 0 ]; _spline . push_back ({ spline :: catumull_spline ( p0 , p0 , p0 , p0 ), 0 }); return ; } case 2 : _size = 1 ; _spline . resize ( _size ); calcu_segment ( _spline [ 0 ], points , error , 0 , 0 , 0 , 1 , 1 ); _all_length = _spline [ 0 ]. length ; return ; } _size = p_size - 1 ; _spline . resize ( _size ); calcu_segment ( _spline [ 0 ], points , error , 0 , 0 , 0 , 1 , 2 ); for ( size_t i = 0 ; i < p_size - 3 ; i ++ ) { calcu_segment ( _spline [ i + 1 ], points , error , i , 0 , 1 , 2 , 3 ); } calcu_segment ( _spline [ _size -1 ], points , error , p_size -3 , 0 , 1 , 2 , 2 ); _all_length = 0 ; for ( auto & seg : _spline ) { _all_length += seg . length ; } } private : void calcu_segment ( segment_t & seg , std :: vector < Vector2d >& points , const double error , const size_t start , const size_t i0 = 0 , const size_t i1 = 1 , const size_t i2 = 2 , const size_t i3 = 3 ) { Vector2d & p0 = points [ start + i0 ]; Vector2d & p1 = points [ start + i1 ]; Vector2d & p2 = points [ start + i2 ]; Vector2d & p3 = points [ start + i3 ]; seg . coeff = spline :: catumull_spline ( p0 , p1 , p2 , p3 ); seg . length = spline :: length ( seg . coeff , error ); } }; class CubicSpline : public Spline2D { public : CubicSpline ( std :: vector < Vector2d >& points , const double error = 0.1 ) { const size_t p_size = points . size (); std :: vector < double > w ; _is_empty = false ; if ( p_size < 2 ) { _is_empty = true ; return ; } _size = p_size - 1 ; _spline . resize ( p_size ); w . resize ( p_size ); for ( size_t xy = 0 ; xy < 2 ; xy ++ ) { // 0\u6b21\u306e\u4fc2\u6570 for ( size_t i = 0 ; i <= _size ; i ++ ) { spline ( i , xy ). x = p ( points , i , xy ); } // 2\u6b21\u306e\u4fc2\u6570 spline ( 0 , xy ). z = spline ( _size , xy ). z = 0.0 ; for ( size_t i = 1 ; i < _size ; i ++ ) { spline ( i , xy ). z = 3.0 * ( spline ( i -1 , xy ). x - 2.0 * spline ( i , xy ). x + spline ( i + 1 , xy ). x ); } // \u5de6\u4e0b\u6d88\u53bb w [ 0 ] = 0.0 ; for ( size_t i = 1 ; i < _size ; i ++ ) { double temp = 4.0 - w [ i -1 ]; spline ( i , xy ). z = ( spline ( i , xy ). z - spline ( i -1 , xy ). z ) / temp ; w [ i ] = 1.0 / temp ; } // \u53f3\u4e0b\u6d88\u53bb for ( size_t i = _size -1 ; i > 0 ; i -- ) { spline ( i , xy ). z = spline ( i , xy ). z - spline ( i + 1 , xy ). z * w [ i ]; } // 1\u6b21\u30683\u6b21\u306e\u4fc2\u6570 spline ( _size , xy ). y = spline ( _size , xy ). w = 0.0 ; for ( size_t i = 0 ; i < _size ; i ++ ) { spline ( i , xy ). w = ( spline ( i + 1 , xy ). z - spline ( i , xy ). z ) / 3.0 ; spline ( i , xy ). y = spline ( i + 1 , xy ). x - spline ( i , xy ). x - spline ( i , xy ). z - spline ( i , xy ). w ; } } // \u6700\u5f8c\u306e\u30bb\u30b0\u30e1\u30f3\u30c8\u306f\u6700\u5f8c\u306e\u5236\u5fa1\u70b9\u4e00\u70b9\u3088\u3046\u306a\u306e\u3067\u6d88\u3057\u3066\u304a\u304f _spline . erase ( _spline . begin () + _spline . size () -1 ); _all_length = 0 ; for ( auto & seg : _spline ) { auto c = seg . coeff ; seg . coeff = spline :: cubic_function_to_bezier ( Vector2d ( c . xb . w , c . yb . w ), Vector2d ( c . xb . z , c . yb . z ), Vector2d ( c . xb . y , c . yb . y ), Vector2d ( c . xb . x , c . yb . x ) ); seg . length = spline :: length ( seg . coeff , error ); _all_length += seg . length ; } } private : Vector4d & spline ( size_t i , size_t xy ) { if ( xy == 0 ) return _spline [ i ]. coeff . xb ; else return _spline [ i ]. coeff . yb ; } double & p ( std :: vector < Vector2d >& points , size_t i , size_t xy ) { if ( xy == 0 ) return points [ i ]. x ; else return points [ i ]. y ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/sqp_8hpp/","text":"include/cpp_robotics/optimize/sqp.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::SQP SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) struct cpp_robotics::SQP::Problem struct cpp_robotics::SQP::Result Source code #pragma once #include <functional> #include <cmath> #include <Eigen/Dense> #include \"./constraint.hpp\" #include \"./bracketing_serach.hpp\" #include \"./bfgs.hpp\" #include \"./quasi_newton_method.hpp\" #include \"./quadprog.hpp\" namespace cpp_robotics { class SQP { public : using func_type = std :: function < double ( Eigen :: VectorXd ) > ; struct Problem { func_type func ; ConstraintArray con ; double tol_step = 1e-6 ; double tol_con = 1e-6 ; size_t max_iter = 10 ; }; struct Result { bool is_solved = false ; Eigen :: VectorXd x ; // Eigen::VectorXd lambda_opt; size_t iter_cnt = 0 ; }; Result solve ( Problem prob , const Eigen :: VectorXd & x0 , std :: optional < std :: function < void ( Eigen :: VectorXd ) >> callback ) { Result result ; // \u5236\u7d04\u304c\u306a\u3044\u6642, \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f if ( prob . con . size () == 0 ) { std :: tie ( result . is_solved , result . x , result . iter_cnt ) = quasi_newton_method ( prob . func , [ & ]( const Eigen :: VectorXd & x ){ return derivative ( prob . func , x ); }, x0 , 1e-6 , prob . max_iter ); return result ; } Eigen :: VectorXd x = x0 ; Eigen :: MatrixXd B = Eigen :: MatrixXd :: Identity ( x . rows (), x . rows ()); Eigen :: VectorXd grad_L = Eigen :: VectorXd :: Zero ( x . rows ()); // Todo: x0\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u306a\u5834\u5408\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u307e\u3067\u79fb\u52d5\u3055\u305b\u308b // \u5236\u7d04 auto eq_con = prob . con . gen_eq_constraint_list (); auto ineq_con = prob . con . gen_ineq_constraint_list (); // \u30b5\u30d6\u554f\u984c\u306e2\u6b21\u8a08\u753b\u554f\u984c\u306e\u30bd\u30eb\u30d0\u30fc QuadProg qp_solver ; qp_solver . set_problem_size ( x . size (), ineq_con . size (), eq_con . size ()); // \u76f4\u7dda\u63a2\u7d22\u7528\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5236\u7d04\u91cd\u307f // Todo: \u521d\u671f\u5024 // const double df0_norm = derivative(prob.func, x).norm(); Eigen :: VectorXd eq_mw = Eigen :: VectorXd :: Ones ( eq_con . size ()); Eigen :: VectorXd ineq_mw = Eigen :: VectorXd :: Ones ( ineq_con . size ()); // for(size_t i = 0; i < eq_con.size(); i++) // { // eq_mw(i) /= eq_con[i].grad(x).norm(); // } // for(size_t i = 0; i < ineq_con.size(); i++) // { // ineq_mw(i) /= std::min(ineq_con[i].grad(x).norm(), 10e3); // } for ( size_t i = 1 ; i < prob . max_iter + 1 ; i ++ ) { // \u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a // \u30b5\u30d6\u306e\u554f\u984c\u8a2d\u5b9a qp_solver . Q = B ; qp_solver . c = derivative ( prob . func , x ). transpose (); // \u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c for ( size_t con_i = 0 ; con_i < eq_con . size (); con_i ++ ) { qp_solver . Aeq . row ( con_i ) = eq_con [ con_i ]. grad ( x ). transpose (); qp_solver . beq ( con_i ) = - eq_con [ con_i ]. eval ( x ); } // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c for ( size_t con_i = 0 ; con_i < ineq_con . size (); con_i ++ ) { qp_solver . A . row ( con_i ) = ineq_con [ con_i ]. grad ( x ). transpose (); qp_solver . b ( con_i ) = - ineq_con [ con_i ]. eval ( x ); } std :: cout << \"//////////\" << std :: endl ; // std::cout << \"x\" << std::endl; // std::cout << x << std::endl; // qp_solver.debug_prog(); // \u30b5\u30d6\u306e2\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f auto sub_result = qp_solver . solve ( x ); if ( not sub_result . is_solved ) { result . is_solved = false ; result . iter_cnt = i ; result . x = x ; // result.lambda_opt = sub_result.lambda_opt; std :: cout << \"cant solve sub qp\" << std :: endl ; return result ; } auto d = sub_result . x ; std :: cout << \"d\" << std :: endl ; std :: cout << d << std :: endl ; // \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u6c7a\u5b9a // \u76f4\u7dda\u63a2\u7d22 auto merit_func = [ & ]( const Eigen :: VectorXd & x ) { double val = prob . func ( x ); // \u7b49\u5f0f\u5236\u7d04 for ( size_t con_i = 0 ; con_i < eq_con . size (); con_i ++ ) { val += eq_mw ( con_i ) * std :: abs ( eq_con [ con_i ]. eval ( x )); } // \u4e0d\u7b49\u5f0f\u5236\u7d04 for ( size_t con_i = 0 ; con_i < ineq_con . size (); con_i ++ ) { val += ineq_mw ( con_i ) * std :: max ( ineq_con [ con_i ]. eval ( x ), 0.0 ); } return val ; }; double alpha = bracketing_serach ( merit_func , [ & ]( const Eigen :: VectorXd & x ){ return derivative ( merit_func , x ); }, x , d ); // std::cout << \"alpha\" << std::endl; // std::cout << alpha << std::endl; if ( callback ) callback . value ()( x ); x += alpha * d ; // \u53ce\u675f\u5224\u5b9a if ( d . norm () < prob . tol_step && prob . con . all_satisfy ( x , prob . tol_con )) { result . is_solved = true ; result . iter_cnt = i ; result . x = x ; return result ; } std :: cout << \"ineq_mw\" << std :: endl ; std :: cout << ineq_mw << std :: endl ; // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u91cd\u307f\u66f4\u65b0 for ( size_t con_i = 0 ; con_i < eq_con . size (); con_i ++ ) { eq_mw ( con_i ) = std :: max ( eq_mw ( con_i ), 0.5 * ( eq_mw ( con_i ) + sub_result . lambda_eq ( con_i ))); } for ( size_t con_i = 0 ; con_i < ineq_con . size (); con_i ++ ) { ineq_mw ( con_i ) = std :: max ( ineq_mw ( con_i ), 0.5 * ( ineq_mw ( con_i ) + sub_result . lambda_ineq ( con_i ))); } // \u89e3\u306e\u4fdd\u5b58 result . x = x ; result . iter_cnt = i ; // \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u95a2\u6570\u306e\u52fe\u914d\u306e\u5909\u5316\u91cf Eigen :: VectorXd delta_grad_L = - grad_L ; grad_L = derivative ( prob . func , x ); if ( ineq_con . size () > 0 ) grad_L += qp_solver . A . transpose () * sub_result . lambda_ineq ; if ( eq_con . size () > 0 ) grad_L += qp_solver . Aeq . transpose () * sub_result . lambda_eq ; delta_grad_L += grad_L ; // std::cout << \"test =\" << std::endl; // std::cout << grad_L << std::endl; // B\u30de\u30c8\u30ea\u30af\u30b9\u306e\u66f4\u65b0 powells_modified_bfgs_step ( B , alpha * d , delta_grad_L ); if ( B . array (). isNaN (). any ()) { std :: cout << \"NaN\u304c\u5b58\u5728\u3057\u307e\u3059\" << std :: endl ; break ; } } return result ; } private : template < typename Mat > bool is_posdef ( Mat H ) { Eigen :: EigenSolver < Mat > eigensolver ( H ); for ( int i = 0 ; i < eigensolver . eigenvalues (). rows (); i ++ ) { double v = eigensolver . eigenvalues ()( i ). real (); if ( v <= 0 ) { return false ; } } return true ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/sqp.hpp"},{"location":"doxybook/Files/sqp_8hpp/#includecpp_roboticsoptimizesqphpp","text":"","title":"include/cpp_robotics/optimize/sqp.hpp"},{"location":"doxybook/Files/sqp_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/sqp_8hpp/#classes","text":"Name class cpp_robotics::SQP SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) struct cpp_robotics::SQP::Problem struct cpp_robotics::SQP::Result","title":"Classes"},{"location":"doxybook/Files/sqp_8hpp/#source-code","text":"#pragma once #include <functional> #include <cmath> #include <Eigen/Dense> #include \"./constraint.hpp\" #include \"./bracketing_serach.hpp\" #include \"./bfgs.hpp\" #include \"./quasi_newton_method.hpp\" #include \"./quadprog.hpp\" namespace cpp_robotics { class SQP { public : using func_type = std :: function < double ( Eigen :: VectorXd ) > ; struct Problem { func_type func ; ConstraintArray con ; double tol_step = 1e-6 ; double tol_con = 1e-6 ; size_t max_iter = 10 ; }; struct Result { bool is_solved = false ; Eigen :: VectorXd x ; // Eigen::VectorXd lambda_opt; size_t iter_cnt = 0 ; }; Result solve ( Problem prob , const Eigen :: VectorXd & x0 , std :: optional < std :: function < void ( Eigen :: VectorXd ) >> callback ) { Result result ; // \u5236\u7d04\u304c\u306a\u3044\u6642, \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u89e3\u304f if ( prob . con . size () == 0 ) { std :: tie ( result . is_solved , result . x , result . iter_cnt ) = quasi_newton_method ( prob . func , [ & ]( const Eigen :: VectorXd & x ){ return derivative ( prob . func , x ); }, x0 , 1e-6 , prob . max_iter ); return result ; } Eigen :: VectorXd x = x0 ; Eigen :: MatrixXd B = Eigen :: MatrixXd :: Identity ( x . rows (), x . rows ()); Eigen :: VectorXd grad_L = Eigen :: VectorXd :: Zero ( x . rows ()); // Todo: x0\u304c\u5b9f\u884c\u4e0d\u53ef\u80fd\u306a\u5834\u5408\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u307e\u3067\u79fb\u52d5\u3055\u305b\u308b // \u5236\u7d04 auto eq_con = prob . con . gen_eq_constraint_list (); auto ineq_con = prob . con . gen_ineq_constraint_list (); // \u30b5\u30d6\u554f\u984c\u306e2\u6b21\u8a08\u753b\u554f\u984c\u306e\u30bd\u30eb\u30d0\u30fc QuadProg qp_solver ; qp_solver . set_problem_size ( x . size (), ineq_con . size (), eq_con . size ()); // \u76f4\u7dda\u63a2\u7d22\u7528\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5236\u7d04\u91cd\u307f // Todo: \u521d\u671f\u5024 // const double df0_norm = derivative(prob.func, x).norm(); Eigen :: VectorXd eq_mw = Eigen :: VectorXd :: Ones ( eq_con . size ()); Eigen :: VectorXd ineq_mw = Eigen :: VectorXd :: Ones ( ineq_con . size ()); // for(size_t i = 0; i < eq_con.size(); i++) // { // eq_mw(i) /= eq_con[i].grad(x).norm(); // } // for(size_t i = 0; i < ineq_con.size(); i++) // { // ineq_mw(i) /= std::min(ineq_con[i].grad(x).norm(), 10e3); // } for ( size_t i = 1 ; i < prob . max_iter + 1 ; i ++ ) { // \u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a // \u30b5\u30d6\u306e\u554f\u984c\u8a2d\u5b9a qp_solver . Q = B ; qp_solver . c = derivative ( prob . func , x ). transpose (); // \u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c for ( size_t con_i = 0 ; con_i < eq_con . size (); con_i ++ ) { qp_solver . Aeq . row ( con_i ) = eq_con [ con_i ]. grad ( x ). transpose (); qp_solver . beq ( con_i ) = - eq_con [ con_i ]. eval ( x ); } // \u4e0d\u7b49\u5f0f\u5236\u7d04\u306e\u4e00\u6b21\u8fd1\u4f3c for ( size_t con_i = 0 ; con_i < ineq_con . size (); con_i ++ ) { qp_solver . A . row ( con_i ) = ineq_con [ con_i ]. grad ( x ). transpose (); qp_solver . b ( con_i ) = - ineq_con [ con_i ]. eval ( x ); } std :: cout << \"//////////\" << std :: endl ; // std::cout << \"x\" << std::endl; // std::cout << x << std::endl; // qp_solver.debug_prog(); // \u30b5\u30d6\u306e2\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f auto sub_result = qp_solver . solve ( x ); if ( not sub_result . is_solved ) { result . is_solved = false ; result . iter_cnt = i ; result . x = x ; // result.lambda_opt = sub_result.lambda_opt; std :: cout << \"cant solve sub qp\" << std :: endl ; return result ; } auto d = sub_result . x ; std :: cout << \"d\" << std :: endl ; std :: cout << d << std :: endl ; // \u30b9\u30c6\u30c3\u30d7\u5e45\u306e\u6c7a\u5b9a // \u76f4\u7dda\u63a2\u7d22 auto merit_func = [ & ]( const Eigen :: VectorXd & x ) { double val = prob . func ( x ); // \u7b49\u5f0f\u5236\u7d04 for ( size_t con_i = 0 ; con_i < eq_con . size (); con_i ++ ) { val += eq_mw ( con_i ) * std :: abs ( eq_con [ con_i ]. eval ( x )); } // \u4e0d\u7b49\u5f0f\u5236\u7d04 for ( size_t con_i = 0 ; con_i < ineq_con . size (); con_i ++ ) { val += ineq_mw ( con_i ) * std :: max ( ineq_con [ con_i ]. eval ( x ), 0.0 ); } return val ; }; double alpha = bracketing_serach ( merit_func , [ & ]( const Eigen :: VectorXd & x ){ return derivative ( merit_func , x ); }, x , d ); // std::cout << \"alpha\" << std::endl; // std::cout << alpha << std::endl; if ( callback ) callback . value ()( x ); x += alpha * d ; // \u53ce\u675f\u5224\u5b9a if ( d . norm () < prob . tol_step && prob . con . all_satisfy ( x , prob . tol_con )) { result . is_solved = true ; result . iter_cnt = i ; result . x = x ; return result ; } std :: cout << \"ineq_mw\" << std :: endl ; std :: cout << ineq_mw << std :: endl ; // \u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u91cd\u307f\u66f4\u65b0 for ( size_t con_i = 0 ; con_i < eq_con . size (); con_i ++ ) { eq_mw ( con_i ) = std :: max ( eq_mw ( con_i ), 0.5 * ( eq_mw ( con_i ) + sub_result . lambda_eq ( con_i ))); } for ( size_t con_i = 0 ; con_i < ineq_con . size (); con_i ++ ) { ineq_mw ( con_i ) = std :: max ( ineq_mw ( con_i ), 0.5 * ( ineq_mw ( con_i ) + sub_result . lambda_ineq ( con_i ))); } // \u89e3\u306e\u4fdd\u5b58 result . x = x ; result . iter_cnt = i ; // \u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u95a2\u6570\u306e\u52fe\u914d\u306e\u5909\u5316\u91cf Eigen :: VectorXd delta_grad_L = - grad_L ; grad_L = derivative ( prob . func , x ); if ( ineq_con . size () > 0 ) grad_L += qp_solver . A . transpose () * sub_result . lambda_ineq ; if ( eq_con . size () > 0 ) grad_L += qp_solver . Aeq . transpose () * sub_result . lambda_eq ; delta_grad_L += grad_L ; // std::cout << \"test =\" << std::endl; // std::cout << grad_L << std::endl; // B\u30de\u30c8\u30ea\u30af\u30b9\u306e\u66f4\u65b0 powells_modified_bfgs_step ( B , alpha * d , delta_grad_L ); if ( B . array (). isNaN (). any ()) { std :: cout << \"NaN\u304c\u5b58\u5728\u3057\u307e\u3059\" << std :: endl ; break ; } } return result ; } private : template < typename Mat > bool is_posdef ( Mat H ) { Eigen :: EigenSolver < Mat > eigensolver ( H ); for ( int i = 0 ; i < eigensolver . eigenvalues (). rows (); i ++ ) { double v = eigensolver . eigenvalues ()( i ). real (); if ( v <= 0 ) { return false ; } } return true ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/state__machine_8hpp/","text":"include/cpp_robotics/algorithm/state_machine.hpp Source code // #pragma once // #include <memory> // namespace cpp_robotics // { // template<class T> // class State // { // public: // State() = delete; // State(const T &id): // id_(id) {} // virtual void entry() {} // virtual void update() {} // virtual void exit() {} // private: // const T id_; // }; // template<class T> // class StateMachine // { // public: // StateMachine() // { // } // void update() // { // state_list_->update(); // } // private: // std::map<T, std::shared_ptr<State<T>>> state_list_; // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/algorithm/state_machine.hpp"},{"location":"doxybook/Files/state__machine_8hpp/#includecpp_roboticsalgorithmstate_machinehpp","text":"","title":"include/cpp_robotics/algorithm/state_machine.hpp"},{"location":"doxybook/Files/state__machine_8hpp/#source-code","text":"// #pragma once // #include <memory> // namespace cpp_robotics // { // template<class T> // class State // { // public: // State() = delete; // State(const T &id): // id_(id) {} // virtual void entry() {} // virtual void update() {} // virtual void exit() {} // private: // const T id_; // }; // template<class T> // class StateMachine // { // public: // StateMachine() // { // } // void update() // { // state_list_->update(); // } // private: // std::map<T, std::shared_ptr<State<T>>> state_list_; // }; // } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/state__space__system_8hpp/","text":"include/cpp_robotics/system/state_space_system.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb Source code #pragma once #include <Eigen/Dense> #include <Eigen/../unsupported/Eigen/MatrixFunctions> #include \"discret.hpp\" namespace cpp_robotics { class StateSpaceSystem { public : StateSpaceSystem () = default ; template < typename DerivedA , typename DerivedB , typename DerivedC > StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts ) { set_continuous ( A , B , C , Ts ); } template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts ) { set_continuous ( A , B , C , D , Ts ); } template < typename DerivedA , typename DerivedB , typename DerivedC > void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts , const bool skip_state_reset = false ) { input_size_ = B . cols (); output_size_ = C . rows (); set_continuous ( A , B , C , Eigen :: MatrixXd :: Zero ( output_size_ , input_size_ ), Ts , skip_state_reset ); } template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts , const bool skip_state_reset = false ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == B . rows ()); assert ( A . cols () == C . cols ()); assert ( C . rows () == D . rows ()); state_size_ = A . rows (); input_size_ = B . cols (); output_size_ = C . rows (); A_ = A ; B_ = B ; Ts_ = Ts ; std :: tie ( Ad_ , Bd_ ) = Discret :: discritize ( A , B , Ts ); Cd_ = C ; Dd_ = D ; if ( not skip_state_reset ) set_state_zero (); } template < typename DerivedA , typename DerivedB , typename DerivedC > void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const double Ts , const bool skip_state_reset = false ) { input_size_ = Bd . cols (); output_size_ = Cd . rows (); set_discrite ( Ad , Bd , Cd , Eigen :: MatrixXd :: Zero ( output_size_ , input_size_ ), Ts , skip_state_reset ); } template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const Eigen :: MatrixBase < DerivedD > & Dd , const double Ts , const bool skip_state_reset = false ) { assert ( Ad . rows () == Ad . cols ()); assert ( Ad . rows () == Bd . rows ()); assert ( Ad . cols () == Cd . cols ()); assert ( Cd . rows () == Dd . rows ()); state_size_ = Ad . rows (); input_size_ = Bd . cols (); output_size_ = Cd . rows (); A_ = std :: nullopt ; B_ = std :: nullopt ; Ts_ = Ts ; Ad_ = Ad ; Bd_ = Bd ; Cd_ = Cd ; Dd_ = Dd ; if ( not skip_state_reset ) set_state_zero (); } size_t state_size () const { return state_size_ ; } size_t input_size () const { return input_size_ ; } size_t output_size () const { return output_size_ ; } bool is_siso_model () const { return ( input_size () == 1 && output_size () == 1 ); } inline void set_state_zero () { set_state ( Eigen :: VectorXd :: Zero ( state_size ())); } void set_state ( const Eigen :: VectorXd & x ) { x_ = x ; } void set_state ( const double & x ) { assert ( input_size () == 1 && output_size () == 1 ); Eigen :: VectorXd x_vec ( 1 ); x_vec ( 0 ) = x ; set_state ( x_vec ); } auto responce ( const Eigen :: VectorXd & u ) { x_ = Ad_ * x_ + Bd_ * u ; return Cd_ * x_ + Dd_ * u ; } double responce ( double u ) { assert ( input_size () == 1 && output_size () == 1 ); Eigen :: VectorXd u_vec ( 1 ); u_vec ( 0 ) = u ; return responce ( u_vec )( 0 ); } std :: optional < Eigen :: MatrixXd > A () const { return A_ ; } std :: optional < Eigen :: MatrixXd > B () const { return B_ ; } double Ts () const { return Ts_ ; } Eigen :: MatrixXd Ad () const { return Ad_ ; } Eigen :: MatrixXd Bd () const { return Bd_ ; } Eigen :: MatrixXd C () const { return Cd_ ; } Eigen :: MatrixXd Cd () const { return Cd_ ; } Eigen :: MatrixXd D () const { return Dd_ ; } Eigen :: MatrixXd Dd () const { return Dd_ ; } Eigen :: VectorXd x () const { return x_ ; } Eigen :: VectorXd y () const { return Cd_ * x_ ; } private : Eigen :: MatrixXd Ad_ ; Eigen :: MatrixXd Bd_ ; Eigen :: MatrixXd Cd_ ; Eigen :: MatrixXd Dd_ ; std :: optional < Eigen :: MatrixXd > A_ ; std :: optional < Eigen :: MatrixXd > B_ ; double Ts_ ; size_t state_size_ ; size_t input_size_ ; size_t output_size_ ; Eigen :: VectorXd x_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/state_space_system.hpp"},{"location":"doxybook/Files/state__space__system_8hpp/#includecpp_roboticssystemstate_space_systemhpp","text":"","title":"include/cpp_robotics/system/state_space_system.hpp"},{"location":"doxybook/Files/state__space__system_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/state__space__system_8hpp/#classes","text":"Name class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb","title":"Classes"},{"location":"doxybook/Files/state__space__system_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> #include <Eigen/../unsupported/Eigen/MatrixFunctions> #include \"discret.hpp\" namespace cpp_robotics { class StateSpaceSystem { public : StateSpaceSystem () = default ; template < typename DerivedA , typename DerivedB , typename DerivedC > StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts ) { set_continuous ( A , B , C , Ts ); } template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > StateSpaceSystem ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts ) { set_continuous ( A , B , C , D , Ts ); } template < typename DerivedA , typename DerivedB , typename DerivedC > void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const double Ts , const bool skip_state_reset = false ) { input_size_ = B . cols (); output_size_ = C . rows (); set_continuous ( A , B , C , Eigen :: MatrixXd :: Zero ( output_size_ , input_size_ ), Ts , skip_state_reset ); } template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > void set_continuous ( const Eigen :: MatrixBase < DerivedA > & A , const Eigen :: MatrixBase < DerivedB > & B , const Eigen :: MatrixBase < DerivedC > & C , const Eigen :: MatrixBase < DerivedD > & D , const double Ts , const bool skip_state_reset = false ) { assert ( A . rows () == A . cols ()); assert ( A . rows () == B . rows ()); assert ( A . cols () == C . cols ()); assert ( C . rows () == D . rows ()); state_size_ = A . rows (); input_size_ = B . cols (); output_size_ = C . rows (); A_ = A ; B_ = B ; Ts_ = Ts ; std :: tie ( Ad_ , Bd_ ) = Discret :: discritize ( A , B , Ts ); Cd_ = C ; Dd_ = D ; if ( not skip_state_reset ) set_state_zero (); } template < typename DerivedA , typename DerivedB , typename DerivedC > void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const double Ts , const bool skip_state_reset = false ) { input_size_ = Bd . cols (); output_size_ = Cd . rows (); set_discrite ( Ad , Bd , Cd , Eigen :: MatrixXd :: Zero ( output_size_ , input_size_ ), Ts , skip_state_reset ); } template < typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD > void set_discrite ( const Eigen :: MatrixBase < DerivedA > & Ad , const Eigen :: MatrixBase < DerivedB > & Bd , const Eigen :: MatrixBase < DerivedC > & Cd , const Eigen :: MatrixBase < DerivedD > & Dd , const double Ts , const bool skip_state_reset = false ) { assert ( Ad . rows () == Ad . cols ()); assert ( Ad . rows () == Bd . rows ()); assert ( Ad . cols () == Cd . cols ()); assert ( Cd . rows () == Dd . rows ()); state_size_ = Ad . rows (); input_size_ = Bd . cols (); output_size_ = Cd . rows (); A_ = std :: nullopt ; B_ = std :: nullopt ; Ts_ = Ts ; Ad_ = Ad ; Bd_ = Bd ; Cd_ = Cd ; Dd_ = Dd ; if ( not skip_state_reset ) set_state_zero (); } size_t state_size () const { return state_size_ ; } size_t input_size () const { return input_size_ ; } size_t output_size () const { return output_size_ ; } bool is_siso_model () const { return ( input_size () == 1 && output_size () == 1 ); } inline void set_state_zero () { set_state ( Eigen :: VectorXd :: Zero ( state_size ())); } void set_state ( const Eigen :: VectorXd & x ) { x_ = x ; } void set_state ( const double & x ) { assert ( input_size () == 1 && output_size () == 1 ); Eigen :: VectorXd x_vec ( 1 ); x_vec ( 0 ) = x ; set_state ( x_vec ); } auto responce ( const Eigen :: VectorXd & u ) { x_ = Ad_ * x_ + Bd_ * u ; return Cd_ * x_ + Dd_ * u ; } double responce ( double u ) { assert ( input_size () == 1 && output_size () == 1 ); Eigen :: VectorXd u_vec ( 1 ); u_vec ( 0 ) = u ; return responce ( u_vec )( 0 ); } std :: optional < Eigen :: MatrixXd > A () const { return A_ ; } std :: optional < Eigen :: MatrixXd > B () const { return B_ ; } double Ts () const { return Ts_ ; } Eigen :: MatrixXd Ad () const { return Ad_ ; } Eigen :: MatrixXd Bd () const { return Bd_ ; } Eigen :: MatrixXd C () const { return Cd_ ; } Eigen :: MatrixXd Cd () const { return Cd_ ; } Eigen :: MatrixXd D () const { return Dd_ ; } Eigen :: MatrixXd Dd () const { return Dd_ ; } Eigen :: VectorXd x () const { return x_ ; } Eigen :: VectorXd y () const { return Cd_ * x_ ; } private : Eigen :: MatrixXd Ad_ ; Eigen :: MatrixXd Bd_ ; Eigen :: MatrixXd Cd_ ; Eigen :: MatrixXd Dd_ ; std :: optional < Eigen :: MatrixXd > A_ ; std :: optional < Eigen :: MatrixXd > B_ ; double Ts_ ; size_t state_size_ ; size_t input_size_ ; size_t output_size_ ; Eigen :: VectorXd x_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/steepest__descent__method_8hpp/","text":"include/cpp_robotics/optimize/steepest_descent_method.hpp Namespaces Name cpp_robotics Source code #pragma once #include <tuple> #include <functional> #include <Eigen/Dense> #include \"bracketing_serach.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > steepest_descent_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; Eigen :: VectorXd s ; for ( size_t i = 0 ; i < max_iter ; i ++ ) { s = - grad ( x ); if ( s . norm () < tol ) { return { true , x , i }; } // \u76f4\u7dda\u63a2\u7d22 double a = bracketing_serach ( f , grad , x , s ); x += a * s ; } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/optimize/steepest_descent_method.hpp"},{"location":"doxybook/Files/steepest__descent__method_8hpp/#includecpp_roboticsoptimizesteepest_descent_methodhpp","text":"","title":"include/cpp_robotics/optimize/steepest_descent_method.hpp"},{"location":"doxybook/Files/steepest__descent__method_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/steepest__descent__method_8hpp/#source-code","text":"#pragma once #include <tuple> #include <functional> #include <Eigen/Dense> #include \"bracketing_serach.hpp\" namespace cpp_robotics { static std :: tuple < bool , Eigen :: VectorXd , size_t > steepest_descent_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) { Eigen :: VectorXd x = x_init ; Eigen :: VectorXd s ; for ( size_t i = 0 ; i < max_iter ; i ++ ) { s = - grad ( x ); if ( s . norm () < tol ) { return { true , x , i }; } // \u76f4\u7dda\u63a2\u7d22 double a = bracketing_serach ( f , grad , x , s ); x += a * s ; } return { false , x , max_iter }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/swerve__ik_8hpp/","text":"include/cpp_robotics/chassis/swerve_ik.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb Source code #pragma once #include <array> #include <Eigen/Dense> #include \"cpp_robotics/vector/transform.hpp\" #include \"cpp_robotics/vector/vector2.hpp\" namespace cpp_robotics { class SwerveIk { public : using VecArray = std :: array < Vector2d , 4 > ; SwerveIk ( const double width , const double length ) { const double hw = width / 2 ; const double hl = length / 2 ; wheel_place_ = { Vector2d { hw , hl }, Vector2d { - hw , hl }, Vector2d { - hw , - hl }, Vector2d { hw , - hl } }; } SwerveIk ( VecArray wheel_place ) : wheel_place_ ( wheel_place ) { } VecArray calculate ( Transformd velocity ) { VecArray wv ; for ( size_t i = 0 ; i < 4 ; i ++ ) { const double wangle = wheel_place_ [ i ]. angle (); const double wpnorm = wheel_place_ [ i ]. norm (); wv [ i ]. x = velocity . x - wpnorm * velocity . theta * std :: sin ( wangle ); wv [ i ]. y = velocity . y + wpnorm * velocity . theta * std :: cos ( wangle ); } return wv ; } VecArray wheel_place () const { return wheel_place_ ; } private : VecArray wheel_place_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/chassis/swerve_ik.hpp"},{"location":"doxybook/Files/swerve__ik_8hpp/#includecpp_roboticschassisswerve_ikhpp","text":"","title":"include/cpp_robotics/chassis/swerve_ik.hpp"},{"location":"doxybook/Files/swerve__ik_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/swerve__ik_8hpp/#classes","text":"Name class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb","title":"Classes"},{"location":"doxybook/Files/swerve__ik_8hpp/#source-code","text":"#pragma once #include <array> #include <Eigen/Dense> #include \"cpp_robotics/vector/transform.hpp\" #include \"cpp_robotics/vector/vector2.hpp\" namespace cpp_robotics { class SwerveIk { public : using VecArray = std :: array < Vector2d , 4 > ; SwerveIk ( const double width , const double length ) { const double hw = width / 2 ; const double hl = length / 2 ; wheel_place_ = { Vector2d { hw , hl }, Vector2d { - hw , hl }, Vector2d { - hw , - hl }, Vector2d { hw , - hl } }; } SwerveIk ( VecArray wheel_place ) : wheel_place_ ( wheel_place ) { } VecArray calculate ( Transformd velocity ) { VecArray wv ; for ( size_t i = 0 ; i < 4 ; i ++ ) { const double wangle = wheel_place_ [ i ]. angle (); const double wpnorm = wheel_place_ [ i ]. norm (); wv [ i ]. x = velocity . x - wpnorm * velocity . theta * std :: sin ( wangle ); wv [ i ]. y = velocity . y + wpnorm * velocity . theta * std :: cos ( wangle ); } return wv ; } VecArray wheel_place () const { return wheel_place_ ; } private : VecArray wheel_place_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/system_8hpp/","text":"include/cpp_robotics/system/system.hpp Source code #include \"./discret.hpp\" #include \"./state_space_system.hpp\" #include \"./transfer_function.hpp\" #include \"./discrete_transfer_function.hpp\" #include \"./polynomial.hpp\" #include \"./bode.hpp\" #include \"./nyquist.hpp\" #include \"./time_responce.hpp\" #include \"./siso_system.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/system.hpp"},{"location":"doxybook/Files/system_8hpp/#includecpp_roboticssystemsystemhpp","text":"","title":"include/cpp_robotics/system/system.hpp"},{"location":"doxybook/Files/system_8hpp/#source-code","text":"#include \"./discret.hpp\" #include \"./state_space_system.hpp\" #include \"./transfer_function.hpp\" #include \"./discrete_transfer_function.hpp\" #include \"./polynomial.hpp\" #include \"./bode.hpp\" #include \"./nyquist.hpp\" #include \"./time_responce.hpp\" #include \"./siso_system.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/time__responce_8hpp/","text":"include/cpp_robotics/system/time_responce.hpp Namespaces Name cpp_robotics Source code #pragma once #include <tuple> #include \"./transfer_function.hpp\" #include \"./discrete_transfer_function.hpp\" namespace cpp_robotics { static std :: tuple < std :: vector < double > , std :: vector < double >> impluse ( TransferFunction & sys , double time ) { std :: vector < double > t = arrange ( 0 , time , sys . Ts ()); std :: vector < double > res ( t . size ()); for ( size_t i = 0 ; i < res . size (); i ++ ) { res [ i ] = sys . responce ( i == 0 ? 1.0 / sys . Ts () : 0.0 ); } return { t , res }; } static std :: tuple < std :: vector < double > , std :: vector < double >> step ( const std :: function < double ( double ) > & sys , double dt , double time , const double gain = 1.0 ) { std :: vector < double > t = arrange ( 0 , time , dt ); std :: vector < double > res ( t . size ()); for ( size_t i = 0 ; i < res . size (); i ++ ) { res [ i ] = sys ( gain ); } return { t , res }; } static std :: tuple < std :: vector < double > , std :: vector < double >> step ( TransferFunction & sys , double time , const double gain = 1.0 ) { return step ([ & ]( double u ){ return sys . responce ( u ); }, sys . Ts (), time , gain ); } static std :: tuple < std :: vector < double > , std :: vector < double >> step ( DiscreteTransferFunction & sys , double time , const double gain = 1.0 ) { return step ([ & ]( double u ){ return sys . responce ( u ); }, sys . Ts (), time , gain ); } static std :: tuple < std :: vector < double > , std :: vector < double >> lsim ( TransferFunction & sys , std :: vector < double > input ) { std :: vector < double > t = linspace ( 0 , sys . Ts () * input . size (), input . size ()); std :: vector < double > res ( t . size ()); for ( size_t i = 0 ; i < res . size (); i ++ ) { res [ i ] = sys . responce ( input [ i ]); } return { t , res }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/time_responce.hpp"},{"location":"doxybook/Files/time__responce_8hpp/#includecpp_roboticssystemtime_responcehpp","text":"","title":"include/cpp_robotics/system/time_responce.hpp"},{"location":"doxybook/Files/time__responce_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/time__responce_8hpp/#source-code","text":"#pragma once #include <tuple> #include \"./transfer_function.hpp\" #include \"./discrete_transfer_function.hpp\" namespace cpp_robotics { static std :: tuple < std :: vector < double > , std :: vector < double >> impluse ( TransferFunction & sys , double time ) { std :: vector < double > t = arrange ( 0 , time , sys . Ts ()); std :: vector < double > res ( t . size ()); for ( size_t i = 0 ; i < res . size (); i ++ ) { res [ i ] = sys . responce ( i == 0 ? 1.0 / sys . Ts () : 0.0 ); } return { t , res }; } static std :: tuple < std :: vector < double > , std :: vector < double >> step ( const std :: function < double ( double ) > & sys , double dt , double time , const double gain = 1.0 ) { std :: vector < double > t = arrange ( 0 , time , dt ); std :: vector < double > res ( t . size ()); for ( size_t i = 0 ; i < res . size (); i ++ ) { res [ i ] = sys ( gain ); } return { t , res }; } static std :: tuple < std :: vector < double > , std :: vector < double >> step ( TransferFunction & sys , double time , const double gain = 1.0 ) { return step ([ & ]( double u ){ return sys . responce ( u ); }, sys . Ts (), time , gain ); } static std :: tuple < std :: vector < double > , std :: vector < double >> step ( DiscreteTransferFunction & sys , double time , const double gain = 1.0 ) { return step ([ & ]( double u ){ return sys . responce ( u ); }, sys . Ts (), time , gain ); } static std :: tuple < std :: vector < double > , std :: vector < double >> lsim ( TransferFunction & sys , std :: vector < double > input ) { std :: vector < double > t = linspace ( 0 , sys . Ts () * input . size (), input . size ()); std :: vector < double > res ( t . size ()); for ( size_t i = 0 ; i < res . size (); i ++ ) { res [ i ] = sys . responce ( input [ i ]); } return { t , res }; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/transfer__function_8hpp/","text":"include/cpp_robotics/system/transfer_function.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb Source code #pragma once #include <Eigen/Dense> #include \"state_space_system.hpp\" #include <iostream> namespace cpp_robotics { class TransferFunction : public StateSpaceSystem { public : static TransferFunction make_first_order_system ( const double T , const double Ts ) { return TransferFunction ({ 1 }, { T , 1 }, Ts ); } static TransferFunction make_second_order_system ( const double omega , const double zeta , const double Ts ) { return TransferFunction ({ omega * omega }, { 1.0 , 2.0 * zeta * omega , omega * omega }, Ts ); } TransferFunction () : StateSpaceSystem () {} TransferFunction ( std :: vector < double > num , std :: vector < double > den , const double Ts ) : num_array_ ( num ), den_array_ ( den ) { // \u4f1d\u9054\u95a2\u6570\u3092\u53ef\u5236\u5fa1\u6b63\u6e96\u7cfb\u306b\u5909\u63db\u3057\u3066\u4fdd\u5b58 const size_t num_size = num_array_ . size (); const size_t den_size = den_array_ . size (); const size_t state_size = den_deg (); Eigen :: MatrixXd A = Eigen :: MatrixXd :: Zero ( state_size , state_size ); // \u5bfe\u89d2\u8981\u7d20\u306e1\u500b\u53f3\u96a3\u30921\u57cb\u3081 for ( size_t i = 0 ; i < state_size -1 ; i ++ ) { A ( i , i + 1 ) = 1 ; } // \u4e00\u756a\u4e0b\u306e\u884c\u3092\u4f1d\u9054\u95a2\u6570\u306e\u8981\u7d20\u3067\u57cb\u3081 for ( size_t i = 0 ; i < state_size ; i ++ ) { A ( state_size -1 , i ) = - den_array_ [ state_size - i ] / den_array_ [ 0 ]; } Eigen :: MatrixXd B = Eigen :: VectorXd :: Zero ( state_size ); B ( state_size -1 ) = 1 ; Eigen :: MatrixXd C = Eigen :: RowVectorXd :: Zero ( state_size ); for ( size_t i = 0 ; i <= num_size ; i ++ ) { C ( i ) = num_array_ [ i ] / den_array_ [ 0 ]; } set_continuous ( A , B , C , Ts ); } size_t num_deg ( size_t num_idx = 0 ) const { return num_array_ . size () -1 - num_idx ; } size_t den_deg ( size_t num_idx = 0 ) const { return den_array_ . size () -1 - num_idx ; } std :: vector < double > num_array () const { return num_array_ ; } std :: vector < double > den_array () const { return den_array_ ; } private : std :: vector < double > num_array_ ; std :: vector < double > den_array_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/system/transfer_function.hpp"},{"location":"doxybook/Files/transfer__function_8hpp/#includecpp_roboticssystemtransfer_functionhpp","text":"","title":"include/cpp_robotics/system/transfer_function.hpp"},{"location":"doxybook/Files/transfer__function_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/transfer__function_8hpp/#classes","text":"Name class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb","title":"Classes"},{"location":"doxybook/Files/transfer__function_8hpp/#source-code","text":"#pragma once #include <Eigen/Dense> #include \"state_space_system.hpp\" #include <iostream> namespace cpp_robotics { class TransferFunction : public StateSpaceSystem { public : static TransferFunction make_first_order_system ( const double T , const double Ts ) { return TransferFunction ({ 1 }, { T , 1 }, Ts ); } static TransferFunction make_second_order_system ( const double omega , const double zeta , const double Ts ) { return TransferFunction ({ omega * omega }, { 1.0 , 2.0 * zeta * omega , omega * omega }, Ts ); } TransferFunction () : StateSpaceSystem () {} TransferFunction ( std :: vector < double > num , std :: vector < double > den , const double Ts ) : num_array_ ( num ), den_array_ ( den ) { // \u4f1d\u9054\u95a2\u6570\u3092\u53ef\u5236\u5fa1\u6b63\u6e96\u7cfb\u306b\u5909\u63db\u3057\u3066\u4fdd\u5b58 const size_t num_size = num_array_ . size (); const size_t den_size = den_array_ . size (); const size_t state_size = den_deg (); Eigen :: MatrixXd A = Eigen :: MatrixXd :: Zero ( state_size , state_size ); // \u5bfe\u89d2\u8981\u7d20\u306e1\u500b\u53f3\u96a3\u30921\u57cb\u3081 for ( size_t i = 0 ; i < state_size -1 ; i ++ ) { A ( i , i + 1 ) = 1 ; } // \u4e00\u756a\u4e0b\u306e\u884c\u3092\u4f1d\u9054\u95a2\u6570\u306e\u8981\u7d20\u3067\u57cb\u3081 for ( size_t i = 0 ; i < state_size ; i ++ ) { A ( state_size -1 , i ) = - den_array_ [ state_size - i ] / den_array_ [ 0 ]; } Eigen :: MatrixXd B = Eigen :: VectorXd :: Zero ( state_size ); B ( state_size -1 ) = 1 ; Eigen :: MatrixXd C = Eigen :: RowVectorXd :: Zero ( state_size ); for ( size_t i = 0 ; i <= num_size ; i ++ ) { C ( i ) = num_array_ [ i ] / den_array_ [ 0 ]; } set_continuous ( A , B , C , Ts ); } size_t num_deg ( size_t num_idx = 0 ) const { return num_array_ . size () -1 - num_idx ; } size_t den_deg ( size_t num_idx = 0 ) const { return den_array_ . size () -1 - num_idx ; } std :: vector < double > num_array () const { return num_array_ ; } std :: vector < double > den_array () const { return den_array_ ; } private : std :: vector < double > num_array_ ; std :: vector < double > den_array_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/transform_8hpp/","text":"include/cpp_robotics/vector/transform.hpp More... Namespaces Name cpp_robotics Classes Name struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 Detailed Description Author : Takumi Odashima ( Kotakkucu@gmail.com ) Date : 2021-01-25 Copyright : Copyright (c) 2021 Source code #pragma once #include \"./vector2.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Transform ; using Transformf = Transform < float > ; using Transformd = Transform < double > ; template < typename FLOATING_TYPE > struct Transform // { using value_type = FLOATING_TYPE ; using vector_type = Vector2 < value_type > ; value_type x , y , theta ; // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf Transform () = default ; constexpr Transform ( const value_type _x , const value_type _y , const value_type _theta ) : x ( _x ), y ( _y ), theta ( _theta ) {} constexpr Transform ( const vector_type & _xy , const value_type _theta ) : x ( _xy . x ), y ( _xy . y ), theta ( _theta ) {} constexpr Transform ( const Transform & ) = default ; constexpr vector_type make_vector2 () const { return vector_type ( x , y ); } constexpr void set ( value_type vx , value_type vy , value_type vtheta ) { x = vx ; y = vy ; theta = vtheta ; } // origin-xy\u8ddd\u96e2 value_type distance () const { return vector_type ( x , y ). norm (); } // \u56de\u8ee2 void rotate ( const value_type theta ) { rotate ( vector_type :: zero (), theta ); } void rotate ( const value_type rotX , const value_type rotY , const value_type theta ) { rotate ( vector_type ( rotX , rotY ), theta ); } void rotate ( vector_type rotPos , const value_type theta ) { vector_type p = make_vector2 () - rotPos ; p . rotate ( theta ); x = p . x + rotPos . x ; y = p . y + rotPos . y ; } // \u6975\u5ea7\u6a19\u6307\u5b9a void set_polar ( const value_type radius , const value_type angle , const value_type robotTheta ) { x = radius * std :: cos ( angle ); y = radius * std :: sin ( angle ); theta = robotTheta ; } bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ) && approx_zero ( theta ); } bool is_zero_pos () const { return x == 0.0 && y == 0.0 ; } bool is_zero_angle () const { return theta == 0.0 ; } bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ) || std :: isnan ( theta ); } static constexpr value_type get_angle ( Transform & a , Transform & b ) { return b . theta - a . theta ; }; static value_type get_distance ( Transform & a , Transform & b ) { return ( b - a ). distance (); } static Transform get_lerp ( Transform & a , Transform & b , const value_type t ) { return { lerp ( a . x , b . x , t ), lerp ( a . y , b . y , t ), lerp ( a . theta , b . theta , t )}; } // constatnt vector static constexpr Transform origin () { return { 0.0 , 0.0 , 0.0 }; } constexpr bool operator == ( const Transform v ) const { return ( x == v . x ) && ( y == v . y ) && ( theta == v . theta ); } constexpr bool operator != ( const Transform & v ) const { return ! (( x == v . x ) && ( y == v . y ) && ( theta == v . theta )); } constexpr Transform operator + ( const Transform & v ) const { return { x + v . x , y + v . y , theta + v . theta }; } constexpr Transform operator - ( const Transform & v ) const { return { x - v . x , y - v . y , theta - v . theta }; } constexpr Transform & operator += ( const Transform & v ) { x += v . x ; y += v . y ; theta += v . theta ; return * this ; } constexpr Transform & operator -= ( const Transform & v ) { x -= v . x ; y -= v . y ; theta -= v . theta ; return * this ; } // xy constexpr Transform operator + ( const vector_type & v ) const { return { x + v . x , y + v . y , theta }; } constexpr Transform operator - ( const vector_type & v ) const { return { x - v . x , y - v . y , theta }; } // theta constexpr Transform operator + ( const value_type angle ) const { return { x , y , theta + angle }; } constexpr Transform operator - ( const value_type angle ) const { return { x , y , theta - angle }; } // xy constexpr Transform & operator += ( const vector_type & v ) { x += v . x ; y += v . y ; return * this ; } constexpr Transform & operator -= ( const vector_type & v ) { x -= v . x ; y -= v . y ; return * this ; } // theta constexpr Transform & operator += ( const value_type angle ) { theta += angle ; return * this ; } constexpr Transform & operator -= ( const value_type angle ) { theta -= angle ; return * this ; } constexpr Transform operator * ( const value_type value ) const { return { x * value , y * value , theta * value }; } constexpr Transform operator / ( const value_type value ) const { return { x / value , y / value , theta / value }; } constexpr Transform & operator *= ( const value_type value ) { x *= value ; y *= value ; theta *= value ; return * this ; } constexpr Transform & operator /= ( const value_type value ) { x /= value ; y /= value ; theta /= value ; return * this ; } // index value_type & operator [] ( const int index ) { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return theta ; } constexpr value_type operator [] ( const int index ) const { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return theta ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/vector/transform.hpp"},{"location":"doxybook/Files/transform_8hpp/#includecpp_roboticsvectortransformhpp","text":"More...","title":"include/cpp_robotics/vector/transform.hpp"},{"location":"doxybook/Files/transform_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/transform_8hpp/#classes","text":"Name struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9","title":"Classes"},{"location":"doxybook/Files/transform_8hpp/#detailed-description","text":"Author : Takumi Odashima ( Kotakkucu@gmail.com ) Date : 2021-01-25 Copyright : Copyright (c) 2021","title":"Detailed Description"},{"location":"doxybook/Files/transform_8hpp/#source-code","text":"#pragma once #include \"./vector2.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Transform ; using Transformf = Transform < float > ; using Transformd = Transform < double > ; template < typename FLOATING_TYPE > struct Transform // { using value_type = FLOATING_TYPE ; using vector_type = Vector2 < value_type > ; value_type x , y , theta ; // \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf Transform () = default ; constexpr Transform ( const value_type _x , const value_type _y , const value_type _theta ) : x ( _x ), y ( _y ), theta ( _theta ) {} constexpr Transform ( const vector_type & _xy , const value_type _theta ) : x ( _xy . x ), y ( _xy . y ), theta ( _theta ) {} constexpr Transform ( const Transform & ) = default ; constexpr vector_type make_vector2 () const { return vector_type ( x , y ); } constexpr void set ( value_type vx , value_type vy , value_type vtheta ) { x = vx ; y = vy ; theta = vtheta ; } // origin-xy\u8ddd\u96e2 value_type distance () const { return vector_type ( x , y ). norm (); } // \u56de\u8ee2 void rotate ( const value_type theta ) { rotate ( vector_type :: zero (), theta ); } void rotate ( const value_type rotX , const value_type rotY , const value_type theta ) { rotate ( vector_type ( rotX , rotY ), theta ); } void rotate ( vector_type rotPos , const value_type theta ) { vector_type p = make_vector2 () - rotPos ; p . rotate ( theta ); x = p . x + rotPos . x ; y = p . y + rotPos . y ; } // \u6975\u5ea7\u6a19\u6307\u5b9a void set_polar ( const value_type radius , const value_type angle , const value_type robotTheta ) { x = radius * std :: cos ( angle ); y = radius * std :: sin ( angle ); theta = robotTheta ; } bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ) && approx_zero ( theta ); } bool is_zero_pos () const { return x == 0.0 && y == 0.0 ; } bool is_zero_angle () const { return theta == 0.0 ; } bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ) || std :: isnan ( theta ); } static constexpr value_type get_angle ( Transform & a , Transform & b ) { return b . theta - a . theta ; }; static value_type get_distance ( Transform & a , Transform & b ) { return ( b - a ). distance (); } static Transform get_lerp ( Transform & a , Transform & b , const value_type t ) { return { lerp ( a . x , b . x , t ), lerp ( a . y , b . y , t ), lerp ( a . theta , b . theta , t )}; } // constatnt vector static constexpr Transform origin () { return { 0.0 , 0.0 , 0.0 }; } constexpr bool operator == ( const Transform v ) const { return ( x == v . x ) && ( y == v . y ) && ( theta == v . theta ); } constexpr bool operator != ( const Transform & v ) const { return ! (( x == v . x ) && ( y == v . y ) && ( theta == v . theta )); } constexpr Transform operator + ( const Transform & v ) const { return { x + v . x , y + v . y , theta + v . theta }; } constexpr Transform operator - ( const Transform & v ) const { return { x - v . x , y - v . y , theta - v . theta }; } constexpr Transform & operator += ( const Transform & v ) { x += v . x ; y += v . y ; theta += v . theta ; return * this ; } constexpr Transform & operator -= ( const Transform & v ) { x -= v . x ; y -= v . y ; theta -= v . theta ; return * this ; } // xy constexpr Transform operator + ( const vector_type & v ) const { return { x + v . x , y + v . y , theta }; } constexpr Transform operator - ( const vector_type & v ) const { return { x - v . x , y - v . y , theta }; } // theta constexpr Transform operator + ( const value_type angle ) const { return { x , y , theta + angle }; } constexpr Transform operator - ( const value_type angle ) const { return { x , y , theta - angle }; } // xy constexpr Transform & operator += ( const vector_type & v ) { x += v . x ; y += v . y ; return * this ; } constexpr Transform & operator -= ( const vector_type & v ) { x -= v . x ; y -= v . y ; return * this ; } // theta constexpr Transform & operator += ( const value_type angle ) { theta += angle ; return * this ; } constexpr Transform & operator -= ( const value_type angle ) { theta -= angle ; return * this ; } constexpr Transform operator * ( const value_type value ) const { return { x * value , y * value , theta * value }; } constexpr Transform operator / ( const value_type value ) const { return { x / value , y / value , theta / value }; } constexpr Transform & operator *= ( const value_type value ) { x *= value ; y *= value ; theta *= value ; return * this ; } constexpr Transform & operator /= ( const value_type value ) { x /= value ; y /= value ; theta /= value ; return * this ; } // index value_type & operator [] ( const int index ) { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return theta ; } constexpr value_type operator [] ( const int index ) const { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return theta ; } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/unit__core_8hpp/","text":"include/cpp_robotics/units/unit_core.hpp Namespaces Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::prefix cpp_robotics::unit::tag Classes Name struct cpp_robotics::unit::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 struct cpp_robotics::unit::prefix::pfx_mul struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag<-1 > struct cpp_robotics::unit::tag::is_normal_tag< 0 > class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9 Defines Name GENERATE_CONV_FACTOR (unit_dim, from_tag, to_tag, factor) GENERATE_UNIT_SUFFIX (unit, suffix) GENERATE_UNIT_PFX_SUFFIX (unit_type, prefix, suffix) Macros Documentation define GENERATE_CONV_FACTOR #define GENERATE_CONV_FACTOR( unit_dim , from_tag , to_tag , factor ) template <> \\ constexpr double conv_factor < unit_dim , from_tag , to_tag > () \\ { \\ return ( factor ); \\ } define GENERATE_UNIT_SUFFIX #define GENERATE_UNIT_SUFFIX( unit , suffix ) constexpr unit operator \"\" _ ## suffix ( unsigned long long val ) \\ { \\ return unit { static_cast < double > ( val )}; \\ } \\ constexpr unit operator \"\" _ ## suffix ( long double val ) \\ { \\ return unit { static_cast < double > ( val )}; \\ } define GENERATE_UNIT_PFX_SUFFIX #define GENERATE_UNIT_PFX_SUFFIX( unit_type , prefix , suffix ) constexpr auto operator \"\" _ ## suffix ( unsigned long long val ) \\ { \\ using namespace cpp_robotics :: unit ; \\ return unit_assem :: unit_pfx_scaled < unit_type , prefix >:: unit { static_cast < double > ( val )}; \\ } \\ constexpr auto operator \"\" _ ## suffix ( long double val ) \\ { \\ using namespace cpp_robotics :: unit ; \\ return unit_assem :: unit_pfx_scaled < unit_type , prefix >:: unit { static_cast < double > ( val )}; \\ } Source code #pragma once #include <cstdint> #include <cstdlib> #include <type_traits> #include <numeric> #include <cmath> namespace cpp_robotics { inline namespace unit { enum UnitIndex { MetereIdx , KiloGramIdx , SecondIdx , AmpereIdx , KelvinIdx , MoleIdx , CandelaIdx }; template < int DIM1 , int DIM2 , int DIM3 , int DIM4 , int DIM5 , int DIM6 , int DIM7 > struct UnitType { static constexpr int dim1 = DIM1 ; static constexpr int dim2 = DIM2 ; static constexpr int dim3 = DIM3 ; static constexpr int dim4 = DIM4 ; static constexpr int dim5 = DIM5 ; static constexpr int dim6 = DIM6 ; static constexpr int dim7 = DIM7 ; }; namespace unit_dim_assem { template < class U1 , class U2 > struct udim_mul { using unit = UnitType < U1 :: dim1 + U2 :: dim1 , U1 :: dim2 + U2 :: dim2 , U1 :: dim3 + U2 :: dim3 , U1 :: dim4 + U2 :: dim4 , U1 :: dim5 + U2 :: dim5 , U1 :: dim6 + U2 :: dim6 , U1 :: dim7 + U2 :: dim7 > ; }; template < class U1 , class U2 > struct udim_div { using unit = UnitType < U1 :: dim1 - U2 :: dim1 , U1 :: dim2 - U2 :: dim2 , U1 :: dim3 - U2 :: dim3 , U1 :: dim4 - U2 :: dim4 , U1 :: dim5 - U2 :: dim5 , U1 :: dim6 - U2 :: dim6 , U1 :: dim7 - U2 :: dim7 > ; }; template < class U1 , int N > struct udim_pow { using unit = UnitType < U1 :: dim1 * N , U1 :: dim2 * N , U1 :: dim3 * N , U1 :: dim4 * N , U1 :: dim5 * N , U1 :: dim6 * N , U1 :: dim7 * N > ; }; template < class U1 > struct udim_inv { using unit = UnitType < - U1 :: dim1 , - U1 :: dim2 , - U1 :: dim3 , - U1 :: dim4 , - U1 :: dim5 , - U1 :: dim6 , - U1 :: dim7 > ; }; } struct PrefixBase { PrefixBase () = delete ; }; template < uint32_t N , uint32_t D > struct Prefix : public PrefixBase { using type = Prefix < N , D > ; static constexpr uint32_t num = N / std :: gcd ( N , D ); static constexpr uint32_t den = D / std :: gcd ( N , D ); }; namespace prefix { using nano = Prefix < 1 , 1000000000 > ; using micro = Prefix < 1 , 1000000 > ; using milli = Prefix < 1 , 1000 > ; using centi = Prefix < 1 , 100 > ; using deci = Prefix < 1 , 10 > ; using none = Prefix < 1 , 1 > ; using deca = Prefix < 10 , 1 > ; using hecto = Prefix < 100 , 1 > ; using kilo = Prefix < 1000 , 1 > ; using mega = Prefix < 1000000 , 1 > ; using giga = Prefix < 1000000000 , 1 > ; template < class P1 , class P2 > struct pfx_mul { static constexpr uint32_t raw_num = P2 :: num * P1 :: num ; static constexpr uint32_t raw_den = P2 :: den * P1 :: den ; using prefix = Prefix < raw_num , raw_den > ; }; template < class P1 , class P2 > struct pfx_div { static constexpr uint32_t raw_num = P1 :: num * P2 :: den ; static constexpr uint32_t raw_den = P1 :: den * P2 :: num ; using prefix = Prefix < raw_num , raw_den > ; }; template < class P > struct pfx_inv { using prefix = Prefix < P :: den , P :: num > ; }; template < class P1 , class P2 > struct pfx_min { static constexpr uint32_t raw_num = std :: min ( P1 :: num * P2 :: den , P2 :: num * P1 :: den ); static constexpr uint32_t raw_den = P1 :: den * P2 :: den ; using prefix = Prefix < raw_num , raw_den > ; }; } namespace tag { enum angle { radian = 0 , degree }; enum angular_vel { rad_per_sec = 0 , rps , rpm }; template < int Tag > struct is_normal_tag : std :: false_type {}; template <> struct is_normal_tag < -1 > : std :: true_type {}; template <> struct is_normal_tag < 0 > : std :: true_type {}; } template < class UnitDimType , int FromTag , int ToTag , bool IsNormalTag = tag :: is_normal_tag < FromTag >:: value && tag :: is_normal_tag < ToTag >:: value > constexpr double conv_factor () { static_assert ( IsNormalTag == true , \"conv_factor is not defined\" ); return 1 ; } template < class T , class UnitDimType , class P , int Tag = -1 > class Unit { static_assert ( std :: is_arithmetic_v < T > , \"T is not arithmetic.\" ); static_assert ( std :: is_base_of_v < PrefixBase , P > && ! std :: is_same_v < PrefixBase , P > , \"\" ); public : using value_type = T ; using unit_dimention_type = UnitDimType ; using prefix_type = P ; using unit_type = Unit < T , UnitDimType , P > ; static constexpr int tag = Tag ; Unit () = default ; constexpr Unit ( T val ) : val_ ( val ){} constexpr T value () const { return val_ ; } constexpr T raw_value () const { return val_ * P :: num / P :: den ; } constexpr unit_type operator + () const { return val_ ; } constexpr unit_type operator - () const { return - val_ ; } constexpr unit_type operator + ( const unit_type & rhl ) const { return { val_ + rhl . value ()}; } constexpr unit_type operator - ( const unit_type & rhl ) const { return { val_ - rhl . value ()}; } constexpr auto operator * ( const unit_type & rhl ) const { using ret_dim_type = typename unit_dim_assem :: udim_mul < unit_dimention_type , unit_dimention_type >:: unit ; using ret_type = Unit < value_type , ret_dim_type , prefix :: none > ; return ret_type { raw_value () * rhl . raw_value ()}; } constexpr unit_type & operator += ( const unit_type & rhl ) { val_ += rhl . value (); return * this ; } constexpr unit_type & operator -= ( const unit_type & rhl ) { val_ -= rhl . value (); return * this ; } // \u30bf\u30b0\u306e\u5909\u63db template < int R_Tag > constexpr operator Unit < value_type , unit_dimention_type , prefix_type , R_Tag > () const { using ret_type = Unit < T , UnitDimType , prefix_type , R_Tag > ; if constexpr ( tag == -1 && R_Tag == 0 ) { ret_type { value ()}; } return ret_type { value () * conv_factor < unit_dimention_type , tag , R_Tag > ()}; } // \u63a5\u982d\u8a9e\u306e\u5909\u63db template < class R_P > constexpr operator Unit < value_type , unit_dimention_type , R_P , tag > () const { using ret_type = Unit < T , UnitDimType , R_P > ; using scale_prefix = typename prefix :: pfx_div < R_P , prefix_type >:: prefix ; return ret_type { value () * scale_prefix :: den / scale_prefix :: num }; } // \u6570\u5024\u578b\u306b\u5909\u63db constexpr operator value_type () const { return static_cast < value_type > ( val_ ); } constexpr bool operator == ( const unit_type & r_value ) { return val_ == r_value . value (); } constexpr bool operator != ( const unit_type & r_value ) { return ! ( val_ == r_value ); } private : T val_ ; }; namespace unit_assem { template < class Unit1 , class Unit2 > struct unit_mul { static_assert ( std :: is_same_v < typename Unit1 :: value_type , typename Unit2 :: value_type > , \"\" ); // static_assert(Unit1::tag == 0 && Unit2::tag == 0, \"\"); using dim = typename unit_dim_assem :: udim_mul < typename Unit1 :: unit_dimention_type , typename Unit2 :: unit_dimention_type >:: unit ; using pfx = typename prefix :: pfx_mul < typename Unit1 :: prefix_type , typename Unit2 :: prefix_type >:: prefix ; using unit = Unit < typename Unit1 :: value_type , dim , pfx > ; }; template < class Unit1 , class Unit2 > struct unit_div { static_assert ( std :: is_same_v < typename Unit1 :: value_type , typename Unit2 :: value_type > , \"\" ); // static_assert(Unit1::tag == 0 && Unit2::tag == 0, \"\"); using dim = typename unit_dim_assem :: udim_div < typename Unit1 :: unit_dimention_type , typename Unit2 :: unit_dimention_type >:: unit ; using pfx = typename prefix :: pfx_div < typename Unit1 :: prefix_type , typename Unit2 :: prefix_type >:: prefix ; using unit = Unit < typename Unit1 :: value_type , dim , pfx > ; }; template < class UnitType > struct unit_inv { using dim = typename unit_dim_assem :: udim_inv < typename UnitType :: unit_dimention_type >:: unit ; using pfx = typename prefix :: pfx_inv < typename UnitType :: prefix_type >:: prefix ; using unit = Unit < typename UnitType :: value_type , dim , pfx , 0 > ; }; template < class UnitType , class PrefixType > struct unit_pfx_scaled { using unit = Unit < typename UnitType :: value_type , typename UnitType :: unit_dimention_type , typename prefix :: pfx_mul < typename UnitType :: prefix_type , PrefixType >:: prefix , UnitType :: tag > ; }; } // template <class UnitType, typename T> // constexpr auto operator <=>(const UnitType &l_value, const T &r_value) // { // return static_cast<typename UnitType::value_type>(l_value) <=> r_value; // } // \u5358\u4f4d*\u6570\u5024 template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T1 , UnitDim , Prefix , Tag > ; return unit_type ( static_cast < T1 > ( l_value ) * r_value ); } // \u6570\u5024*\u5358\u4f4d template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T2 , UnitDim , Prefix , Tag > ; return unit_type ( l_value * static_cast < T1 > ( r_value )); } // \u6570\u5024/\u5358\u4f4d template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T2 , UnitDim , Prefix , Tag > ; return typename unit_assem :: unit_inv < unit_type >:: unit ( l_value / static_cast < T2 > ( r_value )); } // \u5358\u4f4d/\u6570\u5024 template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T1 , UnitDim , Prefix , Tag > ; return unit_type ( static_cast < T1 > ( l_value ) / r_value ); } // \u5358\u4f4d*\u5358\u4f4d template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator * ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 >& lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) { // static_assert(std::is_base_of_v<Unit, R_UnitDimType> && std::is_base_of_v<Unit, L_UnityDimType>, \"test\"); static_assert ( tag :: is_normal_tag < Tag1 >:: value && tag :: is_normal_tag < Tag2 >:: value , \"Type has not normal tag\" ); // static_assert(R_UnitDimType) // static_assert(R_P) using ret_dim_type = typename unit_dim_assem :: udim_mul < UnitDim1 , UnitDim2 >:: unit ; using ret_type = Unit < T1 , ret_dim_type , prefix :: none > ; return ret_type { lhl . raw_value () * rhl . raw_value ()}; } // \u5358\u4f4d/\u5358\u4f4d template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator / ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 >& lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) { static_assert ( tag :: is_normal_tag < Tag1 >:: value && tag :: is_normal_tag < Tag2 >:: value , \"Type has not normal tag\" ); // static_assert(R_UnitDimType) // static_assert(R_P) static_assert ( tag :: is_normal_tag < Tag2 >:: value , \"R_Tag is imcorrect\" ); using ret_dim_type = typename unit_dim_assem :: udim_div < UnitDim1 , UnitDim2 >:: unit ; using ret_type = Unit < T1 , ret_dim_type , prefix :: none > ; return ret_type { lhl . raw_value () / rhl . raw_value ()}; } // \u5358\u4f4d+\u5358\u4f4d(prefix\u9055\u3044) // prefix\u304c\u5c0f\u3055\u3044\u65b9\u3067\u8fd4\u3059 template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator + ( const Unit < T , UnitDim , Prefix1 , Tag >& lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) { using min_prefix = typename prefix :: pfx_min < Prefix1 , Prefix2 >:: prefix ; using lpfx = typename prefix :: pfx_div < Prefix1 , min_prefix >:: prefix ; T lhl_scaled_val = lhl . value () * lpfx :: num / lpfx :: den ; using rpfx = typename prefix :: pfx_div < Prefix2 , min_prefix >:: prefix ; T rhl_scaled_val = rhl . value () * rpfx :: num / rpfx :: den ; using ret_type = Unit < T , UnitDim , min_prefix , Tag > ; return ret_type { lhl_scaled_val + rhl_scaled_val }; } template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator - ( const Unit < T , UnitDim , Prefix1 , Tag >& lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) { using min_prefix = typename prefix :: pfx_min < Prefix1 , Prefix2 >:: prefix ; using lpfx = typename prefix :: pfx_div < Prefix1 , min_prefix >:: prefix ; T lhl_scaled_val = lhl . value () * lpfx :: num / lpfx :: den ; using rpfx = typename prefix :: pfx_div < Prefix2 , min_prefix >:: prefix ; T rhl_scaled_val = rhl . value () * rpfx :: num / rpfx :: den ; using ret_type = Unit < T , UnitDim , min_prefix , Tag > ; return ret_type { lhl_scaled_val - rhl_scaled_val }; } #define GENERATE_CONV_FACTOR(unit_dim, from_tag, to_tag, factor)\\ template<>\\ constexpr double conv_factor<unit_dim, from_tag, to_tag>()\\ {\\ return (factor);\\ } #define GENERATE_UNIT_SUFFIX(unit, suffix)\\ constexpr unit operator\"\" _## suffix(unsigned long long val)\\ {\\ return unit{static_cast<double>(val)};\\ }\\ constexpr unit operator\"\" _## suffix(long double val)\\ {\\ return unit{static_cast<double>(val)};\\ } #define GENERATE_UNIT_PFX_SUFFIX(unit_type, prefix, suffix)\\ constexpr auto operator\"\" _## suffix(unsigned long long val)\\ {\\ using namespace cpp_robotics::unit;\\ return unit_assem::unit_pfx_scaled<unit_type, prefix>::unit{static_cast<double>(val)};\\ }\\ constexpr auto operator\"\" _## suffix(long double val)\\ {\\ using namespace cpp_robotics::unit;\\ return unit_assem::unit_pfx_scaled<unit_type, prefix>::unit{static_cast<double>(val)};\\ } } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/units/unit_core.hpp"},{"location":"doxybook/Files/unit__core_8hpp/#includecpp_roboticsunitsunit_corehpp","text":"","title":"include/cpp_robotics/units/unit_core.hpp"},{"location":"doxybook/Files/unit__core_8hpp/#namespaces","text":"Name cpp_robotics cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::prefix cpp_robotics::unit::tag","title":"Namespaces"},{"location":"doxybook/Files/unit__core_8hpp/#classes","text":"Name struct cpp_robotics::unit::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 struct cpp_robotics::unit::prefix::pfx_mul struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag<-1 > struct cpp_robotics::unit::tag::is_normal_tag< 0 > class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9","title":"Classes"},{"location":"doxybook/Files/unit__core_8hpp/#defines","text":"Name GENERATE_CONV_FACTOR (unit_dim, from_tag, to_tag, factor) GENERATE_UNIT_SUFFIX (unit, suffix) GENERATE_UNIT_PFX_SUFFIX (unit_type, prefix, suffix)","title":"Defines"},{"location":"doxybook/Files/unit__core_8hpp/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_conv_factor","text":"#define GENERATE_CONV_FACTOR( unit_dim , from_tag , to_tag , factor ) template <> \\ constexpr double conv_factor < unit_dim , from_tag , to_tag > () \\ { \\ return ( factor ); \\ }","title":"define GENERATE_CONV_FACTOR"},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_unit_suffix","text":"#define GENERATE_UNIT_SUFFIX( unit , suffix ) constexpr unit operator \"\" _ ## suffix ( unsigned long long val ) \\ { \\ return unit { static_cast < double > ( val )}; \\ } \\ constexpr unit operator \"\" _ ## suffix ( long double val ) \\ { \\ return unit { static_cast < double > ( val )}; \\ }","title":"define GENERATE_UNIT_SUFFIX"},{"location":"doxybook/Files/unit__core_8hpp/#define-generate_unit_pfx_suffix","text":"#define GENERATE_UNIT_PFX_SUFFIX( unit_type , prefix , suffix ) constexpr auto operator \"\" _ ## suffix ( unsigned long long val ) \\ { \\ using namespace cpp_robotics :: unit ; \\ return unit_assem :: unit_pfx_scaled < unit_type , prefix >:: unit { static_cast < double > ( val )}; \\ } \\ constexpr auto operator \"\" _ ## suffix ( long double val ) \\ { \\ using namespace cpp_robotics :: unit ; \\ return unit_assem :: unit_pfx_scaled < unit_type , prefix >:: unit { static_cast < double > ( val )}; \\ }","title":"define GENERATE_UNIT_PFX_SUFFIX"},{"location":"doxybook/Files/unit__core_8hpp/#source-code","text":"#pragma once #include <cstdint> #include <cstdlib> #include <type_traits> #include <numeric> #include <cmath> namespace cpp_robotics { inline namespace unit { enum UnitIndex { MetereIdx , KiloGramIdx , SecondIdx , AmpereIdx , KelvinIdx , MoleIdx , CandelaIdx }; template < int DIM1 , int DIM2 , int DIM3 , int DIM4 , int DIM5 , int DIM6 , int DIM7 > struct UnitType { static constexpr int dim1 = DIM1 ; static constexpr int dim2 = DIM2 ; static constexpr int dim3 = DIM3 ; static constexpr int dim4 = DIM4 ; static constexpr int dim5 = DIM5 ; static constexpr int dim6 = DIM6 ; static constexpr int dim7 = DIM7 ; }; namespace unit_dim_assem { template < class U1 , class U2 > struct udim_mul { using unit = UnitType < U1 :: dim1 + U2 :: dim1 , U1 :: dim2 + U2 :: dim2 , U1 :: dim3 + U2 :: dim3 , U1 :: dim4 + U2 :: dim4 , U1 :: dim5 + U2 :: dim5 , U1 :: dim6 + U2 :: dim6 , U1 :: dim7 + U2 :: dim7 > ; }; template < class U1 , class U2 > struct udim_div { using unit = UnitType < U1 :: dim1 - U2 :: dim1 , U1 :: dim2 - U2 :: dim2 , U1 :: dim3 - U2 :: dim3 , U1 :: dim4 - U2 :: dim4 , U1 :: dim5 - U2 :: dim5 , U1 :: dim6 - U2 :: dim6 , U1 :: dim7 - U2 :: dim7 > ; }; template < class U1 , int N > struct udim_pow { using unit = UnitType < U1 :: dim1 * N , U1 :: dim2 * N , U1 :: dim3 * N , U1 :: dim4 * N , U1 :: dim5 * N , U1 :: dim6 * N , U1 :: dim7 * N > ; }; template < class U1 > struct udim_inv { using unit = UnitType < - U1 :: dim1 , - U1 :: dim2 , - U1 :: dim3 , - U1 :: dim4 , - U1 :: dim5 , - U1 :: dim6 , - U1 :: dim7 > ; }; } struct PrefixBase { PrefixBase () = delete ; }; template < uint32_t N , uint32_t D > struct Prefix : public PrefixBase { using type = Prefix < N , D > ; static constexpr uint32_t num = N / std :: gcd ( N , D ); static constexpr uint32_t den = D / std :: gcd ( N , D ); }; namespace prefix { using nano = Prefix < 1 , 1000000000 > ; using micro = Prefix < 1 , 1000000 > ; using milli = Prefix < 1 , 1000 > ; using centi = Prefix < 1 , 100 > ; using deci = Prefix < 1 , 10 > ; using none = Prefix < 1 , 1 > ; using deca = Prefix < 10 , 1 > ; using hecto = Prefix < 100 , 1 > ; using kilo = Prefix < 1000 , 1 > ; using mega = Prefix < 1000000 , 1 > ; using giga = Prefix < 1000000000 , 1 > ; template < class P1 , class P2 > struct pfx_mul { static constexpr uint32_t raw_num = P2 :: num * P1 :: num ; static constexpr uint32_t raw_den = P2 :: den * P1 :: den ; using prefix = Prefix < raw_num , raw_den > ; }; template < class P1 , class P2 > struct pfx_div { static constexpr uint32_t raw_num = P1 :: num * P2 :: den ; static constexpr uint32_t raw_den = P1 :: den * P2 :: num ; using prefix = Prefix < raw_num , raw_den > ; }; template < class P > struct pfx_inv { using prefix = Prefix < P :: den , P :: num > ; }; template < class P1 , class P2 > struct pfx_min { static constexpr uint32_t raw_num = std :: min ( P1 :: num * P2 :: den , P2 :: num * P1 :: den ); static constexpr uint32_t raw_den = P1 :: den * P2 :: den ; using prefix = Prefix < raw_num , raw_den > ; }; } namespace tag { enum angle { radian = 0 , degree }; enum angular_vel { rad_per_sec = 0 , rps , rpm }; template < int Tag > struct is_normal_tag : std :: false_type {}; template <> struct is_normal_tag < -1 > : std :: true_type {}; template <> struct is_normal_tag < 0 > : std :: true_type {}; } template < class UnitDimType , int FromTag , int ToTag , bool IsNormalTag = tag :: is_normal_tag < FromTag >:: value && tag :: is_normal_tag < ToTag >:: value > constexpr double conv_factor () { static_assert ( IsNormalTag == true , \"conv_factor is not defined\" ); return 1 ; } template < class T , class UnitDimType , class P , int Tag = -1 > class Unit { static_assert ( std :: is_arithmetic_v < T > , \"T is not arithmetic.\" ); static_assert ( std :: is_base_of_v < PrefixBase , P > && ! std :: is_same_v < PrefixBase , P > , \"\" ); public : using value_type = T ; using unit_dimention_type = UnitDimType ; using prefix_type = P ; using unit_type = Unit < T , UnitDimType , P > ; static constexpr int tag = Tag ; Unit () = default ; constexpr Unit ( T val ) : val_ ( val ){} constexpr T value () const { return val_ ; } constexpr T raw_value () const { return val_ * P :: num / P :: den ; } constexpr unit_type operator + () const { return val_ ; } constexpr unit_type operator - () const { return - val_ ; } constexpr unit_type operator + ( const unit_type & rhl ) const { return { val_ + rhl . value ()}; } constexpr unit_type operator - ( const unit_type & rhl ) const { return { val_ - rhl . value ()}; } constexpr auto operator * ( const unit_type & rhl ) const { using ret_dim_type = typename unit_dim_assem :: udim_mul < unit_dimention_type , unit_dimention_type >:: unit ; using ret_type = Unit < value_type , ret_dim_type , prefix :: none > ; return ret_type { raw_value () * rhl . raw_value ()}; } constexpr unit_type & operator += ( const unit_type & rhl ) { val_ += rhl . value (); return * this ; } constexpr unit_type & operator -= ( const unit_type & rhl ) { val_ -= rhl . value (); return * this ; } // \u30bf\u30b0\u306e\u5909\u63db template < int R_Tag > constexpr operator Unit < value_type , unit_dimention_type , prefix_type , R_Tag > () const { using ret_type = Unit < T , UnitDimType , prefix_type , R_Tag > ; if constexpr ( tag == -1 && R_Tag == 0 ) { ret_type { value ()}; } return ret_type { value () * conv_factor < unit_dimention_type , tag , R_Tag > ()}; } // \u63a5\u982d\u8a9e\u306e\u5909\u63db template < class R_P > constexpr operator Unit < value_type , unit_dimention_type , R_P , tag > () const { using ret_type = Unit < T , UnitDimType , R_P > ; using scale_prefix = typename prefix :: pfx_div < R_P , prefix_type >:: prefix ; return ret_type { value () * scale_prefix :: den / scale_prefix :: num }; } // \u6570\u5024\u578b\u306b\u5909\u63db constexpr operator value_type () const { return static_cast < value_type > ( val_ ); } constexpr bool operator == ( const unit_type & r_value ) { return val_ == r_value . value (); } constexpr bool operator != ( const unit_type & r_value ) { return ! ( val_ == r_value ); } private : T val_ ; }; namespace unit_assem { template < class Unit1 , class Unit2 > struct unit_mul { static_assert ( std :: is_same_v < typename Unit1 :: value_type , typename Unit2 :: value_type > , \"\" ); // static_assert(Unit1::tag == 0 && Unit2::tag == 0, \"\"); using dim = typename unit_dim_assem :: udim_mul < typename Unit1 :: unit_dimention_type , typename Unit2 :: unit_dimention_type >:: unit ; using pfx = typename prefix :: pfx_mul < typename Unit1 :: prefix_type , typename Unit2 :: prefix_type >:: prefix ; using unit = Unit < typename Unit1 :: value_type , dim , pfx > ; }; template < class Unit1 , class Unit2 > struct unit_div { static_assert ( std :: is_same_v < typename Unit1 :: value_type , typename Unit2 :: value_type > , \"\" ); // static_assert(Unit1::tag == 0 && Unit2::tag == 0, \"\"); using dim = typename unit_dim_assem :: udim_div < typename Unit1 :: unit_dimention_type , typename Unit2 :: unit_dimention_type >:: unit ; using pfx = typename prefix :: pfx_div < typename Unit1 :: prefix_type , typename Unit2 :: prefix_type >:: prefix ; using unit = Unit < typename Unit1 :: value_type , dim , pfx > ; }; template < class UnitType > struct unit_inv { using dim = typename unit_dim_assem :: udim_inv < typename UnitType :: unit_dimention_type >:: unit ; using pfx = typename prefix :: pfx_inv < typename UnitType :: prefix_type >:: prefix ; using unit = Unit < typename UnitType :: value_type , dim , pfx , 0 > ; }; template < class UnitType , class PrefixType > struct unit_pfx_scaled { using unit = Unit < typename UnitType :: value_type , typename UnitType :: unit_dimention_type , typename prefix :: pfx_mul < typename UnitType :: prefix_type , PrefixType >:: prefix , UnitType :: tag > ; }; } // template <class UnitType, typename T> // constexpr auto operator <=>(const UnitType &l_value, const T &r_value) // { // return static_cast<typename UnitType::value_type>(l_value) <=> r_value; // } // \u5358\u4f4d*\u6570\u5024 template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T1 , UnitDim , Prefix , Tag > ; return unit_type ( static_cast < T1 > ( l_value ) * r_value ); } // \u6570\u5024*\u5358\u4f4d template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T2 , UnitDim , Prefix , Tag > ; return unit_type ( l_value * static_cast < T1 > ( r_value )); } // \u6570\u5024/\u5358\u4f4d template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T2 , UnitDim , Prefix , Tag > ; return typename unit_assem :: unit_inv < unit_type >:: unit ( l_value / static_cast < T2 > ( r_value )); } // \u5358\u4f4d/\u6570\u5024 template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) { static_assert ( std :: is_arithmetic_v < T1 > && std :: is_arithmetic_v < T2 > , \"Type is not arithmetic\" ); using unit_type = Unit < T1 , UnitDim , Prefix , Tag > ; return unit_type ( static_cast < T1 > ( l_value ) / r_value ); } // \u5358\u4f4d*\u5358\u4f4d template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator * ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 >& lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) { // static_assert(std::is_base_of_v<Unit, R_UnitDimType> && std::is_base_of_v<Unit, L_UnityDimType>, \"test\"); static_assert ( tag :: is_normal_tag < Tag1 >:: value && tag :: is_normal_tag < Tag2 >:: value , \"Type has not normal tag\" ); // static_assert(R_UnitDimType) // static_assert(R_P) using ret_dim_type = typename unit_dim_assem :: udim_mul < UnitDim1 , UnitDim2 >:: unit ; using ret_type = Unit < T1 , ret_dim_type , prefix :: none > ; return ret_type { lhl . raw_value () * rhl . raw_value ()}; } // \u5358\u4f4d/\u5358\u4f4d template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator / ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 >& lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) { static_assert ( tag :: is_normal_tag < Tag1 >:: value && tag :: is_normal_tag < Tag2 >:: value , \"Type has not normal tag\" ); // static_assert(R_UnitDimType) // static_assert(R_P) static_assert ( tag :: is_normal_tag < Tag2 >:: value , \"R_Tag is imcorrect\" ); using ret_dim_type = typename unit_dim_assem :: udim_div < UnitDim1 , UnitDim2 >:: unit ; using ret_type = Unit < T1 , ret_dim_type , prefix :: none > ; return ret_type { lhl . raw_value () / rhl . raw_value ()}; } // \u5358\u4f4d+\u5358\u4f4d(prefix\u9055\u3044) // prefix\u304c\u5c0f\u3055\u3044\u65b9\u3067\u8fd4\u3059 template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator + ( const Unit < T , UnitDim , Prefix1 , Tag >& lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) { using min_prefix = typename prefix :: pfx_min < Prefix1 , Prefix2 >:: prefix ; using lpfx = typename prefix :: pfx_div < Prefix1 , min_prefix >:: prefix ; T lhl_scaled_val = lhl . value () * lpfx :: num / lpfx :: den ; using rpfx = typename prefix :: pfx_div < Prefix2 , min_prefix >:: prefix ; T rhl_scaled_val = rhl . value () * rpfx :: num / rpfx :: den ; using ret_type = Unit < T , UnitDim , min_prefix , Tag > ; return ret_type { lhl_scaled_val + rhl_scaled_val }; } template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator - ( const Unit < T , UnitDim , Prefix1 , Tag >& lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) { using min_prefix = typename prefix :: pfx_min < Prefix1 , Prefix2 >:: prefix ; using lpfx = typename prefix :: pfx_div < Prefix1 , min_prefix >:: prefix ; T lhl_scaled_val = lhl . value () * lpfx :: num / lpfx :: den ; using rpfx = typename prefix :: pfx_div < Prefix2 , min_prefix >:: prefix ; T rhl_scaled_val = rhl . value () * rpfx :: num / rpfx :: den ; using ret_type = Unit < T , UnitDim , min_prefix , Tag > ; return ret_type { lhl_scaled_val - rhl_scaled_val }; } #define GENERATE_CONV_FACTOR(unit_dim, from_tag, to_tag, factor)\\ template<>\\ constexpr double conv_factor<unit_dim, from_tag, to_tag>()\\ {\\ return (factor);\\ } #define GENERATE_UNIT_SUFFIX(unit, suffix)\\ constexpr unit operator\"\" _## suffix(unsigned long long val)\\ {\\ return unit{static_cast<double>(val)};\\ }\\ constexpr unit operator\"\" _## suffix(long double val)\\ {\\ return unit{static_cast<double>(val)};\\ } #define GENERATE_UNIT_PFX_SUFFIX(unit_type, prefix, suffix)\\ constexpr auto operator\"\" _## suffix(unsigned long long val)\\ {\\ using namespace cpp_robotics::unit;\\ return unit_assem::unit_pfx_scaled<unit_type, prefix>::unit{static_cast<double>(val)};\\ }\\ constexpr auto operator\"\" _## suffix(long double val)\\ {\\ using namespace cpp_robotics::unit;\\ return unit_assem::unit_pfx_scaled<unit_type, prefix>::unit{static_cast<double>(val)};\\ } } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/units_8hpp/","text":"include/cpp_robotics/units/units.hpp Source code #include \"./unit_core.hpp\" #include \"./si_unit.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/units/units.hpp"},{"location":"doxybook/Files/units_8hpp/#includecpp_roboticsunitsunitshpp","text":"","title":"include/cpp_robotics/units/units.hpp"},{"location":"doxybook/Files/units_8hpp/#source-code","text":"#include \"./unit_core.hpp\" #include \"./si_unit.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/utility_8hpp/","text":"include/cpp_robotics/utility/utility.hpp Source code #include \"./math_utils.hpp\" #include \"./angle_range.hpp\" #include \"./space.hpp\" #include \"./singleton.hpp\" #include \"./cpp_support.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/utility/utility.hpp"},{"location":"doxybook/Files/utility_8hpp/#includecpp_roboticsutilityutilityhpp","text":"","title":"include/cpp_robotics/utility/utility.hpp"},{"location":"doxybook/Files/utility_8hpp/#source-code","text":"#include \"./math_utils.hpp\" #include \"./angle_range.hpp\" #include \"./space.hpp\" #include \"./singleton.hpp\" #include \"./cpp_support.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/vector2_8hpp/","text":"include/cpp_robotics/vector/vector2.hpp More... Namespaces Name cpp_robotics Classes Name struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb Detailed Description Author : Takumi Odashima ( Kotakkucu@gmail.com ) Date : 2021-01-25 Copyright : Copyright (c) 2021 Source code #pragma once #include <cmath> #include <cassert> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Vector2 ; using Vector2f = Vector2 < float > ; using Vector2d = Vector2 < double > ; template < typename FLOATING_TYPE > struct Vector2 { using value_type = FLOATING_TYPE ; value_type x , y ; Vector2 () = default ; constexpr Vector2 ( value_type vx , value_type vy ) : x ( vx ), y ( vy ) {} constexpr Vector2 ( const Vector2 & ) = default ; constexpr void set ( const value_type vx , const value_type vy ) { x = vx ; y = vy ; } void set_polar ( const value_type radius , const value_type theta ) { x = radius * std :: cos ( theta ); y = radius * std :: sin ( theta ); } constexpr value_type dot ( const Vector2 & v ) const { return ( x * v . x + y * v . y ); } constexpr value_type cross ( const Vector2 & v ) const { return ( x * v . y - y * v . x ); } constexpr value_type norm_sq () const { return dot ( * this ); } constexpr value_type norm () const { return std :: sqrt ( norm_sq ()); } void normalize () { * this /= norm (); } constexpr value_type angle () const { return std :: atan2 ( y , x ); } constexpr Vector2 get_normalized () { Vector2 v = * this ; v /= v . norm (); return v ; } void rotate ( const value_type theta ) { Vector2 v = * this ; x = v . x * std :: cos ( theta ) - v . y * std :: sin ( theta ); y = v . x * std :: sin ( theta ) + v . y * std :: cos ( theta ); } constexpr Vector2 get_rotated ( const value_type theta ) const { Vector2 v = { x * std :: cos ( theta ) - y * std :: sin ( theta ), x * std :: sin ( theta ) + y * std :: cos ( theta ) }; return v ; } constexpr bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ); } constexpr bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ); } constexpr Vector2 yx () const { return { y , x }; } constexpr Vector2 nyx () const { return { - y , x }; } constexpr Vector2 ynx () const { return { y , - x }; } constexpr Vector2 nxy () const { return { - x , y }; } constexpr Vector2 xny () const { return { x , - y }; } static constexpr value_type dot ( const Vector2 & a , const Vector2 & b ) { return a . dot ( b ); } static constexpr value_type angle ( const Vector2 & a , const Vector2 & b ) { value_type value = a . dot ( b ) / ( a . norm () * b . norm ()); return std :: acos ( value ); } static constexpr value_type distance ( const Vector2 & a , const Vector2 & b ) { return ( b - a ). norm (); } static constexpr Vector2 lerp ( const Vector2 & a , const Vector2 & b , const value_type t ) { return { cpp_robotics :: lerp ( a . x , b . x , t ), cpp_robotics :: lerp ( a . y , b . y , t )}; } constexpr Vector2 lerp ( const Vector2 & b , const value_type t ) const { return lerp ( * this , b , t ); } // constatnt vector static constexpr Vector2 zero () { return { 0 , 0 }; } static constexpr Vector2 up () { return { 0 , 1 }; } static constexpr Vector2 down () { return { 0 , -1 }; } static constexpr Vector2 right () { return { 1 , 0 }; } static constexpr Vector2 left () { return { -1 , 0 }; } constexpr Vector2 operator + () const { return * this ; } constexpr Vector2 operator - () const { return { - x , - y }; } constexpr bool operator == ( const Vector2 & v ) const { return ( x == v . x ) && ( y == v . y ); } constexpr bool operator != ( const Vector2 & v ) const { return ! (( x == v . x ) && ( y == v . y )); } constexpr Vector2 operator + ( const Vector2 & v ) const { return { x + v . x , y + v . y }; } constexpr Vector2 operator - ( const Vector2 & v ) const { return { x - v . x , y - v . y }; } friend constexpr Vector2 operator / ( const Vector2 & v , const value_type value ) { return { v . x / value , v . y / value }; } constexpr Vector2 & operator += ( const Vector2 & v ) { x += v . x ; y += v . y ; return * this ; } constexpr Vector2 & operator -= ( const Vector2 & v ) { x -= v . x ; y -= v . y ; return * this ; } constexpr Vector2 & operator *= ( const value_type value ) { x *= value ; y *= value ; return * this ; } constexpr Vector2 & operator /= ( const value_type value ) { x /= value ; y /= value ; return * this ; } value_type & operator [] ( const size_t index ) { assert ( index < 2 ); if ( index == 0 ) return x ; return y ; } constexpr value_type operator [] ( const size_t index ) const { assert ( index < 2 ); if ( index == 0 ) return x ; return y ; } template < typename Scaler > friend constexpr Vector2 operator * ( const Vector2 & v , const Scaler s ) noexcept { return { v . x * static_cast < value_type > ( s ), v . y * static_cast < value_type > ( s )}; } template < typename Scaler > friend constexpr Vector2 operator * ( const Scaler s , const Vector2 & v ) noexcept { return ( v * static_cast < value_type > ( s )); } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/vector/vector2.hpp"},{"location":"doxybook/Files/vector2_8hpp/#includecpp_roboticsvectorvector2hpp","text":"More...","title":"include/cpp_robotics/vector/vector2.hpp"},{"location":"doxybook/Files/vector2_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/vector2_8hpp/#classes","text":"Name struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb","title":"Classes"},{"location":"doxybook/Files/vector2_8hpp/#detailed-description","text":"Author : Takumi Odashima ( Kotakkucu@gmail.com ) Date : 2021-01-25 Copyright : Copyright (c) 2021","title":"Detailed Description"},{"location":"doxybook/Files/vector2_8hpp/#source-code","text":"#pragma once #include <cmath> #include <cassert> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Vector2 ; using Vector2f = Vector2 < float > ; using Vector2d = Vector2 < double > ; template < typename FLOATING_TYPE > struct Vector2 { using value_type = FLOATING_TYPE ; value_type x , y ; Vector2 () = default ; constexpr Vector2 ( value_type vx , value_type vy ) : x ( vx ), y ( vy ) {} constexpr Vector2 ( const Vector2 & ) = default ; constexpr void set ( const value_type vx , const value_type vy ) { x = vx ; y = vy ; } void set_polar ( const value_type radius , const value_type theta ) { x = radius * std :: cos ( theta ); y = radius * std :: sin ( theta ); } constexpr value_type dot ( const Vector2 & v ) const { return ( x * v . x + y * v . y ); } constexpr value_type cross ( const Vector2 & v ) const { return ( x * v . y - y * v . x ); } constexpr value_type norm_sq () const { return dot ( * this ); } constexpr value_type norm () const { return std :: sqrt ( norm_sq ()); } void normalize () { * this /= norm (); } constexpr value_type angle () const { return std :: atan2 ( y , x ); } constexpr Vector2 get_normalized () { Vector2 v = * this ; v /= v . norm (); return v ; } void rotate ( const value_type theta ) { Vector2 v = * this ; x = v . x * std :: cos ( theta ) - v . y * std :: sin ( theta ); y = v . x * std :: sin ( theta ) + v . y * std :: cos ( theta ); } constexpr Vector2 get_rotated ( const value_type theta ) const { Vector2 v = { x * std :: cos ( theta ) - y * std :: sin ( theta ), x * std :: sin ( theta ) + y * std :: cos ( theta ) }; return v ; } constexpr bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ); } constexpr bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ); } constexpr Vector2 yx () const { return { y , x }; } constexpr Vector2 nyx () const { return { - y , x }; } constexpr Vector2 ynx () const { return { y , - x }; } constexpr Vector2 nxy () const { return { - x , y }; } constexpr Vector2 xny () const { return { x , - y }; } static constexpr value_type dot ( const Vector2 & a , const Vector2 & b ) { return a . dot ( b ); } static constexpr value_type angle ( const Vector2 & a , const Vector2 & b ) { value_type value = a . dot ( b ) / ( a . norm () * b . norm ()); return std :: acos ( value ); } static constexpr value_type distance ( const Vector2 & a , const Vector2 & b ) { return ( b - a ). norm (); } static constexpr Vector2 lerp ( const Vector2 & a , const Vector2 & b , const value_type t ) { return { cpp_robotics :: lerp ( a . x , b . x , t ), cpp_robotics :: lerp ( a . y , b . y , t )}; } constexpr Vector2 lerp ( const Vector2 & b , const value_type t ) const { return lerp ( * this , b , t ); } // constatnt vector static constexpr Vector2 zero () { return { 0 , 0 }; } static constexpr Vector2 up () { return { 0 , 1 }; } static constexpr Vector2 down () { return { 0 , -1 }; } static constexpr Vector2 right () { return { 1 , 0 }; } static constexpr Vector2 left () { return { -1 , 0 }; } constexpr Vector2 operator + () const { return * this ; } constexpr Vector2 operator - () const { return { - x , - y }; } constexpr bool operator == ( const Vector2 & v ) const { return ( x == v . x ) && ( y == v . y ); } constexpr bool operator != ( const Vector2 & v ) const { return ! (( x == v . x ) && ( y == v . y )); } constexpr Vector2 operator + ( const Vector2 & v ) const { return { x + v . x , y + v . y }; } constexpr Vector2 operator - ( const Vector2 & v ) const { return { x - v . x , y - v . y }; } friend constexpr Vector2 operator / ( const Vector2 & v , const value_type value ) { return { v . x / value , v . y / value }; } constexpr Vector2 & operator += ( const Vector2 & v ) { x += v . x ; y += v . y ; return * this ; } constexpr Vector2 & operator -= ( const Vector2 & v ) { x -= v . x ; y -= v . y ; return * this ; } constexpr Vector2 & operator *= ( const value_type value ) { x *= value ; y *= value ; return * this ; } constexpr Vector2 & operator /= ( const value_type value ) { x /= value ; y /= value ; return * this ; } value_type & operator [] ( const size_t index ) { assert ( index < 2 ); if ( index == 0 ) return x ; return y ; } constexpr value_type operator [] ( const size_t index ) const { assert ( index < 2 ); if ( index == 0 ) return x ; return y ; } template < typename Scaler > friend constexpr Vector2 operator * ( const Vector2 & v , const Scaler s ) noexcept { return { v . x * static_cast < value_type > ( s ), v . y * static_cast < value_type > ( s )}; } template < typename Scaler > friend constexpr Vector2 operator * ( const Scaler s , const Vector2 & v ) noexcept { return ( v * static_cast < value_type > ( s )); } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/vector3_8hpp/","text":"include/cpp_robotics/vector/vector3.hpp Namespaces Name cpp_robotics Classes Name struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb Source code #pragma once #include <cmath> #include <cassert> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Vector3 ; using Vector3f = Vector3 < float > ; using Vector3d = Vector3 < double > ; template < typename FLOATING_TYPE > struct Vector3 { using value_type = FLOATING_TYPE ; value_type x , y , z ; Vector3 () = default ; constexpr Vector3 ( value_type vx , value_type vy , value_type vz ) : x ( vx ), y ( vy ), z ( vz ) {} Vector3 ( const Vector3 & v ) = default ; // function void set ( value_type vx , value_type vy , value_type vz ) { x = vx ; y = vy ; z = vz ; } constexpr value_type dot ( const Vector3 & v ) const { return ( x * v . x + y * v . y + z * v . z ); } constexpr Vector3 cross ( const Vector3 & v ) const { return {( y * v . z ) - ( z * v . y ), z * v . x - x * v . z , x * v . y - y * v . x }; } constexpr value_type norm_sq () const { return dot ( * this ); } value_type norm () { return std :: sqrt ( norm_sq ()); } void normalize () { * this /= norm (); } Vector3 get_normalized () { Vector3 v = * this ; v /= v . norm (); return v ; } constexpr bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ) && approx_zero ( z ); } constexpr bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ) || std :: isnan ( z ); } static constexpr value_type dot ( const Vector3 & a , const Vector3 & b ) { return a . dot ( b ); } static value_type distance ( const Vector3 & a , const Vector3 & b ) { return ( b - a ). norm (); } static constexpr Vector3 lerp ( const Vector3 & a , const Vector3 & b , const value_type t ) { return { cpp_robotics :: lerp ( a . x , b . x , t ), cpp_robotics :: lerp ( a . y , b . y , t ), cpp_robotics :: lerp ( a . z , b . z , t )}; } constexpr Vector3 lerp ( const Vector3 & b , const value_type t ) const { return lerp ( * this , b , t ); } // constant vector static constexpr Vector3 zero () { return { 0 , 0 , 0 }; } static constexpr Vector3 forward () { return { 0 , 0 , 1 }; } static constexpr Vector3 back () { return { 0 , 0 , -1 }; } static constexpr Vector3 up () { return { 0 , 1 , 0 }; } static constexpr Vector3 down () { return { 0 , -1 , 0 }; } static constexpr Vector3 right () { return { 1 , 0 , 0 }; } static constexpr Vector3 left () { return { -1 , 0 , 0 }; } constexpr Vector3 operator + () const { return * this ; } constexpr Vector3 operator - () const { return { - x , - y , - z }; } bool operator == ( const Vector3 & v ) const { return ( x == v . x ) && ( y == v . y ) && ( z == v . z ); } bool operator != ( const Vector3 & v ) const { return ! (( x == v . x ) && ( y == v . y ) && ( z == v . z )); } constexpr Vector3 operator + ( const Vector3 & v ) const { return { x + v . x , y + v . y , z + v . z }; } constexpr Vector3 operator - ( const Vector3 & v ) const { return { x - v . x , y - v . y , z - v . z }; } friend constexpr Vector3 operator / ( const Vector3 & v , const value_type value ) { return { v . x / value , v . y / value , v . z / value }; } constexpr Vector3 & operator += ( const Vector3 & v ) { x += v . x ; y += v . y ; z += v . z ; return * this ; } constexpr Vector3 & operator -= ( const Vector3 & v ) { x -= v . x ; y -= v . y ; z -= v . z ; return * this ; } constexpr Vector3 & operator *= ( const value_type value ) { x *= value ; y *= value ; z *= value ; return * this ; } constexpr Vector3 & operator /= ( const value_type value ) { x /= value ; y /= value ; z /= value ; return * this ; } value_type & operator []( const int index ) { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return z ; } constexpr value_type operator []( const int index ) const { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return z ; } template < typename Scaler > friend constexpr Vector3 operator * ( const Vector3 & v , const Scaler s ) noexcept { return { v . x * static_cast < value_type > ( s ), v . y * static_cast < value_type > ( s ), v . z * static_cast < value_type > ( s )}; } template < typename Scaler > friend constexpr Vector3 operator * ( const Scaler s , const Vector3 & v ) noexcept { return ( v * static_cast < value_type > ( s )); } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/vector/vector3.hpp"},{"location":"doxybook/Files/vector3_8hpp/#includecpp_roboticsvectorvector3hpp","text":"","title":"include/cpp_robotics/vector/vector3.hpp"},{"location":"doxybook/Files/vector3_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/vector3_8hpp/#classes","text":"Name struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb","title":"Classes"},{"location":"doxybook/Files/vector3_8hpp/#source-code","text":"#pragma once #include <cmath> #include <cassert> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Vector3 ; using Vector3f = Vector3 < float > ; using Vector3d = Vector3 < double > ; template < typename FLOATING_TYPE > struct Vector3 { using value_type = FLOATING_TYPE ; value_type x , y , z ; Vector3 () = default ; constexpr Vector3 ( value_type vx , value_type vy , value_type vz ) : x ( vx ), y ( vy ), z ( vz ) {} Vector3 ( const Vector3 & v ) = default ; // function void set ( value_type vx , value_type vy , value_type vz ) { x = vx ; y = vy ; z = vz ; } constexpr value_type dot ( const Vector3 & v ) const { return ( x * v . x + y * v . y + z * v . z ); } constexpr Vector3 cross ( const Vector3 & v ) const { return {( y * v . z ) - ( z * v . y ), z * v . x - x * v . z , x * v . y - y * v . x }; } constexpr value_type norm_sq () const { return dot ( * this ); } value_type norm () { return std :: sqrt ( norm_sq ()); } void normalize () { * this /= norm (); } Vector3 get_normalized () { Vector3 v = * this ; v /= v . norm (); return v ; } constexpr bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ) && approx_zero ( z ); } constexpr bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ) || std :: isnan ( z ); } static constexpr value_type dot ( const Vector3 & a , const Vector3 & b ) { return a . dot ( b ); } static value_type distance ( const Vector3 & a , const Vector3 & b ) { return ( b - a ). norm (); } static constexpr Vector3 lerp ( const Vector3 & a , const Vector3 & b , const value_type t ) { return { cpp_robotics :: lerp ( a . x , b . x , t ), cpp_robotics :: lerp ( a . y , b . y , t ), cpp_robotics :: lerp ( a . z , b . z , t )}; } constexpr Vector3 lerp ( const Vector3 & b , const value_type t ) const { return lerp ( * this , b , t ); } // constant vector static constexpr Vector3 zero () { return { 0 , 0 , 0 }; } static constexpr Vector3 forward () { return { 0 , 0 , 1 }; } static constexpr Vector3 back () { return { 0 , 0 , -1 }; } static constexpr Vector3 up () { return { 0 , 1 , 0 }; } static constexpr Vector3 down () { return { 0 , -1 , 0 }; } static constexpr Vector3 right () { return { 1 , 0 , 0 }; } static constexpr Vector3 left () { return { -1 , 0 , 0 }; } constexpr Vector3 operator + () const { return * this ; } constexpr Vector3 operator - () const { return { - x , - y , - z }; } bool operator == ( const Vector3 & v ) const { return ( x == v . x ) && ( y == v . y ) && ( z == v . z ); } bool operator != ( const Vector3 & v ) const { return ! (( x == v . x ) && ( y == v . y ) && ( z == v . z )); } constexpr Vector3 operator + ( const Vector3 & v ) const { return { x + v . x , y + v . y , z + v . z }; } constexpr Vector3 operator - ( const Vector3 & v ) const { return { x - v . x , y - v . y , z - v . z }; } friend constexpr Vector3 operator / ( const Vector3 & v , const value_type value ) { return { v . x / value , v . y / value , v . z / value }; } constexpr Vector3 & operator += ( const Vector3 & v ) { x += v . x ; y += v . y ; z += v . z ; return * this ; } constexpr Vector3 & operator -= ( const Vector3 & v ) { x -= v . x ; y -= v . y ; z -= v . z ; return * this ; } constexpr Vector3 & operator *= ( const value_type value ) { x *= value ; y *= value ; z *= value ; return * this ; } constexpr Vector3 & operator /= ( const value_type value ) { x /= value ; y /= value ; z /= value ; return * this ; } value_type & operator []( const int index ) { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return z ; } constexpr value_type operator []( const int index ) const { assert ( 0 <= index && index < 3 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; return z ; } template < typename Scaler > friend constexpr Vector3 operator * ( const Vector3 & v , const Scaler s ) noexcept { return { v . x * static_cast < value_type > ( s ), v . y * static_cast < value_type > ( s ), v . z * static_cast < value_type > ( s )}; } template < typename Scaler > friend constexpr Vector3 operator * ( const Scaler s , const Vector3 & v ) noexcept { return ( v * static_cast < value_type > ( s )); } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/vector4_8hpp/","text":"include/cpp_robotics/vector/vector4.hpp Namespaces Name cpp_robotics Classes Name struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb Source code #pragma once #include <cmath> #include <cassert> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Vector4 ; using Vector4f = Vector4 < float > ; using Vector4d = Vector4 < double > ; template < typename FLOATING_TYPE > struct Vector4 { using value_type = FLOATING_TYPE ; value_type x , y , z , w ; Vector4 () = default ; constexpr Vector4 ( value_type vx , value_type vy , value_type vz , value_type vw ) : x ( vx ), y ( vy ), z ( vz ), w ( vw ) {} Vector4 ( const Vector4 & v ) = default ; // function void set ( value_type vx , value_type vy , value_type vz , value_type vw ) { x = vx ; y = vy ; z = vz ; w = vw ; } constexpr value_type dot ( const Vector4 & v ) const { return ( x * v . x + y * v . y + z * v . z + w * v . w ); } constexpr value_type norm_sq () const { return dot ( * this ); } value_type norm () { return std :: sqrt ( norm_sq ()); } void normalize () { * this /= norm (); } Vector4 get_normalized () { Vector4 v = * this ; v /= v . norm (); return v ; } constexpr bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ) && approx_zero ( z ) && approx_zero ( w ); } constexpr bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ) || std :: isnan ( z ) || std :: isnan ( w ); } static constexpr value_type dot ( const Vector4 & a , const Vector4 & b ) { return a . dot ( b ); } static value_type distance ( const Vector4 & a , const Vector4 & b ) { return ( b - a ). norm (); } static constexpr Vector4 lerp ( const Vector4 & a , const Vector4 & b , const value_type t ) { return { cpp_robotics :: lerp ( a . x , b . x , t ), cpp_robotics :: lerp ( a . y , b . y , t ), cpp_robotics :: lerp ( a . z , b . z , t ), cpp_robotics :: lerp ( a . w , b . w , t )}; } constexpr Vector4 lerp ( const Vector4 & b , const value_type t ) const { return lerp ( * this , b , t ); } // constant vector static constexpr Vector4 zero () { return { 0 , 0 , 0 , 0 }; } constexpr Vector4 operator + () const { return * this ; } constexpr Vector4 operator - () const { return { - x , - y , - z , - w }; } bool operator == ( const Vector4 & v ) const { return ( x == v . x ) && ( y == v . y ) && ( z == v . z ) && ( w == v . w ); } bool operator != ( const Vector4 & v ) const { return ! (( x == v . x ) && ( y == v . y ) && ( z == v . z ) && ( w == v . w )); } constexpr Vector4 operator + ( const Vector4 & v ) const { return { x + v . x , y + v . y , z + v . z , w + v . w }; } constexpr Vector4 operator - ( const Vector4 & v ) const { return { x - v . x , y - v . y , z - v . z , w - v . w }; } constexpr Vector4 operator * ( const value_type value ) const { return { x * value , y * value , z * value , w * value }; } constexpr Vector4 operator / ( const value_type value ) const { return { x / value , y / value , z / value , w / value }; } constexpr Vector4 & operator += ( const Vector4 & v ) { x += v . x ; y += v . y ; z += v . z ; w += v . w ; return * this ; } constexpr Vector4 & operator -= ( const Vector4 & v ) { x -= v . x ; y -= v . y ; z -= v . z ; w -= v . w ; return * this ; } constexpr Vector4 & operator *= ( const value_type value ) { x *= value ; y *= value ; z *= value ; w *= value ; return * this ; } constexpr Vector4 & operator /= ( const value_type value ) { x /= value ; y /= value ; z /= value ; w /= value ; return * this ; } value_type & operator []( const int index ) { assert ( 0 <= index && index < 4 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; if ( index == 2 ) return z ; return w ; } constexpr value_type operator []( const int index ) const { assert ( 0 <= index && index < 4 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; if ( index == 2 ) return z ; return w ; } template < typename Scaler > friend constexpr Vector4 operator * ( Scaler s , Vector4 v ) noexcept { return ( v * static_cast < value_type > ( s )); } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/vector/vector4.hpp"},{"location":"doxybook/Files/vector4_8hpp/#includecpp_roboticsvectorvector4hpp","text":"","title":"include/cpp_robotics/vector/vector4.hpp"},{"location":"doxybook/Files/vector4_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/vector4_8hpp/#classes","text":"Name struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb","title":"Classes"},{"location":"doxybook/Files/vector4_8hpp/#source-code","text":"#pragma once #include <cmath> #include <cassert> #include \"../utility/math_utils.hpp\" namespace cpp_robotics { template < typename FLOATING_TYPE > struct Vector4 ; using Vector4f = Vector4 < float > ; using Vector4d = Vector4 < double > ; template < typename FLOATING_TYPE > struct Vector4 { using value_type = FLOATING_TYPE ; value_type x , y , z , w ; Vector4 () = default ; constexpr Vector4 ( value_type vx , value_type vy , value_type vz , value_type vw ) : x ( vx ), y ( vy ), z ( vz ), w ( vw ) {} Vector4 ( const Vector4 & v ) = default ; // function void set ( value_type vx , value_type vy , value_type vz , value_type vw ) { x = vx ; y = vy ; z = vz ; w = vw ; } constexpr value_type dot ( const Vector4 & v ) const { return ( x * v . x + y * v . y + z * v . z + w * v . w ); } constexpr value_type norm_sq () const { return dot ( * this ); } value_type norm () { return std :: sqrt ( norm_sq ()); } void normalize () { * this /= norm (); } Vector4 get_normalized () { Vector4 v = * this ; v /= v . norm (); return v ; } constexpr bool is_zero () const { return approx_zero ( x ) && approx_zero ( y ) && approx_zero ( z ) && approx_zero ( w ); } constexpr bool has_nan () const { return std :: isnan ( x ) || std :: isnan ( y ) || std :: isnan ( z ) || std :: isnan ( w ); } static constexpr value_type dot ( const Vector4 & a , const Vector4 & b ) { return a . dot ( b ); } static value_type distance ( const Vector4 & a , const Vector4 & b ) { return ( b - a ). norm (); } static constexpr Vector4 lerp ( const Vector4 & a , const Vector4 & b , const value_type t ) { return { cpp_robotics :: lerp ( a . x , b . x , t ), cpp_robotics :: lerp ( a . y , b . y , t ), cpp_robotics :: lerp ( a . z , b . z , t ), cpp_robotics :: lerp ( a . w , b . w , t )}; } constexpr Vector4 lerp ( const Vector4 & b , const value_type t ) const { return lerp ( * this , b , t ); } // constant vector static constexpr Vector4 zero () { return { 0 , 0 , 0 , 0 }; } constexpr Vector4 operator + () const { return * this ; } constexpr Vector4 operator - () const { return { - x , - y , - z , - w }; } bool operator == ( const Vector4 & v ) const { return ( x == v . x ) && ( y == v . y ) && ( z == v . z ) && ( w == v . w ); } bool operator != ( const Vector4 & v ) const { return ! (( x == v . x ) && ( y == v . y ) && ( z == v . z ) && ( w == v . w )); } constexpr Vector4 operator + ( const Vector4 & v ) const { return { x + v . x , y + v . y , z + v . z , w + v . w }; } constexpr Vector4 operator - ( const Vector4 & v ) const { return { x - v . x , y - v . y , z - v . z , w - v . w }; } constexpr Vector4 operator * ( const value_type value ) const { return { x * value , y * value , z * value , w * value }; } constexpr Vector4 operator / ( const value_type value ) const { return { x / value , y / value , z / value , w / value }; } constexpr Vector4 & operator += ( const Vector4 & v ) { x += v . x ; y += v . y ; z += v . z ; w += v . w ; return * this ; } constexpr Vector4 & operator -= ( const Vector4 & v ) { x -= v . x ; y -= v . y ; z -= v . z ; w -= v . w ; return * this ; } constexpr Vector4 & operator *= ( const value_type value ) { x *= value ; y *= value ; z *= value ; w *= value ; return * this ; } constexpr Vector4 & operator /= ( const value_type value ) { x /= value ; y /= value ; z /= value ; w /= value ; return * this ; } value_type & operator []( const int index ) { assert ( 0 <= index && index < 4 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; if ( index == 2 ) return z ; return w ; } constexpr value_type operator []( const int index ) const { assert ( 0 <= index && index < 4 ); if ( index == 0 ) return x ; if ( index == 1 ) return y ; if ( index == 2 ) return z ; return w ; } template < typename Scaler > friend constexpr Vector4 operator * ( Scaler s , Vector4 v ) noexcept { return ( v * static_cast < value_type > ( s )); } }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/vector_8hpp/","text":"include/cpp_robotics/vector/vector.hpp Source code #include \"./vector2.hpp\" #include \"./vector3.hpp\" #include \"./vector4.hpp\" #include \"./transform.hpp\" #include \"./quaternion.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/vector/vector.hpp"},{"location":"doxybook/Files/vector_8hpp/#includecpp_roboticsvectorvectorhpp","text":"","title":"include/cpp_robotics/vector/vector.hpp"},{"location":"doxybook/Files/vector_8hpp/#source-code","text":"#include \"./vector2.hpp\" #include \"./vector3.hpp\" #include \"./vector4.hpp\" #include \"./transform.hpp\" #include \"./quaternion.hpp\" Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/","text":"include/cpp_robotics/filter/velocity_limit_filter.hpp Namespaces Name cpp_robotics Classes Name class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf Source code #pragma once #include <cmath> #include <optional> #include <tuple> #include <algorithm> #include \"integrator.hpp\" namespace cpp_robotics { namespace internal { // diff = s / (gpd*s + 1) // pass = 1 / (gpd*s + 1) class DiffPair { public : DiffPair ( double Ts_ , double gpd_ ) : Ts ( Ts_ ), gpd ( gpd_ ) {} void reset () { reset ( 0.0f ); } void reset ( double u ) { u1 = u ; y1diff = 0 ; y1pass = 0 ; } std :: tuple < double , double > filtering ( double u ) { double diff = ( 2.0 * gpd * ( u - u1 ) + ( 2.0 - Ts * gpd ) * y1diff ) / ( 2.0 + Ts * gpd ); double pass = ( gpd * Ts * ( u + u1 ) + ( 2.0 - gpd * Ts ) * y1pass ) / ( 2.0 + Ts * gpd ); u1 = u ; y1diff = diff ; y1pass = pass ; return { diff , pass }; } private : double Ts , gpd ; double u1 = 0 , y1diff = 0 , y1pass = 0 ; }; } // \u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f class VelocityLimitFilter { public : VelocityLimitFilter ( double v_max_ , double Ts_ ) : VelocityLimitFilter ( v_max_ , Ts_ , 1.0 / Ts_ , 0.5 / Ts_ ){} VelocityLimitFilter ( double v_max_ , double Ts_ , std :: pair < double , double > limit ) : VelocityLimitFilter ( v_max_ , Ts_ , 1.0 / Ts_ , 0.5 / Ts_ , limit ){} VelocityLimitFilter ( double v_max_ , double Ts_ , double gpd_ , double fb_gain , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) : Ts ( Ts_ ), v_max ( v_max_ ), gpd ( gpd_ ), Cfb ( fb_gain ), dp ( Ts , gpd ), intr ( Ts ), limit_ ( limit ) { reset (); } virtual void reset () { reset ( 0 ); } void reset ( double u ) { u1 = u ; y1 = u ; dp . reset ( u ); intr . reset ( u ); } virtual double filtering ( double u ) { if ( limit_ ) { u = std :: clamp ( u , limit_ . value (). first , limit_ . value (). second ); } auto [ diff , pass ] = dp . filtering ( u ); double v = diff - ( Cfb * ( y1 - pass )); v = std :: clamp ( v , - v_max , v_max ); prev_v_ = v ; double y = intr . filtering ( v ); if ( limit_ ) { y = std :: clamp ( y , limit_ . value (). first , limit_ . value (). second ); } u1 = u ; y1 = y ; return y ; } double prev_v_ ; private : double Ts , v_max , gpd , Cfb ; internal :: DiffPair dp ; Integrator intr ; double u1 = 0 , y1 = 0 ; std :: optional < std :: pair < double , double >> limit_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/filter/velocity_limit_filter.hpp"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#includecpp_roboticsfiltervelocity_limit_filterhpp","text":"","title":"include/cpp_robotics/filter/velocity_limit_filter.hpp"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#classes","text":"Name class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf","title":"Classes"},{"location":"doxybook/Files/velocity__limit__filter_8hpp/#source-code","text":"#pragma once #include <cmath> #include <optional> #include <tuple> #include <algorithm> #include \"integrator.hpp\" namespace cpp_robotics { namespace internal { // diff = s / (gpd*s + 1) // pass = 1 / (gpd*s + 1) class DiffPair { public : DiffPair ( double Ts_ , double gpd_ ) : Ts ( Ts_ ), gpd ( gpd_ ) {} void reset () { reset ( 0.0f ); } void reset ( double u ) { u1 = u ; y1diff = 0 ; y1pass = 0 ; } std :: tuple < double , double > filtering ( double u ) { double diff = ( 2.0 * gpd * ( u - u1 ) + ( 2.0 - Ts * gpd ) * y1diff ) / ( 2.0 + Ts * gpd ); double pass = ( gpd * Ts * ( u + u1 ) + ( 2.0 - gpd * Ts ) * y1pass ) / ( 2.0 + Ts * gpd ); u1 = u ; y1diff = diff ; y1pass = pass ; return { diff , pass }; } private : double Ts , gpd ; double u1 = 0 , y1diff = 0 , y1pass = 0 ; }; } // \u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u306e\u6587\u732e\u3092\u53c2\u8003\u306b\u3057\u305f class VelocityLimitFilter { public : VelocityLimitFilter ( double v_max_ , double Ts_ ) : VelocityLimitFilter ( v_max_ , Ts_ , 1.0 / Ts_ , 0.5 / Ts_ ){} VelocityLimitFilter ( double v_max_ , double Ts_ , std :: pair < double , double > limit ) : VelocityLimitFilter ( v_max_ , Ts_ , 1.0 / Ts_ , 0.5 / Ts_ , limit ){} VelocityLimitFilter ( double v_max_ , double Ts_ , double gpd_ , double fb_gain , std :: optional < std :: pair < double , double >> limit = std :: nullopt ) : Ts ( Ts_ ), v_max ( v_max_ ), gpd ( gpd_ ), Cfb ( fb_gain ), dp ( Ts , gpd ), intr ( Ts ), limit_ ( limit ) { reset (); } virtual void reset () { reset ( 0 ); } void reset ( double u ) { u1 = u ; y1 = u ; dp . reset ( u ); intr . reset ( u ); } virtual double filtering ( double u ) { if ( limit_ ) { u = std :: clamp ( u , limit_ . value (). first , limit_ . value (). second ); } auto [ diff , pass ] = dp . filtering ( u ); double v = diff - ( Cfb * ( y1 - pass )); v = std :: clamp ( v , - v_max , v_max ); prev_v_ = v ; double y = intr . filtering ( v ); if ( limit_ ) { y = std :: clamp ( y , limit_ . value (). first , limit_ . value (). second ); } u1 = u ; y1 = y ; return y ; } double prev_v_ ; private : double Ts , v_max , gpd , Cfb ; internal :: DiffPair dp ; Integrator intr ; double u1 = 0 , y1 = 0 ; std :: optional < std :: pair < double , double >> limit_ ; }; } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Files/wave__propagation_8hpp/","text":"include/cpp_robotics/path_planning/wave_propagation.hpp Namespaces Name cpp_robotics Source code #pragma once #include <vector> #include <list> #include <Eigen/Dense> #include \"grid_path_planning_utils.hpp\" namespace cpp_robotics { std :: vector < Eigen :: Vector2i > wave_propagation ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) { using namespace grid_path_planning_utils ; if ( not contain_in_map ( map , start ) || not contain_in_map ( map , end )) return { start }; if ( start == end ) return { start }; if ( ! is_correct_step ( start , map ) || ! is_correct_step ( end , map )) return {}; // not exist path const static std :: array < Eigen :: Vector2i , 8 > nb = { Eigen :: Vector2i { 1 , 0 }, { 0 , 1 }, { -1 , 0 }, { 0 , -1 }, { 1 , 1 }, { -1 , 1 }, { -1 , -1 }, { 1 , -1 }}; std :: vector < std :: vector < int >> costs_mat ; costs_mat . resize ( map . rows ()); for ( auto & r : costs_mat ) { r . resize ( map . cols ()); } auto costs = [ & ]( int x , int y ) -> int & { return costs_mat . at ( y ). at ( x ); }; std :: list < GridNode > nodes = {}, new_nodes = {}; GridNode enode ; enode . pos = end ; enode . cost = 1 ; nodes . push_back ( enode ); costs ( end ( 0 ), end ( 1 )) = enode . cost ; // propagate a wave auto exist_wp = [ & costs ]( const Eigen :: Vector2i & p ) { return costs ( p ( 0 ), p ( 1 )) != 0 ; }; while ( not nodes . empty ()) { for ( auto & n : nodes ) { for ( size_t i = 0 ; i < 4 ; i ++ ) { auto pos = n . pos + nb [ i ]; if ( is_correct_step ( pos , map )) // \u30b3\u30b9\u30c8\u304c0\u306e\u3068\u304d { if ( ! exist_wp ( pos )) { int new_cost = n . cost + 1 ; costs ( pos ( 0 ), pos ( 1 )) = new_cost ; GridNode nnode ; nnode . pos = pos ; nnode . cost = new_cost ; new_nodes . push_back ( nnode ); } } } } nodes . clear (); nodes . insert ( nodes . begin (), new_nodes . begin (), new_nodes . end ()); new_nodes . clear (); } // create path std :: vector < Eigen :: Vector2i > path ; Eigen :: Vector2i look = start ; path . push_back ( start ); std :: array < int , 8 > nb_costs ; // \u58c1\u306e\u90e8\u5206\u306f\u30b3\u30b9\u30c80&nb_costs\u306e\u66f8\u304d\u63db\u3048\u3092\u884c\u308f\u306a\u3044\u305f\u3081\u58c1\u5074\u306b\u9032\u3080\u306e\u3092\u9632\u3050 for ( auto & c : nb_costs ) c = costs ( look ( 0 ), look ( 1 )); while ( look != end ) { size_t correct_step_count = 0 ; for ( size_t i = 0 ; i < 8 ; i ++ ) { auto neighbor = look + nb [ i ]; if ( is_correct_step ( neighbor , map )) { int cost = costs ( neighbor ( 0 ), neighbor ( 1 )); if ( cost != 0 ) { correct_step_count ++ ; nb_costs [ i ] = cost ; } } } if ( correct_step_count == 0 ) { // no exist path // std::cout << \"------------------- no exist path\" << std::endl; return {}; } auto min_it = std :: min_element ( nb_costs . begin (), nb_costs . end ()); look += nb [ std :: distance ( nb_costs . begin (), min_it )]; // std::cout << \"------------------- push\" << look(0) << \", \" << look(1) << std::endl; path . push_back ( look ); } return path ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"include/cpp_robotics/path_planning/wave_propagation.hpp"},{"location":"doxybook/Files/wave__propagation_8hpp/#includecpp_roboticspath_planningwave_propagationhpp","text":"","title":"include/cpp_robotics/path_planning/wave_propagation.hpp"},{"location":"doxybook/Files/wave__propagation_8hpp/#namespaces","text":"Name cpp_robotics","title":"Namespaces"},{"location":"doxybook/Files/wave__propagation_8hpp/#source-code","text":"#pragma once #include <vector> #include <list> #include <Eigen/Dense> #include \"grid_path_planning_utils.hpp\" namespace cpp_robotics { std :: vector < Eigen :: Vector2i > wave_propagation ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) { using namespace grid_path_planning_utils ; if ( not contain_in_map ( map , start ) || not contain_in_map ( map , end )) return { start }; if ( start == end ) return { start }; if ( ! is_correct_step ( start , map ) || ! is_correct_step ( end , map )) return {}; // not exist path const static std :: array < Eigen :: Vector2i , 8 > nb = { Eigen :: Vector2i { 1 , 0 }, { 0 , 1 }, { -1 , 0 }, { 0 , -1 }, { 1 , 1 }, { -1 , 1 }, { -1 , -1 }, { 1 , -1 }}; std :: vector < std :: vector < int >> costs_mat ; costs_mat . resize ( map . rows ()); for ( auto & r : costs_mat ) { r . resize ( map . cols ()); } auto costs = [ & ]( int x , int y ) -> int & { return costs_mat . at ( y ). at ( x ); }; std :: list < GridNode > nodes = {}, new_nodes = {}; GridNode enode ; enode . pos = end ; enode . cost = 1 ; nodes . push_back ( enode ); costs ( end ( 0 ), end ( 1 )) = enode . cost ; // propagate a wave auto exist_wp = [ & costs ]( const Eigen :: Vector2i & p ) { return costs ( p ( 0 ), p ( 1 )) != 0 ; }; while ( not nodes . empty ()) { for ( auto & n : nodes ) { for ( size_t i = 0 ; i < 4 ; i ++ ) { auto pos = n . pos + nb [ i ]; if ( is_correct_step ( pos , map )) // \u30b3\u30b9\u30c8\u304c0\u306e\u3068\u304d { if ( ! exist_wp ( pos )) { int new_cost = n . cost + 1 ; costs ( pos ( 0 ), pos ( 1 )) = new_cost ; GridNode nnode ; nnode . pos = pos ; nnode . cost = new_cost ; new_nodes . push_back ( nnode ); } } } } nodes . clear (); nodes . insert ( nodes . begin (), new_nodes . begin (), new_nodes . end ()); new_nodes . clear (); } // create path std :: vector < Eigen :: Vector2i > path ; Eigen :: Vector2i look = start ; path . push_back ( start ); std :: array < int , 8 > nb_costs ; // \u58c1\u306e\u90e8\u5206\u306f\u30b3\u30b9\u30c80&nb_costs\u306e\u66f8\u304d\u63db\u3048\u3092\u884c\u308f\u306a\u3044\u305f\u3081\u58c1\u5074\u306b\u9032\u3080\u306e\u3092\u9632\u3050 for ( auto & c : nb_costs ) c = costs ( look ( 0 ), look ( 1 )); while ( look != end ) { size_t correct_step_count = 0 ; for ( size_t i = 0 ; i < 8 ; i ++ ) { auto neighbor = look + nb [ i ]; if ( is_correct_step ( neighbor , map )) { int cost = costs ( neighbor ( 0 ), neighbor ( 1 )); if ( cost != 0 ) { correct_step_count ++ ; nb_costs [ i ] = cost ; } } } if ( correct_step_count == 0 ) { // no exist path // std::cout << \"------------------- no exist path\" << std::endl; return {}; } auto min_it = std :: min_element ( nb_costs . begin (), nb_costs . end ()); look += nb [ std :: distance ( nb_costs . begin (), min_it )]; // std::cout << \"------------------- push\" << look(0) << \", \" << look(1) << std::endl; path . push_back ( look ); } return path ; } } Updated on 2022-09-30 at 00:12:50 +0900","title":"Source code"},{"location":"doxybook/Namespaces/namespacecpp__robotics/","text":"cpp_robotics Namespaces Name cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::prefix cpp_robotics::unit::tag cpp_robotics::unit::unit_dimention Classes Name class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9 struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf class cpp_robotics::DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668 class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class cpp_robotics::DiscreteTransferFunction z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570 class cpp_robotics::DubinsPath Dubins\u30d1\u30b9 class cpp_robotics::ExtendedKalmanFilter class cpp_robotics::FilterConnector class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Integrator \u7a4d\u5206\u5668 class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf class cpp_robotics::KDTree k-d\u6728 class cpp_robotics::KMeansMethod K-means\u6cd5 struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668 class cpp_robotics::NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::PID2Controller 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 class cpp_robotics::PIDController PID\u5236\u5fa1\u5668 struct cpp_robotics::Polynomial \u591a\u9805\u5f0f struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668 struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::SQP SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct cpp_robotics::unit::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf Types Name enum class CanonicalizeMode enum UnitIndex using RandomGenerator < std::uniform_int_distribution<> > UniformIntRandomEngine \u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::uniform_real_distribution<> > UniformRealRandomEngine \u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::bernoulli_distribution > BernoulliRandomEngine \u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::binomial_distribution<> > BinomialRandomEngine \u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::geometric_distribution<> > GeometricRandomEngine \u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::negative_binomial_distribution<> > NegativeBinomialRandomEngine \u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::poisson_distribution<> > PoissonRandomEngine \u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::exponential_distribution<> > ExponentialRandomEngine \u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::gamma_distribution<> > GammaRandomEngine \u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::weibull_distribution<> > WeibullRandomEngine \u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::extreme_value_distribution<> > ExtremeValueRandomEngine \u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::normal_distribution<> > NormalRandomEngine \u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::lognormal_distribution<> > LognormalRandomEngine \u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::chi_squared_distribution<> > ChiSquaredRandomEngine \u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::cauchy_distribution<> > CauchyRandomEngine \u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::fisher_f_distribution<> > FisherFRandomEngine \u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::student_t_distribution<> > StudentTRandomEngine \u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::discrete_distribution<> > DiscreteRandomEngine \u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::piecewise_constant_distribution<> > PiecewiseConstantRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::piecewise_linear_distribution<> > PiecewiseLinearRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using unit_assem::unit_div< Torque , Ampere >::unit TorqueConstant using unit_assem::unit_div< Volt , AngularVelocity >::unit BackEmfConstant using unit_assem::unit_mul< Torque , Second >::unit FrictionConstant using Unit < double, unit_dimention::second, prefix::none > Second using Unit < double, unit_dimention::second, prefix::milli > MilliSecond using Unit < double, unit_dimention::second, prefix::micro > MicroSecond using Unit < double, unit_dimention::metere, prefix::none > Meter using Unit < double, unit_dimention::metere, prefix::milli > MilliMeter using Unit < double, unit_dimention::metere, prefix::micro > MicroMeter using Unit < double, unit_dimention::metere, prefix::centi > CentiMeter using Unit < double, unit_dimention::kilogram, prefix::none > KiloGram using Unit < double, unit_dimention::kilogram, prefix::milli > Gram using Unit < double, unit_dimention::watt, prefix::none > Watt using Unit < double, unit_dimention::watt, prefix::kilo > KiloWatt using Unit < double, unit_dimention::newton, prefix::none > Newton using Unit < double, unit_dimention::newton, prefix::kilo > KiloNewton using Unit < double, unit_dimention::pascal, prefix::none > Pascal using Unit < double, unit_dimention::pascal, prefix::kilo > KiloPascal using Unit < double, unit_dimention::hertz, prefix::none > Hertz using Unit < double, unit_dimention::area, prefix::none > Area using Unit < double, unit_dimention::volume, prefix::none > Volume using Unit < double, unit_dimention::velocity, prefix::none > Velocity using Unit < double, unit_dimention::acceleration, prefix::none > Acceleration using Unit < double, unit_dimention::dencity, prefix::none > Dencity using Unit < double, unit_dimention::torque, prefix::none > Torque using Unit < double, unit_dimention::inertia, prefix::none > Inertia using Unit < double, unit_dimention::ampere, prefix::none > Ampere using Unit < double, unit_dimention::ampere, prefix::milli > MilliAmpere using Unit < double, unit_dimention::volt, prefix::none > Volt using Unit < double, unit_dimention::volt, prefix::milli > MilliVolt using Unit < double, unit_dimention::ohm, prefix::none > Ohm using Unit < double, unit_dimention::ohm, prefix::milli > MilliOhm using Unit < double, unit_dimention::henry, prefix::none > Henry using Unit < double, unit_dimention::henry, prefix::milli > MilliHenry using Unit < double, unit_dimention::farad, prefix::none > Farad using Unit < double, unit_dimention::farad, prefix::milli > MilliFarad using Unit < double, unit_dimention::farad, prefix::micro > MicroFarad using Unit < double, unit_dimention::farad, prefix::nano > NanoFarad using Unit < double, unit_dimention::angle, prefix::none, tag::angle::radian > Radian using Unit < double, unit_dimention::angle, prefix::none, tag::angle::degree > Degree using Unit < double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec > AngularVelocity using Unit < double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps > Rps using Unit < double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm > Rpm using Unit < double, unit_dimention::angular_acceleration, prefix::none > AngularAcceleration using Quaternion < float > Quaternionf using Quaternion < double > Quaterniond using Transform < float > Transformf using Transform < double > Transformd using Vector2 < float > Vector2f using Vector2 < double > Vector2d using Vector3 < float > Vector3f using Vector3 < double > Vector3d using Vector4 < float > Vector4f using Vector4 < double > Vector4d Functions Name template <size_t DIM> std::pair< Eigen::Matrix< double, DIM, DIM >, Eigen::Matrix< double, DIM, 1 > > calcu_transformatoin (std::vector< Eigen::Matrix< double, DIM, 1 >> dest, std::vector< Eigen::Matrix< double, DIM, 1 >> fixed) template <size_t DIM> std::tuple< std::vector< Eigen::Matrix< double, DIM, 1 > >, size_t > icp (std::vector< Eigen::Matrix< double, DIM, 1 >> dest, std::vector< Eigen::Matrix< double, DIM, 1 >> fixed, size_t max_iter =100) double mahalanobis (const Eigen::VectorXd & a, const Eigen::VectorXd & b, const Eigen::MatrixXd cov_inv) \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 Polynomial poly_regression (const std::vector< double > & x, const std::vector< double > & y, const size_t degree) \u56de\u5e30\u66f2\u7dda template <typename Real =double> Real gererate_random () 0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b std::optional< Eigen::MatrixXd > solve_riccati_arimoto_potter (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & Q, const Eigen::MatrixXd & R) \u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 Eigen::MatrixXd lqr (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & Q, const Eigen::MatrixXd & R) Eigen::MatrixXd controllability_matrix (const Eigen::MatrixXd & A, const Eigen::VectorXd & B) \u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 bool is_controllable (const Eigen::MatrixXd & A, const Eigen::VectorXd & B) \u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 bool is_controllable (const StateSpaceSystem & sys) Eigen::MatrixXd observability_matrix (const Eigen::MatrixXd & A, const Eigen::RowVectorXd & C) \u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b bool is_observable (const Eigen::MatrixXd & A, const Eigen::RowVectorXd & C) \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 bool is_observable (const StateSpaceSystem & sys) std::tuple< Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd > canonicalize_system (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & C, const Eigen::MatrixXd & D, CanonicalizeMode mode = CanonicalizeMode::COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db std::tuple< Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd > canonicalize_system (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & C, CanonicalizeMode mode = CanonicalizeMode::COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db std::tuple< Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd > canonicalize_system (const StateSpaceSystem & sys, CanonicalizeMode mode = CanonicalizeMode::COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Eigen::VectorXd place (const StateSpaceSystem & sys, std::vector< double > poles) \u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e bool intersect (const Vector2d & a, const Vector2d & b) bool intersect (const Vector2d & a, const Line & b) bool intersect (const Vector2d & a, const Rect & b) bool intersect (const Vector2d & a, const Circle & b) bool intersect (const Line & a, const Vector2d & b) bool intersect (const Line & a, const Line & b) bool intersect (const Line & a, const Circle & b) bool intersect (const Rect & a, const Vector2d & b) bool intersect (const Circle & a, const Vector2d & b) bool intersect (const Circle & a, const Line & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Line & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Rect & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Circle & b) std::vector< Vector2d > intersect_at (const Line & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Line & a, const Line & b) std::vector< Vector2d > intersect_at (const Line & a, const Circle & b) std::vector< Vector2d > intersect_at (const Rect & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Circle & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Circle & a, const Line & b) bool contain (const Vector2d & range, const Vector2d & target) bool contain (const Rect & range, const Vector2d & target) std::ostream & operator<< (std::ostream & os, const Vector2d & v) std::ostream & operator<< (std::ostream & os, const Vector3d & v) std::ostream & operator<< (std::ostream & os, const Vector4d & v) std::ostream & operator<< (std::ostream & os, const Transformd & v) constexpr DCMotorParam generate_mabuchi_motor_param ( Volt nominal_voltage, Rpm free_speed, Ampere free_current, Torque stall_torque, Ampere stall_current, Henry inductance, Inertia rotor_inertia) constexpr DCMotorParam generate_maxon_brush_motor_param ( Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm resistance, Henry inductance, TorqueConstant Kt, Inertia rotor_inertia) TransferFunction make_motor_vel_tf (const DCMotorParam & motor, const double dt) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_motor_pos_tf (const DCMotorParam & motor, const double dt) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_vel_tf (const DCGearedMotorParam & geared_motor, const double dt) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_pos_tf (const DCGearedMotorParam & geared_motor, const double dt) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b std::tuple< bool, Eigen::VectorXd, size_t > barrier_method (std::function< double(const Eigen::VectorXd &)> f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =10.0, const double tol =1e-3, const size_t max_iter =1000) \u30d0\u30ea\u30a2\u6cd5 void bfgs_step (Eigen::MatrixXd & hess, Eigen::VectorXd s, Eigen::VectorXd y) BFGS\u6cd5 void powells_modified_bfgs_step (Eigen::MatrixXd & hess, Eigen::VectorXd s, Eigen::VectorXd y, double gamma =0.2) \u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 double bracketing_serach (std::function< double(Eigen::VectorXd)> func, std::function< Eigen::VectorXd(Eigen::VectorXd)> grad, const Eigen::VectorXd & x, const Eigen::VectorXd & d, double gamma =0.3, double tau =0.9, const size_t max_iter =1000) \u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 double bracketing_serach (std::function< double(double)> func, const double init =1.0, const double beta =0.9, const size_t max_iter =1000) \u56f2\u3044\u8fbc\u307f\u6cd5 double derivative (std::function< double(double)> f, double x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R -> R\u306e\u6570\u5024\u5fae\u5206 Eigen::VectorXd derivative (std::function< double(Eigen::VectorXd)> f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R^n -> R\u306e\u6570\u5024\u5fae\u5206 Eigen::MatrixXd derivative (std::function< Eigen::VectorXd(Eigen::VectorXd)> f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R^n -> R^m\u306e\u6570\u5024\u5fae\u5206 double second_derivative (std::function< double(double)> f, double x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R -> R\u306e2\u56de\u6570\u5024\u5fae\u5206 Eigen::MatrixXd approx_hessian (std::function< double(Eigen::VectorXd)> f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) double golden_search (std::function< double(double)> f, double low, double high, const double tol =1e-6, const size_t max_iter =100) \u9ec4\u91d1\u63a2\u7d22 std::tuple< bool, Eigen::VectorXd, size_t > newton_method (std::function< Eigen::VectorXd(const Eigen::VectorXd &)> grad, std::function< Eigen::MatrixXd(const Eigen::VectorXd &)> hesse, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000) \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple< bool, Eigen::VectorXd, size_t > penalty_method (std::function< double(const Eigen::VectorXd &)> f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =1.0, const double tol =1e-3, const size_t max_iter =1000) \u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 std::tuple< bool, Eigen::VectorXd, size_t > quasi_newton_method (std::function< double(const Eigen::VectorXd &)> f, std::function< Eigen::VectorXd(const Eigen::VectorXd &)> grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000) \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple< bool, Eigen::VectorXd, size_t > steepest_descent_method (std::function< double(const Eigen::VectorXd &)> f, std::function< Eigen::VectorXd(const Eigen::VectorXd &)> grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000) \u6700\u6025\u964d\u4e0b\u6cd5 std::vector< Eigen::Vector2i > a_star (const Eigen::Vector2i & start, const Eigen::Vector2i & end, const Eigen::MatrixXi & map) A*\u6cd5 std::vector< Eigen::Vector2i > wave_propagation (const Eigen::Vector2i & start, const Eigen::Vector2i & end, const Eigen::MatrixXi & map) Wave propagation\u6cd5 std::tuple< std::vector< double >, std::vector< double > > bode ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500), bool gain_db_mode =true, bool phase_deg_mode =true) \u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b void bode_plot ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500)) \u30dc\u30fc\u30c9\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) std::tuple< std::vector< double >, std::vector< double > > nyquist ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500)) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b void nyquist_plot ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500)) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) std::ostream & operator<< (std::ostream & os, const Polynomial & v) template <class CONTROLLER_T ,class SYSTEM_T > SisoFeedbackSystem make_feedback_system (CONTROLLER_T & controller, SYSTEM_T & system) void set_controller ( SisoFeedbackSystem::func_list_t & fn, PIDController & controller) void set_controller ( SisoFeedbackSystem::func_list_t & fn, NctfController & controller) void set_system ( SisoFeedbackSystem::func_list_t & fn, TransferFunction & system) std::tuple< std::vector< double >, std::vector< double > > impluse ( TransferFunction & sys, double time) \u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > step (const std::function< double(double)> & sys, double dt, double time, const double gain =1.0) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > step ( TransferFunction & sys, double time, const double gain =1.0) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > step ( DiscreteTransferFunction & sys, double time, const double gain =1.0) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > lsim ( TransferFunction & sys, std::vector< double > input) \u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b template <class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag ::value && tag::is_normal_tag ::value> constexpr double conv_factor () template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator* (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator/ (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator+ (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator- (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl) template <class ForwardIterator > constexpr ForwardIterator shift_left (ForwardIterator first, ForwardIterator last, typename std::iterator_traits< ForwardIterator >::difference_type n) C++17\u306estd::shift_left\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b template <class ForwardIterator > constexpr ForwardIterator shift_right (ForwardIterator first, ForwardIterator last, typename std::iterator_traits< ForwardIterator >::difference_type n) C++17\u306estd::shift_right\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b template <typename... Args> std::string c_format (const std::string & format, Args const &... args) printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b template <typename T > constexpr bool in_range_open (T x, T min, T max) template <typename T > constexpr bool in_range (T x, T min, T max) template <typename T > constexpr int sgn (T x) template <typename T > constexpr float radians (T deg) template <typename T > constexpr float degrees (T rad) float normalize_angle_positive (float angle) float normalize_angle (float angle) float shortest_angular_distance (float from, float to) float nearest_angle (float from, float to) constexpr float square (const float x) constexpr float cubic (const float x) constexpr float lerp (const float a, const float b, const float t) constexpr float approx_eq (const float a, const float b) constexpr float approx_zero (const float a) std::vector< double > arrange (double start, double end, double step =1.0) std::vector< double > linspace (double start, double end, size_t n =100) std::vector< double > logspace (double start, double end, size_t n =100) std::vector< double > funcspace (std::function< double(size_t, size_t)> f, size_t n =100) std::vector< double > sinspace (double a, double b, size_t n =100) Attributes Name constexpr DCMotorParam RZ_735VA_9517 constexpr DCMotorParam RS_775_8513 constexpr DCMotorParam RS_555VC_5524 constexpr DCMotorParam RS_380PH_4045 constexpr DCMotorParam RS_385PH_2465 constexpr DCMotorParam RE_65_250_18 constexpr GearHeadParam IG42C_4 constexpr GearHeadParam IG42C_14 constexpr GearHeadParam IG42C_17 constexpr GearHeadParam IG32_27 constexpr GearHeadParam IG32_71 constexpr GearHeadParam IG32_100 constexpr float PI \u5186\u5468\u7387 constexpr float HALF_PI \u5186\u5468\u7387 / 2 constexpr float TWO_PI \u5186\u5468\u7387 * 2 constexpr float DEG_TO_RAD degree -> radians constexpr float RAD_TO_DEG radian -> degree constexpr float EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr float GRAVITY \u91cd\u529b constexpr float Nm2gfm constexpr float gfm2Nm constexpr float mNm2gfcm constexpr float gfcm2mNm Types Documentation enum CanonicalizeMode Enumerator Value Description COMPANION OBSERBAVLE CONTROLLABLE enum UnitIndex Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx using UniformIntRandomEngine using cpp_robotics :: UniformIntRandomEngine = typedef RandomGenerator < std :: uniform_int_distribution <> > ; \u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using UniformRealRandomEngine using cpp_robotics :: UniformRealRandomEngine = typedef RandomGenerator < std :: uniform_real_distribution <> > ; \u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using BernoulliRandomEngine using cpp_robotics :: BernoulliRandomEngine = typedef RandomGenerator < std :: bernoulli_distribution > ; \u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using BinomialRandomEngine using cpp_robotics :: BinomialRandomEngine = typedef RandomGenerator < std :: binomial_distribution <> > ; \u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using GeometricRandomEngine using cpp_robotics :: GeometricRandomEngine = typedef RandomGenerator < std :: geometric_distribution <> > ; \u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using NegativeBinomialRandomEngine using cpp_robotics :: NegativeBinomialRandomEngine = typedef RandomGenerator < std :: negative_binomial_distribution <> > ; \u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using PoissonRandomEngine using cpp_robotics :: PoissonRandomEngine = typedef RandomGenerator < std :: poisson_distribution <> > ; \u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using ExponentialRandomEngine using cpp_robotics :: ExponentialRandomEngine = typedef RandomGenerator < std :: exponential_distribution <> > ; \u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using GammaRandomEngine using cpp_robotics :: GammaRandomEngine = typedef RandomGenerator < std :: gamma_distribution <> > ; \u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using WeibullRandomEngine using cpp_robotics :: WeibullRandomEngine = typedef RandomGenerator < std :: weibull_distribution <> > ; \u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using ExtremeValueRandomEngine using cpp_robotics :: ExtremeValueRandomEngine = typedef RandomGenerator < std :: extreme_value_distribution <> > ; \u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using NormalRandomEngine using cpp_robotics :: NormalRandomEngine = typedef RandomGenerator < std :: normal_distribution <> > ; \u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using LognormalRandomEngine using cpp_robotics :: LognormalRandomEngine = typedef RandomGenerator < std :: lognormal_distribution <> > ; \u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using ChiSquaredRandomEngine using cpp_robotics :: ChiSquaredRandomEngine = typedef RandomGenerator < std :: chi_squared_distribution <> > ; \u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using CauchyRandomEngine using cpp_robotics :: CauchyRandomEngine = typedef RandomGenerator < std :: cauchy_distribution <> > ; \u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using FisherFRandomEngine using cpp_robotics :: FisherFRandomEngine = typedef RandomGenerator < std :: fisher_f_distribution <> > ; \u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using StudentTRandomEngine using cpp_robotics :: StudentTRandomEngine = typedef RandomGenerator < std :: student_t_distribution <> > ; \u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using DiscreteRandomEngine using cpp_robotics :: DiscreteRandomEngine = typedef RandomGenerator < std :: discrete_distribution <> > ; \u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using PiecewiseConstantRandomEngine using cpp_robotics :: PiecewiseConstantRandomEngine = typedef RandomGenerator < std :: piecewise_constant_distribution <> > ; \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using PiecewiseLinearRandomEngine using cpp_robotics :: PiecewiseLinearRandomEngine = typedef RandomGenerator < std :: piecewise_linear_distribution <> > ; \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using TorqueConstant using cpp_robotics :: unit :: TorqueConstant = typedef unit_assem :: unit_div < Torque , Ampere >:: unit ; using BackEmfConstant using cpp_robotics :: unit :: BackEmfConstant = typedef unit_assem :: unit_div < Volt , AngularVelocity >:: unit ; using FrictionConstant using cpp_robotics :: unit :: FrictionConstant = typedef unit_assem :: unit_mul < Torque , Second >:: unit ; using Second using cpp_robotics :: unit :: Second = typedef Unit < double , unit_dimention :: second , prefix :: none > ; using MilliSecond using cpp_robotics :: unit :: MilliSecond = typedef Unit < double , unit_dimention :: second , prefix :: milli > ; using MicroSecond using cpp_robotics :: unit :: MicroSecond = typedef Unit < double , unit_dimention :: second , prefix :: micro > ; using Meter using cpp_robotics :: unit :: Meter = typedef Unit < double , unit_dimention :: metere , prefix :: none > ; using MilliMeter using cpp_robotics :: unit :: MilliMeter = typedef Unit < double , unit_dimention :: metere , prefix :: milli > ; using MicroMeter using cpp_robotics :: unit :: MicroMeter = typedef Unit < double , unit_dimention :: metere , prefix :: micro > ; using CentiMeter using cpp_robotics :: unit :: CentiMeter = typedef Unit < double , unit_dimention :: metere , prefix :: centi > ; using KiloGram using cpp_robotics :: unit :: KiloGram = typedef Unit < double , unit_dimention :: kilogram , prefix :: none > ; using Gram using cpp_robotics :: unit :: Gram = typedef Unit < double , unit_dimention :: kilogram , prefix :: milli > ; using Watt using cpp_robotics :: unit :: Watt = typedef Unit < double , unit_dimention :: watt , prefix :: none > ; using KiloWatt using cpp_robotics :: unit :: KiloWatt = typedef Unit < double , unit_dimention :: watt , prefix :: kilo > ; using Newton using cpp_robotics :: unit :: Newton = typedef Unit < double , unit_dimention :: newton , prefix :: none > ; using KiloNewton using cpp_robotics :: unit :: KiloNewton = typedef Unit < double , unit_dimention :: newton , prefix :: kilo > ; using Pascal using cpp_robotics :: unit :: Pascal = typedef Unit < double , unit_dimention :: pascal , prefix :: none > ; using KiloPascal using cpp_robotics :: unit :: KiloPascal = typedef Unit < double , unit_dimention :: pascal , prefix :: kilo > ; using Hertz using cpp_robotics :: unit :: Hertz = typedef Unit < double , unit_dimention :: hertz , prefix :: none > ; using Area using cpp_robotics :: unit :: Area = typedef Unit < double , unit_dimention :: area , prefix :: none > ; using Volume using cpp_robotics :: unit :: Volume = typedef Unit < double , unit_dimention :: volume , prefix :: none > ; using Velocity using cpp_robotics :: unit :: Velocity = typedef Unit < double , unit_dimention :: velocity , prefix :: none > ; using Acceleration using cpp_robotics :: unit :: Acceleration = typedef Unit < double , unit_dimention :: acceleration , prefix :: none > ; using Dencity using cpp_robotics :: unit :: Dencity = typedef Unit < double , unit_dimention :: dencity , prefix :: none > ; using Torque using cpp_robotics :: unit :: Torque = typedef Unit < double , unit_dimention :: torque , prefix :: none > ; using Inertia using cpp_robotics :: unit :: Inertia = typedef Unit < double , unit_dimention :: inertia , prefix :: none > ; using Ampere using cpp_robotics :: unit :: Ampere = typedef Unit < double , unit_dimention :: ampere , prefix :: none > ; using MilliAmpere using cpp_robotics :: unit :: MilliAmpere = typedef Unit < double , unit_dimention :: ampere , prefix :: milli > ; using Volt using cpp_robotics :: unit :: Volt = typedef Unit < double , unit_dimention :: volt , prefix :: none > ; using MilliVolt using cpp_robotics :: unit :: MilliVolt = typedef Unit < double , unit_dimention :: volt , prefix :: milli > ; using Ohm using cpp_robotics :: unit :: Ohm = typedef Unit < double , unit_dimention :: ohm , prefix :: none > ; using MilliOhm using cpp_robotics :: unit :: MilliOhm = typedef Unit < double , unit_dimention :: ohm , prefix :: milli > ; using Henry using cpp_robotics :: unit :: Henry = typedef Unit < double , unit_dimention :: henry , prefix :: none > ; using MilliHenry using cpp_robotics :: unit :: MilliHenry = typedef Unit < double , unit_dimention :: henry , prefix :: milli > ; using Farad using cpp_robotics :: unit :: Farad = typedef Unit < double , unit_dimention :: farad , prefix :: none > ; using MilliFarad using cpp_robotics :: unit :: MilliFarad = typedef Unit < double , unit_dimention :: farad , prefix :: milli > ; using MicroFarad using cpp_robotics :: unit :: MicroFarad = typedef Unit < double , unit_dimention :: farad , prefix :: micro > ; using NanoFarad using cpp_robotics :: unit :: NanoFarad = typedef Unit < double , unit_dimention :: farad , prefix :: nano > ; using Radian using cpp_robotics :: unit :: Radian = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: radian > ; using Degree using cpp_robotics :: unit :: Degree = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: degree > ; using AngularVelocity using cpp_robotics :: unit :: AngularVelocity = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rad_per_sec > ; using Rps using cpp_robotics :: unit :: Rps = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rps > ; using Rpm using cpp_robotics :: unit :: Rpm = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rpm > ; using AngularAcceleration using cpp_robotics :: unit :: AngularAcceleration = typedef Unit < double , unit_dimention :: angular_acceleration , prefix :: none > ; using Quaternionf using cpp_robotics :: Quaternionf = typedef Quaternion < float > ; using Quaterniond using cpp_robotics :: Quaterniond = typedef Quaternion < double > ; using Transformf using cpp_robotics :: Transformf = typedef Transform < float > ; using Transformd using cpp_robotics :: Transformd = typedef Transform < double > ; using Vector2f using cpp_robotics :: Vector2f = typedef Vector2 < float > ; using Vector2d using cpp_robotics :: Vector2d = typedef Vector2 < double > ; using Vector3f using cpp_robotics :: Vector3f = typedef Vector3 < float > ; using Vector3d using cpp_robotics :: Vector3d = typedef Vector3 < double > ; using Vector4f using cpp_robotics :: Vector4f = typedef Vector4 < float > ; using Vector4d using cpp_robotics :: Vector4d = typedef Vector4 < double > ; Functions Documentation function calcu_transformatoin template < size_t DIM > static std :: pair < Eigen :: Matrix < double , DIM , DIM > , Eigen :: Matrix < double , DIM , 1 > > calcu_transformatoin ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed ) function icp template < size_t DIM > static std :: tuple < std :: vector < Eigen :: Matrix < double , DIM , 1 > > , size_t > icp ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed , size_t max_iter = 100 ) function mahalanobis double mahalanobis ( const Eigen :: VectorXd & a , const Eigen :: VectorXd & b , const Eigen :: MatrixXd cov_inv ) \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 Parameters : a b cov_inv \u5206\u6563\u306e\u9006\u884c\u5217 Return : double \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2 function poly_regression Polynomial poly_regression ( const std :: vector < double > & x , const std :: vector < double > & y , const size_t degree ) \u56de\u5e30\u66f2\u7dda Parameters : x y degree \u56de\u5e30\u66f2\u7dda\u306e\u6b21\u5143 Return : Polynomial function gererate_random template < typename Real = double > static Real gererate_random () 0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b Template Parameters : Real \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b Return : Real \u4e71\u6570 function solve_riccati_arimoto_potter static std :: optional < Eigen :: MatrixXd > solve_riccati_arimoto_potter ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R ) \u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 Parameters : A B Q R Return : std::optional function lqr static Eigen :: MatrixXd lqr ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R ) function controllability_matrix static Eigen :: MatrixXd controllability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) \u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 Parameters : A B Return : Eigen::MatrixXd function is_controllable static bool is_controllable ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) \u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 Parameters : A B Return : true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u3042\u308b false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u306a\u3044 function is_controllable static bool is_controllable ( const StateSpaceSystem & sys ) function observability_matrix static Eigen :: MatrixXd observability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) \u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b Parameters : A C Return : Eigen::MatrixXd function is_observable static bool is_observable ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 Parameters : A C Return : true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044 function is_observable static bool is_observable ( const StateSpaceSystem & sys ) Parameters : sys \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 Return : true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044 function canonicalize_system static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , const Eigen :: MatrixXd & D , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Parameters : A B C D mode Return : std::tuple function canonicalize_system static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Parameters : A B C mode Return : std::tuple function canonicalize_system static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const StateSpaceSystem & sys , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Parameters : sys mode Return : std::tuple function place static Eigen :: VectorXd place ( const StateSpaceSystem & sys , std :: vector < double > poles ) \u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e Parameters : sys poles Return : Eigen::VectorXd function intersect bool intersect ( const Vector2d & a , const Vector2d & b ) function intersect bool intersect ( const Vector2d & a , const Line & b ) function intersect bool intersect ( const Vector2d & a , const Rect & b ) function intersect bool intersect ( const Vector2d & a , const Circle & b ) function intersect bool intersect ( const Line & a , const Vector2d & b ) function intersect bool intersect ( const Line & a , const Line & b ) function intersect bool intersect ( const Line & a , const Circle & b ) function intersect bool intersect ( const Rect & a , const Vector2d & b ) function intersect bool intersect ( const Circle & a , const Vector2d & b ) function intersect bool intersect ( const Circle & a , const Line & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Vector2d & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Line & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Rect & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Circle & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Line & a , const Vector2d & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Line & a , const Line & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Line & a , const Circle & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Rect & a , const Vector2d & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Circle & a , const Vector2d & b ) function intersect_at std :: vector < Vector2d > intersect_at ( const Circle & a , const Line & b ) function contain bool contain ( const Vector2d & range , const Vector2d & target ) function contain bool contain ( const Rect & range , const Vector2d & target ) function operator<< std :: ostream & operator << ( std :: ostream & os , const Vector2d & v ) function operator<< std :: ostream & operator << ( std :: ostream & os , const Vector3d & v ) function operator<< std :: ostream & operator << ( std :: ostream & os , const Vector4d & v ) function operator<< std :: ostream & operator << ( std :: ostream & os , const Transformd & v ) function generate_mabuchi_motor_param inline constexpr DCMotorParam generate_mabuchi_motor_param ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Torque stall_torque , Ampere stall_current , Henry inductance , Inertia rotor_inertia ) function generate_maxon_brush_motor_param inline constexpr DCMotorParam generate_maxon_brush_motor_param ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Ohm resistance , Henry inductance , TorqueConstant Kt , Inertia rotor_inertia ) function make_motor_vel_tf static TransferFunction make_motor_vel_tf ( const DCMotorParam & motor , const double dt ) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : motor dt Return : TransferFunction function make_motor_pos_tf static TransferFunction make_motor_pos_tf ( const DCMotorParam & motor , const double dt ) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : motor dt Return : TransferFunction function make_geared_motor_vel_tf static TransferFunction make_geared_motor_vel_tf ( const DCGearedMotorParam & geared_motor , const double dt ) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : geared_motor dt Return : TransferFunction function make_geared_motor_pos_tf static TransferFunction make_geared_motor_pos_tf ( const DCGearedMotorParam & geared_motor , const double dt ) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : geared_motor dt Return : TransferFunction function barrier_method static std :: tuple < bool , Eigen :: VectorXd , size_t > barrier_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 10.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) \u30d0\u30ea\u30a2\u6cd5 function bfgs_step static void bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y ) BFGS\u6cd5 Parameters : hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 s x_k+1 - x_k y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k) function powells_modified_bfgs_step static void powells_modified_bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y , double gamma = 0.2 ) \u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 Parameters : hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 s x_k+1 - x_k y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k) gamma function bracketing_serach static double bracketing_serach ( std :: function < double ( Eigen :: VectorXd ) > func , std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > grad , const Eigen :: VectorXd & x , const Eigen :: VectorXd & d , double gamma = 0.3 , double tau = 0.9 , const size_t max_iter = 1000 ) \u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 Parameters : func grad x d gamma tau max_iter Return : double function bracketing_serach static double bracketing_serach ( std :: function < double ( double ) > func , const double init = 1.0 , const double beta = 0.9 , const size_t max_iter = 1000 ) \u56f2\u3044\u8fbc\u307f\u6cd5 Parameters : func init beta max_iter Return : double function derivative static double derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R -> R\u306e\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : double function derivative static Eigen :: VectorXd derivative ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R^n -> R\u306e\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : Eigen::VectorXd function derivative static Eigen :: MatrixXd derivative ( std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R^n -> R^m\u306e\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : Eigen::MatrixXd function second_derivative static double second_derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R -> R\u306e2\u56de\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : double function approx_hessian static Eigen :: MatrixXd approx_hessian ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) Parameters : f x eps Return : Eigen::MatrixXd function golden_search static double golden_search ( std :: function < double ( double ) > f , double low , double high , const double tol = 1e-6 , const size_t max_iter = 100 ) \u9ec4\u91d1\u63a2\u7d22 Parameters : f low high tol max_iter Return : double function newton_method static std :: tuple < bool , Eigen :: VectorXd , size_t > newton_method ( std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , std :: function < Eigen :: MatrixXd ( const Eigen :: VectorXd & ) > hesse , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Parameters : grad hesse x_init tol max_iter Return : std::tuple function penalty_method static std :: tuple < bool , Eigen :: VectorXd , size_t > penalty_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 1.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) \u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 Parameters : f constraint x_init r_init tol max_iter Return : std::tuple function quasi_newton_method static std :: tuple < bool , Eigen :: VectorXd , size_t > quasi_newton_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Parameters : f grad x_init tol max_iter Return : std::tuple function steepest_descent_method static std :: tuple < bool , Eigen :: VectorXd , size_t > steepest_descent_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) \u6700\u6025\u964d\u4e0b\u6cd5 Parameters : f grad x_init tol max_iter Return : std::tuple function a_star static std :: vector < Eigen :: Vector2i > a_star ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) A*\u6cd5 Parameters : start end map Return : std::vector function wave_propagation std :: vector < Eigen :: Vector2i > wave_propagation ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) Wave propagation\u6cd5 Parameters : start end map Return : std::vector function bode static std :: tuple < std :: vector < double > , std :: vector < double > > bode ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ), bool gain_db_mode = true , bool phase_deg_mode = true ) \u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b Parameters : tf omegas gain_db_mode phase_deg_mode Return : std::tuple , std::vector\\ > function bode_plot static void bode_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ) ) \u30dc\u30fc\u30c9\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) Parameters : tf omegas function nyquist static std :: tuple < std :: vector < double > , std :: vector < double > > nyquist ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ) ) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b Parameters : tf omegas Return : std::tuple , std::vector\\ > function nyquist_plot static void nyquist_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ) ) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) Parameters : tf omegas function operator<< std :: ostream & operator << ( std :: ostream & os , const Polynomial & v ) function make_feedback_system template < class CONTROLLER_T , class SYSTEM_T > static SisoFeedbackSystem make_feedback_system ( CONTROLLER_T & controller , SYSTEM_T & system ) function set_controller static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , PIDController & controller ) function set_controller static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , NctfController & controller ) function set_system static void set_system ( SisoFeedbackSystem :: func_list_t & fn , TransferFunction & system ) function impluse static std :: tuple < std :: vector < double > , std :: vector < double > > impluse ( TransferFunction & sys , double time ) \u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys time Return : std::tuple , std::vector\\ > function step static std :: tuple < std :: vector < double > , std :: vector < double > > step ( const std :: function < double ( double ) > & sys , double dt , double time , const double gain = 1.0 ) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys dt time gain Return : std::tuple , std::vector\\ > function step static std :: tuple < std :: vector < double > , std :: vector < double > > step ( TransferFunction & sys , double time , const double gain = 1.0 ) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys time gain Return : std::tuple , std::vector\\ > function step static std :: tuple < std :: vector < double > , std :: vector < double > > step ( DiscreteTransferFunction & sys , double time , const double gain = 1.0 ) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys time gain Return : std::tuple , std::vector\\ > function lsim static std :: tuple < std :: vector < double > , std :: vector < double > > lsim ( TransferFunction & sys , std :: vector < double > input ) \u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys input Return : std::tuple , std::vector\\ > function conv_factor template < class UnitDimType , int FromTag , int ToTag , bool IsNormalTag = tag :: is_normal_tag < FromTag >:: value && tag :: is_normal_tag < ToTag >:: value > constexpr double conv_factor () function operator* template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) function operator* template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) function operator/ template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) function operator/ template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) function operator* template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator * ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) function operator/ template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator / ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) function operator+ template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator + ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) function operator- template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator - ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) function shift_left template < class ForwardIterator > constexpr ForwardIterator shift_left ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) C++17\u306estd::shift_left\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b Parameters : first last n Template Parameters : ForwardIterator Return : constexpr ForwardIterator function shift_right template < class ForwardIterator > constexpr ForwardIterator shift_right ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) C++17\u306estd::shift_right\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b Parameters : first last n Template Parameters : ForwardIterator Return : constexpr ForwardIterator function c_format template < typename ... Args > std :: string c_format ( const std :: string & format , Args const & ... args ) printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b Parameters : format args Template Parameters : Args Return : std::string function in_range_open template < typename T > static constexpr bool in_range_open ( T x , T min , T max ) Parameters : x min max Template Parameters : T Return : true false function in_range template < typename T > static constexpr bool in_range ( T x , T min , T max ) Parameters : x min max Template Parameters : T Return : true false function sgn template < typename T > static constexpr int sgn ( T x ) Parameters : x Template Parameters : T Return : constexpr int function radians template < typename T > static constexpr float radians ( T deg ) Parameters : deg Template Parameters : T Return : constexpr float function degrees template < typename T > static constexpr float degrees ( T rad ) Parameters : rad Template Parameters : T Return : constexpr float function normalize_angle_positive static inline float normalize_angle_positive ( float angle ) Parameters : angle Return : float function normalize_angle static inline float normalize_angle ( float angle ) Parameters : angle Return : float function shortest_angular_distance static inline float shortest_angular_distance ( float from , float to ) Parameters : from to Return : float function nearest_angle static inline float nearest_angle ( float from , float to ) function square inline constexpr float square ( const float x ) function cubic inline constexpr float cubic ( const float x ) function lerp inline constexpr float lerp ( const float a , const float b , const float t ) function approx_eq inline constexpr float approx_eq ( const float a , const float b ) function approx_zero inline constexpr float approx_zero ( const float a ) function arrange static std :: vector < double > arrange ( double start , double end , double step = 1.0 ) function linspace static std :: vector < double > linspace ( double start , double end , size_t n = 100 ) function logspace static std :: vector < double > logspace ( double start , double end , size_t n = 100 ) function funcspace static std :: vector < double > funcspace ( std :: function < double ( size_t , size_t ) > f , size_t n = 100 ) function sinspace static std :: vector < double > sinspace ( double a , double b , size_t n = 100 ) Attributes Documentation variable RZ_735VA_9517 constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param ( 18 _V , 20400 _rpm , 2.8 _A , 1265 _mmNm , 156 _A , 7.088e-5 _H , 2.46e-5 ); variable RS_775_8513 constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param ( 18 _V , 18400 _rpm , 2.7 _A , 1216 _mmNm , 130 _A , 5.872e-5 _H , 2.46e-5 ); variable RS_555VC_5524 constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param ( 12 _V , 9100 _rpm , 0.8 _A , 450 _mmNm , 36 _A , 1.820e-4 _H , 2.46e-5 ); variable RS_380PH_4045 constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param ( 6 _V , 12500 _rpm , 0.56 _A , 77.5 _mmNm , 18 _A , 1.521e-4 _H , 2.46e-5 ); variable RS_385PH_2465 constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param ( 18 _V , 17500 _rpm , 0.23 _A , 76.9 _mmNm , 7.91 _A , 1.521e-4 _H , 2.46e-5 ); variable RE_65_250_18 constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param ( 18 _V , 3520 _rpm , 755 _mA , 0.0609 _ohm , 0.0226 _mH , 46e-3 _Nm_per_A , 1.38 ); variable IG42C_4 constexpr GearHeadParam IG42C_4 = { 1 / 4.0f , 0.8f }; variable IG42C_14 constexpr GearHeadParam IG42C_14 = { 1 / 14.0f , 0.7f }; variable IG42C_17 constexpr GearHeadParam IG42C_17 = { 1 / 17.0f , 0.7f }; variable IG32_27 constexpr GearHeadParam IG32_27 = { 1 / 27.0f , 0.7f }; variable IG32_71 constexpr GearHeadParam IG32_71 = { 1 / 71.0f , 0.6f }; variable IG32_100 constexpr GearHeadParam IG32_100 = { 1 / 100.0f , 0.6f }; variable PI constexpr float PI = 3.1415926535897932384626433832795 ; \u5186\u5468\u7387 variable HALF_PI constexpr float HALF_PI = PI / 2.0 ; \u5186\u5468\u7387 / 2 variable TWO_PI constexpr float TWO_PI = PI * 2.0 ; \u5186\u5468\u7387 * 2 variable DEG_TO_RAD constexpr float DEG_TO_RAD = PI / 180.0 ; degree -> radians variable RAD_TO_DEG constexpr float RAD_TO_DEG = 180.0 / PI ; radian -> degree variable EULER constexpr float EULER = 2.718281828459045235360287471352 ; \u30cd\u30a4\u30d4\u30a2\u6570 variable GRAVITY constexpr float GRAVITY = 9.807 ; \u91cd\u529b variable Nm2gfm constexpr float Nm2gfm = ( 1 / GRAVITY ); variable gfm2Nm constexpr float gfm2Nm = GRAVITY ; variable mNm2gfcm constexpr float mNm2gfcm = ( Nm2gfm * 100 ); variable gfcm2mNm constexpr float gfcm2mNm = ( gfm2Nm / 100 ); Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#cpp_robotics","text":"","title":"cpp_robotics"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#namespaces","text":"Name cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 cpp_robotics::unit \u5358\u4f4d\u7cfb cpp_robotics::unit::prefix cpp_robotics::unit::tag cpp_robotics::unit::unit_dimention","title":"Namespaces"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#classes","text":"Name class cpp_robotics::AccelerationLimitFilter \u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf(\u901f\u5ea6\u5236\u9650\u8fbc\u307f) class cpp_robotics::ActiveSetMethod \u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5\u3092\u89e3\u304f\u6709\u52b9\u5236\u7d04\u6cd5 class cpp_robotics::AngleRange \u89d2\u5ea6[rad]\u306b\u5bfe\u3057\u3066\u7bc4\u56f2\u3092\u6307\u5b9a\u3059\u308b \u8907\u6570\u306e\u89d2\u5ea6\u306e\u7bc4\u56f2\u306e\u5408\u6210\u3092\u3057\u305f\u308a\u9006\u3092\u53d6\u3063\u305f\u308a\u3067\u304d\u308b class cpp_robotics::BandPassFilter \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::CatumullRom2D Catumull\u66f2\u7dda struct cpp_robotics::Circle \u5186\u30af\u30e9\u30b9 struct cpp_robotics::Constraint \u6570\u7406\u6700\u9069\u554f\u984c\u306b\u4f7f\u7528\u3059\u308b\u5236\u7d04\u30af\u30e9\u30b9 class cpp_robotics::ConstraintArray \u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306e\u5236\u7d04\u306e\u96c6\u5408 class cpp_robotics::CubicSpline 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda struct cpp_robotics::DCGearedMotorParam \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb struct cpp_robotics::DCMotorParam DC\u30e2\u30fc\u30bf\u30fc\u30e2\u30c7\u30eb class cpp_robotics::DelayFilter \u9045\u5ef6\u30d5\u30a3\u30eb\u30bf class cpp_robotics::DeltaRobotIk \u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8\u306e\u9006\u904b\u52d5\u5b66 class cpp_robotics::Differentiator \u7591\u4f3c\u5fae\u5206\u5668 class cpp_robotics::Discret \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb\u3092\u53cc\u4e00\u6b21\u5909\u63db\u3067\u96e2\u6563\u5316\u3059\u308b class cpp_robotics::DiscreteTransferFunction z\u7a7a\u9593\u306e\u4f1d\u9054\u95a2\u6570 class cpp_robotics::DubinsPath Dubins\u30d1\u30b9 class cpp_robotics::ExtendedKalmanFilter class cpp_robotics::FilterConnector class cpp_robotics::FilterStateHolder \u30d5\u30a3\u30eb\u30bf\u306e\u5165\u529b\u3068\u8a08\u7b97\u3092\u975e\u540c\u671f\u306b\u3057\u3066\u6700\u5f8c\u306e\u5165\u529b\u3068\u51fa\u529b\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u308b\u3088\u3046\u306b\u3059\u308b\u30af\u30e9\u30b9 struct cpp_robotics::GearHeadParam \u30ae\u30a2\u30d8\u30c3\u30c9\u30e2\u30c7\u30eb class cpp_robotics::HighPassFilter \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Integrator \u7a4d\u5206\u5668 class cpp_robotics::KalmanFilter \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf class cpp_robotics::KDTree k-d\u6728 class cpp_robotics::KMeansMethod K-means\u6cd5 struct cpp_robotics::Line \u76f4\u7dda\u30af\u30e9\u30b9 class cpp_robotics::LowPassFilter \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf\u30fc class cpp_robotics::MecanumIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::NctfController NCTF\u5236\u5fa1\u5668 class cpp_robotics::NDT2d 2\u6b21\u5143\u306eNDT\u30de\u30c3\u30c1\u30f3\u30b0\u30af\u30e9\u30b9 class cpp_robotics::NotchFilter \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf class cpp_robotics::Omni3Ik 3\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::Omni4Ik 4\u8f2a\u30aa\u30e0\u30cb\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::PID2Controller 2\u81ea\u7531\u5ea6PID\u5236\u5fa1\u5668 class cpp_robotics::PIDController PID\u5236\u5fa1\u5668 struct cpp_robotics::Polynomial \u591a\u9805\u5f0f struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::PurePursuit Pure pursuit\u5236\u5fa1\u5668 struct cpp_robotics::Quad \u56db\u89d2\u5f62\u30af\u30e9\u30b9 class cpp_robotics::QuadProg \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u3068\u7dda\u5f62\u4e0d\u7b49\u5f0f\u5236\u7d04\u3092\u6301\u30642\u6b21\u8a08\u753b\u6cd5 class cpp_robotics::Quaternion \u30af\u30a9\u30fc\u30bf\u30cb\u30aa\u30f3\u30af\u30e9\u30b9 class cpp_robotics::RandomGenerator std\u306e\u4e71\u6570\u751f\u6210\u3092\u30e9\u30c3\u30d7\u3057\u3066\u3053\u306e\u30af\u30e9\u30b9\u4e00\u3064\u3060\u3051\u5b9f\u4f53\u5316\u3059\u308c\u3070\u3044\u3044\u3088\u3046\u306b\u3057\u305f\u4e71\u6570\u751f\u6210\u5668 struct cpp_robotics::Rect \u9577\u65b9\u5f62\u30af\u30e9\u30b9(\u56de\u8ee2\u306f\u8003\u3048\u306a\u3044) class cpp_robotics::Singleton \u30b7\u30f3\u30b0\u30eb\u30c8\u30f3\u306a\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u751f\u6210\u3059\u308b class cpp_robotics::SisoFeedbackSystem \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3068\u30b7\u30b9\u30c6\u30e0\u304b\u3089\u306a\u308bSISO\u306e\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b7\u30b9\u30c6\u30e0 class cpp_robotics::Spline2D 2\u6b21\u5143\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30a4\u30b9\u30af\u30e9\u30b9 class cpp_robotics::SQP SQP (\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) class cpp_robotics::StateSpaceSystem \u72b6\u614b\u7a7a\u9593\u30e2\u30c7\u30eb class cpp_robotics::SwerveIk \u30e1\u30ab\u30ca\u30e0\u306e\u9006\u904b\u52d5\u5b66\u30e2\u30c7\u30eb class cpp_robotics::TransferFunction \u4f1d\u9054\u95a2\u6570\u30e2\u30c7\u30eb struct cpp_robotics::Transform 2\u6b21\u5143\u306e\u30ed\u30dc\u30c3\u30c8\u306e\u5ea7\u6a19\u3092\u6271\u3046\u30af\u30e9\u30b9 struct cpp_robotics::Triangle \u4e09\u89d2\u5f62\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct cpp_robotics::unit::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 struct cpp_robotics::Vector2 2\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector3 3\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb struct cpp_robotics::Vector4 4\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb class cpp_robotics::VelocityLimitFilter \u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf","title":"Classes"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#types","text":"Name enum class CanonicalizeMode enum UnitIndex using RandomGenerator < std::uniform_int_distribution<> > UniformIntRandomEngine \u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::uniform_real_distribution<> > UniformRealRandomEngine \u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::bernoulli_distribution > BernoulliRandomEngine \u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::binomial_distribution<> > BinomialRandomEngine \u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::geometric_distribution<> > GeometricRandomEngine \u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::negative_binomial_distribution<> > NegativeBinomialRandomEngine \u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::poisson_distribution<> > PoissonRandomEngine \u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::exponential_distribution<> > ExponentialRandomEngine \u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::gamma_distribution<> > GammaRandomEngine \u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::weibull_distribution<> > WeibullRandomEngine \u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::extreme_value_distribution<> > ExtremeValueRandomEngine \u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::normal_distribution<> > NormalRandomEngine \u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::lognormal_distribution<> > LognormalRandomEngine \u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::chi_squared_distribution<> > ChiSquaredRandomEngine \u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::cauchy_distribution<> > CauchyRandomEngine \u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::fisher_f_distribution<> > FisherFRandomEngine \u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::student_t_distribution<> > StudentTRandomEngine \u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::discrete_distribution<> > DiscreteRandomEngine \u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::piecewise_constant_distribution<> > PiecewiseConstantRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using RandomGenerator < std::piecewise_linear_distribution<> > PiecewiseLinearRandomEngine \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3 using unit_assem::unit_div< Torque , Ampere >::unit TorqueConstant using unit_assem::unit_div< Volt , AngularVelocity >::unit BackEmfConstant using unit_assem::unit_mul< Torque , Second >::unit FrictionConstant using Unit < double, unit_dimention::second, prefix::none > Second using Unit < double, unit_dimention::second, prefix::milli > MilliSecond using Unit < double, unit_dimention::second, prefix::micro > MicroSecond using Unit < double, unit_dimention::metere, prefix::none > Meter using Unit < double, unit_dimention::metere, prefix::milli > MilliMeter using Unit < double, unit_dimention::metere, prefix::micro > MicroMeter using Unit < double, unit_dimention::metere, prefix::centi > CentiMeter using Unit < double, unit_dimention::kilogram, prefix::none > KiloGram using Unit < double, unit_dimention::kilogram, prefix::milli > Gram using Unit < double, unit_dimention::watt, prefix::none > Watt using Unit < double, unit_dimention::watt, prefix::kilo > KiloWatt using Unit < double, unit_dimention::newton, prefix::none > Newton using Unit < double, unit_dimention::newton, prefix::kilo > KiloNewton using Unit < double, unit_dimention::pascal, prefix::none > Pascal using Unit < double, unit_dimention::pascal, prefix::kilo > KiloPascal using Unit < double, unit_dimention::hertz, prefix::none > Hertz using Unit < double, unit_dimention::area, prefix::none > Area using Unit < double, unit_dimention::volume, prefix::none > Volume using Unit < double, unit_dimention::velocity, prefix::none > Velocity using Unit < double, unit_dimention::acceleration, prefix::none > Acceleration using Unit < double, unit_dimention::dencity, prefix::none > Dencity using Unit < double, unit_dimention::torque, prefix::none > Torque using Unit < double, unit_dimention::inertia, prefix::none > Inertia using Unit < double, unit_dimention::ampere, prefix::none > Ampere using Unit < double, unit_dimention::ampere, prefix::milli > MilliAmpere using Unit < double, unit_dimention::volt, prefix::none > Volt using Unit < double, unit_dimention::volt, prefix::milli > MilliVolt using Unit < double, unit_dimention::ohm, prefix::none > Ohm using Unit < double, unit_dimention::ohm, prefix::milli > MilliOhm using Unit < double, unit_dimention::henry, prefix::none > Henry using Unit < double, unit_dimention::henry, prefix::milli > MilliHenry using Unit < double, unit_dimention::farad, prefix::none > Farad using Unit < double, unit_dimention::farad, prefix::milli > MilliFarad using Unit < double, unit_dimention::farad, prefix::micro > MicroFarad using Unit < double, unit_dimention::farad, prefix::nano > NanoFarad using Unit < double, unit_dimention::angle, prefix::none, tag::angle::radian > Radian using Unit < double, unit_dimention::angle, prefix::none, tag::angle::degree > Degree using Unit < double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rad_per_sec > AngularVelocity using Unit < double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rps > Rps using Unit < double, unit_dimention::angular_velocity, prefix::none, tag::angular_vel::rpm > Rpm using Unit < double, unit_dimention::angular_acceleration, prefix::none > AngularAcceleration using Quaternion < float > Quaternionf using Quaternion < double > Quaterniond using Transform < float > Transformf using Transform < double > Transformd using Vector2 < float > Vector2f using Vector2 < double > Vector2d using Vector3 < float > Vector3f using Vector3 < double > Vector3d using Vector4 < float > Vector4f using Vector4 < double > Vector4d","title":"Types"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#functions","text":"Name template <size_t DIM> std::pair< Eigen::Matrix< double, DIM, DIM >, Eigen::Matrix< double, DIM, 1 > > calcu_transformatoin (std::vector< Eigen::Matrix< double, DIM, 1 >> dest, std::vector< Eigen::Matrix< double, DIM, 1 >> fixed) template <size_t DIM> std::tuple< std::vector< Eigen::Matrix< double, DIM, 1 > >, size_t > icp (std::vector< Eigen::Matrix< double, DIM, 1 >> dest, std::vector< Eigen::Matrix< double, DIM, 1 >> fixed, size_t max_iter =100) double mahalanobis (const Eigen::VectorXd & a, const Eigen::VectorXd & b, const Eigen::MatrixXd cov_inv) \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 Polynomial poly_regression (const std::vector< double > & x, const std::vector< double > & y, const size_t degree) \u56de\u5e30\u66f2\u7dda template <typename Real =double> Real gererate_random () 0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b std::optional< Eigen::MatrixXd > solve_riccati_arimoto_potter (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & Q, const Eigen::MatrixXd & R) \u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 Eigen::MatrixXd lqr (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & Q, const Eigen::MatrixXd & R) Eigen::MatrixXd controllability_matrix (const Eigen::MatrixXd & A, const Eigen::VectorXd & B) \u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 bool is_controllable (const Eigen::MatrixXd & A, const Eigen::VectorXd & B) \u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 bool is_controllable (const StateSpaceSystem & sys) Eigen::MatrixXd observability_matrix (const Eigen::MatrixXd & A, const Eigen::RowVectorXd & C) \u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b bool is_observable (const Eigen::MatrixXd & A, const Eigen::RowVectorXd & C) \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 bool is_observable (const StateSpaceSystem & sys) std::tuple< Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd > canonicalize_system (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & C, const Eigen::MatrixXd & D, CanonicalizeMode mode = CanonicalizeMode::COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db std::tuple< Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd > canonicalize_system (const Eigen::MatrixXd & A, const Eigen::MatrixXd & B, const Eigen::MatrixXd & C, CanonicalizeMode mode = CanonicalizeMode::COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db std::tuple< Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd > canonicalize_system (const StateSpaceSystem & sys, CanonicalizeMode mode = CanonicalizeMode::COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Eigen::VectorXd place (const StateSpaceSystem & sys, std::vector< double > poles) \u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e bool intersect (const Vector2d & a, const Vector2d & b) bool intersect (const Vector2d & a, const Line & b) bool intersect (const Vector2d & a, const Rect & b) bool intersect (const Vector2d & a, const Circle & b) bool intersect (const Line & a, const Vector2d & b) bool intersect (const Line & a, const Line & b) bool intersect (const Line & a, const Circle & b) bool intersect (const Rect & a, const Vector2d & b) bool intersect (const Circle & a, const Vector2d & b) bool intersect (const Circle & a, const Line & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Line & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Rect & b) std::vector< Vector2d > intersect_at (const Vector2d & a, const Circle & b) std::vector< Vector2d > intersect_at (const Line & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Line & a, const Line & b) std::vector< Vector2d > intersect_at (const Line & a, const Circle & b) std::vector< Vector2d > intersect_at (const Rect & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Circle & a, const Vector2d & b) std::vector< Vector2d > intersect_at (const Circle & a, const Line & b) bool contain (const Vector2d & range, const Vector2d & target) bool contain (const Rect & range, const Vector2d & target) std::ostream & operator<< (std::ostream & os, const Vector2d & v) std::ostream & operator<< (std::ostream & os, const Vector3d & v) std::ostream & operator<< (std::ostream & os, const Vector4d & v) std::ostream & operator<< (std::ostream & os, const Transformd & v) constexpr DCMotorParam generate_mabuchi_motor_param ( Volt nominal_voltage, Rpm free_speed, Ampere free_current, Torque stall_torque, Ampere stall_current, Henry inductance, Inertia rotor_inertia) constexpr DCMotorParam generate_maxon_brush_motor_param ( Volt nominal_voltage, Rpm free_speed, Ampere free_current, Ohm resistance, Henry inductance, TorqueConstant Kt, Inertia rotor_inertia) TransferFunction make_motor_vel_tf (const DCMotorParam & motor, const double dt) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_motor_pos_tf (const DCMotorParam & motor, const double dt) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_vel_tf (const DCGearedMotorParam & geared_motor, const double dt) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b TransferFunction make_geared_motor_pos_tf (const DCGearedMotorParam & geared_motor, const double dt) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b std::tuple< bool, Eigen::VectorXd, size_t > barrier_method (std::function< double(const Eigen::VectorXd &)> f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =10.0, const double tol =1e-3, const size_t max_iter =1000) \u30d0\u30ea\u30a2\u6cd5 void bfgs_step (Eigen::MatrixXd & hess, Eigen::VectorXd s, Eigen::VectorXd y) BFGS\u6cd5 void powells_modified_bfgs_step (Eigen::MatrixXd & hess, Eigen::VectorXd s, Eigen::VectorXd y, double gamma =0.2) \u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 double bracketing_serach (std::function< double(Eigen::VectorXd)> func, std::function< Eigen::VectorXd(Eigen::VectorXd)> grad, const Eigen::VectorXd & x, const Eigen::VectorXd & d, double gamma =0.3, double tau =0.9, const size_t max_iter =1000) \u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 double bracketing_serach (std::function< double(double)> func, const double init =1.0, const double beta =0.9, const size_t max_iter =1000) \u56f2\u3044\u8fbc\u307f\u6cd5 double derivative (std::function< double(double)> f, double x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R -> R\u306e\u6570\u5024\u5fae\u5206 Eigen::VectorXd derivative (std::function< double(Eigen::VectorXd)> f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R^n -> R\u306e\u6570\u5024\u5fae\u5206 Eigen::MatrixXd derivative (std::function< Eigen::VectorXd(Eigen::VectorXd)> f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R^n -> R^m\u306e\u6570\u5024\u5fae\u5206 double second_derivative (std::function< double(double)> f, double x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) R -> R\u306e2\u56de\u6570\u5024\u5fae\u5206 Eigen::MatrixXd approx_hessian (std::function< double(Eigen::VectorXd)> f, Eigen::VectorXd x, double eps =std::pow(std::numeric_limits< double >::epsilon(), 0.5)) double golden_search (std::function< double(double)> f, double low, double high, const double tol =1e-6, const size_t max_iter =100) \u9ec4\u91d1\u63a2\u7d22 std::tuple< bool, Eigen::VectorXd, size_t > newton_method (std::function< Eigen::VectorXd(const Eigen::VectorXd &)> grad, std::function< Eigen::MatrixXd(const Eigen::VectorXd &)> hesse, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000) \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple< bool, Eigen::VectorXd, size_t > penalty_method (std::function< double(const Eigen::VectorXd &)> f, ConstraintArray constraint, Eigen::VectorXd x_init, const double r_init =1.0, const double tol =1e-3, const size_t max_iter =1000) \u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 std::tuple< bool, Eigen::VectorXd, size_t > quasi_newton_method (std::function< double(const Eigen::VectorXd &)> f, std::function< Eigen::VectorXd(const Eigen::VectorXd &)> grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000) \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 std::tuple< bool, Eigen::VectorXd, size_t > steepest_descent_method (std::function< double(const Eigen::VectorXd &)> f, std::function< Eigen::VectorXd(const Eigen::VectorXd &)> grad, Eigen::VectorXd x_init, const double tol =1e-6, const size_t max_iter =1000) \u6700\u6025\u964d\u4e0b\u6cd5 std::vector< Eigen::Vector2i > a_star (const Eigen::Vector2i & start, const Eigen::Vector2i & end, const Eigen::MatrixXi & map) A*\u6cd5 std::vector< Eigen::Vector2i > wave_propagation (const Eigen::Vector2i & start, const Eigen::Vector2i & end, const Eigen::MatrixXi & map) Wave propagation\u6cd5 std::tuple< std::vector< double >, std::vector< double > > bode ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500), bool gain_db_mode =true, bool phase_deg_mode =true) \u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b void bode_plot ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500)) \u30dc\u30fc\u30c9\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) std::tuple< std::vector< double >, std::vector< double > > nyquist ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500)) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b void nyquist_plot ( TransferFunction & tf, const std::vector< double > & omegas = logspace (-2, 2, 500)) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) std::ostream & operator<< (std::ostream & os, const Polynomial & v) template <class CONTROLLER_T ,class SYSTEM_T > SisoFeedbackSystem make_feedback_system (CONTROLLER_T & controller, SYSTEM_T & system) void set_controller ( SisoFeedbackSystem::func_list_t & fn, PIDController & controller) void set_controller ( SisoFeedbackSystem::func_list_t & fn, NctfController & controller) void set_system ( SisoFeedbackSystem::func_list_t & fn, TransferFunction & system) std::tuple< std::vector< double >, std::vector< double > > impluse ( TransferFunction & sys, double time) \u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > step (const std::function< double(double)> & sys, double dt, double time, const double gain =1.0) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > step ( TransferFunction & sys, double time, const double gain =1.0) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > step ( DiscreteTransferFunction & sys, double time, const double gain =1.0) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b std::tuple< std::vector< double >, std::vector< double > > lsim ( TransferFunction & sys, std::vector< double > input) \u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b template <class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag ::value && tag::is_normal_tag ::value> constexpr double conv_factor () template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator* (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator/ (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator+ (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator- (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl) template <class ForwardIterator > constexpr ForwardIterator shift_left (ForwardIterator first, ForwardIterator last, typename std::iterator_traits< ForwardIterator >::difference_type n) C++17\u306estd::shift_left\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b template <class ForwardIterator > constexpr ForwardIterator shift_right (ForwardIterator first, ForwardIterator last, typename std::iterator_traits< ForwardIterator >::difference_type n) C++17\u306estd::shift_right\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b template <typename... Args> std::string c_format (const std::string & format, Args const &... args) printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b template <typename T > constexpr bool in_range_open (T x, T min, T max) template <typename T > constexpr bool in_range (T x, T min, T max) template <typename T > constexpr int sgn (T x) template <typename T > constexpr float radians (T deg) template <typename T > constexpr float degrees (T rad) float normalize_angle_positive (float angle) float normalize_angle (float angle) float shortest_angular_distance (float from, float to) float nearest_angle (float from, float to) constexpr float square (const float x) constexpr float cubic (const float x) constexpr float lerp (const float a, const float b, const float t) constexpr float approx_eq (const float a, const float b) constexpr float approx_zero (const float a) std::vector< double > arrange (double start, double end, double step =1.0) std::vector< double > linspace (double start, double end, size_t n =100) std::vector< double > logspace (double start, double end, size_t n =100) std::vector< double > funcspace (std::function< double(size_t, size_t)> f, size_t n =100) std::vector< double > sinspace (double a, double b, size_t n =100)","title":"Functions"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#attributes","text":"Name constexpr DCMotorParam RZ_735VA_9517 constexpr DCMotorParam RS_775_8513 constexpr DCMotorParam RS_555VC_5524 constexpr DCMotorParam RS_380PH_4045 constexpr DCMotorParam RS_385PH_2465 constexpr DCMotorParam RE_65_250_18 constexpr GearHeadParam IG42C_4 constexpr GearHeadParam IG42C_14 constexpr GearHeadParam IG42C_17 constexpr GearHeadParam IG32_27 constexpr GearHeadParam IG32_71 constexpr GearHeadParam IG32_100 constexpr float PI \u5186\u5468\u7387 constexpr float HALF_PI \u5186\u5468\u7387 / 2 constexpr float TWO_PI \u5186\u5468\u7387 * 2 constexpr float DEG_TO_RAD degree -> radians constexpr float RAD_TO_DEG radian -> degree constexpr float EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr float GRAVITY \u91cd\u529b constexpr float Nm2gfm constexpr float gfm2Nm constexpr float mNm2gfcm constexpr float gfcm2mNm","title":"Attributes"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#types-documentation","text":"","title":"Types Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-canonicalizemode","text":"Enumerator Value Description COMPANION OBSERBAVLE CONTROLLABLE","title":"enum CanonicalizeMode"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#enum-unitindex","text":"Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx","title":"enum UnitIndex"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-uniformintrandomengine","text":"using cpp_robotics :: UniformIntRandomEngine = typedef RandomGenerator < std :: uniform_int_distribution <> > ; \u6574\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using UniformIntRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-uniformrealrandomengine","text":"using cpp_robotics :: UniformRealRandomEngine = typedef RandomGenerator < std :: uniform_real_distribution <> > ; \u5b9f\u6570\u578b\u4e00\u69d8\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using UniformRealRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-bernoullirandomengine","text":"using cpp_robotics :: BernoulliRandomEngine = typedef RandomGenerator < std :: bernoulli_distribution > ; \u30d9\u30eb\u30cc\u30fc\u30a4\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using BernoulliRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-binomialrandomengine","text":"using cpp_robotics :: BinomialRandomEngine = typedef RandomGenerator < std :: binomial_distribution <> > ; \u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using BinomialRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-geometricrandomengine","text":"using cpp_robotics :: GeometricRandomEngine = typedef RandomGenerator < std :: geometric_distribution <> > ; \u5e7e\u4f55\u5b66\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using GeometricRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-negativebinomialrandomengine","text":"using cpp_robotics :: NegativeBinomialRandomEngine = typedef RandomGenerator < std :: negative_binomial_distribution <> > ; \u8ca0\u306e\u4e8c\u9805\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using NegativeBinomialRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-poissonrandomengine","text":"using cpp_robotics :: PoissonRandomEngine = typedef RandomGenerator < std :: poisson_distribution <> > ; \u30dd\u30ef\u30bd\u30f3\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using PoissonRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-exponentialrandomengine","text":"using cpp_robotics :: ExponentialRandomEngine = typedef RandomGenerator < std :: exponential_distribution <> > ; \u6307\u6570\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using ExponentialRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-gammarandomengine","text":"using cpp_robotics :: GammaRandomEngine = typedef RandomGenerator < std :: gamma_distribution <> > ; \u30ac\u30f3\u30de\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using GammaRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-weibullrandomengine","text":"using cpp_robotics :: WeibullRandomEngine = typedef RandomGenerator < std :: weibull_distribution <> > ; \u30ef\u30a4\u30d6\u30eb\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using WeibullRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-extremevaluerandomengine","text":"using cpp_robotics :: ExtremeValueRandomEngine = typedef RandomGenerator < std :: extreme_value_distribution <> > ; \u6975\u5024\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using ExtremeValueRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-normalrandomengine","text":"using cpp_robotics :: NormalRandomEngine = typedef RandomGenerator < std :: normal_distribution <> > ; \u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using NormalRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-lognormalrandomengine","text":"using cpp_robotics :: LognormalRandomEngine = typedef RandomGenerator < std :: lognormal_distribution <> > ; \u5bfe\u6570\u6b63\u898f\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using LognormalRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-chisquaredrandomengine","text":"using cpp_robotics :: ChiSquaredRandomEngine = typedef RandomGenerator < std :: chi_squared_distribution <> > ; \u30ab\u30a4\u4e8c\u4e57\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using ChiSquaredRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-cauchyrandomengine","text":"using cpp_robotics :: CauchyRandomEngine = typedef RandomGenerator < std :: cauchy_distribution <> > ; \u30b3\u30fc\u30b7\u30fc\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using CauchyRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-fisherfrandomengine","text":"using cpp_robotics :: FisherFRandomEngine = typedef RandomGenerator < std :: fisher_f_distribution <> > ; \u30d5\u30a3\u30c3\u30b7\u30e3\u30fc\u306eF\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using FisherFRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-studenttrandomengine","text":"using cpp_robotics :: StudentTRandomEngine = typedef RandomGenerator < std :: student_t_distribution <> > ; \u30b9\u30c6\u30e5\u30fc\u30c7\u30f3\u30c8\u306et\u5206\u5e03\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using StudentTRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-discreterandomengine","text":"using cpp_robotics :: DiscreteRandomEngine = typedef RandomGenerator < std :: discrete_distribution <> > ; \u6574\u6570\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3054\u3068\u306b\u96e2\u6563\u3057\u305f\u78ba\u7387\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using DiscreteRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-piecewiseconstantrandomengine","text":"using cpp_robotics :: PiecewiseConstantRandomEngine = typedef RandomGenerator < std :: piecewise_constant_distribution <> > ; \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u5b9a\u6570\u5024\u3068\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using PiecewiseConstantRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-piecewiselinearrandomengine","text":"using cpp_robotics :: PiecewiseLinearRandomEngine = typedef RandomGenerator < std :: piecewise_linear_distribution <> > ; \u533a\u9593\u3054\u3068\u306e\u91cd\u307f\u4ed8\u3051\u3092\u7dda\u5f62\u306b\u63a5\u7d9a\u3057\u305f\u5206\u5e03\u306e\u4e71\u6570\u751f\u6210\u30a8\u30f3\u30b8\u30f3","title":"using PiecewiseLinearRandomEngine"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-torqueconstant","text":"using cpp_robotics :: unit :: TorqueConstant = typedef unit_assem :: unit_div < Torque , Ampere >:: unit ;","title":"using TorqueConstant"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-backemfconstant","text":"using cpp_robotics :: unit :: BackEmfConstant = typedef unit_assem :: unit_div < Volt , AngularVelocity >:: unit ;","title":"using BackEmfConstant"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-frictionconstant","text":"using cpp_robotics :: unit :: FrictionConstant = typedef unit_assem :: unit_mul < Torque , Second >:: unit ;","title":"using FrictionConstant"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-second","text":"using cpp_robotics :: unit :: Second = typedef Unit < double , unit_dimention :: second , prefix :: none > ;","title":"using Second"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millisecond","text":"using cpp_robotics :: unit :: MilliSecond = typedef Unit < double , unit_dimention :: second , prefix :: milli > ;","title":"using MilliSecond"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-microsecond","text":"using cpp_robotics :: unit :: MicroSecond = typedef Unit < double , unit_dimention :: second , prefix :: micro > ;","title":"using MicroSecond"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-meter","text":"using cpp_robotics :: unit :: Meter = typedef Unit < double , unit_dimention :: metere , prefix :: none > ;","title":"using Meter"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millimeter","text":"using cpp_robotics :: unit :: MilliMeter = typedef Unit < double , unit_dimention :: metere , prefix :: milli > ;","title":"using MilliMeter"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-micrometer","text":"using cpp_robotics :: unit :: MicroMeter = typedef Unit < double , unit_dimention :: metere , prefix :: micro > ;","title":"using MicroMeter"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-centimeter","text":"using cpp_robotics :: unit :: CentiMeter = typedef Unit < double , unit_dimention :: metere , prefix :: centi > ;","title":"using CentiMeter"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilogram","text":"using cpp_robotics :: unit :: KiloGram = typedef Unit < double , unit_dimention :: kilogram , prefix :: none > ;","title":"using KiloGram"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-gram","text":"using cpp_robotics :: unit :: Gram = typedef Unit < double , unit_dimention :: kilogram , prefix :: milli > ;","title":"using Gram"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-watt","text":"using cpp_robotics :: unit :: Watt = typedef Unit < double , unit_dimention :: watt , prefix :: none > ;","title":"using Watt"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilowatt","text":"using cpp_robotics :: unit :: KiloWatt = typedef Unit < double , unit_dimention :: watt , prefix :: kilo > ;","title":"using KiloWatt"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-newton","text":"using cpp_robotics :: unit :: Newton = typedef Unit < double , unit_dimention :: newton , prefix :: none > ;","title":"using Newton"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilonewton","text":"using cpp_robotics :: unit :: KiloNewton = typedef Unit < double , unit_dimention :: newton , prefix :: kilo > ;","title":"using KiloNewton"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-pascal","text":"using cpp_robotics :: unit :: Pascal = typedef Unit < double , unit_dimention :: pascal , prefix :: none > ;","title":"using Pascal"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-kilopascal","text":"using cpp_robotics :: unit :: KiloPascal = typedef Unit < double , unit_dimention :: pascal , prefix :: kilo > ;","title":"using KiloPascal"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-hertz","text":"using cpp_robotics :: unit :: Hertz = typedef Unit < double , unit_dimention :: hertz , prefix :: none > ;","title":"using Hertz"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-area","text":"using cpp_robotics :: unit :: Area = typedef Unit < double , unit_dimention :: area , prefix :: none > ;","title":"using Area"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-volume","text":"using cpp_robotics :: unit :: Volume = typedef Unit < double , unit_dimention :: volume , prefix :: none > ;","title":"using Volume"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-velocity","text":"using cpp_robotics :: unit :: Velocity = typedef Unit < double , unit_dimention :: velocity , prefix :: none > ;","title":"using Velocity"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-acceleration","text":"using cpp_robotics :: unit :: Acceleration = typedef Unit < double , unit_dimention :: acceleration , prefix :: none > ;","title":"using Acceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-dencity","text":"using cpp_robotics :: unit :: Dencity = typedef Unit < double , unit_dimention :: dencity , prefix :: none > ;","title":"using Dencity"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-torque","text":"using cpp_robotics :: unit :: Torque = typedef Unit < double , unit_dimention :: torque , prefix :: none > ;","title":"using Torque"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-inertia","text":"using cpp_robotics :: unit :: Inertia = typedef Unit < double , unit_dimention :: inertia , prefix :: none > ;","title":"using Inertia"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-ampere","text":"using cpp_robotics :: unit :: Ampere = typedef Unit < double , unit_dimention :: ampere , prefix :: none > ;","title":"using Ampere"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-milliampere","text":"using cpp_robotics :: unit :: MilliAmpere = typedef Unit < double , unit_dimention :: ampere , prefix :: milli > ;","title":"using MilliAmpere"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-volt","text":"using cpp_robotics :: unit :: Volt = typedef Unit < double , unit_dimention :: volt , prefix :: none > ;","title":"using Volt"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millivolt","text":"using cpp_robotics :: unit :: MilliVolt = typedef Unit < double , unit_dimention :: volt , prefix :: milli > ;","title":"using MilliVolt"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-ohm","text":"using cpp_robotics :: unit :: Ohm = typedef Unit < double , unit_dimention :: ohm , prefix :: none > ;","title":"using Ohm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-milliohm","text":"using cpp_robotics :: unit :: MilliOhm = typedef Unit < double , unit_dimention :: ohm , prefix :: milli > ;","title":"using MilliOhm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-henry","text":"using cpp_robotics :: unit :: Henry = typedef Unit < double , unit_dimention :: henry , prefix :: none > ;","title":"using Henry"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millihenry","text":"using cpp_robotics :: unit :: MilliHenry = typedef Unit < double , unit_dimention :: henry , prefix :: milli > ;","title":"using MilliHenry"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-farad","text":"using cpp_robotics :: unit :: Farad = typedef Unit < double , unit_dimention :: farad , prefix :: none > ;","title":"using Farad"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-millifarad","text":"using cpp_robotics :: unit :: MilliFarad = typedef Unit < double , unit_dimention :: farad , prefix :: milli > ;","title":"using MilliFarad"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-microfarad","text":"using cpp_robotics :: unit :: MicroFarad = typedef Unit < double , unit_dimention :: farad , prefix :: micro > ;","title":"using MicroFarad"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-nanofarad","text":"using cpp_robotics :: unit :: NanoFarad = typedef Unit < double , unit_dimention :: farad , prefix :: nano > ;","title":"using NanoFarad"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-radian","text":"using cpp_robotics :: unit :: Radian = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: radian > ;","title":"using Radian"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-degree","text":"using cpp_robotics :: unit :: Degree = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: degree > ;","title":"using Degree"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-angularvelocity","text":"using cpp_robotics :: unit :: AngularVelocity = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rad_per_sec > ;","title":"using AngularVelocity"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-rps","text":"using cpp_robotics :: unit :: Rps = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rps > ;","title":"using Rps"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-rpm","text":"using cpp_robotics :: unit :: Rpm = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rpm > ;","title":"using Rpm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-angularacceleration","text":"using cpp_robotics :: unit :: AngularAcceleration = typedef Unit < double , unit_dimention :: angular_acceleration , prefix :: none > ;","title":"using AngularAcceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-quaternionf","text":"using cpp_robotics :: Quaternionf = typedef Quaternion < float > ;","title":"using Quaternionf"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-quaterniond","text":"using cpp_robotics :: Quaterniond = typedef Quaternion < double > ;","title":"using Quaterniond"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-transformf","text":"using cpp_robotics :: Transformf = typedef Transform < float > ;","title":"using Transformf"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-transformd","text":"using cpp_robotics :: Transformd = typedef Transform < double > ;","title":"using Transformd"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector2f","text":"using cpp_robotics :: Vector2f = typedef Vector2 < float > ;","title":"using Vector2f"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector2d","text":"using cpp_robotics :: Vector2d = typedef Vector2 < double > ;","title":"using Vector2d"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector3f","text":"using cpp_robotics :: Vector3f = typedef Vector3 < float > ;","title":"using Vector3f"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector3d","text":"using cpp_robotics :: Vector3d = typedef Vector3 < double > ;","title":"using Vector3d"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector4f","text":"using cpp_robotics :: Vector4f = typedef Vector4 < float > ;","title":"using Vector4f"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#using-vector4d","text":"using cpp_robotics :: Vector4d = typedef Vector4 < double > ;","title":"using Vector4d"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-calcu_transformatoin","text":"template < size_t DIM > static std :: pair < Eigen :: Matrix < double , DIM , DIM > , Eigen :: Matrix < double , DIM , 1 > > calcu_transformatoin ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed )","title":"function calcu_transformatoin"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-icp","text":"template < size_t DIM > static std :: tuple < std :: vector < Eigen :: Matrix < double , DIM , 1 > > , size_t > icp ( std :: vector < Eigen :: Matrix < double , DIM , 1 >> dest , std :: vector < Eigen :: Matrix < double , DIM , 1 >> fixed , size_t max_iter = 100 )","title":"function icp"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-mahalanobis","text":"double mahalanobis ( const Eigen :: VectorXd & a , const Eigen :: VectorXd & b , const Eigen :: MatrixXd cov_inv ) \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2\u306e\u8a08\u7b97 Parameters : a b cov_inv \u5206\u6563\u306e\u9006\u884c\u5217 Return : double \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2","title":"function mahalanobis"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-poly_regression","text":"Polynomial poly_regression ( const std :: vector < double > & x , const std :: vector < double > & y , const size_t degree ) \u56de\u5e30\u66f2\u7dda Parameters : x y degree \u56de\u5e30\u66f2\u7dda\u306e\u6b21\u5143 Return : Polynomial","title":"function poly_regression"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-gererate_random","text":"template < typename Real = double > static Real gererate_random () 0.0\u301c1.0\u307e\u3067\u306e\u4e00\u69d8\u5206\u5e03\u306e\u4e71\u6570\u3092\u751f\u6210\u3059\u308b Template Parameters : Real \u6d6e\u52d5\u5c0f\u6570\u70b9\u578b Return : Real \u4e71\u6570","title":"function gererate_random"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-solve_riccati_arimoto_potter","text":"static std :: optional < Eigen :: MatrixXd > solve_riccati_arimoto_potter ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R ) \u6709\u672c-\u30dd\u30c3\u30bf\u30fc\u306e\u65b9\u6cd5\u306b\u3088\u308b\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u6cd5 Parameters : A B Q R Return : std::optional","title":"function solve_riccati_arimoto_potter"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lqr","text":"static Eigen :: MatrixXd lqr ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & Q , const Eigen :: MatrixXd & R )","title":"function lqr"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-controllability_matrix","text":"static Eigen :: MatrixXd controllability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) \u53ef\u5236\u5fa1\u6027\u884c\u5217\u306e\u8a08\u7b97 Parameters : A B Return : Eigen::MatrixXd","title":"function controllability_matrix"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_controllable","text":"static bool is_controllable ( const Eigen :: MatrixXd & A , const Eigen :: VectorXd & B ) \u53ef\u5236\u5fa1\u6027\u306e\u5224\u5225 Parameters : A B Return : true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u3042\u308b false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u5236\u5fa1\u3067\u306a\u3044","title":"function is_controllable"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_controllable_1","text":"static bool is_controllable ( const StateSpaceSystem & sys )","title":"function is_controllable"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-observability_matrix","text":"static Eigen :: MatrixXd observability_matrix ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) \u53ef\u89b3\u6e2c\u6027\u884c\u5217\u3092\u8a08\u7b97\u3059\u308b Parameters : A C Return : Eigen::MatrixXd","title":"function observability_matrix"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_observable","text":"static bool is_observable ( const Eigen :: MatrixXd & A , const Eigen :: RowVectorXd & C ) \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 Parameters : A C Return : true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044","title":"function is_observable"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-is_observable_1","text":"static bool is_observable ( const StateSpaceSystem & sys ) Parameters : sys \u53ef\u89b3\u6e2c\u6027\u306e\u5224\u5225 Return : true \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u3042\u308b false \u30b7\u30b9\u30c6\u30e0\u304c\u53ef\u89b3\u6e2c\u3067\u306a\u3044","title":"function is_observable"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-canonicalize_system","text":"static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , const Eigen :: MatrixXd & D , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Parameters : A B C D mode Return : std::tuple","title":"function canonicalize_system"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-canonicalize_system_1","text":"static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const Eigen :: MatrixXd & A , const Eigen :: MatrixXd & B , const Eigen :: MatrixXd & C , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Parameters : A B C mode Return : std::tuple","title":"function canonicalize_system"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-canonicalize_system_2","text":"static std :: tuple < Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd , Eigen :: MatrixXd > canonicalize_system ( const StateSpaceSystem & sys , CanonicalizeMode mode = CanonicalizeMode :: COMPANION ) \u540c\u5024\u5909\u63db\u306b\u3088\u308b\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u3078\u306e\u5909\u63db Parameters : sys mode Return : std::tuple","title":"function canonicalize_system"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-place","text":"static Eigen :: VectorXd place ( const StateSpaceSystem & sys , std :: vector < double > poles ) \u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308bSISO\u30e2\u30c7\u30eb\u306e\u6975\u914d\u7f6e Parameters : sys poles Return : Eigen::VectorXd","title":"function place"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect","text":"bool intersect ( const Vector2d & a , const Vector2d & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_1","text":"bool intersect ( const Vector2d & a , const Line & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_2","text":"bool intersect ( const Vector2d & a , const Rect & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_3","text":"bool intersect ( const Vector2d & a , const Circle & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_4","text":"bool intersect ( const Line & a , const Vector2d & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_5","text":"bool intersect ( const Line & a , const Line & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_6","text":"bool intersect ( const Line & a , const Circle & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_7","text":"bool intersect ( const Rect & a , const Vector2d & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_8","text":"bool intersect ( const Circle & a , const Vector2d & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_9","text":"bool intersect ( const Circle & a , const Line & b )","title":"function intersect"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at","text":"std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Vector2d & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_1","text":"std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Line & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_2","text":"std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Rect & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_3","text":"std :: vector < Vector2d > intersect_at ( const Vector2d & a , const Circle & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_4","text":"std :: vector < Vector2d > intersect_at ( const Line & a , const Vector2d & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_5","text":"std :: vector < Vector2d > intersect_at ( const Line & a , const Line & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_6","text":"std :: vector < Vector2d > intersect_at ( const Line & a , const Circle & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_7","text":"std :: vector < Vector2d > intersect_at ( const Rect & a , const Vector2d & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_8","text":"std :: vector < Vector2d > intersect_at ( const Circle & a , const Vector2d & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-intersect_at_9","text":"std :: vector < Vector2d > intersect_at ( const Circle & a , const Line & b )","title":"function intersect_at"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-contain","text":"bool contain ( const Vector2d & range , const Vector2d & target )","title":"function contain"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-contain_1","text":"bool contain ( const Rect & range , const Vector2d & target )","title":"function contain"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator","text":"std :: ostream & operator << ( std :: ostream & os , const Vector2d & v )","title":"function operator&lt;&lt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_1","text":"std :: ostream & operator << ( std :: ostream & os , const Vector3d & v )","title":"function operator&lt;&lt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_2","text":"std :: ostream & operator << ( std :: ostream & os , const Vector4d & v )","title":"function operator&lt;&lt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_3","text":"std :: ostream & operator << ( std :: ostream & os , const Transformd & v )","title":"function operator&lt;&lt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-generate_mabuchi_motor_param","text":"inline constexpr DCMotorParam generate_mabuchi_motor_param ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Torque stall_torque , Ampere stall_current , Henry inductance , Inertia rotor_inertia )","title":"function generate_mabuchi_motor_param"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-generate_maxon_brush_motor_param","text":"inline constexpr DCMotorParam generate_maxon_brush_motor_param ( Volt nominal_voltage , Rpm free_speed , Ampere free_current , Ohm resistance , Henry inductance , TorqueConstant Kt , Inertia rotor_inertia )","title":"function generate_maxon_brush_motor_param"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_motor_vel_tf","text":"static TransferFunction make_motor_vel_tf ( const DCMotorParam & motor , const double dt ) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : motor dt Return : TransferFunction","title":"function make_motor_vel_tf"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_motor_pos_tf","text":"static TransferFunction make_motor_pos_tf ( const DCMotorParam & motor , const double dt ) DC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : motor dt Return : TransferFunction","title":"function make_motor_pos_tf"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_geared_motor_vel_tf","text":"static TransferFunction make_geared_motor_vel_tf ( const DCGearedMotorParam & geared_motor , const double dt ) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u901f\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : geared_motor dt Return : TransferFunction","title":"function make_geared_motor_vel_tf"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_geared_motor_pos_tf","text":"static TransferFunction make_geared_motor_pos_tf ( const DCGearedMotorParam & geared_motor , const double dt ) \u30ae\u30a2\u30d8\u30c3\u30c9\u4ed8\u304dDC\u30e2\u30fc\u30bf\u30fc\u306e\u30e2\u30c7\u30eb\u304b\u3089\u89d2\u5ea6\u306e\u4f1d\u9054\u95a2\u6570\u3092\u751f\u6210\u3059\u308b Parameters : geared_motor dt Return : TransferFunction","title":"function make_geared_motor_pos_tf"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-barrier_method","text":"static std :: tuple < bool , Eigen :: VectorXd , size_t > barrier_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 10.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) \u30d0\u30ea\u30a2\u6cd5","title":"function barrier_method"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bfgs_step","text":"static void bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y ) BFGS\u6cd5 Parameters : hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 s x_k+1 - x_k y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k)","title":"function bfgs_step"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-powells_modified_bfgs_step","text":"static void powells_modified_bfgs_step ( Eigen :: MatrixXd & hess , Eigen :: VectorXd s , Eigen :: VectorXd y , double gamma = 0.2 ) \u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5 Parameters : hess \u524d\u30b9\u30c6\u30c3\u30d7\u307e\u3067\u306e\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3 s x_k+1 - x_k y \\grad_x L(x_k+1, u_k+1) - \\grad_x L(x_k, u_k) gamma","title":"function powells_modified_bfgs_step"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bracketing_serach","text":"static double bracketing_serach ( std :: function < double ( Eigen :: VectorXd ) > func , std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > grad , const Eigen :: VectorXd & x , const Eigen :: VectorXd & d , double gamma = 0.3 , double tau = 0.9 , const size_t max_iter = 1000 ) \u30a2\u30eb\u30df\u30db\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30b9\u30c6\u30c3\u30d7\u5e45\u3092\u6c42\u3081\u308b\u56f2\u3044\u8fbc\u307f\u6cd5 Parameters : func grad x d gamma tau max_iter Return : double","title":"function bracketing_serach"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bracketing_serach_1","text":"static double bracketing_serach ( std :: function < double ( double ) > func , const double init = 1.0 , const double beta = 0.9 , const size_t max_iter = 1000 ) \u56f2\u3044\u8fbc\u307f\u6cd5 Parameters : func init beta max_iter Return : double","title":"function bracketing_serach"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative","text":"static double derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R -> R\u306e\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : double","title":"function derivative"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative_1","text":"static Eigen :: VectorXd derivative ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R^n -> R\u306e\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : Eigen::VectorXd","title":"function derivative"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-derivative_2","text":"static Eigen :: MatrixXd derivative ( std :: function < Eigen :: VectorXd ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R^n -> R^m\u306e\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : Eigen::MatrixXd","title":"function derivative"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-second_derivative","text":"static double second_derivative ( std :: function < double ( double ) > f , double x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) R -> R\u306e2\u56de\u6570\u5024\u5fae\u5206 Parameters : f x eps Return : double","title":"function second_derivative"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_hessian","text":"static Eigen :: MatrixXd approx_hessian ( std :: function < double ( Eigen :: VectorXd ) > f , Eigen :: VectorXd x , double eps = std :: pow ( std :: numeric_limits < double >:: epsilon (), 0.5 ) ) Parameters : f x eps Return : Eigen::MatrixXd","title":"function approx_hessian"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-golden_search","text":"static double golden_search ( std :: function < double ( double ) > f , double low , double high , const double tol = 1e-6 , const size_t max_iter = 100 ) \u9ec4\u91d1\u63a2\u7d22 Parameters : f low high tol max_iter Return : double","title":"function golden_search"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-newton_method","text":"static std :: tuple < bool , Eigen :: VectorXd , size_t > newton_method ( std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , std :: function < Eigen :: MatrixXd ( const Eigen :: VectorXd & ) > hesse , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Parameters : grad hesse x_init tol max_iter Return : std::tuple","title":"function newton_method"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-penalty_method","text":"static std :: tuple < bool , Eigen :: VectorXd , size_t > penalty_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , ConstraintArray constraint , Eigen :: VectorXd x_init , const double r_init = 1.0 , const double tol = 1e-3 , const size_t max_iter = 1000 ) \u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 Parameters : f constraint x_init r_init tol max_iter Return : std::tuple","title":"function penalty_method"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-quasi_newton_method","text":"static std :: tuple < bool , Eigen :: VectorXd , size_t > quasi_newton_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Parameters : f grad x_init tol max_iter Return : std::tuple","title":"function quasi_newton_method"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-steepest_descent_method","text":"static std :: tuple < bool , Eigen :: VectorXd , size_t > steepest_descent_method ( std :: function < double ( const Eigen :: VectorXd & ) > f , std :: function < Eigen :: VectorXd ( const Eigen :: VectorXd & ) > grad , Eigen :: VectorXd x_init , const double tol = 1e-6 , const size_t max_iter = 1000 ) \u6700\u6025\u964d\u4e0b\u6cd5 Parameters : f grad x_init tol max_iter Return : std::tuple","title":"function steepest_descent_method"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-a_star","text":"static std :: vector < Eigen :: Vector2i > a_star ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) A*\u6cd5 Parameters : start end map Return : std::vector","title":"function a_star"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-wave_propagation","text":"std :: vector < Eigen :: Vector2i > wave_propagation ( const Eigen :: Vector2i & start , const Eigen :: Vector2i & end , const Eigen :: MatrixXi & map ) Wave propagation\u6cd5 Parameters : start end map Return : std::vector","title":"function wave_propagation"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bode","text":"static std :: tuple < std :: vector < double > , std :: vector < double > > bode ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ), bool gain_db_mode = true , bool phase_deg_mode = true ) \u30dc\u30fc\u30c9\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b Parameters : tf omegas gain_db_mode phase_deg_mode Return : std::tuple , std::vector\\ >","title":"function bode"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-bode_plot","text":"static void bode_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ) ) \u30dc\u30fc\u30c9\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) Parameters : tf omegas","title":"function bode_plot"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-nyquist","text":"static std :: tuple < std :: vector < double > , std :: vector < double > > nyquist ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ) ) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u306e\u5fdc\u7b54\u3092\u8a08\u7b97\u3059\u308b Parameters : tf omegas Return : std::tuple , std::vector\\ >","title":"function nyquist"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-nyquist_plot","text":"static void nyquist_plot ( TransferFunction & tf , const std :: vector < double > & omegas = logspace ( -2 , 2 , 500 ) ) \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u8868\u793a\u3059\u308b(matplotlib\u304c\u5fc5\u8981) Parameters : tf omegas","title":"function nyquist_plot"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_4","text":"std :: ostream & operator << ( std :: ostream & os , const Polynomial & v )","title":"function operator&lt;&lt;"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-make_feedback_system","text":"template < class CONTROLLER_T , class SYSTEM_T > static SisoFeedbackSystem make_feedback_system ( CONTROLLER_T & controller , SYSTEM_T & system )","title":"function make_feedback_system"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_controller","text":"static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , PIDController & controller )","title":"function set_controller"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_controller_1","text":"static void set_controller ( SisoFeedbackSystem :: func_list_t & fn , NctfController & controller )","title":"function set_controller"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-set_system","text":"static void set_system ( SisoFeedbackSystem :: func_list_t & fn , TransferFunction & system )","title":"function set_system"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-impluse","text":"static std :: tuple < std :: vector < double > , std :: vector < double > > impluse ( TransferFunction & sys , double time ) \u30a4\u30f3\u30d1\u30eb\u30b9\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys time Return : std::tuple , std::vector\\ >","title":"function impluse"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step","text":"static std :: tuple < std :: vector < double > , std :: vector < double > > step ( const std :: function < double ( double ) > & sys , double dt , double time , const double gain = 1.0 ) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys dt time gain Return : std::tuple , std::vector\\ >","title":"function step"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step_1","text":"static std :: tuple < std :: vector < double > , std :: vector < double > > step ( TransferFunction & sys , double time , const double gain = 1.0 ) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys time gain Return : std::tuple , std::vector\\ >","title":"function step"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-step_2","text":"static std :: tuple < std :: vector < double > , std :: vector < double > > step ( DiscreteTransferFunction & sys , double time , const double gain = 1.0 ) \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys time gain Return : std::tuple , std::vector\\ >","title":"function step"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lsim","text":"static std :: tuple < std :: vector < double > , std :: vector < double > > lsim ( TransferFunction & sys , std :: vector < double > input ) \u4efb\u610f\u306e\u5165\u529b\u306b\u3088\u308b\u5fdc\u7b54\u3092\u6c42\u3081\u308b Parameters : sys input Return : std::tuple , std::vector\\ >","title":"function lsim"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-conv_factor","text":"template < class UnitDimType , int FromTag , int ToTag , bool IsNormalTag = tag :: is_normal_tag < FromTag >:: value && tag :: is_normal_tag < ToTag >:: value > constexpr double conv_factor ()","title":"function conv_factor"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_5","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value )","title":"function operator*"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_6","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value )","title":"function operator*"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_7","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value )","title":"function operator/"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_8","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value )","title":"function operator/"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_9","text":"template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator * ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl )","title":"function operator*"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_10","text":"template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator / ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl )","title":"function operator/"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator_11","text":"template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator + ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl )","title":"function operator+"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-operator-","text":"template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator - ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl )","title":"function operator-"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shift_left","text":"template < class ForwardIterator > constexpr ForwardIterator shift_left ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) C++17\u306estd::shift_left\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b Parameters : first last n Template Parameters : ForwardIterator Return : constexpr ForwardIterator","title":"function shift_left"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shift_right","text":"template < class ForwardIterator > constexpr ForwardIterator shift_right ( ForwardIterator first , ForwardIterator last , typename std :: iterator_traits < ForwardIterator >:: difference_type n ) C++17\u306estd::shift_right\u306e\u81ea\u524d\u5b9f\u88c5 C++14\u3067\u52d5\u4f5c\u3059\u308b Parameters : first last n Template Parameters : ForwardIterator Return : constexpr ForwardIterator","title":"function shift_right"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-c_format","text":"template < typename ... Args > std :: string c_format ( const std :: string & format , Args const & ... args ) printf\u3068\u540c\u69d8\u306e\u64cd\u4f5c\u3067std::string\u3092\u5f97\u308b Parameters : format args Template Parameters : Args Return : std::string","title":"function c_format"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-in_range_open","text":"template < typename T > static constexpr bool in_range_open ( T x , T min , T max ) Parameters : x min max Template Parameters : T Return : true false","title":"function in_range_open"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-in_range","text":"template < typename T > static constexpr bool in_range ( T x , T min , T max ) Parameters : x min max Template Parameters : T Return : true false","title":"function in_range"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sgn","text":"template < typename T > static constexpr int sgn ( T x ) Parameters : x Template Parameters : T Return : constexpr int","title":"function sgn"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-radians","text":"template < typename T > static constexpr float radians ( T deg ) Parameters : deg Template Parameters : T Return : constexpr float","title":"function radians"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-degrees","text":"template < typename T > static constexpr float degrees ( T rad ) Parameters : rad Template Parameters : T Return : constexpr float","title":"function degrees"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalize_angle_positive","text":"static inline float normalize_angle_positive ( float angle ) Parameters : angle Return : float","title":"function normalize_angle_positive"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-normalize_angle","text":"static inline float normalize_angle ( float angle ) Parameters : angle Return : float","title":"function normalize_angle"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-shortest_angular_distance","text":"static inline float shortest_angular_distance ( float from , float to ) Parameters : from to Return : float","title":"function shortest_angular_distance"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-nearest_angle","text":"static inline float nearest_angle ( float from , float to )","title":"function nearest_angle"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-square","text":"inline constexpr float square ( const float x )","title":"function square"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-cubic","text":"inline constexpr float cubic ( const float x )","title":"function cubic"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-lerp","text":"inline constexpr float lerp ( const float a , const float b , const float t )","title":"function lerp"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_eq","text":"inline constexpr float approx_eq ( const float a , const float b )","title":"function approx_eq"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-approx_zero","text":"inline constexpr float approx_zero ( const float a )","title":"function approx_zero"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-arrange","text":"static std :: vector < double > arrange ( double start , double end , double step = 1.0 )","title":"function arrange"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-linspace","text":"static std :: vector < double > linspace ( double start , double end , size_t n = 100 )","title":"function linspace"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-logspace","text":"static std :: vector < double > logspace ( double start , double end , size_t n = 100 )","title":"function logspace"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-funcspace","text":"static std :: vector < double > funcspace ( std :: function < double ( size_t , size_t ) > f , size_t n = 100 )","title":"function funcspace"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#function-sinspace","text":"static std :: vector < double > sinspace ( double a , double b , size_t n = 100 )","title":"function sinspace"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rz_735va_9517","text":"constexpr DCMotorParam RZ_735VA_9517 = generate_mabuchi_motor_param ( 18 _V , 20400 _rpm , 2.8 _A , 1265 _mmNm , 156 _A , 7.088e-5 _H , 2.46e-5 );","title":"variable RZ_735VA_9517"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_775_8513","text":"constexpr DCMotorParam RS_775_8513 = generate_mabuchi_motor_param ( 18 _V , 18400 _rpm , 2.7 _A , 1216 _mmNm , 130 _A , 5.872e-5 _H , 2.46e-5 );","title":"variable RS_775_8513"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_555vc_5524","text":"constexpr DCMotorParam RS_555VC_5524 = generate_mabuchi_motor_param ( 12 _V , 9100 _rpm , 0.8 _A , 450 _mmNm , 36 _A , 1.820e-4 _H , 2.46e-5 );","title":"variable RS_555VC_5524"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_380ph_4045","text":"constexpr DCMotorParam RS_380PH_4045 = generate_mabuchi_motor_param ( 6 _V , 12500 _rpm , 0.56 _A , 77.5 _mmNm , 18 _A , 1.521e-4 _H , 2.46e-5 );","title":"variable RS_380PH_4045"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rs_385ph_2465","text":"constexpr DCMotorParam RS_385PH_2465 = generate_mabuchi_motor_param ( 18 _V , 17500 _rpm , 0.23 _A , 76.9 _mmNm , 7.91 _A , 1.521e-4 _H , 2.46e-5 );","title":"variable RS_385PH_2465"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-re_65_250_18","text":"constexpr DCMotorParam RE_65_250_18 = generate_maxon_brush_motor_param ( 18 _V , 3520 _rpm , 755 _mA , 0.0609 _ohm , 0.0226 _mH , 46e-3 _Nm_per_A , 1.38 );","title":"variable RE_65_250_18"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_4","text":"constexpr GearHeadParam IG42C_4 = { 1 / 4.0f , 0.8f };","title":"variable IG42C_4"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_14","text":"constexpr GearHeadParam IG42C_14 = { 1 / 14.0f , 0.7f };","title":"variable IG42C_14"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig42c_17","text":"constexpr GearHeadParam IG42C_17 = { 1 / 17.0f , 0.7f };","title":"variable IG42C_17"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_27","text":"constexpr GearHeadParam IG32_27 = { 1 / 27.0f , 0.7f };","title":"variable IG32_27"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_71","text":"constexpr GearHeadParam IG32_71 = { 1 / 71.0f , 0.6f };","title":"variable IG32_71"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-ig32_100","text":"constexpr GearHeadParam IG32_100 = { 1 / 100.0f , 0.6f };","title":"variable IG32_100"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-pi","text":"constexpr float PI = 3.1415926535897932384626433832795 ; \u5186\u5468\u7387","title":"variable PI"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-half_pi","text":"constexpr float HALF_PI = PI / 2.0 ; \u5186\u5468\u7387 / 2","title":"variable HALF_PI"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-two_pi","text":"constexpr float TWO_PI = PI * 2.0 ; \u5186\u5468\u7387 * 2","title":"variable TWO_PI"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-deg_to_rad","text":"constexpr float DEG_TO_RAD = PI / 180.0 ; degree -> radians","title":"variable DEG_TO_RAD"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-rad_to_deg","text":"constexpr float RAD_TO_DEG = 180.0 / PI ; radian -> degree","title":"variable RAD_TO_DEG"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-euler","text":"constexpr float EULER = 2.718281828459045235360287471352 ; \u30cd\u30a4\u30d4\u30a2\u6570","title":"variable EULER"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gravity","text":"constexpr float GRAVITY = 9.807 ; \u91cd\u529b","title":"variable GRAVITY"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-nm2gfm","text":"constexpr float Nm2gfm = ( 1 / GRAVITY );","title":"variable Nm2gfm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gfm2nm","text":"constexpr float gfm2Nm = GRAVITY ;","title":"variable gfm2Nm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-mnm2gfcm","text":"constexpr float mNm2gfcm = ( Nm2gfm * 100 );","title":"variable mNm2gfcm"},{"location":"doxybook/Namespaces/namespacecpp__robotics/#variable-gfcm2mnm","text":"constexpr float gfcm2mNm = ( gfm2Nm / 100 ); Updated on 2022-09-30 at 00:12:50 +0900","title":"variable gfcm2mNm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/","text":"cpp_robotics::constants \u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570 Attributes Name constexpr float PI \u5186\u5468\u7387 constexpr float HALF_PI \u5186\u5468\u7387 / 2 constexpr float TWO_PI \u5186\u5468\u7387 * 2 constexpr float DEG_TO_RAD degree -> radians constexpr float RAD_TO_DEG radian -> degree constexpr float EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr float GRAVITY \u91cd\u529b constexpr float Nm2gfm constexpr float gfm2Nm constexpr float mNm2gfcm constexpr float gfcm2mNm Attributes Documentation variable PI constexpr float PI = 3.1415926535897932384626433832795 ; \u5186\u5468\u7387 variable HALF_PI constexpr float HALF_PI = PI / 2.0 ; \u5186\u5468\u7387 / 2 variable TWO_PI constexpr float TWO_PI = PI * 2.0 ; \u5186\u5468\u7387 * 2 variable DEG_TO_RAD constexpr float DEG_TO_RAD = PI / 180.0 ; degree -> radians variable RAD_TO_DEG constexpr float RAD_TO_DEG = 180.0 / PI ; radian -> degree variable EULER constexpr float EULER = 2.718281828459045235360287471352 ; \u30cd\u30a4\u30d4\u30a2\u6570 variable GRAVITY constexpr float GRAVITY = 9.807 ; \u91cd\u529b variable Nm2gfm constexpr float Nm2gfm = ( 1 / GRAVITY ); variable gfm2Nm constexpr float gfm2Nm = GRAVITY ; variable mNm2gfcm constexpr float mNm2gfcm = ( Nm2gfm * 100 ); variable gfcm2mNm constexpr float gfcm2mNm = ( gfm2Nm / 100 ); Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::constants"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#cpp_roboticsconstants","text":"\u6570\u5b66\u30fb\u7269\u7406\u5b9a\u6570","title":"cpp_robotics::constants"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#attributes","text":"Name constexpr float PI \u5186\u5468\u7387 constexpr float HALF_PI \u5186\u5468\u7387 / 2 constexpr float TWO_PI \u5186\u5468\u7387 * 2 constexpr float DEG_TO_RAD degree -> radians constexpr float RAD_TO_DEG radian -> degree constexpr float EULER \u30cd\u30a4\u30d4\u30a2\u6570 constexpr float GRAVITY \u91cd\u529b constexpr float Nm2gfm constexpr float gfm2Nm constexpr float mNm2gfcm constexpr float gfcm2mNm","title":"Attributes"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-pi","text":"constexpr float PI = 3.1415926535897932384626433832795 ; \u5186\u5468\u7387","title":"variable PI"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-half_pi","text":"constexpr float HALF_PI = PI / 2.0 ; \u5186\u5468\u7387 / 2","title":"variable HALF_PI"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-two_pi","text":"constexpr float TWO_PI = PI * 2.0 ; \u5186\u5468\u7387 * 2","title":"variable TWO_PI"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-deg_to_rad","text":"constexpr float DEG_TO_RAD = PI / 180.0 ; degree -> radians","title":"variable DEG_TO_RAD"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-rad_to_deg","text":"constexpr float RAD_TO_DEG = 180.0 / PI ; radian -> degree","title":"variable RAD_TO_DEG"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-euler","text":"constexpr float EULER = 2.718281828459045235360287471352 ; \u30cd\u30a4\u30d4\u30a2\u6570","title":"variable EULER"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gravity","text":"constexpr float GRAVITY = 9.807 ; \u91cd\u529b","title":"variable GRAVITY"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-nm2gfm","text":"constexpr float Nm2gfm = ( 1 / GRAVITY );","title":"variable Nm2gfm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gfm2nm","text":"constexpr float gfm2Nm = GRAVITY ;","title":"variable gfm2Nm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-mnm2gfcm","text":"constexpr float mNm2gfcm = ( Nm2gfm * 100 );","title":"variable mNm2gfcm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1constants/#variable-gfcm2mnm","text":"constexpr float gfcm2mNm = ( gfm2Nm / 100 ); Updated on 2022-09-30 at 00:12:50 +0900","title":"variable gfcm2mNm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/","text":"cpp_robotics::grid_path_planning_utils \u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1 Classes Name struct cpp_robotics::grid_path_planning_utils::GridNode Functions Name bool contain_in_map (const Eigen::MatrixXi & map, const Eigen::Vector2i & p) int dist (const Eigen::Vector2i & pos, const Eigen::Vector2i & end) template <typename T > bool in_range_open (T x, T min, T max) bool is_valid (const Eigen::Vector2i & pos, size_t row, size_t col) bool is_wall (const Eigen::Vector2i & pos, size_t row, size_t col) bool is_correct_step (const Eigen::Vector2i & pos, const Eigen::MatrixXi & map) bool exist (std::list< GridNode > & open, std::list< GridNode > & closed, const Eigen::Vector2i & p, int cost) Functions Documentation function contain_in_map static bool contain_in_map ( const Eigen :: MatrixXi & map , const Eigen :: Vector2i & p ) function dist static int dist ( const Eigen :: Vector2i & pos , const Eigen :: Vector2i & end ) function in_range_open template < typename T > bool in_range_open ( T x , T min , T max ) function is_valid bool is_valid ( const Eigen :: Vector2i & pos , size_t row , size_t col ) function is_wall bool is_wall ( const Eigen :: Vector2i & pos , size_t row , size_t col ) function is_correct_step bool is_correct_step ( const Eigen :: Vector2i & pos , const Eigen :: MatrixXi & map ) function exist bool exist ( std :: list < GridNode > & open , std :: list < GridNode > & closed , const Eigen :: Vector2i & p , int cost ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::grid_path_planning_utils"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#cpp_roboticsgrid_path_planning_utils","text":"\u30b0\u30ea\u30c3\u30c9\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u7528\u95a2\u6570\u30fb\u30af\u30e9\u30b9\u90e1","title":"cpp_robotics::grid_path_planning_utils"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#classes","text":"Name struct cpp_robotics::grid_path_planning_utils::GridNode","title":"Classes"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#functions","text":"Name bool contain_in_map (const Eigen::MatrixXi & map, const Eigen::Vector2i & p) int dist (const Eigen::Vector2i & pos, const Eigen::Vector2i & end) template <typename T > bool in_range_open (T x, T min, T max) bool is_valid (const Eigen::Vector2i & pos, size_t row, size_t col) bool is_wall (const Eigen::Vector2i & pos, size_t row, size_t col) bool is_correct_step (const Eigen::Vector2i & pos, const Eigen::MatrixXi & map) bool exist (std::list< GridNode > & open, std::list< GridNode > & closed, const Eigen::Vector2i & p, int cost)","title":"Functions"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-contain_in_map","text":"static bool contain_in_map ( const Eigen :: MatrixXi & map , const Eigen :: Vector2i & p )","title":"function contain_in_map"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-dist","text":"static int dist ( const Eigen :: Vector2i & pos , const Eigen :: Vector2i & end )","title":"function dist"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-in_range_open","text":"template < typename T > bool in_range_open ( T x , T min , T max )","title":"function in_range_open"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_valid","text":"bool is_valid ( const Eigen :: Vector2i & pos , size_t row , size_t col )","title":"function is_valid"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_wall","text":"bool is_wall ( const Eigen :: Vector2i & pos , size_t row , size_t col )","title":"function is_wall"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-is_correct_step","text":"bool is_correct_step ( const Eigen :: Vector2i & pos , const Eigen :: MatrixXi & map )","title":"function is_correct_step"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1grid__path__planning__utils/#function-exist","text":"bool exist ( std :: list < GridNode > & open , std :: list < GridNode > & closed , const Eigen :: Vector2i & p , int cost ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function exist"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/","text":"cpp_robotics::spline \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1 Classes Name struct cpp_robotics::spline::spline_c Functions Name spline_c bezier_spline (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2, const Vector2d & p3) spline_c hermite_spline (const Vector2d & p0, const Vector2d & p1, const Vector2d & v0, const Vector2d & v1) spline_c catumull_spline (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2, const Vector2d & p3) spline_c cubic_function_to_bezier (const Vector2d & a, const Vector2d & b, const Vector2d & c, const Vector2d & d) Vector4d bezier_weight (const double t) Vector4d bezier_weight (const Vector4d t) Vector2d evaluate (const spline_c & spline, const Vector4d & w) Vector2d position (const spline_c & spline, double t) Vector2d velocity (const spline_c & spline, double t) Vector2d acceleration (const spline_c & spline, double t) void split (const Vector4d & spline, Vector4d & spline0, Vector4d & spline1, double t) void split (const Vector4d & spline, Vector4d & spline0, Vector4d & spline1) void split (const spline_c & spline, spline_c & spline0, spline_c & spline1) void split (const spline_c & spline, spline_c & spline0, spline_c & spline1, double t) double length_estimate (const spline_c & s, double * error) double length (const spline_c & s, double maxError) double length (const spline_c & s, double t0, double t1, double maxError) double curvature (const spline_c & spline, double t) Functions Documentation function bezier_spline spline_c bezier_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) function hermite_spline spline_c hermite_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & v0 , const Vector2d & v1 ) function catumull_spline spline_c catumull_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 ) function cubic_function_to_bezier spline_c cubic_function_to_bezier ( const Vector2d & a , const Vector2d & b , const Vector2d & c , const Vector2d & d ) function bezier_weight Vector4d bezier_weight ( const double t ) function bezier_weight Vector4d bezier_weight ( const Vector4d t ) function evaluate inline Vector2d evaluate ( const spline_c & spline , const Vector4d & w ) function position Vector2d position ( const spline_c & spline , double t ) function velocity Vector2d velocity ( const spline_c & spline , double t ) function acceleration Vector2d acceleration ( const spline_c & spline , double t ) function split inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 , double t ) function split inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 ) function split void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 ) function split void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 , double t ) function length_estimate double length_estimate ( const spline_c & s , double * error ) function length double length ( const spline_c & s , double maxError ) function length double length ( const spline_c & s , double t0 , double t1 , double maxError ) function curvature double curvature ( const spline_c & spline , double t ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::spline"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#cpp_roboticsspline","text":"\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u7528\u95a2\u6570\u90e1","title":"cpp_robotics::spline"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#classes","text":"Name struct cpp_robotics::spline::spline_c","title":"Classes"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#functions","text":"Name spline_c bezier_spline (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2, const Vector2d & p3) spline_c hermite_spline (const Vector2d & p0, const Vector2d & p1, const Vector2d & v0, const Vector2d & v1) spline_c catumull_spline (const Vector2d & p0, const Vector2d & p1, const Vector2d & p2, const Vector2d & p3) spline_c cubic_function_to_bezier (const Vector2d & a, const Vector2d & b, const Vector2d & c, const Vector2d & d) Vector4d bezier_weight (const double t) Vector4d bezier_weight (const Vector4d t) Vector2d evaluate (const spline_c & spline, const Vector4d & w) Vector2d position (const spline_c & spline, double t) Vector2d velocity (const spline_c & spline, double t) Vector2d acceleration (const spline_c & spline, double t) void split (const Vector4d & spline, Vector4d & spline0, Vector4d & spline1, double t) void split (const Vector4d & spline, Vector4d & spline0, Vector4d & spline1) void split (const spline_c & spline, spline_c & spline0, spline_c & spline1) void split (const spline_c & spline, spline_c & spline0, spline_c & spline1, double t) double length_estimate (const spline_c & s, double * error) double length (const spline_c & s, double maxError) double length (const spline_c & s, double t0, double t1, double maxError) double curvature (const spline_c & spline, double t)","title":"Functions"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_spline","text":"spline_c bezier_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 )","title":"function bezier_spline"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-hermite_spline","text":"spline_c hermite_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & v0 , const Vector2d & v1 )","title":"function hermite_spline"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-catumull_spline","text":"spline_c catumull_spline ( const Vector2d & p0 , const Vector2d & p1 , const Vector2d & p2 , const Vector2d & p3 )","title":"function catumull_spline"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-cubic_function_to_bezier","text":"spline_c cubic_function_to_bezier ( const Vector2d & a , const Vector2d & b , const Vector2d & c , const Vector2d & d )","title":"function cubic_function_to_bezier"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_weight","text":"Vector4d bezier_weight ( const double t )","title":"function bezier_weight"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-bezier_weight_1","text":"Vector4d bezier_weight ( const Vector4d t )","title":"function bezier_weight"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-evaluate","text":"inline Vector2d evaluate ( const spline_c & spline , const Vector4d & w )","title":"function evaluate"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-position","text":"Vector2d position ( const spline_c & spline , double t )","title":"function position"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-velocity","text":"Vector2d velocity ( const spline_c & spline , double t )","title":"function velocity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-acceleration","text":"Vector2d acceleration ( const spline_c & spline , double t )","title":"function acceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split","text":"inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 , double t )","title":"function split"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_1","text":"inline void split ( const Vector4d & spline , Vector4d & spline0 , Vector4d & spline1 )","title":"function split"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_2","text":"void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 )","title":"function split"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-split_3","text":"void split ( const spline_c & spline , spline_c & spline0 , spline_c & spline1 , double t )","title":"function split"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length_estimate","text":"double length_estimate ( const spline_c & s , double * error )","title":"function length_estimate"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length","text":"double length ( const spline_c & s , double maxError )","title":"function length"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-length_1","text":"double length ( const spline_c & s , double t0 , double t1 , double maxError )","title":"function length"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1spline/#function-curvature","text":"double curvature ( const spline_c & spline , double t ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function curvature"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/","text":"cpp_robotics::unit \u5358\u4f4d\u7cfb Namespaces Name cpp_robotics::unit::prefix cpp_robotics::unit::tag cpp_robotics::unit::unit_dimention Classes Name struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct cpp_robotics::unit::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9 Types Name enum UnitIndex using unit_assem::unit_div< Torque , Ampere >::unit TorqueConstant using unit_assem::unit_div< Volt , AngularVelocity >::unit BackEmfConstant using unit_assem::unit_mul< Torque , Second >::unit FrictionConstant using Unit < double, unit_dimention::second , prefix::none > Second using Unit < double, unit_dimention::second , prefix::milli > MilliSecond using Unit < double, unit_dimention::second , prefix::micro > MicroSecond using Unit < double, unit_dimention::metere , prefix::none > Meter using Unit < double, unit_dimention::metere , prefix::milli > MilliMeter using Unit < double, unit_dimention::metere , prefix::micro > MicroMeter using Unit < double, unit_dimention::metere , prefix::centi > CentiMeter using Unit < double, unit_dimention::kilogram , prefix::none > KiloGram using Unit < double, unit_dimention::kilogram , prefix::milli > Gram using Unit < double, unit_dimention::watt , prefix::none > Watt using Unit < double, unit_dimention::watt , prefix::kilo > KiloWatt using Unit < double, unit_dimention::newton , prefix::none > Newton using Unit < double, unit_dimention::newton , prefix::kilo > KiloNewton using Unit < double, unit_dimention::pascal , prefix::none > Pascal using Unit < double, unit_dimention::pascal , prefix::kilo > KiloPascal using Unit < double, unit_dimention::hertz , prefix::none > Hertz using Unit < double, unit_dimention::area , prefix::none > Area using Unit < double, unit_dimention::volume , prefix::none > Volume using Unit < double, unit_dimention::velocity , prefix::none > Velocity using Unit < double, unit_dimention::acceleration , prefix::none > Acceleration using Unit < double, unit_dimention::dencity , prefix::none > Dencity using Unit < double, unit_dimention::torque , prefix::none > Torque using Unit < double, unit_dimention::inertia , prefix::none > Inertia using Unit < double, unit_dimention::ampere , prefix::none > Ampere using Unit < double, unit_dimention::ampere , prefix::milli > MilliAmpere using Unit < double, unit_dimention::volt , prefix::none > Volt using Unit < double, unit_dimention::volt , prefix::milli > MilliVolt using Unit < double, unit_dimention::ohm , prefix::none > Ohm using Unit < double, unit_dimention::ohm , prefix::milli > MilliOhm using Unit < double, unit_dimention::henry , prefix::none > Henry using Unit < double, unit_dimention::henry , prefix::milli > MilliHenry using Unit < double, unit_dimention::farad , prefix::none > Farad using Unit < double, unit_dimention::farad , prefix::milli > MilliFarad using Unit < double, unit_dimention::farad , prefix::micro > MicroFarad using Unit < double, unit_dimention::farad , prefix::nano > NanoFarad using Unit < double, unit_dimention::angle , prefix::none , tag::angle::radian > Radian using Unit < double, unit_dimention::angle , prefix::none , tag::angle::degree > Degree using Unit < double, unit_dimention::angular_velocity , prefix::none , tag::angular_vel::rad_per_sec > AngularVelocity using Unit < double, unit_dimention::angular_velocity , prefix::none , tag::angular_vel::rps > Rps using Unit < double, unit_dimention::angular_velocity , prefix::none , tag::angular_vel::rpm > Rpm using Unit < double, unit_dimention::angular_acceleration , prefix::none > AngularAcceleration Functions Name template <class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag ::value && tag::is_normal_tag ::value> constexpr double conv_factor () template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator* (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator/ (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator+ (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator- (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl) Types Documentation enum UnitIndex Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx using TorqueConstant using cpp_robotics :: unit :: TorqueConstant = typedef unit_assem :: unit_div < Torque , Ampere >:: unit ; using BackEmfConstant using cpp_robotics :: unit :: BackEmfConstant = typedef unit_assem :: unit_div < Volt , AngularVelocity >:: unit ; using FrictionConstant using cpp_robotics :: unit :: FrictionConstant = typedef unit_assem :: unit_mul < Torque , Second >:: unit ; using Second using cpp_robotics :: unit :: Second = typedef Unit < double , unit_dimention :: second , prefix :: none > ; using MilliSecond using cpp_robotics :: unit :: MilliSecond = typedef Unit < double , unit_dimention :: second , prefix :: milli > ; using MicroSecond using cpp_robotics :: unit :: MicroSecond = typedef Unit < double , unit_dimention :: second , prefix :: micro > ; using Meter using cpp_robotics :: unit :: Meter = typedef Unit < double , unit_dimention :: metere , prefix :: none > ; using MilliMeter using cpp_robotics :: unit :: MilliMeter = typedef Unit < double , unit_dimention :: metere , prefix :: milli > ; using MicroMeter using cpp_robotics :: unit :: MicroMeter = typedef Unit < double , unit_dimention :: metere , prefix :: micro > ; using CentiMeter using cpp_robotics :: unit :: CentiMeter = typedef Unit < double , unit_dimention :: metere , prefix :: centi > ; using KiloGram using cpp_robotics :: unit :: KiloGram = typedef Unit < double , unit_dimention :: kilogram , prefix :: none > ; using Gram using cpp_robotics :: unit :: Gram = typedef Unit < double , unit_dimention :: kilogram , prefix :: milli > ; using Watt using cpp_robotics :: unit :: Watt = typedef Unit < double , unit_dimention :: watt , prefix :: none > ; using KiloWatt using cpp_robotics :: unit :: KiloWatt = typedef Unit < double , unit_dimention :: watt , prefix :: kilo > ; using Newton using cpp_robotics :: unit :: Newton = typedef Unit < double , unit_dimention :: newton , prefix :: none > ; using KiloNewton using cpp_robotics :: unit :: KiloNewton = typedef Unit < double , unit_dimention :: newton , prefix :: kilo > ; using Pascal using cpp_robotics :: unit :: Pascal = typedef Unit < double , unit_dimention :: pascal , prefix :: none > ; using KiloPascal using cpp_robotics :: unit :: KiloPascal = typedef Unit < double , unit_dimention :: pascal , prefix :: kilo > ; using Hertz using cpp_robotics :: unit :: Hertz = typedef Unit < double , unit_dimention :: hertz , prefix :: none > ; using Area using cpp_robotics :: unit :: Area = typedef Unit < double , unit_dimention :: area , prefix :: none > ; using Volume using cpp_robotics :: unit :: Volume = typedef Unit < double , unit_dimention :: volume , prefix :: none > ; using Velocity using cpp_robotics :: unit :: Velocity = typedef Unit < double , unit_dimention :: velocity , prefix :: none > ; using Acceleration using cpp_robotics :: unit :: Acceleration = typedef Unit < double , unit_dimention :: acceleration , prefix :: none > ; using Dencity using cpp_robotics :: unit :: Dencity = typedef Unit < double , unit_dimention :: dencity , prefix :: none > ; using Torque using cpp_robotics :: unit :: Torque = typedef Unit < double , unit_dimention :: torque , prefix :: none > ; using Inertia using cpp_robotics :: unit :: Inertia = typedef Unit < double , unit_dimention :: inertia , prefix :: none > ; using Ampere using cpp_robotics :: unit :: Ampere = typedef Unit < double , unit_dimention :: ampere , prefix :: none > ; using MilliAmpere using cpp_robotics :: unit :: MilliAmpere = typedef Unit < double , unit_dimention :: ampere , prefix :: milli > ; using Volt using cpp_robotics :: unit :: Volt = typedef Unit < double , unit_dimention :: volt , prefix :: none > ; using MilliVolt using cpp_robotics :: unit :: MilliVolt = typedef Unit < double , unit_dimention :: volt , prefix :: milli > ; using Ohm using cpp_robotics :: unit :: Ohm = typedef Unit < double , unit_dimention :: ohm , prefix :: none > ; using MilliOhm using cpp_robotics :: unit :: MilliOhm = typedef Unit < double , unit_dimention :: ohm , prefix :: milli > ; using Henry using cpp_robotics :: unit :: Henry = typedef Unit < double , unit_dimention :: henry , prefix :: none > ; using MilliHenry using cpp_robotics :: unit :: MilliHenry = typedef Unit < double , unit_dimention :: henry , prefix :: milli > ; using Farad using cpp_robotics :: unit :: Farad = typedef Unit < double , unit_dimention :: farad , prefix :: none > ; using MilliFarad using cpp_robotics :: unit :: MilliFarad = typedef Unit < double , unit_dimention :: farad , prefix :: milli > ; using MicroFarad using cpp_robotics :: unit :: MicroFarad = typedef Unit < double , unit_dimention :: farad , prefix :: micro > ; using NanoFarad using cpp_robotics :: unit :: NanoFarad = typedef Unit < double , unit_dimention :: farad , prefix :: nano > ; using Radian using cpp_robotics :: unit :: Radian = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: radian > ; using Degree using cpp_robotics :: unit :: Degree = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: degree > ; using AngularVelocity using cpp_robotics :: unit :: AngularVelocity = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rad_per_sec > ; using Rps using cpp_robotics :: unit :: Rps = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rps > ; using Rpm using cpp_robotics :: unit :: Rpm = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rpm > ; using AngularAcceleration using cpp_robotics :: unit :: AngularAcceleration = typedef Unit < double , unit_dimention :: angular_acceleration , prefix :: none > ; Functions Documentation function conv_factor template < class UnitDimType , int FromTag , int ToTag , bool IsNormalTag = tag :: is_normal_tag < FromTag >:: value && tag :: is_normal_tag < ToTag >:: value > constexpr double conv_factor () function operator* template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) function operator* template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) function operator/ template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value ) function operator/ template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value ) function operator* template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator * ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) function operator/ template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator / ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl ) function operator+ template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator + ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) function operator- template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator - ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#cpp_roboticsunit","text":"\u5358\u4f4d\u7cfb","title":"cpp_robotics::unit"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#namespaces","text":"Name cpp_robotics::unit::prefix cpp_robotics::unit::tag cpp_robotics::unit::unit_dimention","title":"Namespaces"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#classes","text":"Name struct cpp_robotics::unit::Prefix \u5358\u4f4d\u7cfb\u63a5\u982d\u8f9e\u30af\u30e9\u30b9 class cpp_robotics::unit::Unit \u5358\u4f4d\u30af\u30e9\u30b9 struct cpp_robotics::unit::UnitType SI\u5358\u4f4d\u7cfb\u6b21\u5143\u5b9a\u7fa9\u30af\u30e9\u30b9","title":"Classes"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#types","text":"Name enum UnitIndex using unit_assem::unit_div< Torque , Ampere >::unit TorqueConstant using unit_assem::unit_div< Volt , AngularVelocity >::unit BackEmfConstant using unit_assem::unit_mul< Torque , Second >::unit FrictionConstant using Unit < double, unit_dimention::second , prefix::none > Second using Unit < double, unit_dimention::second , prefix::milli > MilliSecond using Unit < double, unit_dimention::second , prefix::micro > MicroSecond using Unit < double, unit_dimention::metere , prefix::none > Meter using Unit < double, unit_dimention::metere , prefix::milli > MilliMeter using Unit < double, unit_dimention::metere , prefix::micro > MicroMeter using Unit < double, unit_dimention::metere , prefix::centi > CentiMeter using Unit < double, unit_dimention::kilogram , prefix::none > KiloGram using Unit < double, unit_dimention::kilogram , prefix::milli > Gram using Unit < double, unit_dimention::watt , prefix::none > Watt using Unit < double, unit_dimention::watt , prefix::kilo > KiloWatt using Unit < double, unit_dimention::newton , prefix::none > Newton using Unit < double, unit_dimention::newton , prefix::kilo > KiloNewton using Unit < double, unit_dimention::pascal , prefix::none > Pascal using Unit < double, unit_dimention::pascal , prefix::kilo > KiloPascal using Unit < double, unit_dimention::hertz , prefix::none > Hertz using Unit < double, unit_dimention::area , prefix::none > Area using Unit < double, unit_dimention::volume , prefix::none > Volume using Unit < double, unit_dimention::velocity , prefix::none > Velocity using Unit < double, unit_dimention::acceleration , prefix::none > Acceleration using Unit < double, unit_dimention::dencity , prefix::none > Dencity using Unit < double, unit_dimention::torque , prefix::none > Torque using Unit < double, unit_dimention::inertia , prefix::none > Inertia using Unit < double, unit_dimention::ampere , prefix::none > Ampere using Unit < double, unit_dimention::ampere , prefix::milli > MilliAmpere using Unit < double, unit_dimention::volt , prefix::none > Volt using Unit < double, unit_dimention::volt , prefix::milli > MilliVolt using Unit < double, unit_dimention::ohm , prefix::none > Ohm using Unit < double, unit_dimention::ohm , prefix::milli > MilliOhm using Unit < double, unit_dimention::henry , prefix::none > Henry using Unit < double, unit_dimention::henry , prefix::milli > MilliHenry using Unit < double, unit_dimention::farad , prefix::none > Farad using Unit < double, unit_dimention::farad , prefix::milli > MilliFarad using Unit < double, unit_dimention::farad , prefix::micro > MicroFarad using Unit < double, unit_dimention::farad , prefix::nano > NanoFarad using Unit < double, unit_dimention::angle , prefix::none , tag::angle::radian > Radian using Unit < double, unit_dimention::angle , prefix::none , tag::angle::degree > Degree using Unit < double, unit_dimention::angular_velocity , prefix::none , tag::angular_vel::rad_per_sec > AngularVelocity using Unit < double, unit_dimention::angular_velocity , prefix::none , tag::angular_vel::rps > Rps using Unit < double, unit_dimention::angular_velocity , prefix::none , tag::angular_vel::rpm > Rpm using Unit < double, unit_dimention::angular_acceleration , prefix::none > AngularAcceleration","title":"Types"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#functions","text":"Name template <class UnitDimType ,int FromTag,int ToTag,bool IsNormalTag =tag::is_normal_tag ::value && tag::is_normal_tag ::value> constexpr double conv_factor () template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator* (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const T1 & l_value, const Unit < T2, UnitDim, Prefix , Tag > & r_value) template <typename T1 ,typename T2 ,class UnitDim ,class Prefix ,int Tag> constexpr auto operator/ (const Unit < T1, UnitDim, Prefix , Tag > & l_value, const T2 & r_value) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator* (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T1 ,class UnitDim1 ,class Prefix1 ,int Tag1,typename T2 ,class UnitDim2 ,class Prefix2 ,int Tag2> constexpr auto operator/ (const Unit < T1, UnitDim1, Prefix1, Tag1 > & lhl, const Unit < T2, UnitDim2, Prefix2, Tag2 > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator+ (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl) template <typename T ,class UnitDim ,class Prefix1 ,class Prefix2 ,int Tag> constexpr auto operator- (const Unit < T, UnitDim, Prefix1, Tag > & lhl, const Unit < T, UnitDim, Prefix2, Tag > & rhl)","title":"Functions"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#types-documentation","text":"","title":"Types Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#enum-unitindex","text":"Enumerator Value Description MetereIdx KiloGramIdx SecondIdx AmpereIdx KelvinIdx MoleIdx CandelaIdx","title":"enum UnitIndex"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-torqueconstant","text":"using cpp_robotics :: unit :: TorqueConstant = typedef unit_assem :: unit_div < Torque , Ampere >:: unit ;","title":"using TorqueConstant"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-backemfconstant","text":"using cpp_robotics :: unit :: BackEmfConstant = typedef unit_assem :: unit_div < Volt , AngularVelocity >:: unit ;","title":"using BackEmfConstant"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-frictionconstant","text":"using cpp_robotics :: unit :: FrictionConstant = typedef unit_assem :: unit_mul < Torque , Second >:: unit ;","title":"using FrictionConstant"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-second","text":"using cpp_robotics :: unit :: Second = typedef Unit < double , unit_dimention :: second , prefix :: none > ;","title":"using Second"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millisecond","text":"using cpp_robotics :: unit :: MilliSecond = typedef Unit < double , unit_dimention :: second , prefix :: milli > ;","title":"using MilliSecond"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-microsecond","text":"using cpp_robotics :: unit :: MicroSecond = typedef Unit < double , unit_dimention :: second , prefix :: micro > ;","title":"using MicroSecond"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-meter","text":"using cpp_robotics :: unit :: Meter = typedef Unit < double , unit_dimention :: metere , prefix :: none > ;","title":"using Meter"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millimeter","text":"using cpp_robotics :: unit :: MilliMeter = typedef Unit < double , unit_dimention :: metere , prefix :: milli > ;","title":"using MilliMeter"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-micrometer","text":"using cpp_robotics :: unit :: MicroMeter = typedef Unit < double , unit_dimention :: metere , prefix :: micro > ;","title":"using MicroMeter"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-centimeter","text":"using cpp_robotics :: unit :: CentiMeter = typedef Unit < double , unit_dimention :: metere , prefix :: centi > ;","title":"using CentiMeter"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilogram","text":"using cpp_robotics :: unit :: KiloGram = typedef Unit < double , unit_dimention :: kilogram , prefix :: none > ;","title":"using KiloGram"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-gram","text":"using cpp_robotics :: unit :: Gram = typedef Unit < double , unit_dimention :: kilogram , prefix :: milli > ;","title":"using Gram"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-watt","text":"using cpp_robotics :: unit :: Watt = typedef Unit < double , unit_dimention :: watt , prefix :: none > ;","title":"using Watt"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilowatt","text":"using cpp_robotics :: unit :: KiloWatt = typedef Unit < double , unit_dimention :: watt , prefix :: kilo > ;","title":"using KiloWatt"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-newton","text":"using cpp_robotics :: unit :: Newton = typedef Unit < double , unit_dimention :: newton , prefix :: none > ;","title":"using Newton"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilonewton","text":"using cpp_robotics :: unit :: KiloNewton = typedef Unit < double , unit_dimention :: newton , prefix :: kilo > ;","title":"using KiloNewton"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-pascal","text":"using cpp_robotics :: unit :: Pascal = typedef Unit < double , unit_dimention :: pascal , prefix :: none > ;","title":"using Pascal"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-kilopascal","text":"using cpp_robotics :: unit :: KiloPascal = typedef Unit < double , unit_dimention :: pascal , prefix :: kilo > ;","title":"using KiloPascal"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-hertz","text":"using cpp_robotics :: unit :: Hertz = typedef Unit < double , unit_dimention :: hertz , prefix :: none > ;","title":"using Hertz"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-area","text":"using cpp_robotics :: unit :: Area = typedef Unit < double , unit_dimention :: area , prefix :: none > ;","title":"using Area"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-volume","text":"using cpp_robotics :: unit :: Volume = typedef Unit < double , unit_dimention :: volume , prefix :: none > ;","title":"using Volume"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-velocity","text":"using cpp_robotics :: unit :: Velocity = typedef Unit < double , unit_dimention :: velocity , prefix :: none > ;","title":"using Velocity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-acceleration","text":"using cpp_robotics :: unit :: Acceleration = typedef Unit < double , unit_dimention :: acceleration , prefix :: none > ;","title":"using Acceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-dencity","text":"using cpp_robotics :: unit :: Dencity = typedef Unit < double , unit_dimention :: dencity , prefix :: none > ;","title":"using Dencity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-torque","text":"using cpp_robotics :: unit :: Torque = typedef Unit < double , unit_dimention :: torque , prefix :: none > ;","title":"using Torque"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-inertia","text":"using cpp_robotics :: unit :: Inertia = typedef Unit < double , unit_dimention :: inertia , prefix :: none > ;","title":"using Inertia"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-ampere","text":"using cpp_robotics :: unit :: Ampere = typedef Unit < double , unit_dimention :: ampere , prefix :: none > ;","title":"using Ampere"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-milliampere","text":"using cpp_robotics :: unit :: MilliAmpere = typedef Unit < double , unit_dimention :: ampere , prefix :: milli > ;","title":"using MilliAmpere"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-volt","text":"using cpp_robotics :: unit :: Volt = typedef Unit < double , unit_dimention :: volt , prefix :: none > ;","title":"using Volt"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millivolt","text":"using cpp_robotics :: unit :: MilliVolt = typedef Unit < double , unit_dimention :: volt , prefix :: milli > ;","title":"using MilliVolt"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-ohm","text":"using cpp_robotics :: unit :: Ohm = typedef Unit < double , unit_dimention :: ohm , prefix :: none > ;","title":"using Ohm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-milliohm","text":"using cpp_robotics :: unit :: MilliOhm = typedef Unit < double , unit_dimention :: ohm , prefix :: milli > ;","title":"using MilliOhm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-henry","text":"using cpp_robotics :: unit :: Henry = typedef Unit < double , unit_dimention :: henry , prefix :: none > ;","title":"using Henry"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millihenry","text":"using cpp_robotics :: unit :: MilliHenry = typedef Unit < double , unit_dimention :: henry , prefix :: milli > ;","title":"using MilliHenry"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-farad","text":"using cpp_robotics :: unit :: Farad = typedef Unit < double , unit_dimention :: farad , prefix :: none > ;","title":"using Farad"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-millifarad","text":"using cpp_robotics :: unit :: MilliFarad = typedef Unit < double , unit_dimention :: farad , prefix :: milli > ;","title":"using MilliFarad"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-microfarad","text":"using cpp_robotics :: unit :: MicroFarad = typedef Unit < double , unit_dimention :: farad , prefix :: micro > ;","title":"using MicroFarad"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-nanofarad","text":"using cpp_robotics :: unit :: NanoFarad = typedef Unit < double , unit_dimention :: farad , prefix :: nano > ;","title":"using NanoFarad"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-radian","text":"using cpp_robotics :: unit :: Radian = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: radian > ;","title":"using Radian"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-degree","text":"using cpp_robotics :: unit :: Degree = typedef Unit < double , unit_dimention :: angle , prefix :: none , tag :: angle :: degree > ;","title":"using Degree"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-angularvelocity","text":"using cpp_robotics :: unit :: AngularVelocity = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rad_per_sec > ;","title":"using AngularVelocity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-rps","text":"using cpp_robotics :: unit :: Rps = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rps > ;","title":"using Rps"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-rpm","text":"using cpp_robotics :: unit :: Rpm = typedef Unit < double , unit_dimention :: angular_velocity , prefix :: none , tag :: angular_vel :: rpm > ;","title":"using Rpm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#using-angularacceleration","text":"using cpp_robotics :: unit :: AngularAcceleration = typedef Unit < double , unit_dimention :: angular_acceleration , prefix :: none > ;","title":"using AngularAcceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-conv_factor","text":"template < class UnitDimType , int FromTag , int ToTag , bool IsNormalTag = tag :: is_normal_tag < FromTag >:: value && tag :: is_normal_tag < ToTag >:: value > constexpr double conv_factor ()","title":"function conv_factor"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value )","title":"function operator*"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_1","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator * ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value )","title":"function operator*"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_2","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const T1 & l_value , const Unit < T2 , UnitDim , Prefix , Tag > & r_value )","title":"function operator/"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_3","text":"template < typename T1 , typename T2 , class UnitDim , class Prefix , int Tag > constexpr auto operator / ( const Unit < T1 , UnitDim , Prefix , Tag > & l_value , const T2 & r_value )","title":"function operator/"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_4","text":"template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator * ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl )","title":"function operator*"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_5","text":"template < typename T1 , class UnitDim1 , class Prefix1 , int Tag1 , typename T2 , class UnitDim2 , class Prefix2 , int Tag2 > constexpr auto operator / ( const Unit < T1 , UnitDim1 , Prefix1 , Tag1 > & lhl , const Unit < T2 , UnitDim2 , Prefix2 , Tag2 > & rhl )","title":"function operator/"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator_6","text":"template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator + ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl )","title":"function operator+"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit/#function-operator-","text":"template < typename T , class UnitDim , class Prefix1 , class Prefix2 , int Tag > constexpr auto operator - ( const Unit < T , UnitDim , Prefix1 , Tag > & lhl , const Unit < T , UnitDim , Prefix2 , Tag > & rhl ) Updated on 2022-09-30 at 00:12:50 +0900","title":"function operator-"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/","text":"cpp_robotics::unit::prefix Classes Name struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min struct cpp_robotics::unit::prefix::pfx_mul Types Name using Prefix < 1, 1000000000 > nano using Prefix < 1, 1000000 > micro using Prefix < 1, 1000 > milli using Prefix < 1, 100 > centi using Prefix < 1, 10 > deci using Prefix < 1, 1 > none using Prefix < 10, 1 > deca using Prefix < 100, 1 > hecto using Prefix < 1000, 1 > kilo using Prefix < 1000000, 1 > mega using Prefix < 1000000000, 1 > giga Types Documentation using nano using cpp_robotics :: unit :: prefix :: nano = typedef Prefix < 1 , 1000000000 > ; using micro using cpp_robotics :: unit :: prefix :: micro = typedef Prefix < 1 , 1000000 > ; using milli using cpp_robotics :: unit :: prefix :: milli = typedef Prefix < 1 , 1000 > ; using centi using cpp_robotics :: unit :: prefix :: centi = typedef Prefix < 1 , 100 > ; using deci using cpp_robotics :: unit :: prefix :: deci = typedef Prefix < 1 , 10 > ; using none using cpp_robotics :: unit :: prefix :: none = typedef Prefix < 1 , 1 > ; using deca using cpp_robotics :: unit :: prefix :: deca = typedef Prefix < 10 , 1 > ; using hecto using cpp_robotics :: unit :: prefix :: hecto = typedef Prefix < 100 , 1 > ; using kilo using cpp_robotics :: unit :: prefix :: kilo = typedef Prefix < 1000 , 1 > ; using mega using cpp_robotics :: unit :: prefix :: mega = typedef Prefix < 1000000 , 1 > ; using giga using cpp_robotics :: unit :: prefix :: giga = typedef Prefix < 1000000000 , 1 > ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::prefix"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#cpp_roboticsunitprefix","text":"","title":"cpp_robotics::unit::prefix"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#classes","text":"Name struct cpp_robotics::unit::prefix::pfx_div struct cpp_robotics::unit::prefix::pfx_inv struct cpp_robotics::unit::prefix::pfx_min struct cpp_robotics::unit::prefix::pfx_mul","title":"Classes"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#types","text":"Name using Prefix < 1, 1000000000 > nano using Prefix < 1, 1000000 > micro using Prefix < 1, 1000 > milli using Prefix < 1, 100 > centi using Prefix < 1, 10 > deci using Prefix < 1, 1 > none using Prefix < 10, 1 > deca using Prefix < 100, 1 > hecto using Prefix < 1000, 1 > kilo using Prefix < 1000000, 1 > mega using Prefix < 1000000000, 1 > giga","title":"Types"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#types-documentation","text":"","title":"Types Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-nano","text":"using cpp_robotics :: unit :: prefix :: nano = typedef Prefix < 1 , 1000000000 > ;","title":"using nano"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-micro","text":"using cpp_robotics :: unit :: prefix :: micro = typedef Prefix < 1 , 1000000 > ;","title":"using micro"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-milli","text":"using cpp_robotics :: unit :: prefix :: milli = typedef Prefix < 1 , 1000 > ;","title":"using milli"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-centi","text":"using cpp_robotics :: unit :: prefix :: centi = typedef Prefix < 1 , 100 > ;","title":"using centi"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-deci","text":"using cpp_robotics :: unit :: prefix :: deci = typedef Prefix < 1 , 10 > ;","title":"using deci"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-none","text":"using cpp_robotics :: unit :: prefix :: none = typedef Prefix < 1 , 1 > ;","title":"using none"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-deca","text":"using cpp_robotics :: unit :: prefix :: deca = typedef Prefix < 10 , 1 > ;","title":"using deca"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-hecto","text":"using cpp_robotics :: unit :: prefix :: hecto = typedef Prefix < 100 , 1 > ;","title":"using hecto"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-kilo","text":"using cpp_robotics :: unit :: prefix :: kilo = typedef Prefix < 1000 , 1 > ;","title":"using kilo"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-mega","text":"using cpp_robotics :: unit :: prefix :: mega = typedef Prefix < 1000000 , 1 > ;","title":"using mega"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1prefix/#using-giga","text":"using cpp_robotics :: unit :: prefix :: giga = typedef Prefix < 1000000000 , 1 > ; Updated on 2022-09-30 at 00:12:50 +0900","title":"using giga"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/","text":"cpp_robotics::unit::tag Classes Name struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag< 0 > struct cpp_robotics::unit::tag::is_normal_tag<-1 > Types Name enum angle enum angular_vel Types Documentation enum angle Enumerator Value Description radian 0 degree enum angular_vel Enumerator Value Description rad_per_sec 0 rps rpm Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::tag"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#cpp_roboticsunittag","text":"","title":"cpp_robotics::unit::tag"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#classes","text":"Name struct cpp_robotics::unit::tag::is_normal_tag struct cpp_robotics::unit::tag::is_normal_tag< 0 > struct cpp_robotics::unit::tag::is_normal_tag<-1 >","title":"Classes"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#types","text":"Name enum angle enum angular_vel","title":"Types"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#types-documentation","text":"","title":"Types Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#enum-angle","text":"Enumerator Value Description radian 0 degree","title":"enum angle"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1tag/#enum-angular_vel","text":"Enumerator Value Description rad_per_sec 0 rps rpm Updated on 2022-09-30 at 00:12:50 +0900","title":"enum angular_vel"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/","text":"cpp_robotics::unit::unit_dimention Types Name using UnitType < 0, 0, 0, 0, 0, 0, 0 > no_dimention using UnitType < 1, 0, 0, 0, 0, 0, 0 > metere using UnitType < 0, 1, 0, 0, 0, 0, 0 > kilogram using UnitType < 0, 0, 1, 0, 0, 0, 0 > second using UnitType < 0, 0, 0, 1, 0, 0, 0 > ampere using UnitType < 0, 0, 0, 0, 1, 0, 0 > kelvin using UnitType < 0, 0, 0, 0, 0, 1, 0 > mole using UnitType < 0, 0, 0, 0, 0, 0, 1 > candela using udim_pow< metere , 2 >::unit area using udim_pow< metere , 3 >::unit volume using udim_div< metere , second >::unit velocity using udim_div< velocity , second >::unit acceleration using udim_div< kilogram , volume >::unit dencity using udim_div< metere , metere >::unit angle using udim_inv< second >::unit hertz using udim_div< udim_mul< metere , kilogram >::unit, udim_pow< second , 2 >::unit >::unit newton using udim_div< newton , area >::unit pascal using udim_mul< pascal , second >::unit viscosity using udim_mul< newton , metere >::unit joule using udim_div< joule , second >::unit watt using udim_div< watt , ampere >::unit volt using udim_mul< second , ampere >::unit coulomb using udim_div< coulomb , volt >::unit farad using udim_div< volt , ampere >::unit ohm using udim_mul< volt , second >::unit weber using udim_div< weber , ampere >::unit henry using udim_mul< newton , metere >::unit torque using udim_mul< kilogram , area >::unit inertia using udim_div< angle , second >::unit angular_velocity using udim_div< angular_velocity , second >::unit angular_acceleration Types Documentation using no_dimention using cpp_robotics :: unit :: unit_dimention :: no_dimention = typedef UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 0 > ; using metere using cpp_robotics :: unit :: unit_dimention :: metere = typedef UnitType < 1 , 0 , 0 , 0 , 0 , 0 , 0 > ; using kilogram using cpp_robotics :: unit :: unit_dimention :: kilogram = typedef UnitType < 0 , 1 , 0 , 0 , 0 , 0 , 0 > ; using second using cpp_robotics :: unit :: unit_dimention :: second = typedef UnitType < 0 , 0 , 1 , 0 , 0 , 0 , 0 > ; using ampere using cpp_robotics :: unit :: unit_dimention :: ampere = typedef UnitType < 0 , 0 , 0 , 1 , 0 , 0 , 0 > ; using kelvin using cpp_robotics :: unit :: unit_dimention :: kelvin = typedef UnitType < 0 , 0 , 0 , 0 , 1 , 0 , 0 > ; using mole using cpp_robotics :: unit :: unit_dimention :: mole = typedef UnitType < 0 , 0 , 0 , 0 , 0 , 1 , 0 > ; using candela using cpp_robotics :: unit :: unit_dimention :: candela = typedef UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 1 > ; using area using cpp_robotics :: unit :: unit_dimention :: area = typedef udim_pow < metere , 2 >:: unit ; using volume using cpp_robotics :: unit :: unit_dimention :: volume = typedef udim_pow < metere , 3 >:: unit ; using velocity using cpp_robotics :: unit :: unit_dimention :: velocity = typedef udim_div < metere , second >:: unit ; using acceleration using cpp_robotics :: unit :: unit_dimention :: acceleration = typedef udim_div < velocity , second >:: unit ; using dencity using cpp_robotics :: unit :: unit_dimention :: dencity = typedef udim_div < kilogram , volume >:: unit ; using angle using cpp_robotics :: unit :: unit_dimention :: angle = typedef udim_div < metere , metere >:: unit ; using hertz using cpp_robotics :: unit :: unit_dimention :: hertz = typedef udim_inv < second >:: unit ; using newton using cpp_robotics :: unit :: unit_dimention :: newton = typedef udim_div < udim_mul < metere , kilogram >:: unit , udim_pow < second , 2 >:: unit >:: unit ; using pascal using cpp_robotics :: unit :: unit_dimention :: pascal = typedef udim_div < newton , area >:: unit ; using viscosity using cpp_robotics :: unit :: unit_dimention :: viscosity = typedef udim_mul < pascal , second >:: unit ; using joule using cpp_robotics :: unit :: unit_dimention :: joule = typedef udim_mul < newton , metere >:: unit ; using watt using cpp_robotics :: unit :: unit_dimention :: watt = typedef udim_div < joule , second >:: unit ; using volt using cpp_robotics :: unit :: unit_dimention :: volt = typedef udim_div < watt , ampere >:: unit ; using coulomb using cpp_robotics :: unit :: unit_dimention :: coulomb = typedef udim_mul < second , ampere >:: unit ; using farad using cpp_robotics :: unit :: unit_dimention :: farad = typedef udim_div < coulomb , volt >:: unit ; using ohm using cpp_robotics :: unit :: unit_dimention :: ohm = typedef udim_div < volt , ampere >:: unit ; using weber using cpp_robotics :: unit :: unit_dimention :: weber = typedef udim_mul < volt , second >:: unit ; using henry using cpp_robotics :: unit :: unit_dimention :: henry = typedef udim_div < weber , ampere >:: unit ; using torque using cpp_robotics :: unit :: unit_dimention :: torque = typedef udim_mul < newton , metere >:: unit ; using inertia using cpp_robotics :: unit :: unit_dimention :: inertia = typedef udim_mul < kilogram , area >:: unit ; using angular_velocity using cpp_robotics :: unit :: unit_dimention :: angular_velocity = typedef udim_div < angle , second >:: unit ; using angular_acceleration using cpp_robotics :: unit :: unit_dimention :: angular_acceleration = typedef udim_div < angular_velocity , second >:: unit ; Updated on 2022-09-30 at 00:12:50 +0900","title":"cpp_robotics::unit::unit_dimention"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#cpp_roboticsunitunit_dimention","text":"","title":"cpp_robotics::unit::unit_dimention"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#types","text":"Name using UnitType < 0, 0, 0, 0, 0, 0, 0 > no_dimention using UnitType < 1, 0, 0, 0, 0, 0, 0 > metere using UnitType < 0, 1, 0, 0, 0, 0, 0 > kilogram using UnitType < 0, 0, 1, 0, 0, 0, 0 > second using UnitType < 0, 0, 0, 1, 0, 0, 0 > ampere using UnitType < 0, 0, 0, 0, 1, 0, 0 > kelvin using UnitType < 0, 0, 0, 0, 0, 1, 0 > mole using UnitType < 0, 0, 0, 0, 0, 0, 1 > candela using udim_pow< metere , 2 >::unit area using udim_pow< metere , 3 >::unit volume using udim_div< metere , second >::unit velocity using udim_div< velocity , second >::unit acceleration using udim_div< kilogram , volume >::unit dencity using udim_div< metere , metere >::unit angle using udim_inv< second >::unit hertz using udim_div< udim_mul< metere , kilogram >::unit, udim_pow< second , 2 >::unit >::unit newton using udim_div< newton , area >::unit pascal using udim_mul< pascal , second >::unit viscosity using udim_mul< newton , metere >::unit joule using udim_div< joule , second >::unit watt using udim_div< watt , ampere >::unit volt using udim_mul< second , ampere >::unit coulomb using udim_div< coulomb , volt >::unit farad using udim_div< volt , ampere >::unit ohm using udim_mul< volt , second >::unit weber using udim_div< weber , ampere >::unit henry using udim_mul< newton , metere >::unit torque using udim_mul< kilogram , area >::unit inertia using udim_div< angle , second >::unit angular_velocity using udim_div< angular_velocity , second >::unit angular_acceleration","title":"Types"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#types-documentation","text":"","title":"Types Documentation"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-no_dimention","text":"using cpp_robotics :: unit :: unit_dimention :: no_dimention = typedef UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 0 > ;","title":"using no_dimention"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-metere","text":"using cpp_robotics :: unit :: unit_dimention :: metere = typedef UnitType < 1 , 0 , 0 , 0 , 0 , 0 , 0 > ;","title":"using metere"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-kilogram","text":"using cpp_robotics :: unit :: unit_dimention :: kilogram = typedef UnitType < 0 , 1 , 0 , 0 , 0 , 0 , 0 > ;","title":"using kilogram"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-second","text":"using cpp_robotics :: unit :: unit_dimention :: second = typedef UnitType < 0 , 0 , 1 , 0 , 0 , 0 , 0 > ;","title":"using second"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-ampere","text":"using cpp_robotics :: unit :: unit_dimention :: ampere = typedef UnitType < 0 , 0 , 0 , 1 , 0 , 0 , 0 > ;","title":"using ampere"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-kelvin","text":"using cpp_robotics :: unit :: unit_dimention :: kelvin = typedef UnitType < 0 , 0 , 0 , 0 , 1 , 0 , 0 > ;","title":"using kelvin"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-mole","text":"using cpp_robotics :: unit :: unit_dimention :: mole = typedef UnitType < 0 , 0 , 0 , 0 , 0 , 1 , 0 > ;","title":"using mole"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-candela","text":"using cpp_robotics :: unit :: unit_dimention :: candela = typedef UnitType < 0 , 0 , 0 , 0 , 0 , 0 , 1 > ;","title":"using candela"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-area","text":"using cpp_robotics :: unit :: unit_dimention :: area = typedef udim_pow < metere , 2 >:: unit ;","title":"using area"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-volume","text":"using cpp_robotics :: unit :: unit_dimention :: volume = typedef udim_pow < metere , 3 >:: unit ;","title":"using volume"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-velocity","text":"using cpp_robotics :: unit :: unit_dimention :: velocity = typedef udim_div < metere , second >:: unit ;","title":"using velocity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-acceleration","text":"using cpp_robotics :: unit :: unit_dimention :: acceleration = typedef udim_div < velocity , second >:: unit ;","title":"using acceleration"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-dencity","text":"using cpp_robotics :: unit :: unit_dimention :: dencity = typedef udim_div < kilogram , volume >:: unit ;","title":"using dencity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angle","text":"using cpp_robotics :: unit :: unit_dimention :: angle = typedef udim_div < metere , metere >:: unit ;","title":"using angle"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-hertz","text":"using cpp_robotics :: unit :: unit_dimention :: hertz = typedef udim_inv < second >:: unit ;","title":"using hertz"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-newton","text":"using cpp_robotics :: unit :: unit_dimention :: newton = typedef udim_div < udim_mul < metere , kilogram >:: unit , udim_pow < second , 2 >:: unit >:: unit ;","title":"using newton"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-pascal","text":"using cpp_robotics :: unit :: unit_dimention :: pascal = typedef udim_div < newton , area >:: unit ;","title":"using pascal"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-viscosity","text":"using cpp_robotics :: unit :: unit_dimention :: viscosity = typedef udim_mul < pascal , second >:: unit ;","title":"using viscosity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-joule","text":"using cpp_robotics :: unit :: unit_dimention :: joule = typedef udim_mul < newton , metere >:: unit ;","title":"using joule"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-watt","text":"using cpp_robotics :: unit :: unit_dimention :: watt = typedef udim_div < joule , second >:: unit ;","title":"using watt"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-volt","text":"using cpp_robotics :: unit :: unit_dimention :: volt = typedef udim_div < watt , ampere >:: unit ;","title":"using volt"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-coulomb","text":"using cpp_robotics :: unit :: unit_dimention :: coulomb = typedef udim_mul < second , ampere >:: unit ;","title":"using coulomb"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-farad","text":"using cpp_robotics :: unit :: unit_dimention :: farad = typedef udim_div < coulomb , volt >:: unit ;","title":"using farad"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-ohm","text":"using cpp_robotics :: unit :: unit_dimention :: ohm = typedef udim_div < volt , ampere >:: unit ;","title":"using ohm"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-weber","text":"using cpp_robotics :: unit :: unit_dimention :: weber = typedef udim_mul < volt , second >:: unit ;","title":"using weber"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-henry","text":"using cpp_robotics :: unit :: unit_dimention :: henry = typedef udim_div < weber , ampere >:: unit ;","title":"using henry"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-torque","text":"using cpp_robotics :: unit :: unit_dimention :: torque = typedef udim_mul < newton , metere >:: unit ;","title":"using torque"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-inertia","text":"using cpp_robotics :: unit :: unit_dimention :: inertia = typedef udim_mul < kilogram , area >:: unit ;","title":"using inertia"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angular_velocity","text":"using cpp_robotics :: unit :: unit_dimention :: angular_velocity = typedef udim_div < angle , second >:: unit ;","title":"using angular_velocity"},{"location":"doxybook/Namespaces/namespacecpp__robotics_1_1unit_1_1unit__dimention/#using-angular_acceleration","text":"using cpp_robotics :: unit :: unit_dimention :: angular_acceleration = typedef udim_div < angular_velocity , second >:: unit ; Updated on 2022-09-30 at 00:12:50 +0900","title":"using angular_acceleration"},{"location":"doxybook/Namespaces/namespaceunit__dim__assem/","text":"unit_dim_assem Updated on 2022-09-30 at 00:12:50 +0900","title":"unit_dim_assem"},{"location":"doxybook/Namespaces/namespaceunit__dim__assem/#unit_dim_assem","text":"Updated on 2022-09-30 at 00:12:50 +0900","title":"unit_dim_assem"},{"location":"example/hello_world/","text":"Hello World #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/cpp_robotics.hpp> int main ( int argc , char * argv []) { ( void ) argc ; ( void ) argv ; namespace cr = cpp_robotics ; std :: cout << \"test\" << std :: endl ; constexpr cr :: Vector2d vec ( 3.0 , 4.0 ); printf ( \"constexpr 2D vector: %f, %f \\n \" , vec . x , vec . y ); Eigen :: MatrixXd A ( 2 , 2 ), B ( 2 , 1 ), Q ( 2 , 2 ), R ( 1 , 1 ), P ( 2 , 2 ); A << 0 , 1 , -10 , -1 ; B << 0 , 1 ; Q << 300 , 0 , 0 , 60 ; R << 1 ; Eigen :: MatrixXd K = cr :: lqr ( A , B , Q , R ); std :: cout << \"LQR feedback vector\" << std :: endl ; std :: cout << K << std :: endl ; std :: cout << \"polynomial\" << std :: endl ; cr :: Polynomial p0 ({ 1 , 0 , 3 }); std :: cout << p0 << std :: endl ; cr :: Polynomial p1 = cr :: Polynomial ({ 1 , -2 }) * cr :: Polynomial ({ 1 , 2 }); std :: cout << p1 << std :: endl ; cr :: TransferFunction tf ({ 1.0 }, { 1 , 1.0 }, 0.01 ); namespace plt = matplotlibcpp ; std :: cout << \"transfer function step responce\" << std :: endl ; { auto [ t , y ] = cr :: step ( tf , 30 ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function sin cruve input responce\" << std :: endl ; { auto input = cr :: sinspace ( 1 , 0.1 , 1000 ); auto [ t , y ] = cr :: lsim ( tf , input ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function bode fig plot\" << std :: endl ; cr :: bode_plot ( tf ); std :: cout << \"transfer function nyquist fig plot\" << std :: endl ; cr :: nyquist_plot ( tf ); }","title":"HelloWorld"},{"location":"example/hello_world/#hello-world","text":"#include <iostream> #include <Eigen/Dense> #include <cpp_robotics/cpp_robotics.hpp> int main ( int argc , char * argv []) { ( void ) argc ; ( void ) argv ; namespace cr = cpp_robotics ; std :: cout << \"test\" << std :: endl ; constexpr cr :: Vector2d vec ( 3.0 , 4.0 ); printf ( \"constexpr 2D vector: %f, %f \\n \" , vec . x , vec . y ); Eigen :: MatrixXd A ( 2 , 2 ), B ( 2 , 1 ), Q ( 2 , 2 ), R ( 1 , 1 ), P ( 2 , 2 ); A << 0 , 1 , -10 , -1 ; B << 0 , 1 ; Q << 300 , 0 , 0 , 60 ; R << 1 ; Eigen :: MatrixXd K = cr :: lqr ( A , B , Q , R ); std :: cout << \"LQR feedback vector\" << std :: endl ; std :: cout << K << std :: endl ; std :: cout << \"polynomial\" << std :: endl ; cr :: Polynomial p0 ({ 1 , 0 , 3 }); std :: cout << p0 << std :: endl ; cr :: Polynomial p1 = cr :: Polynomial ({ 1 , -2 }) * cr :: Polynomial ({ 1 , 2 }); std :: cout << p1 << std :: endl ; cr :: TransferFunction tf ({ 1.0 }, { 1 , 1.0 }, 0.01 ); namespace plt = matplotlibcpp ; std :: cout << \"transfer function step responce\" << std :: endl ; { auto [ t , y ] = cr :: step ( tf , 30 ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function sin cruve input responce\" << std :: endl ; { auto input = cr :: sinspace ( 1 , 0.1 , 1000 ); auto [ t , y ] = cr :: lsim ( tf , input ); plt :: plot ( t , y ); plt :: show (); } std :: cout << \"transfer function bode fig plot\" << std :: endl ; cr :: bode_plot ( tf ); std :: cout << \"transfer function nyquist fig plot\" << std :: endl ; cr :: nyquist_plot ( tf ); }","title":"Hello World"},{"location":"example/algorithm/icp_sample/","text":"ICP #include <iostream> #include <cpp_robotics/algorithm/algorithm.hpp> #include <cpp_robotics/vector/vector2.hpp> #include <cpp_robotics/third_party/matplotlib-cpp/matplotlibcpp.h> int main () { namespace cr = cpp_robotics ; { std :: vector < Eigen :: Vector2d > fixed = { { 0 , 9 }, { 0 , 7 }, { 0 , 5 }, { 0 , 3 }, { 2 , 1 }, { 4 , 1 }, { 6 , 1 }, { 8 , 3 }, { 8 , 5 }, { 8 , 9 }, }; std :: vector < Eigen :: Vector2d > p2 = fixed ; for ( size_t i = 0 ; i < fixed . size (); i ++ ) { // p2[i][0] = fixed[i][1] + 1; // p2[i][1] = -fixed[i][0]; p2 [ i ][ 0 ] += 3.0 ; //fixed[i][0]; p2 [ i ][ 1 ] += 1.0 ; //fixed[i][1]; } auto [ R , T ] = cr :: calcu_transformatoin < 2 > ( p2 , fixed ); std :: cout << \"R = \" << std :: endl ; std :: cout << R << std :: endl ; std :: cout << \"T = \" << std :: endl ; std :: cout << T << std :: endl ; std :: cout << \"///// check /////\" << std :: endl ; for ( size_t i = 0 ; i < p2 . size (); i ++ ) { auto moved_p = R * p2 [ i ] + T ; std :: cout << moved_p . transpose () << \", err = \" << ( moved_p - fixed [ i ]). transpose () << std :: endl ; } } { std :: vector < Eigen :: Vector2d > p1 = { { 0 , 8 }, { 0 , 7 }, { 0 , 5 }, { 0 , 3 }, { 2 , 1 }, { 4 , 1 }, { 6 , 1 }, { 8 , 3 }, { 8 , 5 }, { 8 , 9 }, }; std :: vector < Eigen :: Vector2d > p2 = p1 ; for ( auto & v : p2 ) v += Eigen :: Vector2d ( 3 , 0 ); auto [ points , cnt ] = cr :: icp < 2 > ( p2 , p1 , 50 ); auto gen = []( std :: vector < Eigen :: Vector2d > ps ) { std :: vector < double > x_ ( ps . size ()), y_ ( ps . size ()); for ( size_t i = 0 ; i < ( ps . size ()); i ++ ) { x_ [ i ] = ps [ i ][ 0 ]; y_ [ i ] = ps [ i ][ 1 ]; } return std :: tuple < std :: vector < double > , std :: vector < double >> ( x_ , y_ ); }; auto [ x , y ] = gen ( p1 ); matplotlibcpp :: plot ( x , y ); auto [ x2 , y2 ] = gen ( points ); matplotlibcpp :: plot ( x2 , y2 ); matplotlibcpp :: show (); } }","title":"ICP"},{"location":"example/algorithm/icp_sample/#icp","text":"#include <iostream> #include <cpp_robotics/algorithm/algorithm.hpp> #include <cpp_robotics/vector/vector2.hpp> #include <cpp_robotics/third_party/matplotlib-cpp/matplotlibcpp.h> int main () { namespace cr = cpp_robotics ; { std :: vector < Eigen :: Vector2d > fixed = { { 0 , 9 }, { 0 , 7 }, { 0 , 5 }, { 0 , 3 }, { 2 , 1 }, { 4 , 1 }, { 6 , 1 }, { 8 , 3 }, { 8 , 5 }, { 8 , 9 }, }; std :: vector < Eigen :: Vector2d > p2 = fixed ; for ( size_t i = 0 ; i < fixed . size (); i ++ ) { // p2[i][0] = fixed[i][1] + 1; // p2[i][1] = -fixed[i][0]; p2 [ i ][ 0 ] += 3.0 ; //fixed[i][0]; p2 [ i ][ 1 ] += 1.0 ; //fixed[i][1]; } auto [ R , T ] = cr :: calcu_transformatoin < 2 > ( p2 , fixed ); std :: cout << \"R = \" << std :: endl ; std :: cout << R << std :: endl ; std :: cout << \"T = \" << std :: endl ; std :: cout << T << std :: endl ; std :: cout << \"///// check /////\" << std :: endl ; for ( size_t i = 0 ; i < p2 . size (); i ++ ) { auto moved_p = R * p2 [ i ] + T ; std :: cout << moved_p . transpose () << \", err = \" << ( moved_p - fixed [ i ]). transpose () << std :: endl ; } } { std :: vector < Eigen :: Vector2d > p1 = { { 0 , 8 }, { 0 , 7 }, { 0 , 5 }, { 0 , 3 }, { 2 , 1 }, { 4 , 1 }, { 6 , 1 }, { 8 , 3 }, { 8 , 5 }, { 8 , 9 }, }; std :: vector < Eigen :: Vector2d > p2 = p1 ; for ( auto & v : p2 ) v += Eigen :: Vector2d ( 3 , 0 ); auto [ points , cnt ] = cr :: icp < 2 > ( p2 , p1 , 50 ); auto gen = []( std :: vector < Eigen :: Vector2d > ps ) { std :: vector < double > x_ ( ps . size ()), y_ ( ps . size ()); for ( size_t i = 0 ; i < ( ps . size ()); i ++ ) { x_ [ i ] = ps [ i ][ 0 ]; y_ [ i ] = ps [ i ][ 1 ]; } return std :: tuple < std :: vector < double > , std :: vector < double >> ( x_ , y_ ); }; auto [ x , y ] = gen ( p1 ); matplotlibcpp :: plot ( x , y ); auto [ x2 , y2 ] = gen ( points ); matplotlibcpp :: plot ( x2 , y2 ); matplotlibcpp :: show (); } }","title":"ICP"},{"location":"example/algorithm/kdtree_sample/","text":"KDTree #include <iostream> #include <cpp_robotics/algorithm/kdtree.hpp> #include <cpp_robotics/vector/vector2.hpp> #include <Eigen/Dense> int main () { namespace cr = cpp_robotics ; // for cpp_rototics::VectorXx std :: cout << \"for cpp_rototics::VectorXx\" << std :: endl ; { cr :: KDTree < cr :: Vector2d , 2 > kdtree ; std :: vector < cr :: Vector2d > points = { { 0 , 1 }, { 2 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, }; kdtree . build ( points ); // kdtree.debug_node(); auto ret = kdtree . knn_search_points ( cr :: Vector2d ( 0 , 1 ), 1 ); printf ( \"size %ld \\n \" , ret . size ()); std :: for_each ( ret . begin (), ret . end (), [ & ]( cr :: Vector2d p ) { printf ( \"%6.2f, %6.2f \\n \" , p . x , p . y ); }); } // for Eigen::VectorXx std :: cout << \"for Eigen::VectorXx\" << std :: endl ; { cr :: KDTree < Eigen :: Vector2d , 2 > kdtree ; std :: vector < Eigen :: Vector2d > points = { { 0 , 1 }, { 2 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, }; kdtree . build ( points ); // kdtree.debug_node(); auto ret = kdtree . knn_search_points ( Eigen :: Vector2d ( 0 , 1 ), 1 ); printf ( \"size %ld \\n \" , ret . size ()); std :: for_each ( ret . begin (), ret . end (), [ & ]( Eigen :: Vector2d p ) { printf ( \"%6.2f, %6.2f \\n \" , p [ 0 ], p [ 1 ]); }); } }","title":"KDtree"},{"location":"example/algorithm/kdtree_sample/#kdtree","text":"#include <iostream> #include <cpp_robotics/algorithm/kdtree.hpp> #include <cpp_robotics/vector/vector2.hpp> #include <Eigen/Dense> int main () { namespace cr = cpp_robotics ; // for cpp_rototics::VectorXx std :: cout << \"for cpp_rototics::VectorXx\" << std :: endl ; { cr :: KDTree < cr :: Vector2d , 2 > kdtree ; std :: vector < cr :: Vector2d > points = { { 0 , 1 }, { 2 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, }; kdtree . build ( points ); // kdtree.debug_node(); auto ret = kdtree . knn_search_points ( cr :: Vector2d ( 0 , 1 ), 1 ); printf ( \"size %ld \\n \" , ret . size ()); std :: for_each ( ret . begin (), ret . end (), [ & ]( cr :: Vector2d p ) { printf ( \"%6.2f, %6.2f \\n \" , p . x , p . y ); }); } // for Eigen::VectorXx std :: cout << \"for Eigen::VectorXx\" << std :: endl ; { cr :: KDTree < Eigen :: Vector2d , 2 > kdtree ; std :: vector < Eigen :: Vector2d > points = { { 0 , 1 }, { 2 , 3 }, { 3 , 4 }, { 4 , 5 }, { 5 , 6 }, }; kdtree . build ( points ); // kdtree.debug_node(); auto ret = kdtree . knn_search_points ( Eigen :: Vector2d ( 0 , 1 ), 1 ); printf ( \"size %ld \\n \" , ret . size ()); std :: for_each ( ret . begin (), ret . end (), [ & ]( Eigen :: Vector2d p ) { printf ( \"%6.2f, %6.2f \\n \" , p [ 0 ], p [ 1 ]); }); } }","title":"KDTree"},{"location":"example/control/canonicalize/","text":"\u6b63\u6e96\u5f62 #include <iostream> #include <iomanip> #include <cpp_robotics/system/system.hpp> #include <cpp_robotics/controller/controller.hpp> #define PRINT_MAT(MAT) \\ std::cout << #MAT << std::endl;\\ std::cout << MAT << std::endl << std::endl; int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; Eigen :: MatrixXd A ( 3 , 3 ); Eigen :: MatrixXd B ( 3 , 1 ); Eigen :: MatrixXd C ( 1 , 3 ); Eigen :: MatrixXd D ( 1 , 1 ); A << -0.313 , 56.7 , 0 , -0.0139 , -0.426 , 0 , 0 , 56.7 , 0 ; B << 0.232 , 0.0203 , 0 ; C << 0 , 0 , 1 ; D << 0 ; const double dt = 0.01 ; cr :: StateSpaceSystem sys ( A , B , C , D , dt ); std :: cout << \"//////////////////////////////\" << std :: endl ; std :: cout << \"controllability: \" << ( cr :: is_controllable ( sys ) ? \"true\" : \"false\" ) << std :: endl ; std :: cout << \"observability : \" << ( cr :: is_observable ( sys ) ? \"true\" : \"false\" ) << std :: endl ; std :: cout << \" \\n //////////////////////////////\" << std :: endl ; std :: cout << \"canonicalize\" << std :: endl ; auto [ A_tilde , B_tilde , C_tilde , D_tilde ] = cr :: canonicalize_system ( sys , cr :: CanonicalizeMode :: CONTROLLABLE ); std :: cout << std :: fixed << std :: setprecision ( 2 ); PRINT_MAT ( A_tilde ); PRINT_MAT ( B_tilde ); PRINT_MAT ( C_tilde ); PRINT_MAT ( D_tilde ); }","title":"\u6b63\u6e96\u5f62"},{"location":"example/control/canonicalize/#_1","text":"#include <iostream> #include <iomanip> #include <cpp_robotics/system/system.hpp> #include <cpp_robotics/controller/controller.hpp> #define PRINT_MAT(MAT) \\ std::cout << #MAT << std::endl;\\ std::cout << MAT << std::endl << std::endl; int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; Eigen :: MatrixXd A ( 3 , 3 ); Eigen :: MatrixXd B ( 3 , 1 ); Eigen :: MatrixXd C ( 1 , 3 ); Eigen :: MatrixXd D ( 1 , 1 ); A << -0.313 , 56.7 , 0 , -0.0139 , -0.426 , 0 , 0 , 56.7 , 0 ; B << 0.232 , 0.0203 , 0 ; C << 0 , 0 , 1 ; D << 0 ; const double dt = 0.01 ; cr :: StateSpaceSystem sys ( A , B , C , D , dt ); std :: cout << \"//////////////////////////////\" << std :: endl ; std :: cout << \"controllability: \" << ( cr :: is_controllable ( sys ) ? \"true\" : \"false\" ) << std :: endl ; std :: cout << \"observability : \" << ( cr :: is_observable ( sys ) ? \"true\" : \"false\" ) << std :: endl ; std :: cout << \" \\n //////////////////////////////\" << std :: endl ; std :: cout << \"canonicalize\" << std :: endl ; auto [ A_tilde , B_tilde , C_tilde , D_tilde ] = cr :: canonicalize_system ( sys , cr :: CanonicalizeMode :: CONTROLLABLE ); std :: cout << std :: fixed << std :: setprecision ( 2 ); PRINT_MAT ( A_tilde ); PRINT_MAT ( B_tilde ); PRINT_MAT ( C_tilde ); PRINT_MAT ( D_tilde ); }","title":"\u6b63\u6e96\u5f62"},{"location":"example/control/lqr/","text":"LQR #include <iostream> #include <cpp_robotics/core.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; const double dt = 0.01 ; //////////////////// plant //////////////////// Eigen :: MatrixXd A ( 2 , 2 ), B ( 2 , 1 ), C ( 2 , 2 ); A << 0 , 1 , -10 , -1 ; B << 0 , 1 ; C . setIdentity (); cr :: StateSpaceSystem sys ; sys . set_continuous ( A , B , C , dt ); //////////////////// controller //////////////////// Eigen :: MatrixXd Q ( 2 , 2 ), R ( 1 , 1 ); Q << 3000 , 0 , 0 , 60 ; R << 0.01 ; Eigen :: MatrixXd K = cr :: lqr ( A , B , Q , R ); std :: cout << \"fb gain\" << std :: endl ; std :: cout << K << std :: endl ; Eigen :: Vector2d target_vec ; target_vec << 30 , 0 ; { auto t = cr :: arrange ( 0 , 5.0 , dt ); std :: vector < double > x1 ( t . size ()), x2 ( t . size ()), x1_ref ( t . size ()); //////////////////// simulation //////////////////// for ( size_t i = 0 ; i < t . size (); i ++ ) { Eigen :: VectorXd u = K * ( target_vec - sys . x ()); auto x = sys . responce ( u ); x1 [ i ] = x ( 0 ); x2 [ i ] = x ( 1 ); x1_ref [ i ] = target_vec ( 0 ); } std :: cout << \"plot\" << std :: endl ; plt :: named_plot ( \"x1\" , t , x1 ); plt :: named_plot ( \"x2\" , t , x2 ); plt :: named_plot ( \"x1_ref\" , t , x1_ref ); plt :: legend (); plt :: show (); } }","title":"LQR"},{"location":"example/control/lqr/#lqr","text":"#include <iostream> #include <cpp_robotics/core.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; const double dt = 0.01 ; //////////////////// plant //////////////////// Eigen :: MatrixXd A ( 2 , 2 ), B ( 2 , 1 ), C ( 2 , 2 ); A << 0 , 1 , -10 , -1 ; B << 0 , 1 ; C . setIdentity (); cr :: StateSpaceSystem sys ; sys . set_continuous ( A , B , C , dt ); //////////////////// controller //////////////////// Eigen :: MatrixXd Q ( 2 , 2 ), R ( 1 , 1 ); Q << 3000 , 0 , 0 , 60 ; R << 0.01 ; Eigen :: MatrixXd K = cr :: lqr ( A , B , Q , R ); std :: cout << \"fb gain\" << std :: endl ; std :: cout << K << std :: endl ; Eigen :: Vector2d target_vec ; target_vec << 30 , 0 ; { auto t = cr :: arrange ( 0 , 5.0 , dt ); std :: vector < double > x1 ( t . size ()), x2 ( t . size ()), x1_ref ( t . size ()); //////////////////// simulation //////////////////// for ( size_t i = 0 ; i < t . size (); i ++ ) { Eigen :: VectorXd u = K * ( target_vec - sys . x ()); auto x = sys . responce ( u ); x1 [ i ] = x ( 0 ); x2 [ i ] = x ( 1 ); x1_ref [ i ] = target_vec ( 0 ); } std :: cout << \"plot\" << std :: endl ; plt :: named_plot ( \"x1\" , t , x1 ); plt :: named_plot ( \"x2\" , t , x2 ); plt :: named_plot ( \"x1_ref\" , t , x1_ref ); plt :: legend (); plt :: show (); } }","title":"LQR"},{"location":"example/control/pid_vs_nctf/","text":"PID vs NCTF #include <iostream> #include <cpp_robotics/core.hpp> #include <cpp_robotics/motor/dc_motor_list.hpp> #include <cpp_robotics/motor/motor_tf.hpp> static std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double > , std :: vector < double > , std :: vector < double >> step_test ( cpp_robotics :: SisoFeedbackSystem & sys , double time , double dt ) { std :: vector < double > t = cpp_robotics :: arrange ( 0 , time , dt ); std :: vector < double > target ( t . size ()); std :: vector < double > res ( t . size ()); std :: vector < double > dres ( t . size ()); std :: vector < double > input ( t . size ()); cpp_robotics :: Differentiator diff_ ( 1 / dt , dt ); for ( size_t i = 0 ; i < res . size (); i ++ ) { target [ i ] = ( res . size () / 2 < i ) ? ( ( res . size () * 3 / 4 < i ) ? 0 : 20 ) : 20 * std :: cos ( i * 0.03 ); // : 1.0; res [ i ] = sys . control ( target [ i ]); dres [ i ] = diff_ . filtering ( res [ i ]); input [ i ] = sys . u (); } return { t , target , input , res , dres }; } void make_nct_test ( std :: function < double ( double ) > f ) { std :: vector < double > e = cpp_robotics :: arrange ( -10 , 10 , 0.05 ); std :: vector < double > e_dot ( e . size ()); for ( size_t i = 0 ; i < e . size (); i ++ ) { e_dot [ i ] = f ( e [ i ]); } namespace plt = matplotlibcpp ; plt :: plot ( e , e_dot ); plt :: ylim ( -10 , 10 ); plt :: show (); } int main () { using namespace cpp_robotics ; const double dt = 0.01 ; const double max_output = 24 ; //////////////////// PID //////////////////// PIDController :: pid_param_t pid_param = { . Ts = dt , . gpd = 100 , . Kp = 10.0 , . Ki = 0.0 , . Kd = 0.09 , . output_limit = std :: pair ( - max_output , max_output ) }; PIDController pid ( pid_param ); //////////////////// NCTF //////////////////// PIDController :: pid_param_t nctf_pid_param = { . Ts = dt , . gpd = 500 , . Kp = 0.8 , . Ki = 0.0 , . Kd = 0.005 , . output_limit = std :: pair ( - max_output , max_output ) }; const double nct_max_velocity = 300.0 ; const double nct_slope = 10 ; NctfController nctf ( nct_max_velocity , nct_slope , nctf_pid_param , dt ); //////////////////// Plant //////////////////// auto motor = DCGearedMotorParam ( 24 _V , RZ_735VA_9517 , IG42C_17 ); auto plant = make_geared_motor_pos_tf ( motor , dt ); // [rad] // make_nct_test(nctf.nct()); // { // auto vel_plant = make_geared_motor_vel_tf(motor, dt); // [rad] // namespace plt = matplotlibcpp; // auto [t, res] = step(vel_plant, 3.0, max_output); // plt::named_plot(\"responce\", t, res); // plt::legend(); // plt::show(); // } { namespace plt = matplotlibcpp ; { SisoFeedbackSystem siso_sys = cpp_robotics :: make_feedback_system ( pid , plant ); siso_sys . reset (); auto [ t , target , input , ret , dres ] = step_test ( siso_sys , 5.0 , dt ); plt :: named_plot ( \"target\" , t , target ); plt :: named_plot ( \"PID responce\" , t , ret ); } { SisoFeedbackSystem siso_sys = cpp_robotics :: make_feedback_system ( nctf , plant ); auto [ t , target , input , ret , dres ] = step_test ( siso_sys , 5.0 , dt ); plant . set_state_zero (); siso_sys . reset (); // plt::named_plot(\"target\", t, target); plt :: named_plot ( \"NCTF responce\" , t , ret ); // plt::named_plot(\"input\", t, input); } // plt::named_plot(\"input\", t, input); // plt::named_plot(\"d responce / dt\", t, dres); plt :: ylim ( -30.0 , 30.0 ); plt :: legend (); plt :: show (); // // show NCT // plt::named_plot(\"actual NCT\", nctf.e_, nctf.e_dot_); // plt::named_plot(\"target NCT\", nctf.e_, nctf.target_e_dot_); // plt::show(); } }","title":"PID vs NCTF"},{"location":"example/control/pid_vs_nctf/#pid-vs-nctf","text":"#include <iostream> #include <cpp_robotics/core.hpp> #include <cpp_robotics/motor/dc_motor_list.hpp> #include <cpp_robotics/motor/motor_tf.hpp> static std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double > , std :: vector < double > , std :: vector < double >> step_test ( cpp_robotics :: SisoFeedbackSystem & sys , double time , double dt ) { std :: vector < double > t = cpp_robotics :: arrange ( 0 , time , dt ); std :: vector < double > target ( t . size ()); std :: vector < double > res ( t . size ()); std :: vector < double > dres ( t . size ()); std :: vector < double > input ( t . size ()); cpp_robotics :: Differentiator diff_ ( 1 / dt , dt ); for ( size_t i = 0 ; i < res . size (); i ++ ) { target [ i ] = ( res . size () / 2 < i ) ? ( ( res . size () * 3 / 4 < i ) ? 0 : 20 ) : 20 * std :: cos ( i * 0.03 ); // : 1.0; res [ i ] = sys . control ( target [ i ]); dres [ i ] = diff_ . filtering ( res [ i ]); input [ i ] = sys . u (); } return { t , target , input , res , dres }; } void make_nct_test ( std :: function < double ( double ) > f ) { std :: vector < double > e = cpp_robotics :: arrange ( -10 , 10 , 0.05 ); std :: vector < double > e_dot ( e . size ()); for ( size_t i = 0 ; i < e . size (); i ++ ) { e_dot [ i ] = f ( e [ i ]); } namespace plt = matplotlibcpp ; plt :: plot ( e , e_dot ); plt :: ylim ( -10 , 10 ); plt :: show (); } int main () { using namespace cpp_robotics ; const double dt = 0.01 ; const double max_output = 24 ; //////////////////// PID //////////////////// PIDController :: pid_param_t pid_param = { . Ts = dt , . gpd = 100 , . Kp = 10.0 , . Ki = 0.0 , . Kd = 0.09 , . output_limit = std :: pair ( - max_output , max_output ) }; PIDController pid ( pid_param ); //////////////////// NCTF //////////////////// PIDController :: pid_param_t nctf_pid_param = { . Ts = dt , . gpd = 500 , . Kp = 0.8 , . Ki = 0.0 , . Kd = 0.005 , . output_limit = std :: pair ( - max_output , max_output ) }; const double nct_max_velocity = 300.0 ; const double nct_slope = 10 ; NctfController nctf ( nct_max_velocity , nct_slope , nctf_pid_param , dt ); //////////////////// Plant //////////////////// auto motor = DCGearedMotorParam ( 24 _V , RZ_735VA_9517 , IG42C_17 ); auto plant = make_geared_motor_pos_tf ( motor , dt ); // [rad] // make_nct_test(nctf.nct()); // { // auto vel_plant = make_geared_motor_vel_tf(motor, dt); // [rad] // namespace plt = matplotlibcpp; // auto [t, res] = step(vel_plant, 3.0, max_output); // plt::named_plot(\"responce\", t, res); // plt::legend(); // plt::show(); // } { namespace plt = matplotlibcpp ; { SisoFeedbackSystem siso_sys = cpp_robotics :: make_feedback_system ( pid , plant ); siso_sys . reset (); auto [ t , target , input , ret , dres ] = step_test ( siso_sys , 5.0 , dt ); plt :: named_plot ( \"target\" , t , target ); plt :: named_plot ( \"PID responce\" , t , ret ); } { SisoFeedbackSystem siso_sys = cpp_robotics :: make_feedback_system ( nctf , plant ); auto [ t , target , input , ret , dres ] = step_test ( siso_sys , 5.0 , dt ); plant . set_state_zero (); siso_sys . reset (); // plt::named_plot(\"target\", t, target); plt :: named_plot ( \"NCTF responce\" , t , ret ); // plt::named_plot(\"input\", t, input); } // plt::named_plot(\"input\", t, input); // plt::named_plot(\"d responce / dt\", t, dres); plt :: ylim ( -30.0 , 30.0 ); plt :: legend (); plt :: show (); // // show NCT // plt::named_plot(\"actual NCT\", nctf.e_, nctf.e_dot_); // plt::named_plot(\"target NCT\", nctf.e_, nctf.target_e_dot_); // plt::show(); } }","title":"PID vs NCTF"},{"location":"example/control/place/","text":"\u6975\u914d\u7f6e #include <iostream> #include <iomanip> #include <cpp_robotics/system/system.hpp> #include <cpp_robotics/controller/controller.hpp> #define PRINT_MAT(MAT) \\ std::cout << #MAT << std::endl;\\ std::cout << MAT << std::endl << std::endl; int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; // http://arduinopid.web.fc2.com/O7.html Eigen :: MatrixXd A ( 2 , 2 ); Eigen :: MatrixXd B ( 2 , 1 ); Eigen :: MatrixXd C ( 1 , 2 ); Eigen :: MatrixXd D ( 1 , 1 ); A << -10 , -10 , 5 , 0 ; B << 10 , 0 ; C << 0 , 1 ; D << 0 ; const double dt = 0.01 ; cr :: StateSpaceSystem sys ( A , B , C , D , dt ); std :: cout << std :: fixed << std :: setprecision ( 2 ); std :: cout << \"pole place\" << std :: endl ; std :: vector < double > pole = { -6 , -6 }; auto K = cr :: place ( sys , pole ); PRINT_MAT ( K ); }","title":"\u6975\u914d\u7f6e"},{"location":"example/control/place/#_1","text":"#include <iostream> #include <iomanip> #include <cpp_robotics/system/system.hpp> #include <cpp_robotics/controller/controller.hpp> #define PRINT_MAT(MAT) \\ std::cout << #MAT << std::endl;\\ std::cout << MAT << std::endl << std::endl; int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; // http://arduinopid.web.fc2.com/O7.html Eigen :: MatrixXd A ( 2 , 2 ); Eigen :: MatrixXd B ( 2 , 1 ); Eigen :: MatrixXd C ( 1 , 2 ); Eigen :: MatrixXd D ( 1 , 1 ); A << -10 , -10 , 5 , 0 ; B << 10 , 0 ; C << 0 , 1 ; D << 0 ; const double dt = 0.01 ; cr :: StateSpaceSystem sys ( A , B , C , D , dt ); std :: cout << std :: fixed << std :: setprecision ( 2 ); std :: cout << \"pole place\" << std :: endl ; std :: vector < double > pole = { -6 , -6 }; auto K = cr :: place ( sys , pole ); PRINT_MAT ( K ); }","title":"\u6975\u914d\u7f6e"},{"location":"example/control/pure_pursuit/","text":"Pure pursuit","title":"Pure pursuit"},{"location":"example/control/pure_pursuit/#pure-pursuit","text":"","title":"Pure pursuit"},{"location":"example/optimize/active_set_method_example/","text":"\u6709\u52b9\u5236\u7d04\u6cd5 #include <iostream> #include <cpp_robotics/algorithm/algorithm.hpp> #include <cpp_robotics/optimize/active_set_method.hpp> int main () { namespace cr = cpp_robotics ; cr :: ActiveSetMethod solver ; cr :: ActiveSetMethod :: Problem prob ( 2 ); std :: cout << \"prob setup\" << std :: endl ; prob . Q << 1 , 0 , 0 , 1 ; prob . c << -6 , -2 ; Eigen :: VectorXd A ( 2 ); A << 0 , 0 ; Eigen :: VectorXd b ( 1 ); b << 1 ; // prob.add_inequality_constraint(A.transpose(), b); // x2 = 1\u306e\u5236\u7d04 // A << -1, 0; // prob.add_equality_constraint(A.transpose(), b); // x1 = 1\u306e\u5236\u7d04 Eigen :: Vector2d x0 ; x0 << 3 , 2 ; std :: cout << \"prob setup end\" << std :: endl ; auto result = solver . solve ( prob , x0 ); if ( result . is_solved ) { std :: cout << \"\u89e3\u3051\u305f\" << std :: endl ; } else { std :: cout << \"\u89e3\u7121\u3057\" << std :: endl ; } std :: cout << result . x_opt . transpose () << std :: endl ; std :: cout << \"iter: \" << result . iter_cnt << std :: endl ; }","title":"\u6709\u52b9\u5236\u7d04\u6cd5"},{"location":"example/optimize/active_set_method_example/#_1","text":"#include <iostream> #include <cpp_robotics/algorithm/algorithm.hpp> #include <cpp_robotics/optimize/active_set_method.hpp> int main () { namespace cr = cpp_robotics ; cr :: ActiveSetMethod solver ; cr :: ActiveSetMethod :: Problem prob ( 2 ); std :: cout << \"prob setup\" << std :: endl ; prob . Q << 1 , 0 , 0 , 1 ; prob . c << -6 , -2 ; Eigen :: VectorXd A ( 2 ); A << 0 , 0 ; Eigen :: VectorXd b ( 1 ); b << 1 ; // prob.add_inequality_constraint(A.transpose(), b); // x2 = 1\u306e\u5236\u7d04 // A << -1, 0; // prob.add_equality_constraint(A.transpose(), b); // x1 = 1\u306e\u5236\u7d04 Eigen :: Vector2d x0 ; x0 << 3 , 2 ; std :: cout << \"prob setup end\" << std :: endl ; auto result = solver . solve ( prob , x0 ); if ( result . is_solved ) { std :: cout << \"\u89e3\u3051\u305f\" << std :: endl ; } else { std :: cout << \"\u89e3\u7121\u3057\" << std :: endl ; } std :: cout << result . x_opt . transpose () << std :: endl ; std :: cout << \"iter: \" << result . iter_cnt << std :: endl ; }","title":"\u6709\u52b9\u5236\u7d04\u6cd5"},{"location":"example/optimize/optimize_rosenbrock/","text":"Rosenbrock\u95a2\u6570\u306e\u6700\u9069\u5316 #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { namespace cr = cpp_robotics ; // 2\u5909\u6570 Rosenbrock\u95a2\u6570 // \u6700\u9069\u89e3\u306f x = (1, 1) auto f = []( Eigen :: VectorXd x ) -> double { return 100 * ( std :: pow ( ( x ( 0 ) - std :: pow ( x ( 1 ), 2 )), 2 ) ) + std :: pow ( 1 - x ( 1 ), 2 ); }; auto g = [ & ]( const Eigen :: VectorXd & x ) { return cr :: derivative ( f , x ); }; Eigen :: VectorXd x_init = Eigen :: VectorXd :: Zero ( 2 ); { auto [ ret , rx , rcnt ] = cr :: quasi_newton_method ( f , g , x_init ); std :: cout << \"optimize Rosenbrock function with quasi newton method\" << std :: endl ; std :: cout << \"ans: \" << rx . transpose () << std :: endl ; std :: cout << \"itr: \" << rcnt << std :: endl ; } }","title":"Rosenbrock\u95a2\u6570\u306e\u6700\u9069\u5316"},{"location":"example/optimize/optimize_rosenbrock/#rosenbrock","text":"#include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { namespace cr = cpp_robotics ; // 2\u5909\u6570 Rosenbrock\u95a2\u6570 // \u6700\u9069\u89e3\u306f x = (1, 1) auto f = []( Eigen :: VectorXd x ) -> double { return 100 * ( std :: pow ( ( x ( 0 ) - std :: pow ( x ( 1 ), 2 )), 2 ) ) + std :: pow ( 1 - x ( 1 ), 2 ); }; auto g = [ & ]( const Eigen :: VectorXd & x ) { return cr :: derivative ( f , x ); }; Eigen :: VectorXd x_init = Eigen :: VectorXd :: Zero ( 2 ); { auto [ ret , rx , rcnt ] = cr :: quasi_newton_method ( f , g , x_init ); std :: cout << \"optimize Rosenbrock function with quasi newton method\" << std :: endl ; std :: cout << \"ans: \" << rx . transpose () << std :: endl ; std :: cout << \"itr: \" << rcnt << std :: endl ; } }","title":"Rosenbrock\u95a2\u6570\u306e\u6700\u9069\u5316"},{"location":"example/optimize/optimize_scalar/","text":"\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u306e\u6700\u9069\u5316 #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { namespace cr = cpp_robotics ; std :: cout << \"optimize_scalar\" << std :: endl ; std :: cout << \"min x => (x+1)^2 = \" << cr :: golden_search ([]( double x ){ return std :: pow ( x + 1 , 2 ); }, -10 , 10 ) << std :: endl ; std :: cout << \"sin'(0) = cos(0) = \" << cr :: derivative ([]( double x ){ return std :: sin ( x ); }, 0 ) << std :: endl ; }","title":"\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u306e\u6700\u9069\u5316"},{"location":"example/optimize/optimize_scalar/#_1","text":"#include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { namespace cr = cpp_robotics ; std :: cout << \"optimize_scalar\" << std :: endl ; std :: cout << \"min x => (x+1)^2 = \" << cr :: golden_search ([]( double x ){ return std :: pow ( x + 1 , 2 ); }, -10 , 10 ) << std :: endl ; std :: cout << \"sin'(0) = cos(0) = \" << cr :: derivative ([]( double x ){ return std :: sin ( x ); }, 0 ) << std :: endl ; }","title":"\u30b9\u30ab\u30e9\u30fc\u95a2\u6570\u306e\u6700\u9069\u5316"},{"location":"example/optimize/optimize_with_constraint/","text":"\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316 #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { using namespace cpp_robotics ; std :: cout << \"test\" << std :: endl ; auto f = []( Eigen :: VectorXd x ) { return std :: pow ( x ( 0 ) -2 , 2 ) + std :: pow ( x ( 1 ), 2 ); }; Eigen :: VectorXd x_init = Eigen :: VectorXd :: Zero ( 2 ); ConstraintArray con ; con . push_back ({ Constraint :: Type :: Ineq , []( Eigen :: VectorXd x ) { return ( std :: pow ( x ( 0 ), 2 ) + std :: pow ( x ( 1 ), 2 )) - 1 ; } }); { x_init ( 0 ) = 0.4 ; x_init ( 1 ) = 0.5 ; auto [ ret , rx , rcnt ] = penalty_method ( f , con , x_init ); std :: cout << rx . transpose () << \"(norm: \" << rx . norm () << \"), \" << rcnt << std :: endl ; } { x_init ( 0 ) = 0.4 ; x_init ( 1 ) = 0.5 ; auto [ ret , rx , rcnt ] = barrier_method ( f , con , x_init ); std :: cout << rx . transpose () << \"(norm: \" << rx . norm () << \"), \" << rcnt << std :: endl ; } }","title":"\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316"},{"location":"example/optimize/optimize_with_constraint/#_1","text":"#include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { using namespace cpp_robotics ; std :: cout << \"test\" << std :: endl ; auto f = []( Eigen :: VectorXd x ) { return std :: pow ( x ( 0 ) -2 , 2 ) + std :: pow ( x ( 1 ), 2 ); }; Eigen :: VectorXd x_init = Eigen :: VectorXd :: Zero ( 2 ); ConstraintArray con ; con . push_back ({ Constraint :: Type :: Ineq , []( Eigen :: VectorXd x ) { return ( std :: pow ( x ( 0 ), 2 ) + std :: pow ( x ( 1 ), 2 )) - 1 ; } }); { x_init ( 0 ) = 0.4 ; x_init ( 1 ) = 0.5 ; auto [ ret , rx , rcnt ] = penalty_method ( f , con , x_init ); std :: cout << rx . transpose () << \"(norm: \" << rx . norm () << \"), \" << rcnt << std :: endl ; } { x_init ( 0 ) = 0.4 ; x_init ( 1 ) = 0.5 ; auto [ ret , rx , rcnt ] = barrier_method ( f , con , x_init ); std :: cout << rx . transpose () << \"(norm: \" << rx . norm () << \"), \" << rcnt << std :: endl ; } }","title":"\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316"},{"location":"example/optimize/optimize_without_constraint/","text":"\u7121\u5236\u7d04\u6700\u9069\u5316 #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { namespace cr = cpp_robotics ; std :: cout << \"test\" << std :: endl ; auto f1 = []( Eigen :: VectorXd x ) { return std :: sin ( x ( 0 )) + std :: cos ( x ( 1 )) + std :: sin ( x ( 1 ) + M_PI ) + std :: sin ( x ( 2 )); }; std :: cout << \"f({0, 0, 0}) = \" << f1 ( Eigen :: VectorXd :: Zero ( 3 )) << std :: endl ; std :: cout << \"f'({0, 0, 0}) = \" << cr :: derivative ( f1 , Eigen :: VectorXd :: Zero ( 3 )). transpose () << std :: endl ; auto f = []( Eigen :: VectorXd x ) { //return 4.5*(std::pow(std::cos(x(0)), 4) + std::pow(std::cos(x(1)), 4)); // return std::sin(x(0)) + std::sin(x(1)); return std :: pow ( x ( 0 ) -2 , 2 ) + std :: pow ( x ( 1 ) -3 , 2 ); }; auto g = [ & ]( const Eigen :: VectorXd & x ) { return cr :: derivative ( f , x ); }; // auto g = [](Eigen::VectorXd x) // { // Eigen::VectorXd gval(2); // gval(0) = 2*(x(0)-2); // gval(1) = 2*(x(1)-3); // return gval; // }; // auto h = [](Eigen::VectorXd x) // { // (void) x; // Eigen::MatrixXd hval(2, 2); // hval(0, 0) = 2; // hval(1, 0) = 0; // hval(0, 1) = 0; // hval(1, 1) = 2; // return hval; // }; Eigen :: VectorXd x_init = Eigen :: VectorXd :: Zero ( 2 ); x_init ( 0 ) = 0 ; x_init ( 1 ) = 0 ; { auto [ ret , rx , rcnt ] = cr :: steepest_descent_method ( f , g , x_init ); std :: cout << \"steepest_descent_method\" << std :: endl ; std :: cout << rx . transpose () << \", \" << rcnt << std :: endl ; } x_init ( 0 ) = 0 ; x_init ( 1 ) = 0 ; { auto [ ret , rx , rcnt ] = cr :: newton_method ( g , h , x_init ); std :: cout << \"newton_method\" << std :: endl ; std :: cout << rx . transpose () << \", \" << rcnt << std :: endl ; } x_init ( 0 ) = 0 ; x_init ( 1 ) = 0 ; { auto [ ret , rx , rcnt ] = cr :: quasi_newton_method ( f , g , x_init ); std :: cout << \"quasi_newton_method\" << std :: endl ; std :: cout << rx . transpose () << \", \" << rcnt << std :: endl ; } }","title":"\u7121\u5236\u7d04\u6700\u9069\u5316"},{"location":"example/optimize/optimize_without_constraint/#_1","text":"#include <iostream> #include <Eigen/Dense> #include <cpp_robotics/optimize/optimize.hpp> int main () { namespace cr = cpp_robotics ; std :: cout << \"test\" << std :: endl ; auto f1 = []( Eigen :: VectorXd x ) { return std :: sin ( x ( 0 )) + std :: cos ( x ( 1 )) + std :: sin ( x ( 1 ) + M_PI ) + std :: sin ( x ( 2 )); }; std :: cout << \"f({0, 0, 0}) = \" << f1 ( Eigen :: VectorXd :: Zero ( 3 )) << std :: endl ; std :: cout << \"f'({0, 0, 0}) = \" << cr :: derivative ( f1 , Eigen :: VectorXd :: Zero ( 3 )). transpose () << std :: endl ; auto f = []( Eigen :: VectorXd x ) { //return 4.5*(std::pow(std::cos(x(0)), 4) + std::pow(std::cos(x(1)), 4)); // return std::sin(x(0)) + std::sin(x(1)); return std :: pow ( x ( 0 ) -2 , 2 ) + std :: pow ( x ( 1 ) -3 , 2 ); }; auto g = [ & ]( const Eigen :: VectorXd & x ) { return cr :: derivative ( f , x ); }; // auto g = [](Eigen::VectorXd x) // { // Eigen::VectorXd gval(2); // gval(0) = 2*(x(0)-2); // gval(1) = 2*(x(1)-3); // return gval; // }; // auto h = [](Eigen::VectorXd x) // { // (void) x; // Eigen::MatrixXd hval(2, 2); // hval(0, 0) = 2; // hval(1, 0) = 0; // hval(0, 1) = 0; // hval(1, 1) = 2; // return hval; // }; Eigen :: VectorXd x_init = Eigen :: VectorXd :: Zero ( 2 ); x_init ( 0 ) = 0 ; x_init ( 1 ) = 0 ; { auto [ ret , rx , rcnt ] = cr :: steepest_descent_method ( f , g , x_init ); std :: cout << \"steepest_descent_method\" << std :: endl ; std :: cout << rx . transpose () << \", \" << rcnt << std :: endl ; } x_init ( 0 ) = 0 ; x_init ( 1 ) = 0 ; { auto [ ret , rx , rcnt ] = cr :: newton_method ( g , h , x_init ); std :: cout << \"newton_method\" << std :: endl ; std :: cout << rx . transpose () << \", \" << rcnt << std :: endl ; } x_init ( 0 ) = 0 ; x_init ( 1 ) = 0 ; { auto [ ret , rx , rcnt ] = cr :: quasi_newton_method ( f , g , x_init ); std :: cout << \"quasi_newton_method\" << std :: endl ; std :: cout << rx . transpose () << \", \" << rcnt << std :: endl ; } }","title":"\u7121\u5236\u7d04\u6700\u9069\u5316"},{"location":"example/optimize/sqp_example/","text":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) #include <iostream> #include <cpp_robotics/algorithm/algorithm.hpp> #include <cpp_robotics/optimize/sqp.hpp> using namespace cpp_robotics ; int main () { SQP solver ; SQP :: Problem prob ; //////////////////// \u554f\u984c\u8a2d\u5b9a //////////////////// prob . func = []( Eigen :: VectorXd x ) { return std :: pow ( x ( 0 ) -3 , 2 ) + std :: pow ( x ( 1 ) -3 , 2 ); }; prob . con . push_back ({ Constraint :: Ineq , []( Eigen :: VectorXd x ) { return ( x . squaredNorm () - 1 ); }, }); // prob.con.push_back({ // Constraint::Ineq, // [](Eigen::VectorXd x) // { // x(0) -= 1.5; // return x.squaredNorm() - 1; // }, // }); prob . max_iter = 3 ; Eigen :: VectorXd x0 ( 2 ); x0 << 1.0 , 0 ; //////////////////// \u89e3\u304f //////////////////// auto result = solver . solve ( prob , x0 ); std :: cout << \"min (x(0)-3)^2 + x(1)^2\" << std :: endl ; std :: cout << \"s.t. x(0)^2 + x(1)^2 <= 1\" << std :: endl ; if ( result . is_solved ) { std :: cout << \"\u89e3\u3051\u305f\" << std :: endl ; } else { std :: cout << \"\u89e3\u3051\u306a\u304b\u3063\u305f\" << std :: endl ; } std :: cout << \"x_opt =\" << std :: endl ; std :: cout << result . x_opt << std :: endl ; std :: cout << \"lambda_opt =\" << std :: endl ; std :: cout << result . lambda_opt << std :: endl ; std :: cout << \"iter: \" << result . iter_cnt << std :: endl ; }","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)"},{"location":"example/optimize/sqp_example/#sqp","text":"#include <iostream> #include <cpp_robotics/algorithm/algorithm.hpp> #include <cpp_robotics/optimize/sqp.hpp> using namespace cpp_robotics ; int main () { SQP solver ; SQP :: Problem prob ; //////////////////// \u554f\u984c\u8a2d\u5b9a //////////////////// prob . func = []( Eigen :: VectorXd x ) { return std :: pow ( x ( 0 ) -3 , 2 ) + std :: pow ( x ( 1 ) -3 , 2 ); }; prob . con . push_back ({ Constraint :: Ineq , []( Eigen :: VectorXd x ) { return ( x . squaredNorm () - 1 ); }, }); // prob.con.push_back({ // Constraint::Ineq, // [](Eigen::VectorXd x) // { // x(0) -= 1.5; // return x.squaredNorm() - 1; // }, // }); prob . max_iter = 3 ; Eigen :: VectorXd x0 ( 2 ); x0 << 1.0 , 0 ; //////////////////// \u89e3\u304f //////////////////// auto result = solver . solve ( prob , x0 ); std :: cout << \"min (x(0)-3)^2 + x(1)^2\" << std :: endl ; std :: cout << \"s.t. x(0)^2 + x(1)^2 <= 1\" << std :: endl ; if ( result . is_solved ) { std :: cout << \"\u89e3\u3051\u305f\" << std :: endl ; } else { std :: cout << \"\u89e3\u3051\u306a\u304b\u3063\u305f\" << std :: endl ; } std :: cout << \"x_opt =\" << std :: endl ; std :: cout << result . x_opt << std :: endl ; std :: cout << \"lambda_opt =\" << std :: endl ; std :: cout << result . lambda_opt << std :: endl ; std :: cout << \"iter: \" << result . iter_cnt << std :: endl ; }","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)"},{"location":"example/path_planning/dubins_path/","text":"Dubins\u66f2\u7dda #include <iostream> #include \"cpp_robotics/cpp_robotics.hpp\" int main () { using namespace cpp_robotics ; namespace plt = matplotlibcpp ; const Transformd start ( 4.0 , 3.0 , radians ( -45 )); const Transformd end ( 1.0 , 1.0 , radians ( 45 )); const double cavature = 1 ; DubinsPath dpath ( start , end , cavature ); std :: cout << dpath . path_type () << std :: endl ; for ( size_t i = 0 ; i < 3 ; i ++ ) std :: cout << dpath . segment_length ( i ) << std :: endl ; auto l = linspace ( 0 , dpath . length ()); std :: vector < double > x ( l . size ()), y ( l . size ()); for ( size_t i = 0 ; i < l . size (); i ++ ) { auto pos = dpath . position ( l [ i ]); x [ i ] = pos . x ; y [ i ] = pos . y ; } plt :: plot ( x , y ); plt :: set_aspect ( 1.0 ); plt :: show (); }","title":"Dubins\u66f2\u7dda"},{"location":"example/path_planning/dubins_path/#dubins","text":"#include <iostream> #include \"cpp_robotics/cpp_robotics.hpp\" int main () { using namespace cpp_robotics ; namespace plt = matplotlibcpp ; const Transformd start ( 4.0 , 3.0 , radians ( -45 )); const Transformd end ( 1.0 , 1.0 , radians ( 45 )); const double cavature = 1 ; DubinsPath dpath ( start , end , cavature ); std :: cout << dpath . path_type () << std :: endl ; for ( size_t i = 0 ; i < 3 ; i ++ ) std :: cout << dpath . segment_length ( i ) << std :: endl ; auto l = linspace ( 0 , dpath . length ()); std :: vector < double > x ( l . size ()), y ( l . size ()); for ( size_t i = 0 ; i < l . size (); i ++ ) { auto pos = dpath . position ( l [ i ]); x [ i ] = pos . x ; y [ i ] = pos . y ; } plt :: plot ( x , y ); plt :: set_aspect ( 1.0 ); plt :: show (); }","title":"Dubins\u66f2\u7dda"},{"location":"example/system/bode_nyquist/","text":"\u30dc\u30fc\u30c9\u7dda\u56f3\u30fb\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3 #include <iostream> #include <Eigen/Dense> #include <cpp_robotics/system/system.hpp> int main () { namespace cr = cpp_robotics ; // \u4f1d\u9054\u95a2\u6570 // tf(s) = 1 / (s + 1) cr :: TransferFunction tf ({ 1.0 }, { 1.0 , 1.0 }, 0.01 ); // \u30dc\u30fc\u30c9\u7dda\u56f3 cr :: bode_plot ( tf ); // \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3 cr :: nyquist_plot ( tf ); }","title":"\u30dc\u30fc\u30c9\u7dda\u56f3\u30fb\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3"},{"location":"example/system/bode_nyquist/#_1","text":"#include <iostream> #include <Eigen/Dense> #include <cpp_robotics/system/system.hpp> int main () { namespace cr = cpp_robotics ; // \u4f1d\u9054\u95a2\u6570 // tf(s) = 1 / (s + 1) cr :: TransferFunction tf ({ 1.0 }, { 1.0 , 1.0 }, 0.01 ); // \u30dc\u30fc\u30c9\u7dda\u56f3 cr :: bode_plot ( tf ); // \u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3 cr :: nyquist_plot ( tf ); }","title":"\u30dc\u30fc\u30c9\u7dda\u56f3\u30fb\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3"},{"location":"example/system/disc_tf/","text":"z\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54 #include <cpp_robotics/system/system.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; // LPF // K // G(s) = -------- // Ts + 1 // // \u96e2\u6563\u5316\u3057\u3066 // K*dt*z^-1 + K*dt // G(z) = ----------------------- // (dt-2T)z^-1 + (dt+2T) const double K = 1.5 ; const double T = 0.6 ; const double dt = 0.01 ; cr :: DiscreteTransferFunction tf ({ K * dt , K * dt }, { dt -2 * T , dt + 2 * T }, dt ); // \u521d\u671f\u72b6\u614b\u304b\u30894\u79d2\u5206\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u8a08\u7b97 auto [ t , y ] = cr :: step ( tf , 4.0 ); plt :: plot ( t , y ); plt :: show (); }","title":"z\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54"},{"location":"example/system/disc_tf/#z","text":"#include <cpp_robotics/system/system.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; // LPF // K // G(s) = -------- // Ts + 1 // // \u96e2\u6563\u5316\u3057\u3066 // K*dt*z^-1 + K*dt // G(z) = ----------------------- // (dt-2T)z^-1 + (dt+2T) const double K = 1.5 ; const double T = 0.6 ; const double dt = 0.01 ; cr :: DiscreteTransferFunction tf ({ K * dt , K * dt }, { dt -2 * T , dt + 2 * T }, dt ); // \u521d\u671f\u72b6\u614b\u304b\u30894\u79d2\u5206\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u8a08\u7b97 auto [ t , y ] = cr :: step ( tf , 4.0 ); plt :: plot ( t , y ); plt :: show (); }","title":"z\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54"},{"location":"example/system/state_space_system/","text":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe #include <cpp_robotics/system/system.hpp> #include <cpp_robotics/controller/controller.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; Eigen :: Matrix2d A ; Eigen :: Matrix < double , 2 , 1 > B ; Eigen :: Matrix < double , 1 , 2 > C ; A << 0 , 1 , 1 , 0.5 ; B << 0 , 0.5 ; C << 1 , 0 ; const double dt = 0.01 ; cr :: StateSpaceSystem sys ( A , B , C , dt ); std :: cout << cr :: is_controllable ( A , B ) << std :: endl ; std :: cout << cr :: is_observable ( A , C ) << std :: endl ; }","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe"},{"location":"example/system/state_space_system/#_1","text":"#include <cpp_robotics/system/system.hpp> #include <cpp_robotics/controller/controller.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; Eigen :: Matrix2d A ; Eigen :: Matrix < double , 2 , 1 > B ; Eigen :: Matrix < double , 1 , 2 > C ; A << 0 , 1 , 1 , 0.5 ; B << 0 , 0.5 ; C << 1 , 0 ; const double dt = 0.01 ; cr :: StateSpaceSystem sys ( A , B , C , dt ); std :: cout << cr :: is_controllable ( A , B ) << std :: endl ; std :: cout << cr :: is_observable ( A , C ) << std :: endl ; }","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe"},{"location":"example/system/step_responce/","text":"\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54 #include <cpp_robotics/system/system.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; // 2\u6b21\u7cfb\u306e\u4f1d\u9054\u95a2\u6570\u30920.01\u79d2\u3067\u96e2\u6563\u5316 // omega^2 // G(s) = ------------------------------ // s^2 + 2*zeta*omega*s + omega^2 const double omega = 4.0 ; const double zeta = 0.5 ; cr :: TransferFunction tf ({ omega * omega }, { 1.0 , 2.0 * zeta * omega , omega * omega }, 0.01 ); // \u521d\u671f\u72b6\u614b\u304b\u30894\u79d2\u5206\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u8a08\u7b97 auto [ t , y ] = cr :: step ( tf , 4.0 ); plt :: plot ( t , y ); plt :: show (); }","title":"\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54"},{"location":"example/system/step_responce/#_1","text":"#include <cpp_robotics/system/system.hpp> int main () { namespace cr = cpp_robotics ; namespace plt = matplotlibcpp ; // 2\u6b21\u7cfb\u306e\u4f1d\u9054\u95a2\u6570\u30920.01\u79d2\u3067\u96e2\u6563\u5316 // omega^2 // G(s) = ------------------------------ // s^2 + 2*zeta*omega*s + omega^2 const double omega = 4.0 ; const double zeta = 0.5 ; cr :: TransferFunction tf ({ omega * omega }, { 1.0 , 2.0 * zeta * omega , omega * omega }, 0.01 ); // \u521d\u671f\u72b6\u614b\u304b\u30894\u79d2\u5206\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u3092\u8a08\u7b97 auto [ t , y ] = cr :: step ( tf , 4.0 ); plt :: plot ( t , y ); plt :: show (); }","title":"\u4f1d\u9054\u95a2\u6570\u306e\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54"},{"location":"example/units/units/","text":"\u5358\u4f4d\u7cfb #include <iostream> // #include <cpp_robotics/core.hpp> #include \"cpp_robotics/utility/utility.hpp\" #include \"cpp_robotics/vector/vector.hpp\" #include \"cpp_robotics/units/units.hpp\" int main () { using namespace cpp_robotics ; constexpr Meter width = 1.5 _m ; constexpr Meter height = 3000 _mm ; constexpr Meter perimeter = 2 * ( width + height ); // 8.0 constexpr Area rectangle_area = width * height ; // 4.5 constexpr Volt voltage = 20 _V ; constexpr Ohm res = 5 _ohm ; constexpr Ampere current = voltage / res ; // 4.0 }","title":"constexpr\u5358\u4f4d\u7cfb"},{"location":"example/units/units/#_1","text":"#include <iostream> // #include <cpp_robotics/core.hpp> #include \"cpp_robotics/utility/utility.hpp\" #include \"cpp_robotics/vector/vector.hpp\" #include \"cpp_robotics/units/units.hpp\" int main () { using namespace cpp_robotics ; constexpr Meter width = 1.5 _m ; constexpr Meter height = 3000 _mm ; constexpr Meter perimeter = 2 * ( width + height ); // 8.0 constexpr Area rectangle_area = width * height ; // 4.5 constexpr Volt voltage = 20 _V ; constexpr Ohm res = 5 _ohm ; constexpr Ampere current = voltage / res ; // 4.0 }","title":"\u5358\u4f4d\u7cfb"},{"location":"tech_note/algorithm/icp/","text":"ICP (Iterative Closest Point)","title":"ICP"},{"location":"tech_note/algorithm/icp/#icp-iterative-closest-point","text":"","title":"ICP (Iterative Closest Point)"},{"location":"tech_note/algorithm/jerk_minimum_model/","text":"\u8e8d\u5ea6\u6700\u5c0f\u5316\u30e2\u30c7\u30eb \u53c2\u8003\u6587\u732e","title":"\u8e8d\u5ea6\u6700\u5c0f\u5316\u30e2\u30c7\u30eb"},{"location":"tech_note/algorithm/jerk_minimum_model/#_1","text":"","title":"\u8e8d\u5ea6\u6700\u5c0f\u5316\u30e2\u30c7\u30eb"},{"location":"tech_note/algorithm/jerk_minimum_model/#_2","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/algorithm/k_means_method/","text":"K-means\u6cd5 K-means++\u6cd5 \u53c2\u8003\u6587\u732e","title":"K-means\u6cd5"},{"location":"tech_note/algorithm/k_means_method/#k-means","text":"","title":"K-means\u6cd5"},{"location":"tech_note/algorithm/k_means_method/#k-means_1","text":"","title":"K-means++\u6cd5"},{"location":"tech_note/algorithm/k_means_method/#_1","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/algorithm/kdtree/","text":"KDTree","title":"KDTree"},{"location":"tech_note/algorithm/kdtree/#kdtree","text":"","title":"KDTree"},{"location":"tech_note/algorithm/mahalanobis/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2 \u7570\u5e38\u691c\u77e5\u306a\u3069\u306b\u3088\u304f\u4f7f\u308f\u308c\u308b\u591a\u5909\u6570\u306e\u7a7a\u9593\u306b\u5bfe\u3057\u3066\u305d\u308c\u305e\u308c\u306e\u5909\u6570\u306e\u5171\u5206\u6563\u884c\u5217\u3092\u4f7f\u3063\u3066\u8868\u73fe\u3055\u308c\u308b\u8ddd\u96e2 d = ( x \u2212 \u03bc ) T \u03a3 \u2212 1 ( x \u2212 \u03bc ) d = \\sqrt{(x-\\mu)^T\\Sigma^{-1}(x-\\mu)} d = ( x \u2212 \u03bc ) T \u03a3 \u2212 1 ( x \u2212 \u03bc ) \u200b \u53c2\u8003\u6587\u732e \u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2","title":"\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2"},{"location":"tech_note/algorithm/mahalanobis/#_1","text":"\u7570\u5e38\u691c\u77e5\u306a\u3069\u306b\u3088\u304f\u4f7f\u308f\u308c\u308b\u591a\u5909\u6570\u306e\u7a7a\u9593\u306b\u5bfe\u3057\u3066\u305d\u308c\u305e\u308c\u306e\u5909\u6570\u306e\u5171\u5206\u6563\u884c\u5217\u3092\u4f7f\u3063\u3066\u8868\u73fe\u3055\u308c\u308b\u8ddd\u96e2 d = ( x \u2212 \u03bc ) T \u03a3 \u2212 1 ( x \u2212 \u03bc ) d = \\sqrt{(x-\\mu)^T\\Sigma^{-1}(x-\\mu)} d = ( x \u2212 \u03bc ) T \u03a3 \u2212 1 ( x \u2212 \u03bc ) \u200b","title":"\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2"},{"location":"tech_note/algorithm/mahalanobis/#_2","text":"\u30de\u30cf\u30e9\u30ce\u30d3\u30b9\u8ddd\u96e2","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/algorithm/ndt/","text":"NDT scan matching NDT\u30de\u30c3\u30c1\u30f3\u30b0\u5927\u307e\u304b\u306a\u6d41\u308c \u30de\u30c3\u30d7\u3092NDT\u5316\u3059\u308b \u30ec\u30fc\u30b6\u30fc\u306e\u89b3\u6e2c\u30c7\u30fc\u30bf\u3092\u3053\u308c\u307e\u3067\u306e\u81ea\u5df1\u4f4d\u7f6e\u3092\u30d9\u30fc\u30b9\u306b\u3057\u3066NDT\u5316\u3059\u308b? \u30ec\u30fc\u30b6\u30fc\u3067\u306e \u53c2\u8003\u6587\u732e NDT\u52c9\u5f37\u4f1a \u3010ROS\u3011\u30b9\u30ad\u30e3\u30f3\u30de\u30c3\u30c1\u30f3\u30b0SLAM\u306e\u5b9f\u88c5\uff08NDT\u5b9f\u88c5\u7de8\uff09 Scan Matching \u81ea\u5df1\u4f4d\u7f6e\u63a8\u5b9a\u624b\u6cd5 pcl_apps ROS2\u3067pcl\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8","title":"NDT"},{"location":"tech_note/algorithm/ndt/#ndt-scan-matching","text":"","title":"NDT scan matching"},{"location":"tech_note/algorithm/ndt/#ndt","text":"\u30de\u30c3\u30d7\u3092NDT\u5316\u3059\u308b \u30ec\u30fc\u30b6\u30fc\u306e\u89b3\u6e2c\u30c7\u30fc\u30bf\u3092\u3053\u308c\u307e\u3067\u306e\u81ea\u5df1\u4f4d\u7f6e\u3092\u30d9\u30fc\u30b9\u306b\u3057\u3066NDT\u5316\u3059\u308b? \u30ec\u30fc\u30b6\u30fc\u3067\u306e","title":"NDT\u30de\u30c3\u30c1\u30f3\u30b0\u5927\u307e\u304b\u306a\u6d41\u308c"},{"location":"tech_note/algorithm/ndt/#_1","text":"NDT\u52c9\u5f37\u4f1a \u3010ROS\u3011\u30b9\u30ad\u30e3\u30f3\u30de\u30c3\u30c1\u30f3\u30b0SLAM\u306e\u5b9f\u88c5\uff08NDT\u5b9f\u88c5\u7de8\uff09 Scan Matching \u81ea\u5df1\u4f4d\u7f6e\u63a8\u5b9a\u624b\u6cd5 pcl_apps ROS2\u3067pcl\u4f7f\u3048\u308b\u3088\u3046\u306b\u3057\u305f\u30d1\u30c3\u30b1\u30fc\u30b8","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/algorithm/poly/","text":"\u591a\u9805\u5f0f \u52a0\u6e1b\u4e57\u9664 \u5c55\u958b \u56e0\u6570\u5206\u89e3 \u5fae\u5206\u30fb\u7a4d\u5206","title":"\u591a\u9805\u5f0f"},{"location":"tech_note/algorithm/poly/#_1","text":"","title":"\u591a\u9805\u5f0f"},{"location":"tech_note/algorithm/poly/#_2","text":"","title":"\u52a0\u6e1b\u4e57\u9664"},{"location":"tech_note/algorithm/poly/#_3","text":"","title":"\u5c55\u958b"},{"location":"tech_note/algorithm/poly/#_4","text":"","title":"\u56e0\u6570\u5206\u89e3"},{"location":"tech_note/algorithm/poly/#_5","text":"","title":"\u5fae\u5206\u30fb\u7a4d\u5206"},{"location":"tech_note/algorithm/poly_lerp/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u591a\u9805\u5f0f\u88dc\u9593 \u30ed\u30dc\u30c3\u30c8\u30a2\u30fc\u30e0\u306a\u3069\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3057\u305f\u3044\u6642\u306b\u76ee\u6a19\u5024\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3059\u3053\u3068\u3067\u5b9f\u73fe\u3057\u3088\u3046\u3068\u3057\u305f\u6642\u306b\u306a\u308b\u3079\u304f\u7c21\u5358\u306b\u53c2\u7167\u8ecc\u9053\u3092\u4f5c\u308a\u305f\u3044\u3053\u3068\u304c\u3042\u308b\u3002\u7c21\u5358\u306b\u5b9f\u88c5\u3059\u308b\u306a\u3089\u591a\u9805\u5f0f\u3067\u8ecc\u9053\u3092\u4f5c\u308b\u306e\u304c\u7c21\u5358\u3067\u3042\u308b\u3002 1\u6b21\u5f0f \u5883\u754c\u6761\u4ef6\u65702 \u59cb\u70b9\u4f4d\u7f6e P 0 P_0 P 0 \u200b , \u7d42\u70b9\u4f4d\u7f6e P 1 P_1 P 1 \u200b , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t f(t) = a_0 + a_1 t f ( t ) = a 0 \u200b + a 1 \u200b t a 0 = P 0 a 1 = P 1 \u2212 P 0 T \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& \\dfrac{P_1 - P_0}{T} \\end{array} a 0 \u200b a 1 \u200b \u200b = = \u200b P 0 \u200b T P 1 \u200b \u2212 P 0 \u200b \u200b \u200b 2\u6b21\u5f0f \u5883\u754c\u6761\u4ef6\u65703 \u59cb\u70b9 ( P 0 , v 0 ) (P_0, v_0) ( P 0 \u200b , v 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 ) (P_1) ( P 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 f(t) = a_0 + a_1 t + a_2 t^2 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 a 0 = P 0 a 1 = v 0 a 2 = 1 T 2 { ( P 1 \u2212 P 0 ) \u2212 v 0 T } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{T^2}\\left\\{ (P_1 - P_0) - v_0T \\right\\}\\\\ \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b \u200b = = = \u200b P 0 \u200b v 0 \u200b T 2 1 \u200b { ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 v 0 \u200b T } \u200b \u59cb\u70b9 ( P 0 , v 0 ) (P_0, v_0) ( P 0 \u200b , v 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( v 1 ) (v_1) ( v 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 f(t) = a_0 + a_1 t + a_2 t^2 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 a 0 = P 0 a 1 = v 0 a 2 = 1 2 T ( v 1 \u2212 v 0 ) \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{2T}(v_1 - v_0)\\\\ \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b \u200b = = = \u200b P 0 \u200b v 0 \u200b 2 T 1 \u200b ( v 1 \u200b \u2212 v 0 \u200b ) \u200b 3\u6b21\u5f0f \u5883\u754c\u6761\u4ef6\u65704 \u59cb\u70b9 ( P 0 , v 0 ) (P_0, v_0) ( P 0 \u200b , v 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , v 1 ) (P_1, v_1) ( P 1 \u200b , v 1 \u200b ) , \u9593\u9694$ T x$\u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 + a 3 t 3 f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 + a 3 \u200b t 3 a 0 = P 0 a 1 = v 0 a 2 = 1 T 2 { 3 ( P 1 \u2212 P 0 ) \u2212 ( v 1 + 2 v 0 ) T } a 3 = 1 T 3 { \u2212 2 ( P 1 \u2212 P 0 ) \u2212 ( v 1 + v 0 ) T } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{T^2}\\left\\{ 3(P_1 - P_0) - (v_1 + 2v_0)T \\right\\}\\\\ a_3 &=& \\dfrac{1}{T^3}\\left\\{ -2(P_1 - P_0) - (v_1 + v_0)T \\right\\} \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b a 3 \u200b \u200b = = = = \u200b P 0 \u200b v 0 \u200b T 2 1 \u200b { 3 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 ( v 1 \u200b + 2 v 0 \u200b ) T } T 3 1 \u200b { \u2212 2 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 ( v 1 \u200b + v 0 \u200b ) T } \u200b 4\u6b21\u5f0f \u5883\u754c\u6761\u4ef6\u65705 \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( v 1 , a c c 1 ) (v_1, acc_1) ( v 1 \u200b , a c c 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 + a 3 t 3 + a 4 t 4 f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 + a 3 \u200b t 3 + a 4 \u200b t 4 a 0 = P 0 a 1 = v 0 a 2 = 1 2 a c c 0 a 3 = 1 3 T 2 { 3 ( v 1 \u2212 v 0 ) \u2212 ( a c c 1 + 2 a c c 0 ) T } a 4 = 1 4 T 3 { \u2212 2 ( v 1 \u2212 v 0 ) + ( a c c 1 + a c c 0 ) T } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{2} acc_0\\\\ a_3 &=& \\dfrac{1}{3T^2}\\left\\{ 3(v_1 - v_0) - (acc_1 + 2acc_0)T \\right\\}\\\\ a_4 &=& \\dfrac{1}{4T^3}\\left\\{ -2(v_1 - v_0) + (acc_1 + acc_0)T \\right\\}\\\\ \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b a 3 \u200b a 4 \u200b \u200b = = = = = \u200b P 0 \u200b v 0 \u200b 2 1 \u200b a c c 0 \u200b 3 T 2 1 \u200b { 3 ( v 1 \u200b \u2212 v 0 \u200b ) \u2212 ( a c c 1 \u200b + 2 a c c 0 \u200b ) T } 4 T 3 1 \u200b { \u2212 2 ( v 1 \u200b \u2212 v 0 \u200b ) + ( a c c 1 \u200b + a c c 0 \u200b ) T } \u200b \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , v 1 ) (P_1, v_1) ( P 1 \u200b , v 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , a c c 1 ) (P_1, acc_1) ( P 1 \u200b , a c c 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d 5\u6b21\u5f0f \u5883\u754c\u6761\u4ef6\u65706 \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , v 1 , a c c 1 ) (P_1, v_1, acc_1) ( P 1 \u200b , v 1 \u200b , a c c 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 + a 3 t 3 + a 4 t 4 + a 5 t 5 f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 + a 3 \u200b t 3 + a 4 \u200b t 4 + a 5 \u200b t 5 a 0 = P 0 a 1 = v 0 a 2 = 1 2 a c c 0 a 3 = 1 2 T 3 { 20 ( P 1 \u2212 P 0 ) \u2212 ( 8 v 1 + 12 v 0 ) T + ( a c c 1 \u2212 3 a c c 0 ) T 2 } a 4 = 1 2 T 4 { \u2212 30 ( P 1 \u2212 P 0 ) + ( 14 v 1 + 16 v 0 ) T \u2212 ( 2 a c c 1 \u2212 3 a c c 0 ) T 2 } a 5 = 1 2 T 5 { 12 ( P 1 \u2212 P 0 ) \u2212 6 ( v 1 + v 0 ) T + ( a c c 1 \u2212 a c c 0 ) T 2 } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{2} acc_0\\\\ a_3 &=& \\dfrac{1}{2T^3}\\left\\{ 20(P_1 - P_0) - (8v_1 + 12v_0)T + (acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_4 &=& \\dfrac{1}{2T^4}\\left\\{ -30(P_1 - P_0) + (14v_1 + 16v_0)T - (2acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_5 &=& \\dfrac{1}{2T^5}\\left\\{ 12(P_1 - P_0) - 6(v_1 + v_0)T + (acc_1 - acc_0)T^2 \\right\\} \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b a 3 \u200b a 4 \u200b a 5 \u200b \u200b = = = = = = \u200b P 0 \u200b v 0 \u200b 2 1 \u200b a c c 0 \u200b 2 T 3 1 \u200b { 20 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 ( 8 v 1 \u200b + 12 v 0 \u200b ) T + ( a c c 1 \u200b \u2212 3 a c c 0 \u200b ) T 2 } 2 T 4 1 \u200b { \u2212 30 ( P 1 \u200b \u2212 P 0 \u200b ) + ( 14 v 1 \u200b + 16 v 0 \u200b ) T \u2212 ( 2 a c c 1 \u200b \u2212 3 a c c 0 \u200b ) T 2 } 2 T 5 1 \u200b { 12 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 6 ( v 1 \u200b + v 0 \u200b ) T + ( a c c 1 \u200b \u2212 a c c 0 \u200b ) T 2 } \u200b \u53c2\u8003\u6587\u732e \u30ed\u30dc\u30c3\u30c8\u5de5\u5b66\u306e\u57fa\u790e\uff08\u7b2c2\u7248\uff09","title":"\u591a\u9805\u5f0f\u88dc\u9593"},{"location":"tech_note/algorithm/poly_lerp/#_1","text":"\u30ed\u30dc\u30c3\u30c8\u30a2\u30fc\u30e0\u306a\u3069\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3057\u305f\u3044\u6642\u306b\u76ee\u6a19\u5024\u3092\u306a\u3081\u3089\u304b\u306b\u52d5\u304b\u3059\u3053\u3068\u3067\u5b9f\u73fe\u3057\u3088\u3046\u3068\u3057\u305f\u6642\u306b\u306a\u308b\u3079\u304f\u7c21\u5358\u306b\u53c2\u7167\u8ecc\u9053\u3092\u4f5c\u308a\u305f\u3044\u3053\u3068\u304c\u3042\u308b\u3002\u7c21\u5358\u306b\u5b9f\u88c5\u3059\u308b\u306a\u3089\u591a\u9805\u5f0f\u3067\u8ecc\u9053\u3092\u4f5c\u308b\u306e\u304c\u7c21\u5358\u3067\u3042\u308b\u3002","title":"\u591a\u9805\u5f0f\u88dc\u9593"},{"location":"tech_note/algorithm/poly_lerp/#1","text":"\u5883\u754c\u6761\u4ef6\u65702 \u59cb\u70b9\u4f4d\u7f6e P 0 P_0 P 0 \u200b , \u7d42\u70b9\u4f4d\u7f6e P 1 P_1 P 1 \u200b , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t f(t) = a_0 + a_1 t f ( t ) = a 0 \u200b + a 1 \u200b t a 0 = P 0 a 1 = P 1 \u2212 P 0 T \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& \\dfrac{P_1 - P_0}{T} \\end{array} a 0 \u200b a 1 \u200b \u200b = = \u200b P 0 \u200b T P 1 \u200b \u2212 P 0 \u200b \u200b \u200b","title":"1\u6b21\u5f0f"},{"location":"tech_note/algorithm/poly_lerp/#2","text":"\u5883\u754c\u6761\u4ef6\u65703 \u59cb\u70b9 ( P 0 , v 0 ) (P_0, v_0) ( P 0 \u200b , v 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 ) (P_1) ( P 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 f(t) = a_0 + a_1 t + a_2 t^2 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 a 0 = P 0 a 1 = v 0 a 2 = 1 T 2 { ( P 1 \u2212 P 0 ) \u2212 v 0 T } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{T^2}\\left\\{ (P_1 - P_0) - v_0T \\right\\}\\\\ \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b \u200b = = = \u200b P 0 \u200b v 0 \u200b T 2 1 \u200b { ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 v 0 \u200b T } \u200b \u59cb\u70b9 ( P 0 , v 0 ) (P_0, v_0) ( P 0 \u200b , v 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( v 1 ) (v_1) ( v 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 f(t) = a_0 + a_1 t + a_2 t^2 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 a 0 = P 0 a 1 = v 0 a 2 = 1 2 T ( v 1 \u2212 v 0 ) \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{2T}(v_1 - v_0)\\\\ \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b \u200b = = = \u200b P 0 \u200b v 0 \u200b 2 T 1 \u200b ( v 1 \u200b \u2212 v 0 \u200b ) \u200b","title":"2\u6b21\u5f0f"},{"location":"tech_note/algorithm/poly_lerp/#3","text":"\u5883\u754c\u6761\u4ef6\u65704 \u59cb\u70b9 ( P 0 , v 0 ) (P_0, v_0) ( P 0 \u200b , v 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , v 1 ) (P_1, v_1) ( P 1 \u200b , v 1 \u200b ) , \u9593\u9694$ T x$\u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 + a 3 t 3 f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 + a 3 \u200b t 3 a 0 = P 0 a 1 = v 0 a 2 = 1 T 2 { 3 ( P 1 \u2212 P 0 ) \u2212 ( v 1 + 2 v 0 ) T } a 3 = 1 T 3 { \u2212 2 ( P 1 \u2212 P 0 ) \u2212 ( v 1 + v 0 ) T } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{T^2}\\left\\{ 3(P_1 - P_0) - (v_1 + 2v_0)T \\right\\}\\\\ a_3 &=& \\dfrac{1}{T^3}\\left\\{ -2(P_1 - P_0) - (v_1 + v_0)T \\right\\} \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b a 3 \u200b \u200b = = = = \u200b P 0 \u200b v 0 \u200b T 2 1 \u200b { 3 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 ( v 1 \u200b + 2 v 0 \u200b ) T } T 3 1 \u200b { \u2212 2 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 ( v 1 \u200b + v 0 \u200b ) T } \u200b","title":"3\u6b21\u5f0f"},{"location":"tech_note/algorithm/poly_lerp/#4","text":"\u5883\u754c\u6761\u4ef6\u65705 \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( v 1 , a c c 1 ) (v_1, acc_1) ( v 1 \u200b , a c c 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 + a 3 t 3 + a 4 t 4 f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 + a 3 \u200b t 3 + a 4 \u200b t 4 a 0 = P 0 a 1 = v 0 a 2 = 1 2 a c c 0 a 3 = 1 3 T 2 { 3 ( v 1 \u2212 v 0 ) \u2212 ( a c c 1 + 2 a c c 0 ) T } a 4 = 1 4 T 3 { \u2212 2 ( v 1 \u2212 v 0 ) + ( a c c 1 + a c c 0 ) T } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{2} acc_0\\\\ a_3 &=& \\dfrac{1}{3T^2}\\left\\{ 3(v_1 - v_0) - (acc_1 + 2acc_0)T \\right\\}\\\\ a_4 &=& \\dfrac{1}{4T^3}\\left\\{ -2(v_1 - v_0) + (acc_1 + acc_0)T \\right\\}\\\\ \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b a 3 \u200b a 4 \u200b \u200b = = = = = \u200b P 0 \u200b v 0 \u200b 2 1 \u200b a c c 0 \u200b 3 T 2 1 \u200b { 3 ( v 1 \u200b \u2212 v 0 \u200b ) \u2212 ( a c c 1 \u200b + 2 a c c 0 \u200b ) T } 4 T 3 1 \u200b { \u2212 2 ( v 1 \u200b \u2212 v 0 \u200b ) + ( a c c 1 \u200b + a c c 0 \u200b ) T } \u200b \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , v 1 ) (P_1, v_1) ( P 1 \u200b , v 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , a c c 1 ) (P_1, acc_1) ( P 1 \u200b , a c c 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d","title":"4\u6b21\u5f0f"},{"location":"tech_note/algorithm/poly_lerp/#5","text":"\u5883\u754c\u6761\u4ef6\u65706 \u59cb\u70b9 ( P 0 , v 0 , a c c 0 ) (P_0, v_0, acc_0) ( P 0 \u200b , v 0 \u200b , a c c 0 \u200b ) , \u7d42\u70b9\u4f4d\u7f6e ( P 1 , v 1 , a c c 1 ) (P_1, v_1, acc_1) ( P 1 \u200b , v 1 \u200b , a c c 1 \u200b ) , \u9593\u9694 T T T \u306e\u3068\u304d f ( t ) = a 0 + a 1 t + a 2 t 2 + a 3 t 3 + a 4 t 4 + a 5 t 5 f(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5 f ( t ) = a 0 \u200b + a 1 \u200b t + a 2 \u200b t 2 + a 3 \u200b t 3 + a 4 \u200b t 4 + a 5 \u200b t 5 a 0 = P 0 a 1 = v 0 a 2 = 1 2 a c c 0 a 3 = 1 2 T 3 { 20 ( P 1 \u2212 P 0 ) \u2212 ( 8 v 1 + 12 v 0 ) T + ( a c c 1 \u2212 3 a c c 0 ) T 2 } a 4 = 1 2 T 4 { \u2212 30 ( P 1 \u2212 P 0 ) + ( 14 v 1 + 16 v 0 ) T \u2212 ( 2 a c c 1 \u2212 3 a c c 0 ) T 2 } a 5 = 1 2 T 5 { 12 ( P 1 \u2212 P 0 ) \u2212 6 ( v 1 + v 0 ) T + ( a c c 1 \u2212 a c c 0 ) T 2 } \\begin{array}{rcl} a_0 &=& P_0\\\\ a_1 &=& v_0\\\\ a_2 &=& \\dfrac{1}{2} acc_0\\\\ a_3 &=& \\dfrac{1}{2T^3}\\left\\{ 20(P_1 - P_0) - (8v_1 + 12v_0)T + (acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_4 &=& \\dfrac{1}{2T^4}\\left\\{ -30(P_1 - P_0) + (14v_1 + 16v_0)T - (2acc_1 - 3acc_0)T^2 \\right\\}\\\\ a_5 &=& \\dfrac{1}{2T^5}\\left\\{ 12(P_1 - P_0) - 6(v_1 + v_0)T + (acc_1 - acc_0)T^2 \\right\\} \\end{array} a 0 \u200b a 1 \u200b a 2 \u200b a 3 \u200b a 4 \u200b a 5 \u200b \u200b = = = = = = \u200b P 0 \u200b v 0 \u200b 2 1 \u200b a c c 0 \u200b 2 T 3 1 \u200b { 20 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 ( 8 v 1 \u200b + 12 v 0 \u200b ) T + ( a c c 1 \u200b \u2212 3 a c c 0 \u200b ) T 2 } 2 T 4 1 \u200b { \u2212 30 ( P 1 \u200b \u2212 P 0 \u200b ) + ( 14 v 1 \u200b + 16 v 0 \u200b ) T \u2212 ( 2 a c c 1 \u200b \u2212 3 a c c 0 \u200b ) T 2 } 2 T 5 1 \u200b { 12 ( P 1 \u200b \u2212 P 0 \u200b ) \u2212 6 ( v 1 \u200b + v 0 \u200b ) T + ( a c c 1 \u200b \u2212 a c c 0 \u200b ) T 2 } \u200b","title":"5\u6b21\u5f0f"},{"location":"tech_note/algorithm/poly_lerp/#_2","text":"\u30ed\u30dc\u30c3\u30c8\u5de5\u5b66\u306e\u57fa\u790e\uff08\u7b2c2\u7248\uff09","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/algorithm/poly_regression/","text":"\u56de\u5e30\u66f2\u7dda \u53c2\u8003\u6587\u732e","title":"\u56de\u5e30\u66f2\u7dda"},{"location":"tech_note/algorithm/poly_regression/#_1","text":"","title":"\u56de\u5e30\u66f2\u7dda"},{"location":"tech_note/algorithm/poly_regression/#_2","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/lqr/","text":"LQR \u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f \u53c2\u8003\u6587\u732e \u7dda\u5f62\u4e8c\u6b21\u30ec\u30ae\u30e5\u30ec\u30fc\u30bf(Linear-Quadratic Regulator:LQR)\u306e\u6982\u8981\u3068Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9 \u7dda\u5f62\u6700\u9069\u5236\u5fa1\uff08LQR\uff09\u3068Riccati\u30bd\u30eb\u30d0\u30fc\u306b\u3064\u3044\u3066 LQR\u5236\u5fa1\u3068\u306f\u30fb\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u304d\u65b9","title":"LQR"},{"location":"tech_note/control/lqr/#lqr","text":"","title":"LQR"},{"location":"tech_note/control/lqr/#_1","text":"","title":"\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f"},{"location":"tech_note/control/lqr/#_2","text":"\u7dda\u5f62\u4e8c\u6b21\u30ec\u30ae\u30e5\u30ec\u30fc\u30bf(Linear-Quadratic Regulator:LQR)\u306e\u6982\u8981\u3068Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9 \u7dda\u5f62\u6700\u9069\u5236\u5fa1\uff08LQR\uff09\u3068Riccati\u30bd\u30eb\u30d0\u30fc\u306b\u3064\u3044\u3066 LQR\u5236\u5fa1\u3068\u306f\u30fb\u30ea\u30ab\u30c3\u30c1\u65b9\u7a0b\u5f0f\u306e\u89e3\u304d\u65b9","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/minphase/","text":"\u6700\u5c0f\u4f4d\u76f8\u7cfb\u30fb\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb \u53c2\u8003\u6587\u732e \u3010\u5236\u5fa1\u5de5\u5b66\u3011\u4e0d\u5b89\u5b9a\u96f6\u70b9\u3068\u30a2\u30f3\u30c0\u30fc\u30b7\u30e5\u30fc\u30c8\uff08\u5236\u5fa1\u7406\u8ad6#7\uff09(YouTube) 106\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb#\u3064\u3076\u3084\u304d\u5236\u5fa1\u5de5\u5b66 (YouTube)","title":"\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb"},{"location":"tech_note/control/minphase/#_1","text":"","title":"\u6700\u5c0f\u4f4d\u76f8\u7cfb\u30fb\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb"},{"location":"tech_note/control/minphase/#_2","text":"\u3010\u5236\u5fa1\u5de5\u5b66\u3011\u4e0d\u5b89\u5b9a\u96f6\u70b9\u3068\u30a2\u30f3\u30c0\u30fc\u30b7\u30e5\u30fc\u30c8\uff08\u5236\u5fa1\u7406\u8ad6#7\uff09(YouTube) 106\u975e\u6700\u5c0f\u4f4d\u76f8\u7cfb#\u3064\u3076\u3084\u304d\u5236\u5fa1\u5de5\u5b66 (YouTube)","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/nctf/","text":"NCTF","title":"NCTF"},{"location":"tech_note/control/nctf/#nctf","text":"","title":"NCTF"},{"location":"tech_note/control/pfc/","text":"PFC \u53c2\u8003\u6587\u732e Predictive Functional Control\u306e\u5b9f\u88c5","title":"PFC"},{"location":"tech_note/control/pfc/#pfc","text":"","title":"PFC"},{"location":"tech_note/control/pfc/#_1","text":"Predictive Functional Control\u306e\u5b9f\u88c5","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/pid/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } PID \u53e4\u5178\u5236\u5fa1\u306e\u4ee3\u8868\u7684\u306a\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u5668\u3002\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3092\u3001\u72b6\u614b\u91cf\u3068\u76ee\u6a19\u5024\u306e\u5dee\u5206\u3001\u305d\u306e\u7a4d\u5206\u5024\u3001\u5fae\u5206\u5024\u306b\u3088\u3063\u3066\u6c7a\u5b9a\u3059\u308b\u30023\u3064\u306e\u5024\u306b\u5bfe\u3057\u3066\u30b2\u30a4\u30f3\u3092\u304b\u3051\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5fdc\u7b54\u3092\u8abf\u6574\u3059\u308b\u3002 u ( t ) = K p e + K i \u222b 0 t e d t + K d e \u02d9 u(t) = K_p e + K_i \\int_0^t e dt + K_d \\dot{e} u ( t ) = K p \u200b e + K i \u200b \u222b 0 t \u200b e d t + K d \u200b e \u02d9 PID\u5236\u5fa1\u5668\u306f\u4e0a\u8a18\u306e\u3088\u3046\u306b\u8868\u3055\u308c\u3001 K p K_p K p \u200b , K i K_i K i \u200b , K d K_d K d \u200b \u3092\u305d\u308c\u305e\u308c\u6bd4\u4f8b\u30b2\u30a4\u30f3\u3001\u7a4d\u5206\u30b2\u30a4\u30f3\u3001\u5fae\u5206\u30b2\u30a4\u30f3\u3068\u547c\u3076\u3002 \u7a4d\u5206\u9805\u3001\u5fae\u5206\u9805\u306e\u4fc2\u6570\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u8a18\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002 u ( t ) = K p ( e + 1 T i \u222b 0 t e d t + T d e \u02d9 ) \u305f\u3060\u3057 K i = K p / T i , K d = K p T d u(t) = K_p \\left( e + \\frac{1}{T_i} \\int_0^t e dt + T_d \\dot{e} \\right) \\text{ \u305f\u3060\u3057}K_i=K_p/T_i, Kd = K_pT_d u ( t ) = K p \u200b ( e + T i \u200b 1 \u200b \u222b 0 t \u200b e d t + T d \u200b e \u02d9 ) \u305f\u3060\u3057 K i \u200b = K p \u200b / T i \u200b , K d = K p \u200b T d \u200b \u3053\u3053\u3067 T i T_i T i \u200b \u306f\u7a4d\u5206\u6642\u9593\u3068\u547c\u3070\u308c T d T_d T d \u200b \u306f\u5fae\u5206\u6642\u9593\u3068\u547c\u3070\u308c\u308b\u3002 \u30d1\u30e9\u30e1\u30fc\u30bf\u8abf\u6574\u6cd5 \u9650\u754c\u611f\u5ea6\u6cd5 \u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u6cd5 CHR\u6cd5 \u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7 \u7a4d\u5206\u9805\u304c\u6709\u52b9\u306aPID\u5236\u5fa1\u5668\u306e\u5834\u5408\u3001\u504f\u5dee\u304c\u9577\u3044\u6642\u9593\u306b\u6e21\u3063\u3066\u5b58\u5728\u3059\u308b\u3068\u7a4d\u5206\u5024\u304c\u5927\u304d\u304f\u306a\u308a\u5165\u529b\u91cf\u304c\u98fd\u548c\u3059\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u3053\u308c\u3092\u9632\u3050\u305f\u3081\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b\u3002 \u7a4d\u5206\u306e\u505c\u6b62 \u4e00\u756a\u7c21\u5358\u306a\u624b\u6cd5\u3068\u3057\u3066\u7a4d\u5206\u3092\u505c\u6b62\u3055\u305b\u308b\u3053\u3068\u304c\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u308c\u306fPID\u5236\u5fa1\u306e\u51fa\u529b\u304c\u98fd\u548c\u3057\u305f\u3068\u304d\u306b\u306f\u7a4d\u5206\u9805\u3078\u306e\u5165\u529b\u3092\u305d\u308c\u4ee5\u4e0a\u7a4d\u5206\u9805\u304c\u5927\u304d\u304f\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u7c21\u5358\u3067\u3042\u308b\u304c\u4eba\u306b\u3088\u3063\u3066\u5b9f\u88c5\u65b9\u6cd5\u306b\u3086\u3089\u304e\u304c\u51fa\u3084\u3059\u3044 \u81ea\u52d5\u6574\u5408 \u81ea\u52d5\u6574\u5408\u3084\u9006\u89e3\u6790\u3068\u547c\u3070\u308c\u308b\u3053\u306e\u624b\u6cd5\u306f\u3001\u7d14\u7c8b\u306aPID\u306e\u51fa\u529b\u3068\u98fd\u548c\u3057\u3066\u5236\u9650\u304c\u304b\u304b\u3063\u305f\u51fa\u529b\u306e\u5dee\u5206\u3092PD\u5236\u5fa1\u5668\u306e\u9006\u30b7\u30b9\u30c6\u30e0\u3092\u901a\u3057\u3066\u7a4d\u5206\u9805\u3078\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b\u5f62\u3092\u53d6\u308b\u3002 \u901f\u5ea6\u578bPID \u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3068\u3044\u3046\u308f\u3051\u3067\u306f\u306a\u3044\u304c\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3057\u306a\u3044\u5f62\u306ePID\u5236\u5fa1\u5668\u306e\u5f62\u3068\u3057\u3066\u901f\u5ea6\u578bPID\u304c\u3042\u308b\u3002\u6700\u521d\u306b\u7d39\u4ecb\u3057\u305fPID\u5236\u5fa1\u5668\u306f\u4f4d\u7f6e\u578bPID\u3068\u547c\u3070\u308c\u5bfe\u6bd4\u3055\u308c\u308b\u3002\u901f\u5ea6\u578bPID\u306f\u504f\u5dee\u3092\u4e00\u968e\u5fae\u5206\u3057\u3066PID\u306b\u5165\u529b\u3059\u308b\u3053\u3068\u3067PID\u306e\u4e2d\u304b\u3089\u7a4d\u5206\u8981\u7d20\u3092\u6392\u9664\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u3042\u308b\u3002 \u53c2\u8003\u6587\u732e PID\u5236\u5fa1 PID\u5236\u5fa1\u3068\u306f\uff1f\u4ed5\u7d44\u307f\u3068\u52d5\u4f5c\u30a4\u30e1\u30fc\u30b8\u3092\u5206\u304b\u308a\u3084\u3059\u304f\u89e3\u8aac\uff01 PID\u5236\u5fa1\u5668\u306eAnti-windup","title":"PID"},{"location":"tech_note/control/pid/#pid","text":"\u53e4\u5178\u5236\u5fa1\u306e\u4ee3\u8868\u7684\u306a\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u5668\u3002\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5165\u529b\u3092\u3001\u72b6\u614b\u91cf\u3068\u76ee\u6a19\u5024\u306e\u5dee\u5206\u3001\u305d\u306e\u7a4d\u5206\u5024\u3001\u5fae\u5206\u5024\u306b\u3088\u3063\u3066\u6c7a\u5b9a\u3059\u308b\u30023\u3064\u306e\u5024\u306b\u5bfe\u3057\u3066\u30b2\u30a4\u30f3\u3092\u304b\u3051\u30b7\u30b9\u30c6\u30e0\u3078\u306e\u5fdc\u7b54\u3092\u8abf\u6574\u3059\u308b\u3002 u ( t ) = K p e + K i \u222b 0 t e d t + K d e \u02d9 u(t) = K_p e + K_i \\int_0^t e dt + K_d \\dot{e} u ( t ) = K p \u200b e + K i \u200b \u222b 0 t \u200b e d t + K d \u200b e \u02d9 PID\u5236\u5fa1\u5668\u306f\u4e0a\u8a18\u306e\u3088\u3046\u306b\u8868\u3055\u308c\u3001 K p K_p K p \u200b , K i K_i K i \u200b , K d K_d K d \u200b \u3092\u305d\u308c\u305e\u308c\u6bd4\u4f8b\u30b2\u30a4\u30f3\u3001\u7a4d\u5206\u30b2\u30a4\u30f3\u3001\u5fae\u5206\u30b2\u30a4\u30f3\u3068\u547c\u3076\u3002 \u7a4d\u5206\u9805\u3001\u5fae\u5206\u9805\u306e\u4fc2\u6570\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8868\u8a18\u3059\u308b\u3053\u3068\u3082\u3067\u304d\u308b\u3002 u ( t ) = K p ( e + 1 T i \u222b 0 t e d t + T d e \u02d9 ) \u305f\u3060\u3057 K i = K p / T i , K d = K p T d u(t) = K_p \\left( e + \\frac{1}{T_i} \\int_0^t e dt + T_d \\dot{e} \\right) \\text{ \u305f\u3060\u3057}K_i=K_p/T_i, Kd = K_pT_d u ( t ) = K p \u200b ( e + T i \u200b 1 \u200b \u222b 0 t \u200b e d t + T d \u200b e \u02d9 ) \u305f\u3060\u3057 K i \u200b = K p \u200b / T i \u200b , K d = K p \u200b T d \u200b \u3053\u3053\u3067 T i T_i T i \u200b \u306f\u7a4d\u5206\u6642\u9593\u3068\u547c\u3070\u308c T d T_d T d \u200b \u306f\u5fae\u5206\u6642\u9593\u3068\u547c\u3070\u308c\u308b\u3002","title":"PID"},{"location":"tech_note/control/pid/#_1","text":"","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u8abf\u6574\u6cd5"},{"location":"tech_note/control/pid/#_2","text":"","title":"\u9650\u754c\u611f\u5ea6\u6cd5"},{"location":"tech_note/control/pid/#_3","text":"","title":"\u30b9\u30c6\u30c3\u30d7\u5fdc\u7b54\u6cd5"},{"location":"tech_note/control/pid/#chr","text":"","title":"CHR\u6cd5"},{"location":"tech_note/control/pid/#_4","text":"\u7a4d\u5206\u9805\u304c\u6709\u52b9\u306aPID\u5236\u5fa1\u5668\u306e\u5834\u5408\u3001\u504f\u5dee\u304c\u9577\u3044\u6642\u9593\u306b\u6e21\u3063\u3066\u5b58\u5728\u3059\u308b\u3068\u7a4d\u5206\u5024\u304c\u5927\u304d\u304f\u306a\u308a\u5165\u529b\u91cf\u304c\u98fd\u548c\u3059\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u3053\u308c\u3092\u9632\u3050\u305f\u3081\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b\u3002","title":"\u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7"},{"location":"tech_note/control/pid/#_5","text":"\u4e00\u756a\u7c21\u5358\u306a\u624b\u6cd5\u3068\u3057\u3066\u7a4d\u5206\u3092\u505c\u6b62\u3055\u305b\u308b\u3053\u3068\u304c\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u308c\u306fPID\u5236\u5fa1\u306e\u51fa\u529b\u304c\u98fd\u548c\u3057\u305f\u3068\u304d\u306b\u306f\u7a4d\u5206\u9805\u3078\u306e\u5165\u529b\u3092\u305d\u308c\u4ee5\u4e0a\u7a4d\u5206\u9805\u304c\u5927\u304d\u304f\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u7c21\u5358\u3067\u3042\u308b\u304c\u4eba\u306b\u3088\u3063\u3066\u5b9f\u88c5\u65b9\u6cd5\u306b\u3086\u3089\u304e\u304c\u51fa\u3084\u3059\u3044","title":"\u7a4d\u5206\u306e\u505c\u6b62"},{"location":"tech_note/control/pid/#_6","text":"\u81ea\u52d5\u6574\u5408\u3084\u9006\u89e3\u6790\u3068\u547c\u3070\u308c\u308b\u3053\u306e\u624b\u6cd5\u306f\u3001\u7d14\u7c8b\u306aPID\u306e\u51fa\u529b\u3068\u98fd\u548c\u3057\u3066\u5236\u9650\u304c\u304b\u304b\u3063\u305f\u51fa\u529b\u306e\u5dee\u5206\u3092PD\u5236\u5fa1\u5668\u306e\u9006\u30b7\u30b9\u30c6\u30e0\u3092\u901a\u3057\u3066\u7a4d\u5206\u9805\u3078\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b\u5f62\u3092\u53d6\u308b\u3002","title":"\u81ea\u52d5\u6574\u5408"},{"location":"tech_note/control/pid/#pid_1","text":"\u30a2\u30f3\u30c1\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3068\u3044\u3046\u308f\u3051\u3067\u306f\u306a\u3044\u304c\u30ef\u30a4\u30f3\u30c9\u30a2\u30c3\u30d7\u3057\u306a\u3044\u5f62\u306ePID\u5236\u5fa1\u5668\u306e\u5f62\u3068\u3057\u3066\u901f\u5ea6\u578bPID\u304c\u3042\u308b\u3002\u6700\u521d\u306b\u7d39\u4ecb\u3057\u305fPID\u5236\u5fa1\u5668\u306f\u4f4d\u7f6e\u578bPID\u3068\u547c\u3070\u308c\u5bfe\u6bd4\u3055\u308c\u308b\u3002\u901f\u5ea6\u578bPID\u306f\u504f\u5dee\u3092\u4e00\u968e\u5fae\u5206\u3057\u3066PID\u306b\u5165\u529b\u3059\u308b\u3053\u3068\u3067PID\u306e\u4e2d\u304b\u3089\u7a4d\u5206\u8981\u7d20\u3092\u6392\u9664\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u3042\u308b\u3002","title":"\u901f\u5ea6\u578bPID"},{"location":"tech_note/control/pid/#_7","text":"PID\u5236\u5fa1 PID\u5236\u5fa1\u3068\u306f\uff1f\u4ed5\u7d44\u307f\u3068\u52d5\u4f5c\u30a4\u30e1\u30fc\u30b8\u3092\u5206\u304b\u308a\u3084\u3059\u304f\u89e3\u8aac\uff01 PID\u5236\u5fa1\u5668\u306eAnti-windup","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/pid2/","text":"2\u81ea\u7531\u5ea6PID 2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306bPID\u3092\u4f7f\u7528\u3057\u305f\u3082\u306e\u30922\u81ea\u7531\u5ea6PID\u3068\u547c\u3076\u3002 2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u3068\u306f\u76ee\u6a19\u5024\u3068\u72b6\u614b\u91cf\u306e2\u3064\u306e\u60c5\u5831\u3092\u6271\u3063\u3066\u5236\u5fa1\u3059\u308b\u5236\u5fa1\u7cfb\u3092\u6307\u3059\u3002 \u5358\u7d14\u306aPID\u5236\u5fa1\u7cfb\u306b\u3082\u76ee\u6a19\u5024\u306e\u5165\u529b\u3068\u72b6\u614b\u91cf\u306e\u51fa\u529b\u306f\u5b58\u5728\u3059\u308b\u304cPID\u5236\u5fa1\u5668\u3078\u306e\u5165\u529b\u306f\u305d\u308c\u3089\u306e\u5dee\u5206\u3067\u3042\u308b\u504f\u5dee\u306e\u307f\u3067\u3042\u308b\u305f\u3081\u81ea\u7531\u5ea6\u306f1\u3067\u3042\u308b\u3002 2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306e\u30d6\u30ed\u30c3\u30af\u56f3 2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306f\u30d6\u30ed\u30c3\u30af\u56f3\u3067\u8003\u3048\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u578b\u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u76f4\u5217\u578b MathWorks\u3067\u306f\u30d5\u30a3\u30eb\u30bf\u30fc\u578b\u3068\u547c\u3070\u308c\u308b \u4e26\u5217\u578b \u53c2\u8003\u6587\u732e 2 \u81ea\u7531\u5ea6 PID \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc","title":"2\u81ea\u7531\u5ea6PID"},{"location":"tech_note/control/pid2/#2pid","text":"2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306bPID\u3092\u4f7f\u7528\u3057\u305f\u3082\u306e\u30922\u81ea\u7531\u5ea6PID\u3068\u547c\u3076\u3002 2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u3068\u306f\u76ee\u6a19\u5024\u3068\u72b6\u614b\u91cf\u306e2\u3064\u306e\u60c5\u5831\u3092\u6271\u3063\u3066\u5236\u5fa1\u3059\u308b\u5236\u5fa1\u7cfb\u3092\u6307\u3059\u3002 \u5358\u7d14\u306aPID\u5236\u5fa1\u7cfb\u306b\u3082\u76ee\u6a19\u5024\u306e\u5165\u529b\u3068\u72b6\u614b\u91cf\u306e\u51fa\u529b\u306f\u5b58\u5728\u3059\u308b\u304cPID\u5236\u5fa1\u5668\u3078\u306e\u5165\u529b\u306f\u305d\u308c\u3089\u306e\u5dee\u5206\u3067\u3042\u308b\u504f\u5dee\u306e\u307f\u3067\u3042\u308b\u305f\u3081\u81ea\u7531\u5ea6\u306f1\u3067\u3042\u308b\u3002","title":"2\u81ea\u7531\u5ea6PID"},{"location":"tech_note/control/pid2/#2","text":"2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306f\u30d6\u30ed\u30c3\u30af\u56f3\u3067\u8003\u3048\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u578b\u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002","title":"2\u81ea\u7531\u5ea6\u5236\u5fa1\u7cfb\u306e\u30d6\u30ed\u30c3\u30af\u56f3"},{"location":"tech_note/control/pid2/#_1","text":"MathWorks\u3067\u306f\u30d5\u30a3\u30eb\u30bf\u30fc\u578b\u3068\u547c\u3070\u308c\u308b","title":"\u76f4\u5217\u578b"},{"location":"tech_note/control/pid2/#_2","text":"","title":"\u4e26\u5217\u578b"},{"location":"tech_note/control/pid2/#_3","text":"2 \u81ea\u7531\u5ea6 PID \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u30fc","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/place/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u6975\u914d\u7f6e\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af \u7c21\u5358\u306a\u30b7\u30b9\u30c6\u30e0\u306e\u624b\u8a08\u7b97\u306b\u3088\u308b\u6975\u914d\u7f6e \u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308b\u6975\u914d\u7f6e \u6570\u5024\u8a08\u7b97\u3067\u6975\u914d\u7f6e\u3092\u884c\u3046\u306b\u306fSISO\u30e2\u30c7\u30eb\u306b\u5bfe\u3057\u3066\u306f\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u3068\u3044\u3046\u3082\u306e\u304c\u63d0\u5531\u3055\u308c\u3066\u304d\u305f\u3002 \u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u65b9\u3067\u306f\u4ee5\u4e0b\u306e\u624b\u9806\u3067\u6975\u914d\u7f6e\u3092\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u6c42\u3081\u308b\u3002 \u914d\u7f6e\u3057\u305f\u3044\u6975\u306e\u5024\u304b\u3089\u7279\u6027\u65b9\u7a0b\u5f0f\u306b\u5c55\u958b\u3059\u308b \u30b7\u30b9\u30c6\u30e0\u306e\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092\u6c42\u3081\u308b \u53ef\u5236\u5fa1\u6027\u884c\u5217 U c U_c U c \u200b \u3068\u30b7\u30b9\u30c6\u30e0\u306e\u9077\u79fb\u884c\u5217 A A A \u3068\u7279\u6027\u65b9\u7a0b\u5f0f\u306e\u4fc2\u6570 d n d_n d n \u200b \u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a08\u7b97\u3059\u308b K = [ 0 0 0 \u2026 1 ] U c \u2212 1 ( A n + d n \u2212 1 A n \u2212 1 + \u22ef + d 2 A 2 + d 1 A 1 + d 0 I ) \\begin{array}{l} K = [0 & 0 & 0 & \\dots \\ & 1]U_c^{-1}(A^n + d_{n-1}A^{n-1} + \\dots + d_{2}A^{2} + d_{1}A^{1} + d_{0}I) \\end{array} K = [ 0 \u200b 0 \u200b 0 \u200b \u2026 \u200b 1 ] U c \u2212 1 \u200b ( A n + d n \u2212 1 \u200b A n \u2212 1 + \u22ef + d 2 \u200b A 2 + d 1 \u200b A 1 + d 0 \u200b I ) \u200b \u3053\u308c\u306b\u3088\u308a\u6c42\u3081\u305f\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3 K K K \u3067 u = \u2212 K x u = -Kx u = \u2212 K x \u306e\u3088\u3046\u306b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3092\u884c\u3046\u3002 \u53c2\u8003\u6587\u732e \u6975\u914d\u7f6e\u306e\u5b9f\u88c5\uff1a\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\uff0cEigenvalueStructure\u6cd5\u306eMATLAB\u5b9f\u88c5","title":"\u6975\u914d\u7f6e\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af"},{"location":"tech_note/control/place/#_1","text":"","title":"\u6975\u914d\u7f6e\u306b\u3088\u308b\u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af"},{"location":"tech_note/control/place/#_2","text":"","title":"\u7c21\u5358\u306a\u30b7\u30b9\u30c6\u30e0\u306e\u624b\u8a08\u7b97\u306b\u3088\u308b\u6975\u914d\u7f6e"},{"location":"tech_note/control/place/#_3","text":"\u6570\u5024\u8a08\u7b97\u3067\u6975\u914d\u7f6e\u3092\u884c\u3046\u306b\u306fSISO\u30e2\u30c7\u30eb\u306b\u5bfe\u3057\u3066\u306f\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u3068\u3044\u3046\u3082\u306e\u304c\u63d0\u5531\u3055\u308c\u3066\u304d\u305f\u3002 \u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u65b9\u3067\u306f\u4ee5\u4e0b\u306e\u624b\u9806\u3067\u6975\u914d\u7f6e\u3092\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3\u3092\u6c42\u3081\u308b\u3002 \u914d\u7f6e\u3057\u305f\u3044\u6975\u306e\u5024\u304b\u3089\u7279\u6027\u65b9\u7a0b\u5f0f\u306b\u5c55\u958b\u3059\u308b \u30b7\u30b9\u30c6\u30e0\u306e\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092\u6c42\u3081\u308b \u53ef\u5236\u5fa1\u6027\u884c\u5217 U c U_c U c \u200b \u3068\u30b7\u30b9\u30c6\u30e0\u306e\u9077\u79fb\u884c\u5217 A A A \u3068\u7279\u6027\u65b9\u7a0b\u5f0f\u306e\u4fc2\u6570 d n d_n d n \u200b \u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u8a08\u7b97\u3059\u308b K = [ 0 0 0 \u2026 1 ] U c \u2212 1 ( A n + d n \u2212 1 A n \u2212 1 + \u22ef + d 2 A 2 + d 1 A 1 + d 0 I ) \\begin{array}{l} K = [0 & 0 & 0 & \\dots \\ & 1]U_c^{-1}(A^n + d_{n-1}A^{n-1} + \\dots + d_{2}A^{2} + d_{1}A^{1} + d_{0}I) \\end{array} K = [ 0 \u200b 0 \u200b 0 \u200b \u2026 \u200b 1 ] U c \u2212 1 \u200b ( A n + d n \u2212 1 \u200b A n \u2212 1 + \u22ef + d 2 \u200b A 2 + d 1 \u200b A 1 + d 0 \u200b I ) \u200b \u3053\u308c\u306b\u3088\u308a\u6c42\u3081\u305f\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u30b2\u30a4\u30f3 K K K \u3067 u = \u2212 K x u = -Kx u = \u2212 K x \u306e\u3088\u3046\u306b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3092\u884c\u3046\u3002","title":"\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\u306b\u3088\u308b\u6975\u914d\u7f6e"},{"location":"tech_note/control/place/#_4","text":"\u6975\u914d\u7f6e\u306e\u5b9f\u88c5\uff1a\u30a2\u30c3\u30ab\u30fc\u30de\u30f3\u6cd5\uff0cEigenvalueStructure\u6cd5\u306eMATLAB\u5b9f\u88c5","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/pole_and_zero/","text":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975\u30fb\u96f6\u70b9 \u30b7\u30b9\u30c6\u30e0\u306e\u6975 \u30b7\u30b9\u30c6\u30e0\u306e\u96f6\u70b9 \u53c2\u8003\u6587\u732e","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975\u30fb\u96f6\u70b9"},{"location":"tech_note/control/pole_and_zero/#_1","text":"","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975\u30fb\u96f6\u70b9"},{"location":"tech_note/control/pole_and_zero/#_2","text":"","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u6975"},{"location":"tech_note/control/pole_and_zero/#_3","text":"","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u96f6\u70b9"},{"location":"tech_note/control/pole_and_zero/#_4","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/control/pure_pursuit/","text":"Pure pursuit","title":"Pure pursuit"},{"location":"tech_note/control/pure_pursuit/#pure-pursuit","text":"","title":"Pure pursuit"},{"location":"tech_note/control/stability/","text":"\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027 \u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027\u3068\u306f \u5b89\u5b9a\u5224\u5225 \u53c2\u8003\u6587\u732e","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027"},{"location":"tech_note/control/stability/#_1","text":"\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027\u3068\u306f","title":"\u30b7\u30b9\u30c6\u30e0\u306e\u5b89\u5b9a\u6027"},{"location":"tech_note/control/stability/#_2","text":"","title":"\u5b89\u5b9a\u5224\u5225"},{"location":"tech_note/control/stability/#_3","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/filter/extend_kalman_filter/","text":"\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf \u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306f\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u3057\u304b\u6271\u3046\u3053\u3068\u304c\u51fa\u6765\u306a\u304b\u3063\u305f\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306e\u7406\u8ad6\u3092\u975e\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306b\u307e\u3067\u62e1\u5f35\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002 \u53c2\u8003\u6587\u732e","title":"\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/extend_kalman_filter/#_1","text":"\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306f\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u3057\u304b\u6271\u3046\u3053\u3068\u304c\u51fa\u6765\u306a\u304b\u3063\u305f\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306e\u7406\u8ad6\u3092\u975e\u7dda\u5f62\u30b7\u30b9\u30c6\u30e0\u306b\u307e\u3067\u62e1\u5f35\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002","title":"\u62e1\u5f35\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/extend_kalman_filter/#_2","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/filter/kalman_filter/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3068\u306f\u7dda\u5f62\u306e\u904b\u52d5\u30e2\u30c7\u30eb\u3068\u89b3\u6e2c\u30e2\u30c7\u30eb\u304b\u3089\u72b6\u614b\u3092\u63a8\u5b9a\u3059\u308b\u30d5\u30a3\u30eb\u30bf\u306e\u4e00\u7a2e\u3067\u3042\u308b \u96e2\u6563\u5316\u30e2\u30c7\u30eb \u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f\u3067\u96e2\u6563\u5316\u3057\u305f\u7dda\u5f62\u30e2\u30c7\u30eb\u304c\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3068\u3059\u308b\u3002 x ( t ) = F x ( t \u2212 1 ) + G u ( t ) + w ( t ) z ( t ) = H x ( t ) + v ( t ) \\begin{array}{lll} x(t) = Fx(t-1) + Gu(t) + w(t) \\\\ z(t) = Hx(t) + v(t) \\end{array} x ( t ) = F x ( t \u2212 1 ) + G u ( t ) + w ( t ) z ( t ) = H x ( t ) + v ( t ) \u200b \u3053\u3053\u3067\u5404\u5909\u6570\u306f\u4ee5\u4e0b\u306e\u901a\u308a x \u2208 R n \u00d7 1 x \\in \\R^{n \\times 1} x \u2208 R n \u00d7 1 : \u72b6\u614b\u91cf u \u2208 R r \u00d7 1 u \\in \\R^{r \\times 1} u \u2208 R r \u00d7 1 : \u5236\u5fa1\u91cf z \u2208 R p \u00d7 1 z \\in \\R^{p \\times 1} z \u2208 R p \u00d7 1 : \u89b3\u6e2c\u91cf F \u2208 R n \u00d7 n F \\in \\R^{n \\times n} F \u2208 R n \u00d7 n : \u72b6\u614b\u9077\u79fb\u884c\u5217 G \u2208 R n \u00d7 r G \\in \\R^{n \\times r} G \u2208 R n \u00d7 r : \u5236\u5fa1\u884c\u5217 H \u2208 R p \u00d7 n H \\in \\R^{p \\times n} H \u2208 R p \u00d7 n : \u89b3\u6e2c\u884c\u5217 Q \u2208 R n \u00d7 n Q \\in \\R^{n \\times n} Q \u2208 R n \u00d7 n : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 w \u2208 R n \u00d7 1 w \\in \\R^{n \\times 1} w \u2208 R n \u00d7 1 : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba N [ 0 , Q ] N[0, Q] N [ 0 , Q ] \u306b\u5f93\u3046 R \u2208 R p \u00d7 p R \\in \\R^{p \\times p} R \u2208 R p \u00d7 p : \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 v \u2208 R p \u00d7 1 v \\in \\R^{p \\times 1} v \u2208 R p \u00d7 1 : \u89b3\u6e2c\u30ce\u30a4\u30ba N [ 0 , R ] N[0, R] N [ 0 , R ] \u306b\u5f93\u3046 \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf \u30b7\u30b9\u30c6\u30e0\u306b\u4e0e\u3048\u305f\u5165\u529b u u u \u3068\u8aa4\u5dee\u304c\u3042\u308b\u89b3\u6e2c\u91cf z z z \u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf x \u02c9 \\bar{x} x \u02c9 \u3092\u63a8\u5b9a\u3059\u308b\u3002 \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306b\u306f\u5927\u304d\u304f\u5206\u3051\u3066\u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7\u3068\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7\u306b\u5206\u3051\u3089\u308c\u308b\u3002 \u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7 \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a \u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u3092\u4f7f\u3063\u3066\u3001\u524d\u30b9\u30c6\u30c3\u30d7\u306e\u72b6\u614b\u91cf\u3068\u5165\u529b\u91cf\u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf\u304c\u3069\u3046\u306a\u308b\u304b\u3092\u8a08\u7b97\u3059\u308b x \u02c9 = F x \u02c9 + G u \\bar{x} = F\\bar{x} + Gu x \u02c9 = F x \u02c9 + G u \u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0 \u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\u3067\u72b6\u614b\u3092\u66f4\u65b0\u3057\u305f\u3053\u3068\u306b\u3088\u308b\u72b6\u614b\u306e\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b P = F P F T + Q P = FPF^T + Q P = FP F T + Q \u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7 \u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u306e\u8a08\u7b97 \u72b6\u614b\u306e\u4e0d\u78ba\u304b\u3055\u3068\u89b3\u6e2c\u306e\u4e0d\u78ba\u304b\u3055\u304b\u3089\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b K = P H T ( H P H T + R ) \u2212 1 K = PH^T(HPH^T + R)^-1 K = P H T ( H P H T + R ) \u2212 1 \u72b6\u614b\u63a8\u5b9a \u8aa4\u5dee\u4ed8\u304d\u306e\u89b3\u6e2c\u91cf\u3068\u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u304b\u3089\u4e88\u6e2c\u3055\u308c\u308b\u89b3\u6e2c\u91cf\u306e\u5dee\u5206\u3092\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3067\u8abf\u6574\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b x \u02c9 = x \u02c9 + K ( z \u2212 H x \u02c9 ) \\bar{x} = \\bar{x} + K(z - H\\bar{x}) x \u02c9 = x \u02c9 + K ( z \u2212 H x \u02c9 ) \u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0 \u72b6\u614b\u63a8\u5b9a\u306e\u66f4\u65b0\u306e\u5206\u306e\u72b6\u614b\u91cf\u306e\u4e0d\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b P = ( I \u2212 K H ) P P = (I -KH)P P = ( I \u2212 KH ) P \u53c2\u8003\u6587\u732e \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3063\u3066\u306a\u306b\uff1f \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u30fc \u88cf\u53e3\u304b\u3089\u306e\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u5165\u9580 (YouTube)","title":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/kalman_filter/#_1","text":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3068\u306f\u7dda\u5f62\u306e\u904b\u52d5\u30e2\u30c7\u30eb\u3068\u89b3\u6e2c\u30e2\u30c7\u30eb\u304b\u3089\u72b6\u614b\u3092\u63a8\u5b9a\u3059\u308b\u30d5\u30a3\u30eb\u30bf\u306e\u4e00\u7a2e\u3067\u3042\u308b","title":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/kalman_filter/#_2","text":"\u30b5\u30f3\u30d7\u30ea\u30f3\u30b0\u5468\u671f\u3067\u96e2\u6563\u5316\u3057\u305f\u7dda\u5f62\u30e2\u30c7\u30eb\u304c\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3068\u3059\u308b\u3002 x ( t ) = F x ( t \u2212 1 ) + G u ( t ) + w ( t ) z ( t ) = H x ( t ) + v ( t ) \\begin{array}{lll} x(t) = Fx(t-1) + Gu(t) + w(t) \\\\ z(t) = Hx(t) + v(t) \\end{array} x ( t ) = F x ( t \u2212 1 ) + G u ( t ) + w ( t ) z ( t ) = H x ( t ) + v ( t ) \u200b \u3053\u3053\u3067\u5404\u5909\u6570\u306f\u4ee5\u4e0b\u306e\u901a\u308a x \u2208 R n \u00d7 1 x \\in \\R^{n \\times 1} x \u2208 R n \u00d7 1 : \u72b6\u614b\u91cf u \u2208 R r \u00d7 1 u \\in \\R^{r \\times 1} u \u2208 R r \u00d7 1 : \u5236\u5fa1\u91cf z \u2208 R p \u00d7 1 z \\in \\R^{p \\times 1} z \u2208 R p \u00d7 1 : \u89b3\u6e2c\u91cf F \u2208 R n \u00d7 n F \\in \\R^{n \\times n} F \u2208 R n \u00d7 n : \u72b6\u614b\u9077\u79fb\u884c\u5217 G \u2208 R n \u00d7 r G \\in \\R^{n \\times r} G \u2208 R n \u00d7 r : \u5236\u5fa1\u884c\u5217 H \u2208 R p \u00d7 n H \\in \\R^{p \\times n} H \u2208 R p \u00d7 n : \u89b3\u6e2c\u884c\u5217 Q \u2208 R n \u00d7 n Q \\in \\R^{n \\times n} Q \u2208 R n \u00d7 n : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 w \u2208 R n \u00d7 1 w \\in \\R^{n \\times 1} w \u2208 R n \u00d7 1 : \u30b7\u30b9\u30c6\u30e0\u30ce\u30a4\u30ba N [ 0 , Q ] N[0, Q] N [ 0 , Q ] \u306b\u5f93\u3046 R \u2208 R p \u00d7 p R \\in \\R^{p \\times p} R \u2208 R p \u00d7 p : \u89b3\u6e2c\u30ce\u30a4\u30ba\u306e\u5171\u5206\u6563\u884c\u5217 v \u2208 R p \u00d7 1 v \\in \\R^{p \\times 1} v \u2208 R p \u00d7 1 : \u89b3\u6e2c\u30ce\u30a4\u30ba N [ 0 , R ] N[0, R] N [ 0 , R ] \u306b\u5f93\u3046","title":"\u96e2\u6563\u5316\u30e2\u30c7\u30eb"},{"location":"tech_note/filter/kalman_filter/#_3","text":"\u30b7\u30b9\u30c6\u30e0\u306b\u4e0e\u3048\u305f\u5165\u529b u u u \u3068\u8aa4\u5dee\u304c\u3042\u308b\u89b3\u6e2c\u91cf z z z \u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf x \u02c9 \\bar{x} x \u02c9 \u3092\u63a8\u5b9a\u3059\u308b\u3002 \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u306b\u306f\u5927\u304d\u304f\u5206\u3051\u3066\u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7\u3068\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7\u306b\u5206\u3051\u3089\u308c\u308b\u3002","title":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/kalman_filter/#_4","text":"","title":"\u4e88\u6e2c\u30b9\u30c6\u30c3\u30d7"},{"location":"tech_note/filter/kalman_filter/#_5","text":"\u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u3092\u4f7f\u3063\u3066\u3001\u524d\u30b9\u30c6\u30c3\u30d7\u306e\u72b6\u614b\u91cf\u3068\u5165\u529b\u91cf\u304b\u3089\u73fe\u5728\u306e\u72b6\u614b\u91cf\u304c\u3069\u3046\u306a\u308b\u304b\u3092\u8a08\u7b97\u3059\u308b x \u02c9 = F x \u02c9 + G u \\bar{x} = F\\bar{x} + Gu x \u02c9 = F x \u02c9 + G u","title":"\u4e8b\u524d\u72b6\u614b\u63a8\u5b9a"},{"location":"tech_note/filter/kalman_filter/#_6","text":"\u4e8b\u524d\u72b6\u614b\u63a8\u5b9a\u3067\u72b6\u614b\u3092\u66f4\u65b0\u3057\u305f\u3053\u3068\u306b\u3088\u308b\u72b6\u614b\u306e\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b P = F P F T + Q P = FPF^T + Q P = FP F T + Q","title":"\u4e8b\u524d\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0"},{"location":"tech_note/filter/kalman_filter/#_7","text":"","title":"\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u30b9\u30c6\u30c3\u30d7"},{"location":"tech_note/filter/kalman_filter/#_8","text":"\u72b6\u614b\u306e\u4e0d\u78ba\u304b\u3055\u3068\u89b3\u6e2c\u306e\u4e0d\u78ba\u304b\u3055\u304b\u3089\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3092\u8a08\u7b97\u3059\u308b K = P H T ( H P H T + R ) \u2212 1 K = PH^T(HPH^T + R)^-1 K = P H T ( H P H T + R ) \u2212 1","title":"\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u306e\u8a08\u7b97"},{"location":"tech_note/filter/kalman_filter/#_9","text":"\u8aa4\u5dee\u4ed8\u304d\u306e\u89b3\u6e2c\u91cf\u3068\u30b7\u30b9\u30c6\u30e0\u306e\u30e2\u30c7\u30eb\u304b\u3089\u4e88\u6e2c\u3055\u308c\u308b\u89b3\u6e2c\u91cf\u306e\u5dee\u5206\u3092\u30ab\u30eb\u30de\u30f3\u30b2\u30a4\u30f3\u3067\u8abf\u6574\u3057\u3066\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u3059\u308b x \u02c9 = x \u02c9 + K ( z \u2212 H x \u02c9 ) \\bar{x} = \\bar{x} + K(z - H\\bar{x}) x \u02c9 = x \u02c9 + K ( z \u2212 H x \u02c9 )","title":"\u72b6\u614b\u63a8\u5b9a"},{"location":"tech_note/filter/kalman_filter/#_10","text":"\u72b6\u614b\u63a8\u5b9a\u306e\u66f4\u65b0\u306e\u5206\u306e\u72b6\u614b\u91cf\u306e\u4e0d\u78ba\u304b\u3055\u3092\u66f4\u65b0\u3059\u308b P = ( I \u2212 K H ) P P = (I -KH)P P = ( I \u2212 KH ) P","title":"\u4e8b\u5f8c\u8aa4\u5dee\u5171\u5206\u6563\u884c\u5217\u306e\u66f4\u65b0"},{"location":"tech_note/filter/kalman_filter/#_11","text":"\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u3063\u3066\u306a\u306b\uff1f \u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u30fc \u88cf\u53e3\u304b\u3089\u306e\u30ab\u30eb\u30de\u30f3\u30d5\u30a3\u30eb\u30bf\u5165\u9580 (YouTube)","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/filter/limitted_filter/","text":"\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u30fb\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf \u3053\u3053\u3067\u306f\u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u308b\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3068\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u306b\u3064\u3044\u3066\u8aac\u660e\u3092\u3057\u3066\u3044\u304f\u3002 \u53c2\u8003\u6587\u732e","title":"\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u30fb\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/limitted_filter/#_1","text":"\u3053\u3053\u3067\u306f\u718a\u672c\u5927\u5b66\u306e\u5ca1\u5cf6\u7814\u7a76\u5ba4\u3067\u516c\u958b\u3055\u308c\u3066\u3044\u308b\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u3068\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u306b\u3064\u3044\u3066\u8aac\u660e\u3092\u3057\u3066\u3044\u304f\u3002","title":"\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf\u30fb\u52a0\u901f\u5ea6\u5236\u9650\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/limitted_filter/#_2","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/filter/tf_filter/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u4f1d\u9054\u95a2\u6570\u3067\u8868\u73fe\u3055\u308c\u308b\u30d5\u30a3\u30eb\u30bf \u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \u4f1d\u9054\u95a2\u6570 G ( s ) = 1 T s + 1 G(s) = \\frac{1}{Ts + 1} G ( s ) = T s + 1 1 \u200b z\u9818\u57df\u4f1d\u9054\u95a2\u6570 G ( z ) = G(z) = \\frac{}{} G ( z ) = \u200b \u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \u4f1d\u9054\u95a2\u6570 G ( s ) = T s T s + 1 G(s) = \\frac{Ts}{Ts + 1} G ( s ) = T s + 1 T s \u200b \u7a4d\u5206\u8981\u7d20 \u4f1d\u9054\u95a2\u6570 G ( s ) = 1 s G(s) = \\frac{1}{s} G ( s ) = s 1 \u200b \u4e0d\u5b8c\u5168\u5fae\u5206 \u4f1d\u9054\u95a2\u6570 G ( s ) = s T s + 1 G(s) = \\frac{s}{Ts+1} G ( s ) = T s + 1 s \u200b \u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf \u4f1d\u9054\u95a2\u6570 G ( s ) = s 2 + \u03c9 2 s 2 + 2 \u03b6 \u03c9 + \u03c9 2 G(s) = \\frac{s^2 + \\omega^2}{s^2 + 2\\zeta\\omega + \\omega^2} G ( s ) = s 2 + 2 \u03b6 \u03c9 + \u03c9 2 s 2 + \u03c9 2 \u200b \u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf \u4f1d\u9054\u95a2\u6570 G ( s ) = 2 \u03b6 \u03c9 s 2 + 2 \u03b6 \u03c9 + \u03c9 2 G(s) = \\frac{2\\zeta\\omega}{s^2 + 2\\zeta\\omega + \\omega^2} G ( s ) = s 2 + 2 \u03b6 \u03c9 + \u03c9 2 2 \u03b6 \u03c9 \u200b","title":"\u4f1d\u9054\u95a2\u6570\u3067\u8868\u73fe\u3055\u308c\u308b\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/tf_filter/#_1","text":"","title":"\u4f1d\u9054\u95a2\u6570\u3067\u8868\u73fe\u3055\u308c\u308b\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/tf_filter/#_2","text":"\u4f1d\u9054\u95a2\u6570 G ( s ) = 1 T s + 1 G(s) = \\frac{1}{Ts + 1} G ( s ) = T s + 1 1 \u200b z\u9818\u57df\u4f1d\u9054\u95a2\u6570 G ( z ) = G(z) = \\frac{}{} G ( z ) = \u200b","title":"\u30ed\u30fc\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/tf_filter/#_3","text":"\u4f1d\u9054\u95a2\u6570 G ( s ) = T s T s + 1 G(s) = \\frac{Ts}{Ts + 1} G ( s ) = T s + 1 T s \u200b","title":"\u30cf\u30a4\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/tf_filter/#_4","text":"\u4f1d\u9054\u95a2\u6570 G ( s ) = 1 s G(s) = \\frac{1}{s} G ( s ) = s 1 \u200b","title":"\u7a4d\u5206\u8981\u7d20"},{"location":"tech_note/filter/tf_filter/#_5","text":"\u4f1d\u9054\u95a2\u6570 G ( s ) = s T s + 1 G(s) = \\frac{s}{Ts+1} G ( s ) = T s + 1 s \u200b","title":"\u4e0d\u5b8c\u5168\u5fae\u5206"},{"location":"tech_note/filter/tf_filter/#_6","text":"\u4f1d\u9054\u95a2\u6570 G ( s ) = s 2 + \u03c9 2 s 2 + 2 \u03b6 \u03c9 + \u03c9 2 G(s) = \\frac{s^2 + \\omega^2}{s^2 + 2\\zeta\\omega + \\omega^2} G ( s ) = s 2 + 2 \u03b6 \u03c9 + \u03c9 2 s 2 + \u03c9 2 \u200b","title":"\u30ce\u30c3\u30c1\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/filter/tf_filter/#_7","text":"\u4f1d\u9054\u95a2\u6570 G ( s ) = 2 \u03b6 \u03c9 s 2 + 2 \u03b6 \u03c9 + \u03c9 2 G(s) = \\frac{2\\zeta\\omega}{s^2 + 2\\zeta\\omega + \\omega^2} G ( s ) = s 2 + 2 \u03b6 \u03c9 + \u03c9 2 2 \u03b6 \u03c9 \u200b","title":"\u30d0\u30f3\u30c9\u30d1\u30b9\u30d5\u30a3\u30eb\u30bf"},{"location":"tech_note/geometry/geometry/","text":"\u56f3\u5f62\u306e\u885d\u7a81\u5224\u5b9a","title":"\u56f3\u5f62\u306e\u885d\u7a81\u5224\u5b9a"},{"location":"tech_note/geometry/geometry/#_1","text":"","title":"\u56f3\u5f62\u306e\u885d\u7a81\u5224\u5b9a"},{"location":"tech_note/kinematics/delta_robot/","text":"\u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8 \u9806\u904b\u52d5\u5b66 \u9006\u904b\u52d5\u5b66 \u53c2\u8003\u6587\u732e","title":"\u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8"},{"location":"tech_note/kinematics/delta_robot/#_1","text":"","title":"\u30c7\u30eb\u30bf\u30ed\u30dc\u30c3\u30c8"},{"location":"tech_note/kinematics/delta_robot/#_2","text":"","title":"\u9806\u904b\u52d5\u5b66"},{"location":"tech_note/kinematics/delta_robot/#_3","text":"","title":"\u9006\u904b\u52d5\u5b66"},{"location":"tech_note/kinematics/delta_robot/#_4","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/kinematics/diff_robot/","text":"\u5dee\u52d5\u4e8c\u8f2a \u9806\u904b\u52d5\u5b66 \u9006\u904b\u52d5\u5b66 \u53c2\u8003\u6587\u732e","title":"\u5dee\u52d5\u4e8c\u8f2a\u6a5f\u69cb"},{"location":"tech_note/kinematics/diff_robot/#_1","text":"","title":"\u5dee\u52d5\u4e8c\u8f2a"},{"location":"tech_note/kinematics/diff_robot/#_2","text":"","title":"\u9806\u904b\u52d5\u5b66"},{"location":"tech_note/kinematics/diff_robot/#_3","text":"","title":"\u9006\u904b\u52d5\u5b66"},{"location":"tech_note/kinematics/diff_robot/#_4","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/kinematics/mecanum/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u30e1\u30ab\u30ca\u30e0\u79fb\u52d5\u6a5f\u69cb \u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u30e1\u30ab\u30ca\u30e0\u30db\u30a4\u30fc\u30eb\u306e\u6a3d\u306e\u8ef8\u65b9\u5411\u306e\u307f\u306b\u529b\u304c\u4f5c\u7528\u3059\u308b\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\u3068 v 1 cos \u2061 \u03c0 4 = \u2212 x \u02d9 cos \u2061 \u03c0 4 + y \u02d9 cos \u2061 \u03c0 4 + l \u03b8 \u02d9 cos \u2061 ( \u03b1 \u2212 \u03c0 4 ) v_1 \\cos \\frac{\\pi}{4} = - \\dot{x} \\cos \\frac{\\pi}{4} + \\dot{y} \\cos \\frac{\\pi}{4} + l \\dot{\\theta} \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right) v 1 \u200b cos 4 \u03c0 \u200b = \u2212 x \u02d9 cos 4 \u03c0 \u200b + y \u02d9 \u200b cos 4 \u03c0 \u200b + l \u03b8 \u02d9 cos ( \u03b1 \u2212 4 \u03c0 \u200b ) \u5f0f\u6574\u7406\u3057\u3066 v 1 = \u2212 x \u02d9 + y \u02d9 + ( a + b ) \u03b8 \u02d9 v_1 = - \\dot{x} + \\dot{y} + (a+b)\\dot{\\theta} v 1 \u200b = \u2212 x \u02d9 + y \u02d9 \u200b + ( a + b ) \u03b8 \u02d9 \u3053\u3053\u3067\u53f3\u8fba\u7b2c3\u9805\u306e \u03b8 \u02d9 \\dot{\\theta} \u03b8 \u02d9 \u306b\u3064\u3044\u3066\u306e\u5f0f\u5909\u5f62\u306b\u3064\u3044\u3066\u4e0b\u8a18\u306e\u3088\u3046\u306b\u306a\u308b l cos \u2061 ( \u03b1 \u2212 \u03c0 4 ) cos \u2061 \u03c0 4 \u03b8 \u02d9 \\frac{l \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right)}{\\cos \\frac{\\pi}{4} } \\dot{\\theta}\\\\ cos 4 \u03c0 \u200b l cos ( \u03b1 \u2212 4 \u03c0 \u200b ) \u200b \u03b8 \u02d9 \u5206\u5b50\u306b\u52a0\u6cd5\u5b9a\u7406\u3092\u9069\u7528 \u21d4 l { cos \u2061 \u03b1 cos \u2061 \u03c0 4 + sin \u2061 \u03b1 sin \u2061 \u03c0 4 } cos \u2061 \u03c0 4 \u03b8 \u02d9 \u21d4 l { cos \u2061 \u03b1 cos \u2061 \u03c0 4 + sin \u2061 \u03b1 cos \u2061 \u03c0 4 } cos \u2061 \u03c0 4 \u03b8 \u02d9 \u21d4 l ( cos \u2061 \u03b1 + sin \u2061 \u03b1 ) \u03b8 \u02d9 \u21d4 l ( a l + b l ) \u03b8 \u02d9 \u21d4 ( a + b ) \u03b8 \u02d9 \\Leftrightarrow \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\sin \\frac{\\pi}{4} \\right\\}} {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\ \\Leftrightarrow \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\cos \\frac{\\pi}{4} \\right\\}} {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\ \\Leftrightarrow l \\left( \\cos \\alpha + \\sin \\alpha \\right) \\dot{\\theta}\\\\ \\Leftrightarrow l \\left( \\frac{a}{l} + \\frac{b}{l} \\right) \\dot{\\theta}\\\\ \\Leftrightarrow \\left(a +b \\right) \\dot{\\theta} \u21d4 cos 4 \u03c0 \u200b l { cos \u03b1 cos 4 \u03c0 \u200b + sin \u03b1 sin 4 \u03c0 \u200b } \u200b \u03b8 \u02d9 \u21d4 cos 4 \u03c0 \u200b l { cos \u03b1 cos 4 \u03c0 \u200b + sin \u03b1 cos 4 \u03c0 \u200b } \u200b \u03b8 \u02d9 \u21d4 l ( cos \u03b1 + sin \u03b1 ) \u03b8 \u02d9 \u21d4 l ( l a \u200b + l b \u200b ) \u03b8 \u02d9 \u21d4 ( a + b ) \u03b8 \u02d9 4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b [ v 1 v 2 v 3 v 4 ] = [ \u2212 1 1 ( a + b ) \u2212 1 \u2212 1 ( a + b ) 1 \u2212 1 ( a + b ) 1 1 ( a + b ) ] [ x \u02d9 y \u02d9 \u03b8 \u02d9 ] \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -1 & 1 & (a+b) \\\\ -1 & -1 & (a+b) \\\\ 1 & -1 & (a+b) \\\\ 1 & 1 & (a+b) \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \u23a3 \u23a1 \u200b v 1 \u200b v 2 \u200b v 3 \u200b v 4 \u200b \u200b \u23a6 \u23a4 \u200b = \u23a3 \u23a1 \u200b \u2212 1 \u2212 1 1 1 \u200b 1 \u2212 1 \u2212 1 1 \u200b ( a + b ) ( a + b ) ( a + b ) ( a + b ) \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b x \u02d9 y \u02d9 \u200b \u03b8 \u02d9 \u200b \u23a6 \u23a4 \u200b Note Todo: \u56f3\u3092\u8f09\u305b\u308b \u53c2\u8003\u6587\u732e \u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76 \u53c2\u8003\u6587\u732e\u3068\u306f\u30bf\u30a4\u30e4\u306e\u56de\u8ee2\u65b9\u5411\u306e\u5b9a\u7fa9\u304c\u7570\u306a\u308b\u305f\u3081\u9006\u904b\u52d5\u5b66\u304c\u7570\u306a\u308b\u3053\u3068\u306b\u6ce8\u610f","title":"\u30e1\u30ab\u30ca\u30e0\u79fb\u52d5\u6a5f\u69cb"},{"location":"tech_note/kinematics/mecanum/#_1","text":"\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u30e1\u30ab\u30ca\u30e0\u30db\u30a4\u30fc\u30eb\u306e\u6a3d\u306e\u8ef8\u65b9\u5411\u306e\u307f\u306b\u529b\u304c\u4f5c\u7528\u3059\u308b\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\u3068 v 1 cos \u2061 \u03c0 4 = \u2212 x \u02d9 cos \u2061 \u03c0 4 + y \u02d9 cos \u2061 \u03c0 4 + l \u03b8 \u02d9 cos \u2061 ( \u03b1 \u2212 \u03c0 4 ) v_1 \\cos \\frac{\\pi}{4} = - \\dot{x} \\cos \\frac{\\pi}{4} + \\dot{y} \\cos \\frac{\\pi}{4} + l \\dot{\\theta} \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right) v 1 \u200b cos 4 \u03c0 \u200b = \u2212 x \u02d9 cos 4 \u03c0 \u200b + y \u02d9 \u200b cos 4 \u03c0 \u200b + l \u03b8 \u02d9 cos ( \u03b1 \u2212 4 \u03c0 \u200b ) \u5f0f\u6574\u7406\u3057\u3066 v 1 = \u2212 x \u02d9 + y \u02d9 + ( a + b ) \u03b8 \u02d9 v_1 = - \\dot{x} + \\dot{y} + (a+b)\\dot{\\theta} v 1 \u200b = \u2212 x \u02d9 + y \u02d9 \u200b + ( a + b ) \u03b8 \u02d9 \u3053\u3053\u3067\u53f3\u8fba\u7b2c3\u9805\u306e \u03b8 \u02d9 \\dot{\\theta} \u03b8 \u02d9 \u306b\u3064\u3044\u3066\u306e\u5f0f\u5909\u5f62\u306b\u3064\u3044\u3066\u4e0b\u8a18\u306e\u3088\u3046\u306b\u306a\u308b l cos \u2061 ( \u03b1 \u2212 \u03c0 4 ) cos \u2061 \u03c0 4 \u03b8 \u02d9 \\frac{l \\cos \\left( \\alpha - \\frac{\\pi}{4} \\right)}{\\cos \\frac{\\pi}{4} } \\dot{\\theta}\\\\ cos 4 \u03c0 \u200b l cos ( \u03b1 \u2212 4 \u03c0 \u200b ) \u200b \u03b8 \u02d9 \u5206\u5b50\u306b\u52a0\u6cd5\u5b9a\u7406\u3092\u9069\u7528 \u21d4 l { cos \u2061 \u03b1 cos \u2061 \u03c0 4 + sin \u2061 \u03b1 sin \u2061 \u03c0 4 } cos \u2061 \u03c0 4 \u03b8 \u02d9 \u21d4 l { cos \u2061 \u03b1 cos \u2061 \u03c0 4 + sin \u2061 \u03b1 cos \u2061 \u03c0 4 } cos \u2061 \u03c0 4 \u03b8 \u02d9 \u21d4 l ( cos \u2061 \u03b1 + sin \u2061 \u03b1 ) \u03b8 \u02d9 \u21d4 l ( a l + b l ) \u03b8 \u02d9 \u21d4 ( a + b ) \u03b8 \u02d9 \\Leftrightarrow \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\sin \\frac{\\pi}{4} \\right\\}} {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\ \\Leftrightarrow \\frac{l \\left\\{ \\cos \\alpha \\cos \\frac{\\pi}{4} + \\sin \\alpha \\cos \\frac{\\pi}{4} \\right\\}} {\\cos \\frac{\\pi}{4} } \\dot{\\theta} \\\\ \\Leftrightarrow l \\left( \\cos \\alpha + \\sin \\alpha \\right) \\dot{\\theta}\\\\ \\Leftrightarrow l \\left( \\frac{a}{l} + \\frac{b}{l} \\right) \\dot{\\theta}\\\\ \\Leftrightarrow \\left(a +b \\right) \\dot{\\theta} \u21d4 cos 4 \u03c0 \u200b l { cos \u03b1 cos 4 \u03c0 \u200b + sin \u03b1 sin 4 \u03c0 \u200b } \u200b \u03b8 \u02d9 \u21d4 cos 4 \u03c0 \u200b l { cos \u03b1 cos 4 \u03c0 \u200b + sin \u03b1 cos 4 \u03c0 \u200b } \u200b \u03b8 \u02d9 \u21d4 l ( cos \u03b1 + sin \u03b1 ) \u03b8 \u02d9 \u21d4 l ( l a \u200b + l b \u200b ) \u03b8 \u02d9 \u21d4 ( a + b ) \u03b8 \u02d9 4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b [ v 1 v 2 v 3 v 4 ] = [ \u2212 1 1 ( a + b ) \u2212 1 \u2212 1 ( a + b ) 1 \u2212 1 ( a + b ) 1 1 ( a + b ) ] [ x \u02d9 y \u02d9 \u03b8 \u02d9 ] \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -1 & 1 & (a+b) \\\\ -1 & -1 & (a+b) \\\\ 1 & -1 & (a+b) \\\\ 1 & 1 & (a+b) \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \u23a3 \u23a1 \u200b v 1 \u200b v 2 \u200b v 3 \u200b v 4 \u200b \u200b \u23a6 \u23a4 \u200b = \u23a3 \u23a1 \u200b \u2212 1 \u2212 1 1 1 \u200b 1 \u2212 1 \u2212 1 1 \u200b ( a + b ) ( a + b ) ( a + b ) ( a + b ) \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b x \u02d9 y \u02d9 \u200b \u03b8 \u02d9 \u200b \u23a6 \u23a4 \u200b Note Todo: \u56f3\u3092\u8f09\u305b\u308b","title":"\u30e1\u30ab\u30ca\u30e0\u79fb\u52d5\u6a5f\u69cb"},{"location":"tech_note/kinematics/mecanum/#_2","text":"\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76 \u53c2\u8003\u6587\u732e\u3068\u306f\u30bf\u30a4\u30e4\u306e\u56de\u8ee2\u65b9\u5411\u306e\u5b9a\u7fa9\u304c\u7570\u306a\u308b\u305f\u3081\u9006\u904b\u52d5\u5b66\u304c\u7570\u306a\u308b\u3053\u3068\u306b\u6ce8\u610f","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/kinematics/omni/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u30aa\u30e0\u30cb\u79fb\u52d5\u6a5f\u69cb 3\u8f2a\u30aa\u30e0\u30cb \u56f3\u306e\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066 v 1 = \u2212 x \u02d9 sin \u2061 \u03b1 + y \u02d9 cos \u2061 \u03b1 + L \u03b8 \u02d9 v_1 = - \\dot{x} \\sin \\alpha + \\dot{y} \\cos \\alpha + L \\dot{\\theta} v 1 \u200b = \u2212 x \u02d9 sin \u03b1 + y \u02d9 \u200b cos \u03b1 + L \u03b8 \u02d9 3\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b [ v 1 v 2 v 3 ] = [ \u2212 sin \u2061 \u03b1 cos \u2061 \u03b1 L \u2212 sin \u2061 ( \u03b1 + 2 3 \u03c0 ) cos \u2061 ( \u03b1 + 2 3 \u03c0 ) L \u2212 sin \u2061 ( \u03b1 \u2212 2 3 \u03c0 ) cos \u2061 ( \u03b1 \u2212 2 3 \u03c0 ) L ] [ x \u02d9 y \u02d9 \u03b8 \u02d9 ] \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha & \\cos\\alpha & L \\\\ -\\sin \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) & \\cos \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) & L \\\\ -\\sin \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) & \\cos \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) & L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \u23a3 \u23a1 \u200b v 1 \u200b v 2 \u200b v 3 \u200b \u200b \u23a6 \u23a4 \u200b = \u23a3 \u23a1 \u200b \u2212 sin \u03b1 \u2212 sin ( \u03b1 + 3 2 \u200b \u03c0 ) \u2212 sin ( \u03b1 \u2212 3 2 \u200b \u03c0 ) \u200b cos \u03b1 cos ( \u03b1 + 3 2 \u200b \u03c0 ) cos ( \u03b1 \u2212 3 2 \u200b \u03c0 ) \u200b L L L \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b x \u02d9 y \u02d9 \u200b \u03b8 \u02d9 \u200b \u23a6 \u23a4 \u200b Note Todo: \u56f3\u3092\u8f09\u305b\u308b 4\u8f2a\u30aa\u30e0\u30cb \u5404\u8eca\u8f2a\u3054\u3068\u306b\u8003\u3048\u308b\u3053\u3068\u306f3\u8f2a\u30aa\u30e0\u30cb\u3068\u5909\u308f\u3089\u306a\u3044 [ v 1 v 2 v 3 v 4 ] = [ \u2212 sin \u2061 \u03b1 cos \u2061 \u03b1 L \u2212 sin \u2061 ( \u03b1 + \u03c0 2 ) cos \u2061 ( \u03b1 + \u03c0 2 ) L \u2212 sin \u2061 ( \u03b1 + \u03c0 ) cos \u2061 ( \u03b1 + \u03c0 ) L \u2212 sin \u2061 ( \u03b1 + 3 \u03c0 2 ) cos \u2061 ( \u03b1 + 3 \u03c0 2 ) L ] [ x \u02d9 y \u02d9 \u03b8 \u02d9 ] \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha & \\cos\\alpha & L \\\\ -\\sin \\left( \\alpha + \\dfrac{\\pi}{2} \\right) & \\cos \\left( \\alpha + \\dfrac{\\pi}{2} \\right) & L \\\\ -\\sin \\left( \\alpha + \\pi \\right) & \\cos \\left( \\alpha + \\pi \\right) & L \\\\ -\\sin \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) & \\cos \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) & L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \u23a3 \u23a1 \u200b v 1 \u200b v 2 \u200b v 3 \u200b v 4 \u200b \u200b \u23a6 \u23a4 \u200b = \u23a3 \u23a1 \u200b \u2212 sin \u03b1 \u2212 sin ( \u03b1 + 2 \u03c0 \u200b ) \u2212 sin ( \u03b1 + \u03c0 ) \u2212 sin ( \u03b1 + 2 3 \u03c0 \u200b ) \u200b cos \u03b1 cos ( \u03b1 + 2 \u03c0 \u200b ) cos ( \u03b1 + \u03c0 ) cos ( \u03b1 + 2 3 \u03c0 \u200b ) \u200b L L L L \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b x \u02d9 y \u02d9 \u200b \u03b8 \u02d9 \u200b \u23a6 \u23a4 \u200b Note Todo: \u56f3\u3092\u8f09\u305b\u308b \u53c2\u8003\u6587\u732e \u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76","title":"\u30aa\u30e0\u30cb\u79fb\u52d5\u6a5f\u69cb"},{"location":"tech_note/kinematics/omni/#_1","text":"","title":"\u30aa\u30e0\u30cb\u79fb\u52d5\u6a5f\u69cb"},{"location":"tech_note/kinematics/omni/#3","text":"\u56f3\u306e\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066 v 1 = \u2212 x \u02d9 sin \u2061 \u03b1 + y \u02d9 cos \u2061 \u03b1 + L \u03b8 \u02d9 v_1 = - \\dot{x} \\sin \\alpha + \\dot{y} \\cos \\alpha + L \\dot{\\theta} v 1 \u200b = \u2212 x \u02d9 sin \u03b1 + y \u02d9 \u200b cos \u03b1 + L \u03b8 \u02d9 3\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b [ v 1 v 2 v 3 ] = [ \u2212 sin \u2061 \u03b1 cos \u2061 \u03b1 L \u2212 sin \u2061 ( \u03b1 + 2 3 \u03c0 ) cos \u2061 ( \u03b1 + 2 3 \u03c0 ) L \u2212 sin \u2061 ( \u03b1 \u2212 2 3 \u03c0 ) cos \u2061 ( \u03b1 \u2212 2 3 \u03c0 ) L ] [ x \u02d9 y \u02d9 \u03b8 \u02d9 ] \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha & \\cos\\alpha & L \\\\ -\\sin \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) & \\cos \\left( \\alpha + \\dfrac{2}{3}\\pi \\right) & L \\\\ -\\sin \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) & \\cos \\left( \\alpha - \\dfrac{2}{3}\\pi \\right) & L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \u23a3 \u23a1 \u200b v 1 \u200b v 2 \u200b v 3 \u200b \u200b \u23a6 \u23a4 \u200b = \u23a3 \u23a1 \u200b \u2212 sin \u03b1 \u2212 sin ( \u03b1 + 3 2 \u200b \u03c0 ) \u2212 sin ( \u03b1 \u2212 3 2 \u200b \u03c0 ) \u200b cos \u03b1 cos ( \u03b1 + 3 2 \u200b \u03c0 ) cos ( \u03b1 \u2212 3 2 \u200b \u03c0 ) \u200b L L L \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b x \u02d9 y \u02d9 \u200b \u03b8 \u02d9 \u200b \u23a6 \u23a4 \u200b Note Todo: \u56f3\u3092\u8f09\u305b\u308b","title":"3\u8f2a\u30aa\u30e0\u30cb"},{"location":"tech_note/kinematics/omni/#4","text":"\u5404\u8eca\u8f2a\u3054\u3068\u306b\u8003\u3048\u308b\u3053\u3068\u306f3\u8f2a\u30aa\u30e0\u30cb\u3068\u5909\u308f\u3089\u306a\u3044 [ v 1 v 2 v 3 v 4 ] = [ \u2212 sin \u2061 \u03b1 cos \u2061 \u03b1 L \u2212 sin \u2061 ( \u03b1 + \u03c0 2 ) cos \u2061 ( \u03b1 + \u03c0 2 ) L \u2212 sin \u2061 ( \u03b1 + \u03c0 ) cos \u2061 ( \u03b1 + \u03c0 ) L \u2212 sin \u2061 ( \u03b1 + 3 \u03c0 2 ) cos \u2061 ( \u03b1 + 3 \u03c0 2 ) L ] [ x \u02d9 y \u02d9 \u03b8 \u02d9 ] \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ \\end{bmatrix} = \\begin{bmatrix} -\\sin \\alpha & \\cos\\alpha & L \\\\ -\\sin \\left( \\alpha + \\dfrac{\\pi}{2} \\right) & \\cos \\left( \\alpha + \\dfrac{\\pi}{2} \\right) & L \\\\ -\\sin \\left( \\alpha + \\pi \\right) & \\cos \\left( \\alpha + \\pi \\right) & L \\\\ -\\sin \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) & \\cos \\left( \\alpha + \\dfrac{3\\pi}{2} \\right) & L \\\\ \\end{bmatrix} \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{\\theta} \\end{bmatrix} \u23a3 \u23a1 \u200b v 1 \u200b v 2 \u200b v 3 \u200b v 4 \u200b \u200b \u23a6 \u23a4 \u200b = \u23a3 \u23a1 \u200b \u2212 sin \u03b1 \u2212 sin ( \u03b1 + 2 \u03c0 \u200b ) \u2212 sin ( \u03b1 + \u03c0 ) \u2212 sin ( \u03b1 + 2 3 \u03c0 \u200b ) \u200b cos \u03b1 cos ( \u03b1 + 2 \u03c0 \u200b ) cos ( \u03b1 + \u03c0 ) cos ( \u03b1 + 2 3 \u03c0 \u200b ) \u200b L L L L \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b x \u02d9 y \u02d9 \u200b \u03b8 \u02d9 \u200b \u23a6 \u23a4 \u200b Note Todo: \u56f3\u3092\u8f09\u305b\u308b","title":"4\u8f2a\u30aa\u30e0\u30cb"},{"location":"tech_note/kinematics/omni/#_2","text":"\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/kinematics/swerve/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb \u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u8003\u3048\u308b\u3068 v 1 \u20d7 = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 , y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 ) \\vec{v_1} = \\left( \\dot{x} -r \\dot{\\theta}\\sin{\\theta}, \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right) v 1 \u200b \u200b = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 , y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 ) \u3053\u306e\u6642\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306e\u64cd\u8235\u89d2\u5ea6\u306f \u03b8 1 = tan \u2061 \u2212 1 y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}} \u03b8 1 \u200b = tan \u2212 1 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 \u200b 4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b v 1 \u20d7 = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 , y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 ) v 2 \u20d7 = ( x \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 , y \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 ) v 3 \u20d7 = ( x \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 , y \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 ) v 4 \u20d7 = ( x \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 , y \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 ) \\vec{v_1} = \\left( \\dot{x} -r \\dot{\\theta}\\sin{\\theta}, \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_2} = \\left( \\dot{x} -r \\dot{\\theta}\\cos{\\theta}, \\dot{y} -r \\dot{\\theta}\\sin{\\theta} \\right)\\\\ \\vec{v_3} = \\left( \\dot{x} +r \\dot{\\theta}\\sin{\\theta}, \\dot{y} -r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_4} = \\left( \\dot{x} +r \\dot{\\theta}\\cos{\\theta}, \\dot{y} +r \\dot{\\theta}\\sin{\\theta} \\right) v 1 \u200b \u200b = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 , y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 ) v 2 \u200b \u200b = ( x \u02d9 \u2212 r \u03b8 \u02d9 cos \u03b8 , y \u02d9 \u200b \u2212 r \u03b8 \u02d9 sin \u03b8 ) v 3 \u200b \u200b = ( x \u02d9 + r \u03b8 \u02d9 sin \u03b8 , y \u02d9 \u200b \u2212 r \u03b8 \u02d9 cos \u03b8 ) v 4 \u200b \u200b = ( x \u02d9 + r \u03b8 \u02d9 cos \u03b8 , y \u02d9 \u200b + r \u03b8 \u02d9 sin \u03b8 ) \u03b8 1 = tan \u2061 \u2212 1 y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 \u03b8 2 = tan \u2061 \u2212 1 y \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 x \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 \u03b8 3 = tan \u2061 \u2212 1 y \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 x \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 \u03b8 4 = tan \u2061 \u2212 1 y \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 x \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_2 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} -r \\dot{\\theta}\\cos{\\theta}}\\\\ \\theta_3 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} +r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_4 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} +r \\dot{\\theta}\\cos{\\theta}}\\\\ \u03b8 1 \u200b = tan \u2212 1 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 \u200b \u03b8 2 \u200b = tan \u2212 1 x \u02d9 \u2212 r \u03b8 \u02d9 cos \u03b8 y \u02d9 \u200b \u2212 r \u03b8 \u02d9 sin \u03b8 \u200b \u03b8 3 \u200b = tan \u2212 1 x \u02d9 + r \u03b8 \u02d9 sin \u03b8 y \u02d9 \u200b \u2212 r \u03b8 \u02d9 cos \u03b8 \u200b \u03b8 4 \u200b = tan \u2212 1 x \u02d9 + r \u03b8 \u02d9 cos \u03b8 y \u02d9 \u200b + r \u03b8 \u02d9 sin \u03b8 \u200b \u5236\u5fa1\u3059\u308b\u969b\u306b\u306f\u64cd\u8235\u89d2\u306e\u89d2\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b \u03b8 j \\theta_j \u03b8 j \u200b \u3092\u4e0e\u3048\u3001\u30db\u30a4\u30fc\u30eb\u306e\u901f\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b \u2223 v j \u20d7 \u2223 |\\vec{v_j}| \u2223 v j \u200b \u200b \u2223 \u3092\u4e0e\u3048\u308b\u3002 Note Todo: \u56f3\u3092\u8f09\u305b\u308b \u53c2\u8003\u6587\u732e \u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76 \u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb\u306e\u9006\u904b\u52d5\u5b66\u306b\u3064\u3044\u3066\u3053\u306e\u30da\u30fc\u30b8\u3068\u53c2\u8003\u6587\u732e\u3067 v 1 v_1 v 1 \u200b \u306b\u3064\u3044\u3066\u306e cos \u2061 , sin \u2061 \\cos, \\sin cos , sin \u304c\u7570\u306a\u3063\u3066\u3044\u308b\u7b87\u6240\u304c\u5b58\u5728\u3059\u308b\u304c\u5c0e\u51fa\u3092\u8003\u3048\u308b\u3068\u53c2\u8003\u6587\u732e\u306e\u65b9\u306b\u8aa4\u690d\u304c\u3042\u308b\u3068\u8003\u3048\u3089\u308c\u308b","title":"\u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb"},{"location":"tech_note/kinematics/swerve/#4","text":"\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306b\u3064\u3044\u3066\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u8003\u3048\u308b\u3068 v 1 \u20d7 = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 , y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 ) \\vec{v_1} = \\left( \\dot{x} -r \\dot{\\theta}\\sin{\\theta}, \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right) v 1 \u200b \u200b = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 , y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 ) \u3053\u306e\u6642\u56f3\u306e\u53f3\u4e0a\u306e\u30db\u30a4\u30fc\u30eb\u306e\u64cd\u8235\u89d2\u5ea6\u306f \u03b8 1 = tan \u2061 \u2212 1 y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}} \u03b8 1 \u200b = tan \u2212 1 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 \u200b 4\u8f2a\u5206\u3092\u4e0a\u8a18\u306e\u3088\u3046\u306b\u5c0e\u51fa\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b v 1 \u20d7 = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 , y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 ) v 2 \u20d7 = ( x \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 , y \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 ) v 3 \u20d7 = ( x \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 , y \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 ) v 4 \u20d7 = ( x \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 , y \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 ) \\vec{v_1} = \\left( \\dot{x} -r \\dot{\\theta}\\sin{\\theta}, \\dot{y} +r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_2} = \\left( \\dot{x} -r \\dot{\\theta}\\cos{\\theta}, \\dot{y} -r \\dot{\\theta}\\sin{\\theta} \\right)\\\\ \\vec{v_3} = \\left( \\dot{x} +r \\dot{\\theta}\\sin{\\theta}, \\dot{y} -r \\dot{\\theta}\\cos{\\theta} \\right)\\\\ \\vec{v_4} = \\left( \\dot{x} +r \\dot{\\theta}\\cos{\\theta}, \\dot{y} +r \\dot{\\theta}\\sin{\\theta} \\right) v 1 \u200b \u200b = ( x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 , y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 ) v 2 \u200b \u200b = ( x \u02d9 \u2212 r \u03b8 \u02d9 cos \u03b8 , y \u02d9 \u200b \u2212 r \u03b8 \u02d9 sin \u03b8 ) v 3 \u200b \u200b = ( x \u02d9 + r \u03b8 \u02d9 sin \u03b8 , y \u02d9 \u200b \u2212 r \u03b8 \u02d9 cos \u03b8 ) v 4 \u200b \u200b = ( x \u02d9 + r \u03b8 \u02d9 cos \u03b8 , y \u02d9 \u200b + r \u03b8 \u02d9 sin \u03b8 ) \u03b8 1 = tan \u2061 \u2212 1 y \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 \u03b8 2 = tan \u2061 \u2212 1 y \u02d9 \u2212 r \u03b8 \u02d9 sin \u2061 \u03b8 x \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 \u03b8 3 = tan \u2061 \u2212 1 y \u02d9 \u2212 r \u03b8 \u02d9 cos \u2061 \u03b8 x \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 \u03b8 4 = tan \u2061 \u2212 1 y \u02d9 + r \u03b8 \u02d9 sin \u2061 \u03b8 x \u02d9 + r \u03b8 \u02d9 cos \u2061 \u03b8 \\theta_1 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} -r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_2 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} -r \\dot{\\theta}\\cos{\\theta}}\\\\ \\theta_3 = \\tan^{-1}\\dfrac{\\dot{y} -r \\dot{\\theta}\\cos{\\theta}}{\\dot{x} +r \\dot{\\theta}\\sin{\\theta}}\\\\ \\theta_4 = \\tan^{-1}\\dfrac{\\dot{y} +r \\dot{\\theta}\\sin{\\theta}}{\\dot{x} +r \\dot{\\theta}\\cos{\\theta}}\\\\ \u03b8 1 \u200b = tan \u2212 1 x \u02d9 \u2212 r \u03b8 \u02d9 sin \u03b8 y \u02d9 \u200b + r \u03b8 \u02d9 cos \u03b8 \u200b \u03b8 2 \u200b = tan \u2212 1 x \u02d9 \u2212 r \u03b8 \u02d9 cos \u03b8 y \u02d9 \u200b \u2212 r \u03b8 \u02d9 sin \u03b8 \u200b \u03b8 3 \u200b = tan \u2212 1 x \u02d9 + r \u03b8 \u02d9 sin \u03b8 y \u02d9 \u200b \u2212 r \u03b8 \u02d9 cos \u03b8 \u200b \u03b8 4 \u200b = tan \u2212 1 x \u02d9 + r \u03b8 \u02d9 cos \u03b8 y \u02d9 \u200b + r \u03b8 \u02d9 sin \u03b8 \u200b \u5236\u5fa1\u3059\u308b\u969b\u306b\u306f\u64cd\u8235\u89d2\u306e\u89d2\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b \u03b8 j \\theta_j \u03b8 j \u200b \u3092\u4e0e\u3048\u3001\u30db\u30a4\u30fc\u30eb\u306e\u901f\u5ea6\u5236\u5fa1\u306e\u76ee\u6a19\u5024\u306b \u2223 v j \u20d7 \u2223 |\\vec{v_j}| \u2223 v j \u200b \u200b \u2223 \u3092\u4e0e\u3048\u308b\u3002 Note Todo: \u56f3\u3092\u8f09\u305b\u308b","title":"\u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb"},{"location":"tech_note/kinematics/swerve/#_1","text":"\u30ed\u30dc\u30b3\u30f3\u306b\u304a\u3051\u308b\u81ea\u52d5\u8d70\u884c\u30ed\u30dc\u30c3\u30c8\u306e\u8db3\u56de\u308a\u306e\u7814\u7a76 \u72ec\u7acb4\u8f2a\u30b9\u30c6\u30a2\u79fb\u52d5\u6a5f\u69cb\u306e\u9006\u904b\u52d5\u5b66\u306b\u3064\u3044\u3066\u3053\u306e\u30da\u30fc\u30b8\u3068\u53c2\u8003\u6587\u732e\u3067 v 1 v_1 v 1 \u200b \u306b\u3064\u3044\u3066\u306e cos \u2061 , sin \u2061 \\cos, \\sin cos , sin \u304c\u7570\u306a\u3063\u3066\u3044\u308b\u7b87\u6240\u304c\u5b58\u5728\u3059\u308b\u304c\u5c0e\u51fa\u3092\u8003\u3048\u308b\u3068\u53c2\u8003\u6587\u732e\u306e\u65b9\u306b\u8aa4\u690d\u304c\u3042\u308b\u3068\u8003\u3048\u3089\u308c\u308b","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/motor/mabuchi/","text":"\u30de\u30d6\u30c1\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a \u53c2\u8003\u6587\u732e","title":"\u30de\u30d6\u30c1\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a"},{"location":"tech_note/motor/mabuchi/#_1","text":"","title":"\u30de\u30d6\u30c1\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a"},{"location":"tech_note/motor/mabuchi/#_2","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/motor/maxon/","text":"maxon\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a \u53c2\u8003\u6587\u732e","title":"maxon\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a"},{"location":"tech_note/motor/maxon/#maxon","text":"","title":"maxon\u30e2\u30fc\u30bf\u306e\u30b9\u30da\u30c3\u30af\u8aad\u307f\u53d6\u308a"},{"location":"tech_note/motor/maxon/#_1","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/motor/motor_model/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u30e2\u30fc\u30bf\u30fc\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe d d t [ i ( t ) \u03c9 ( t ) ] = [ \u2212 R L \u2212 K e L K t J 0 ] [ i ( t ) \u03c9 ( t ) ] + [ 1 L 0 ] V ( t ) y ( t ) = [ 0 1 ] [ i ( t ) \u03c9 ( t ) ] \\begin{array}{l} \\frac{\\rm{d}}{\\rm{dt}} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} = \\begin{bmatrix} -\\frac{R}{L} & -\\frac{K_e}{L} \\\\ \\frac{K_t}{J} & 0 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} + \\begin{bmatrix} \\frac{1}{L}\\\\ 0 \\end{bmatrix} V(t) \\\\ y(t) = \\begin{bmatrix} 0 & 1 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} \\end{array} dt d \u200b [ i ( t ) \u03c9 ( t ) \u200b ] = [ \u2212 L R \u200b J K t \u200b \u200b \u200b \u2212 L K e \u200b \u200b 0 \u200b ] [ i ( t ) \u03c9 ( t ) \u200b ] + [ L 1 \u200b 0 \u200b ] V ( t ) y ( t ) = [ 0 \u200b 1 \u200b ] [ i ( t ) \u03c9 ( t ) \u200b ] \u200b \u53c2\u8003\u6587\u732e \u73fe\u4ee3\u5236\u5fa1 2\u6b21\u30b7\u30b9\u30c6\u30e0(RL\u56de\u8def+\u30e2\u30fc\u30bf\u30fc)\u306e\u72b6\u614b\u65b9\u7a0b\u5f0f","title":"\u30e2\u30fc\u30bf\u30fc\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe"},{"location":"tech_note/motor/motor_model/#_1","text":"d d t [ i ( t ) \u03c9 ( t ) ] = [ \u2212 R L \u2212 K e L K t J 0 ] [ i ( t ) \u03c9 ( t ) ] + [ 1 L 0 ] V ( t ) y ( t ) = [ 0 1 ] [ i ( t ) \u03c9 ( t ) ] \\begin{array}{l} \\frac{\\rm{d}}{\\rm{dt}} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} = \\begin{bmatrix} -\\frac{R}{L} & -\\frac{K_e}{L} \\\\ \\frac{K_t}{J} & 0 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} + \\begin{bmatrix} \\frac{1}{L}\\\\ 0 \\end{bmatrix} V(t) \\\\ y(t) = \\begin{bmatrix} 0 & 1 \\end{bmatrix} \\begin{bmatrix} i(t)\\\\ \\omega(t) \\end{bmatrix} \\end{array} dt d \u200b [ i ( t ) \u03c9 ( t ) \u200b ] = [ \u2212 L R \u200b J K t \u200b \u200b \u200b \u2212 L K e \u200b \u200b 0 \u200b ] [ i ( t ) \u03c9 ( t ) \u200b ] + [ L 1 \u200b 0 \u200b ] V ( t ) y ( t ) = [ 0 \u200b 1 \u200b ] [ i ( t ) \u03c9 ( t ) \u200b ] \u200b","title":"\u30e2\u30fc\u30bf\u30fc\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe"},{"location":"tech_note/motor/motor_model/#_2","text":"\u73fe\u4ee3\u5236\u5fa1 2\u6b21\u30b7\u30b9\u30c6\u30e0(RL\u56de\u8def+\u30e2\u30fc\u30bf\u30fc)\u306e\u72b6\u614b\u65b9\u7a0b\u5f0f","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimal_control/mpc/","text":"\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1 \u53c2\u8003\u6587\u732e \u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580","title":"\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1(MPC)"},{"location":"tech_note/optimal_control/mpc/#_1","text":"","title":"\u30e2\u30c7\u30eb\u4e88\u6e2c\u5236\u5fa1"},{"location":"tech_note/optimal_control/mpc/#_2","text":"\u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimal_control/optimal_control/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u6700\u9069\u5236\u5fa1 \u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f \u30b7\u30b9\u30c6\u30e0\u30fb\u521d\u671f\u72b6\u614b\u30fb\u8a55\u4fa1\u95a2\u6570\u304c\u4e0e\u3048\u3089\u308c\u305f\u6642\u306b\u8a55\u4fa1\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u6700\u9069\u306a\u5236\u5fa1\u5165\u529b\u304c\u6e80\u305f\u3059\u3079\u304d\u6761\u4ef6\u3002\u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308bKKT\u6761\u4ef6\u3068\u8003\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u3064\u307e\u308a\u6700\u9069\u5236\u5fa1\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6 \u52d5\u7684\u8a08\u753b\u6cd5 \u52d5\u7684\u8a08\u753b\u6cd5\u3067\u306f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5206\u91ce\u3067\u306f\u5bfe\u8c61\u3068\u306a\u308b\u554f\u984c\u3092\u8907\u6570\u306e\u90e8\u5206\u554f\u984c\u306b\u5206\u5272\u3057\u3001\u90e8\u5206\u554f\u984c\u306e\u8a08\u7b97\u7d50\u679c\u3092\u8a18\u9332\u3057\u306a\u304c\u3089\u89e3\u3044\u3066\u3044\u304f\u624b\u6cd5\u306e\u7dcf\u79f0\u3092\u6307\u3059\u3002 \u6700\u9069\u5236\u5fa1\u306b\u304a\u3051\u308b\u52d5\u7684\u8a08\u753b\u6cd5\u3068\u306f\u8a55\u4fa1\u95a2\u6570\u306e\u6700\u5c0f\u5024\u3092\u518d\u5e30\u7684\u306b\u8868\u3059\u624b\u6cd5\u306e\u3053\u3068\u3092\u6307\u3059\u3002 \u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f \u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u3063\u3066\u8868\u3055\u308c\u305f\u5024\u95a2\u6570\u306e\u518d\u5e30\u4e00\u56de\u5206\u3092\u53d6\u308a\u51fa\u3057\u305f\u6642\u523bk\u3068\u6642\u523bk+1\u306e\u5024\u95a2\u6570\u306e\u95a2\u4fc2\u5f0f\u3002\u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f\u306b\u3088\u3063\u3066\u6700\u9069\u5236\u5fa1\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6\u304c\u5c0e\u304b\u308c\u308b\u304c\u3001\u6700\u9069\u5236\u5fa1\u554f\u984c\u304c\u6301\u3064\u6642\u9593\u7684\u306a\u69cb\u9020\u3092\u4f7f\u3046\u3053\u3068\u3067\u5c0e\u304b\u308c\u308b\u5225\u306e\u5f62\u306e\u6700\u9069\u6027\u6761\u4ef6\u304c\u3053\u306e\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u3067\u8868\u3055\u308c\u308b\u3002 \u6700\u9069\u5236\u5fa1\u306e\u5fc5\u8981\u6761\u4ef6 \u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u306e\u7d42\u7aef\u6761\u4ef6\u306e\u3082\u3068\u3067\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u304c\u6210\u7acb\u3059\u308b \u6700\u9069\u5236\u5fa1\u306e\u5341\u5206\u6761\u4ef6 \u5909\u5206\u6cd5 \u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u6700\u9069\u5236\u5fa1\u306b\u304a\u3044\u3066\u57fa\u790e\u3068\u306a\u308b\u3001\u95a2\u6570\u306e\u5fae\u5206\u3092\u6c4e\u95a2\u6570\u306b\u62e1\u5f35\u3057\u305f\u3082\u306e\u3002 \u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5 \u4ee5\u4e0b\u306e\u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5\u306f\u30b7\u30b9\u30c6\u30e0\u304c\u9023\u7d9a\u6642\u9593\u3067\u3082\u96e2\u6563\u6642\u9593\u3067\u3082\u96e2\u6563\u7684\u306b\u6c42\u3081\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u96e2\u6563\u30b7\u30b9\u30c6\u30e0\u306e\u5834\u5408\u306f\u6570\u5024\u7684\u306b\u7a4d\u5206\u64cd\u4f5c\u3092\u884c\u3046\u306a\u3069\u306e\u64cd\u4f5c\u304c\u767a\u751f\u3059\u308b\u3002 \u6570\u5024\u89e3\u6cd5 \u9577\u6240 \u77ed\u6240 \u9069\u3059\u308b\u7528\u9014 \u52fe\u914d\u6cd5 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u4e0d\u8981 \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u9045\u3044 \u6700\u9069\u89e3\u306e\u304a\u304a\u3088\u305d\u306e\u69d8\u5b50\u3092\u624b\u8efd\u306b\u77e5\u308a\u305f\u3044\u6642 \u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5 \u672a\u77e5\u91cf\u304c\u6709\u9650\u6b21\u5143 \u8a08\u7b97\u304c\u767a\u6563\u3057\u3084\u3059\u3044 \u826f\u597d\u306a\u521d\u671f\u63a8\u5b9a\u89e3\u3092\u9078\u3079\u308b\u6642 \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(2\u6b21\u306e\u52fe\u914d\u6cd5) \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u901f\u3044 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u5fc5\u8981\u3067\u5404\u53cd\u5fa9\u306b\u304a\u3051\u308b\u8a08\u7b97\u91cf\u304c\u591a\u3044 \u6700\u9069\u89e3\u3092\u7cbe\u5ea6\u826f\u304f\u6c42\u3081\u305f\u3044\u6642 \u52d5\u7684\u8a08\u753b\u6cd5 \u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u304c\u5f97\u3089\u308c\u308b \u72b6\u614b\u306e\u6b21\u5143\u304c\u9ad8\u3044\u3068\u8a18\u61b6\u91cf\u304c\u81a8\u5927 \u72b6\u614b\u306e\u6b21\u5143\u304c\u4f4e\u3044\u304b\u3001\u72ed\u3044\u7bc4\u56f2\u3060\u3051\u8003\u616e\u3059\u308c\u3070\u826f\u3044\u6642 \u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5) \u30cf\u30df\u30eb\u30c8\u30f3\u95a2\u6570\u306e\u5236\u5fa1\u5165\u529b\u504f\u5fae\u5206 \u2202 H \u2202 u \\frac{\\partial H}{\\partial u} \u2202 u \u2202 H \u200b \u304c0\u306b\u306a\u308b\u307e\u3067 \u2212 \u2202 H \u2202 u -\\frac{\\partial H}{\\partial u} \u2212 \u2202 u \u2202 H \u200b \u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3001\u76f4\u7dda\u7dda\u63a2\u7d22\u3068\u7d44\u307f\u5408\u308f\u305b\u3066 u u u \u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u3002\u968f\u4f34\u5909\u6570\u306f\u968f\u4f34\u65b9\u7a0b\u5f0f\u304b\u3089$ \\frac{\\partial H}{\\partial x} \u3092\u4f7f\u3063\u3066\u6c42\u3081\u308b\u3002\u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u5236\u5fa1\u91cf u u u \u3002 \u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5 \u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u521d\u671f\u5024\u304b\u3089\u72b6\u614b\u91cf\u3092\u64cd\u4f5c\u3057\u3001\u7d42\u7aef\u6761\u4ef6\u3092\u5408\u308f\u305b\u306b\u3044\u304f\u69d8\u304c\u5c04\u6483\u306b\u4f3c\u3066\u3044\u308b\u3053\u3068\u304b\u3089\u3053\u306e\u540d\u304c\u3064\u3051\u3089\u308c\u305f\u3002 \u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5 \u958b\u59cb\u6642\u9593\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u306e\u521d\u671f\u5024\u3092\u4e0e\u3048\u3001\u521d\u671f\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6761\u4ef6\u3068\u3057\u3066\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3092\u7d42\u7aef\u6642\u9593\u307e\u3067\u89e3\u304d\u3001\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6c42\u3081\u308b\u3002\u305d\u306e\u5f8c\u65b9\u7a0b\u5f0f\u304b\u3089\u5236\u5fa1\u91cf\u304c\u6c42\u307e\u308b\u3002\u7d42\u7aef\u6642\u523b\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u304c \u2202 \u03d5 \u2202 x \\frac{\\partial \\phi}{\\partial x} \u2202 x \u2202 \u03d5 \u200b \u306b\u5341\u5206\u306b\u8fd1\u3065\u304f\u307e\u3067\u968f\u4f34\u5909\u6570\u3092\u66f4\u65b0\u3059\u308b\u3002 \u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u968f\u4f34\u5909\u6570 \u03bb \\lambda \u03bb \u3002 DDP(Differential Dynamic Programming) iLQR(interactive Linear Quadratic Regulator) SLQ(Sequential Linear Quadratic Regulator) \u6570\u5024\u89e3\u6cd5 \u53cd\u5fa9\u306b\u304a\u3051\u308b\u64cd\u4f5c\u91cf \u7279\u5fb4 \u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5 \u968f\u4f34\u5909\u6570 iLQR \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c\u30ac\u30a6\u30b9\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 DDP \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c2\u6b21\u8fd1\u4f3c\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 SLQ \u5236\u5fa1\u5165\u529b ??? \u5165\u529b\u91cf\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 \u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5)\u306b\u304a\u3044\u3066\u306ft\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\u306b \u2202 H \u2202 u \\frac{\\partial H}{\\partial u} \u2202 u \u2202 H \u200b \u3092\u4f7f\u7528\u3057\u305f\u304c\u3053\u308c\u306f\u6700\u9069\u5316\u554f\u984c\u30921\u6b21\u8fd1\u4f3c\u3057\u53cd\u5fa9\u306b\u3088\u3063\u3066\u6700\u9069\u89e3\u3092\u6c42\u3081\u3066\u3044\u308b\u3002\u306a\u3089\u3070\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3066\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u89e3\u304f\u3053\u3068\u3082\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u306e\u65b9\u6cd5\u3067\u306f\u7dda\u5f62\uff12\u70b9\u5883\u754c\u5024\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3067 \u03b4 x \\delta x \u03b4 x \u3001 \u03b4 \u03bb \\delta \\lambda \u03b4 \u03bb \u304c\u6c42\u3081\u3089\u308c\u305d\u3053\u304b\u3089 \u03b4 u \\delta u \u03b4 u \u304c\u6c42\u3081\u3089\u308c\u308b\u305f\u3081 \u03b4 u \\delta u \u03b4 u \u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002 \u52d5\u7684\u8a08\u753b\u6cd5 \u53c2\u8003\u6587\u732e \u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580 Differential Dynamic Programming(DDP)/iterative LQR(iLQR)/Sequential LQR(SLQ)","title":"\u6700\u9069\u5236\u5fa1"},{"location":"tech_note/optimal_control/optimal_control/#_1","text":"","title":"\u6700\u9069\u5236\u5fa1"},{"location":"tech_note/optimal_control/optimal_control/#_2","text":"\u30b7\u30b9\u30c6\u30e0\u30fb\u521d\u671f\u72b6\u614b\u30fb\u8a55\u4fa1\u95a2\u6570\u304c\u4e0e\u3048\u3089\u308c\u305f\u6642\u306b\u8a55\u4fa1\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u6700\u9069\u306a\u5236\u5fa1\u5165\u529b\u304c\u6e80\u305f\u3059\u3079\u304d\u6761\u4ef6\u3002\u6570\u7406\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308bKKT\u6761\u4ef6\u3068\u8003\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u3064\u307e\u308a\u6700\u9069\u5236\u5fa1\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6","title":"\u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f"},{"location":"tech_note/optimal_control/optimal_control/#_3","text":"\u52d5\u7684\u8a08\u753b\u6cd5\u3067\u306f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5206\u91ce\u3067\u306f\u5bfe\u8c61\u3068\u306a\u308b\u554f\u984c\u3092\u8907\u6570\u306e\u90e8\u5206\u554f\u984c\u306b\u5206\u5272\u3057\u3001\u90e8\u5206\u554f\u984c\u306e\u8a08\u7b97\u7d50\u679c\u3092\u8a18\u9332\u3057\u306a\u304c\u3089\u89e3\u3044\u3066\u3044\u304f\u624b\u6cd5\u306e\u7dcf\u79f0\u3092\u6307\u3059\u3002 \u6700\u9069\u5236\u5fa1\u306b\u304a\u3051\u308b\u52d5\u7684\u8a08\u753b\u6cd5\u3068\u306f\u8a55\u4fa1\u95a2\u6570\u306e\u6700\u5c0f\u5024\u3092\u518d\u5e30\u7684\u306b\u8868\u3059\u624b\u6cd5\u306e\u3053\u3068\u3092\u6307\u3059\u3002","title":"\u52d5\u7684\u8a08\u753b\u6cd5"},{"location":"tech_note/optimal_control/optimal_control/#_4","text":"\u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u3063\u3066\u8868\u3055\u308c\u305f\u5024\u95a2\u6570\u306e\u518d\u5e30\u4e00\u56de\u5206\u3092\u53d6\u308a\u51fa\u3057\u305f\u6642\u523bk\u3068\u6642\u523bk+1\u306e\u5024\u95a2\u6570\u306e\u95a2\u4fc2\u5f0f\u3002\u30aa\u30a4\u30e9\u30fc\u30fb\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u65b9\u7a0b\u5f0f\u306b\u3088\u3063\u3066\u6700\u9069\u5236\u5fa1\u304c\u6e80\u305f\u3059\u3079\u304d\u5fc5\u8981\u6761\u4ef6\u304c\u5c0e\u304b\u308c\u308b\u304c\u3001\u6700\u9069\u5236\u5fa1\u554f\u984c\u304c\u6301\u3064\u6642\u9593\u7684\u306a\u69cb\u9020\u3092\u4f7f\u3046\u3053\u3068\u3067\u5c0e\u304b\u308c\u308b\u5225\u306e\u5f62\u306e\u6700\u9069\u6027\u6761\u4ef6\u304c\u3053\u306e\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u3067\u8868\u3055\u308c\u308b\u3002","title":"\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f"},{"location":"tech_note/optimal_control/optimal_control/#_5","text":"\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u306e\u7d42\u7aef\u6761\u4ef6\u306e\u3082\u3068\u3067\u30d9\u30eb\u30de\u30f3\u65b9\u7a0b\u5f0f\u304c\u6210\u7acb\u3059\u308b","title":"\u6700\u9069\u5236\u5fa1\u306e\u5fc5\u8981\u6761\u4ef6"},{"location":"tech_note/optimal_control/optimal_control/#_6","text":"","title":"\u6700\u9069\u5236\u5fa1\u306e\u5341\u5206\u6761\u4ef6"},{"location":"tech_note/optimal_control/optimal_control/#_7","text":"\u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u6700\u9069\u5236\u5fa1\u306b\u304a\u3044\u3066\u57fa\u790e\u3068\u306a\u308b\u3001\u95a2\u6570\u306e\u5fae\u5206\u3092\u6c4e\u95a2\u6570\u306b\u62e1\u5f35\u3057\u305f\u3082\u306e\u3002","title":"\u5909\u5206\u6cd5"},{"location":"tech_note/optimal_control/optimal_control/#_8","text":"\u4ee5\u4e0b\u306e\u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5\u306f\u30b7\u30b9\u30c6\u30e0\u304c\u9023\u7d9a\u6642\u9593\u3067\u3082\u96e2\u6563\u6642\u9593\u3067\u3082\u96e2\u6563\u7684\u306b\u6c42\u3081\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u96e2\u6563\u30b7\u30b9\u30c6\u30e0\u306e\u5834\u5408\u306f\u6570\u5024\u7684\u306b\u7a4d\u5206\u64cd\u4f5c\u3092\u884c\u3046\u306a\u3069\u306e\u64cd\u4f5c\u304c\u767a\u751f\u3059\u308b\u3002 \u6570\u5024\u89e3\u6cd5 \u9577\u6240 \u77ed\u6240 \u9069\u3059\u308b\u7528\u9014 \u52fe\u914d\u6cd5 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u4e0d\u8981 \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u9045\u3044 \u6700\u9069\u89e3\u306e\u304a\u304a\u3088\u305d\u306e\u69d8\u5b50\u3092\u624b\u8efd\u306b\u77e5\u308a\u305f\u3044\u6642 \u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5 \u672a\u77e5\u91cf\u304c\u6709\u9650\u6b21\u5143 \u8a08\u7b97\u304c\u767a\u6563\u3057\u3084\u3059\u3044 \u826f\u597d\u306a\u521d\u671f\u63a8\u5b9a\u89e3\u3092\u9078\u3079\u308b\u6642 \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(2\u6b21\u306e\u52fe\u914d\u6cd5) \u6700\u9069\u89e3\u8fd1\u508d\u3067\u306e\u53ce\u675f\u304c\u901f\u3044 H\u306e\u9ad8\u968e\u504f\u5c0e\u95a2\u6570\u304c\u5fc5\u8981\u3067\u5404\u53cd\u5fa9\u306b\u304a\u3051\u308b\u8a08\u7b97\u91cf\u304c\u591a\u3044 \u6700\u9069\u89e3\u3092\u7cbe\u5ea6\u826f\u304f\u6c42\u3081\u305f\u3044\u6642 \u52d5\u7684\u8a08\u753b\u6cd5 \u72b6\u614b\u30d5\u30a3\u30fc\u30c9\u30d0\u30c3\u30af\u5236\u5fa1\u304c\u5f97\u3089\u308c\u308b \u72b6\u614b\u306e\u6b21\u5143\u304c\u9ad8\u3044\u3068\u8a18\u61b6\u91cf\u304c\u81a8\u5927 \u72b6\u614b\u306e\u6b21\u5143\u304c\u4f4e\u3044\u304b\u3001\u72ed\u3044\u7bc4\u56f2\u3060\u3051\u8003\u616e\u3059\u308c\u3070\u826f\u3044\u6642","title":"\u6700\u9069\u5236\u5fa1\u306e\u6570\u5024\u89e3\u6cd5"},{"location":"tech_note/optimal_control/optimal_control/#_9","text":"\u30cf\u30df\u30eb\u30c8\u30f3\u95a2\u6570\u306e\u5236\u5fa1\u5165\u529b\u504f\u5fae\u5206 \u2202 H \u2202 u \\frac{\\partial H}{\\partial u} \u2202 u \u2202 H \u200b \u304c0\u306b\u306a\u308b\u307e\u3067 \u2212 \u2202 H \u2202 u -\\frac{\\partial H}{\\partial u} \u2212 \u2202 u \u2202 H \u200b \u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3001\u76f4\u7dda\u7dda\u63a2\u7d22\u3068\u7d44\u307f\u5408\u308f\u305b\u3066 u u u \u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u3002\u968f\u4f34\u5909\u6570\u306f\u968f\u4f34\u65b9\u7a0b\u5f0f\u304b\u3089$ \\frac{\\partial H}{\\partial x} \u3092\u4f7f\u3063\u3066\u6c42\u3081\u308b\u3002\u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u5236\u5fa1\u91cf u u u \u3002","title":"\u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5)"},{"location":"tech_note/optimal_control/optimal_control/#_10","text":"\u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u521d\u671f\u5024\u304b\u3089\u72b6\u614b\u91cf\u3092\u64cd\u4f5c\u3057\u3001\u7d42\u7aef\u6761\u4ef6\u3092\u5408\u308f\u305b\u306b\u3044\u304f\u69d8\u304c\u5c04\u6483\u306b\u4f3c\u3066\u3044\u308b\u3053\u3068\u304b\u3089\u3053\u306e\u540d\u304c\u3064\u3051\u3089\u308c\u305f\u3002","title":"\u30b7\u30e5\u30fc\u30c6\u30a3\u30f3\u30b0\u6cd5"},{"location":"tech_note/optimal_control/optimal_control/#_11","text":"\u958b\u59cb\u6642\u9593\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u306e\u521d\u671f\u5024\u3092\u4e0e\u3048\u3001\u521d\u671f\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6761\u4ef6\u3068\u3057\u3066\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3092\u7d42\u7aef\u6642\u9593\u307e\u3067\u89e3\u304d\u3001\u72b6\u614b\u91cf\u3068\u968f\u4f34\u5909\u6570\u3092\u6c42\u3081\u308b\u3002\u305d\u306e\u5f8c\u65b9\u7a0b\u5f0f\u304b\u3089\u5236\u5fa1\u91cf\u304c\u6c42\u307e\u308b\u3002\u7d42\u7aef\u6642\u523b\u306b\u304a\u3051\u308b\u968f\u4f34\u5909\u6570\u304c \u2202 \u03d5 \u2202 x \\frac{\\partial \\phi}{\\partial x} \u2202 x \u2202 \u03d5 \u200b \u306b\u5341\u5206\u306b\u8fd1\u3065\u304f\u307e\u3067\u968f\u4f34\u5909\u6570\u3092\u66f4\u65b0\u3059\u308b\u3002 \u53cd\u5fa9\u306b\u3088\u3063\u3066\u8abf\u6574\u3059\u308b\u72b6\u614b\u91cf\u306f\u968f\u4f34\u5909\u6570 \u03bb \\lambda \u03bb \u3002","title":"\u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5"},{"location":"tech_note/optimal_control/optimal_control/#ddpdifferential-dynamic-programming","text":"","title":"DDP(Differential Dynamic Programming)"},{"location":"tech_note/optimal_control/optimal_control/#ilqrinteractive-linear-quadratic-regulator","text":"","title":"iLQR(interactive Linear Quadratic Regulator)"},{"location":"tech_note/optimal_control/optimal_control/#slqsequential-linear-quadratic-regulator","text":"\u6570\u5024\u89e3\u6cd5 \u53cd\u5fa9\u306b\u304a\u3051\u308b\u64cd\u4f5c\u91cf \u7279\u5fb4 \u9077\u79fb\u884c\u5217\u306b\u3088\u308b\u65b9\u6cd5 \u968f\u4f34\u5909\u6570 iLQR \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c\u30ac\u30a6\u30b9\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 DDP \u5236\u5fa1\u5165\u529b \u5f8c\u9000\u30d1\u30b9\u306e\u6700\u9069\u5316\u65b9\u6cd5\u304c2\u6b21\u8fd1\u4f3c\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 SLQ \u5236\u5fa1\u5165\u529b ???","title":"SLQ(Sequential Linear Quadratic Regulator)"},{"location":"tech_note/optimal_control/optimal_control/#_12","text":"\u52fe\u914d\u6cd5(\u6700\u6025\u964d\u4e0b\u6cd5\u306b\u3088\u308b\u5b9f\u88c5)\u306b\u304a\u3044\u3066\u306ft\u63a2\u7d22\u65b9\u5411\u306e\u6c7a\u5b9a\u306b \u2202 H \u2202 u \\frac{\\partial H}{\\partial u} \u2202 u \u2202 H \u200b \u3092\u4f7f\u7528\u3057\u305f\u304c\u3053\u308c\u306f\u6700\u9069\u5316\u554f\u984c\u30921\u6b21\u8fd1\u4f3c\u3057\u53cd\u5fa9\u306b\u3088\u3063\u3066\u6700\u9069\u89e3\u3092\u6c42\u3081\u3066\u3044\u308b\u3002\u306a\u3089\u3070\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3066\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u89e3\u304f\u3053\u3068\u3082\u8003\u3048\u3089\u308c\u308b\u3002\u3053\u306e\u65b9\u6cd5\u3067\u306f\u7dda\u5f62\uff12\u70b9\u5883\u754c\u5024\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u3067 \u03b4 x \\delta x \u03b4 x \u3001 \u03b4 \u03bb \\delta \\lambda \u03b4 \u03bb \u304c\u6c42\u3081\u3089\u308c\u305d\u3053\u304b\u3089 \u03b4 u \\delta u \u03b4 u \u304c\u6c42\u3081\u3089\u308c\u308b\u305f\u3081 \u03b4 u \\delta u \u03b4 u \u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002","title":"\u5165\u529b\u91cf\u306e\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5"},{"location":"tech_note/optimal_control/optimal_control/#_13","text":"","title":"\u52d5\u7684\u8a08\u753b\u6cd5"},{"location":"tech_note/optimal_control/optimal_control/#_14","text":"\u975e\u7dda\u5f62\u6700\u9069\u5236\u5fa1\u5165\u9580 Differential Dynamic Programming(DDP)/iterative LQR(iLQR)/Sequential LQR(SLQ)","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/active_set_method/","text":"\u6709\u52b9\u5236\u7d04\u6cd5 \u6709\u52b9\u5236\u7d04\u6cd5\u3068\u306f\u7dda\u5f62\u5236\u7d04\u3092\u6301\u3064\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b","title":"\u6709\u52b9\u5236\u7d04\u6cd5"},{"location":"tech_note/optimize/active_set_method/#_1","text":"\u6709\u52b9\u5236\u7d04\u6cd5\u3068\u306f\u7dda\u5f62\u5236\u7d04\u3092\u6301\u3064\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b","title":"\u6709\u52b9\u5236\u7d04\u6cd5"},{"location":"tech_note/optimize/algo_abst/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u6982\u8981 \u3053\u3053\u3067\u306f\u5909\u6570\u30fb\u5236\u7d04\u306b\u53d6\u308b\u5024\u304c\u6574\u6570\u306b\u5236\u9650\u3055\u308c\u306a\u3044\u6700\u9069\u5316\u554f\u984c\u306b\u3064\u3044\u3066\u6982\u8981\u3092\u307e\u3068\u3081\u308b \u5358\u4f53\u6cd5(\u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5) \u7dda\u5f62\u8a08\u753b\u554f\u984c\u3067\u4f7f\u7528\u3055\u308c\u308bDantzig\u306b\u3088\u3063\u3066\u63d0\u6848\u3055\u308c\u305f\u624b\u6cd5\u3002\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5883\u754c\u306b\u6cbf\u3063\u3066\u89e3\u3092\u66f4\u65b0\u3059\u308b\u3002\u5f8c\u306b\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u304c\u63d0\u6848\u3057\u305f\u591a\u9805\u5f0f\u6642\u9593\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u6955\u5186\u4f53\u6cd5\u306b\u3088\u3063\u3066\u666e\u53ca\u3057\u305f\u5185\u70b9\u6cd5\u3068\u4e26\u3093\u3067\u5e83\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b\u3002 \u5358\u4f53\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u3001Dantzig\u304c\u63d0\u6848\u3057\u305f\u7279\u6b8a\u306a\u56f3\u89e3\u6cd5\u306b\u304a\u3044\u3066\u306f\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u9032\u884c\u306b\u5f93\u3063\u3066\u5358\u4f53\u304c\u4e0b\u306b\u843d\u3061\u3066\u3044\u304f\u3088\u3046\u306b\u898b\u3048\u308b\u3053\u3068\u306b\u7531\u6765\u3059\u308b\u3002 max z = C x s.t. A x < b \\text{max} \\space z = Cx \\\\ \\text{s.t.} \\space Ax < b max z = C x s.t. A x < b \u6709\u52b9\u5236\u7d04\u6cd5 \u6709\u52b9\u5236\u7d04\u6cd5\u306f\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\u7528\u3044\u3089\u308c\u308b\u3002 min f ( x ) = 1 2 x T Q x + c x s.t. a i T x \u2265 b i \\text{min} \\space f(x) = \\frac{1}{2}x^TQx + cx \\\\ \\text{s.t.} \\space a_i^T x \\geq b_i min f ( x ) = 2 1 \u200b x T Q x + c x s.t. a i T \u200b x \u2265 b i \u200b \u5185\u70b9\u6cd5 \u30d0\u30ea\u30a2\u6cd5\u306e\u3088\u3046\u306a\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5185\u90e8\u3092\u9032\u3080\u3088\u3046\u306b\u89e3\u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u306e\u7dcf\u79f0 \u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u306a\u3044\u5834\u5408\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u89e3\u3092\u79fb\u52d5\u3055\u305b\u308b\u624b\u6bb5\u304c\u5fc5\u8981\u306b\u306a\u308b \u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u65b9\u6cd5\u306b\u3088\u3063\u3066\u3001\u30a2\u30d5\u30a3\u30f3\u5909\u63db\u6cd5\u3001\u30dd\u30c6\u30f3\u30b7\u30e3\u30eb\u6e1b\u5c11\u6cd5\u3001\u30d1\u30b9\u8ffd\u8de1\u6cd5\u306a\u3069\u306b\u5206\u985e\u3055\u308c\u308b \u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u3092\u76f4\u63a5\u6271\u3046\u65b9\u6cd5(\u4e3b\u5185\u70b9\u6cd5)\u3001\u305d\u306e\u53cc\u5bfe\u554f\u984c\u3092\u6271\u3046\u65b9\u6cd5(\u53cc\u5bfe\u5185\u70b9\u6cd5)\u3001\u4e3b\u554f\u984c\u3068\u53cc\u5bfe\u554f\u984c\u3092\u540c\u6642\u306b\u89e3\u304f\u65b9\u6cd5(\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5)\u306b\u5206\u3051\u3089\u308c\u308b \u4e3b\u5185\u70b9\u6cd5 Note Todo \u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 Note Todo \u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 Note Todo \u5916\u70b9\u6cd5 \u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u306b\u4ee3\u8868\u3055\u308c\u308b\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u306e\u53cd\u5fa9\u3092\u8a31\u3059\u624b\u6cd5\u306e\u7dcf\u79f0 \u5185\u70b9\u6cd5\u3068\u7570\u306a\u308a\u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u3042\u3063\u3066\u3082\u53cd\u5fa9\u8a08\u7b97\u304c\u53ef\u80fd\u3067\u3042\u308b\u304c\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u306e\u30b9\u30b1\u30fc\u30eb\u8abf\u6574\u306b\u3088\u3063\u3066\u306f\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u53ce\u675f\u3059\u308b\u5834\u5408\u304c\u3042\u308b \u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(SQP\u6cd5) NLP\u554f\u984c\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0 \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u89e3\u304f\u624b\u6cd5 \u4fe1\u983c\u9818\u57df\u6cd5\u306b\u3088\u308a\u89e3\u304f\u624b\u6cd5 \u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP) \u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP) \u306a\u3069\u304c\u3042\u308b \u57fa\u672c\u7684\u306b\u9055\u3044\u306f\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3059\u308b\u65b9\u6cd5\u3068\u3001\u8fd1\u4f3c\u3057\u305f\u4e8c\u6b21\u554f\u984c\u304b\u3089\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u5b9a\u3059\u308b\u65b9\u6cd5\u3078\u306e\u9055\u3044 \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 \u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u4ee3\u308f\u308a\u306bBFGS\u6cd5\u3067\u8fd1\u4f3c\u3057\u305fB\u884c\u5217\u3092\u4f7f\u7528\u3057\u305fQP\u554f\u984c\u3092\u4f5c\u6210\u3057\u3001\u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f \u4fe1\u983c\u9818\u57df\u6cd5 Note Todo \u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP, SLQP) \u5236\u7d04\u5145\u8db3\u306e\u305f\u3081\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u76ee\u7684\u95a2\u6570\u5024\u6700\u5c0f\u5316\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u3044\u3046\u4e8c\u3064\u306e\u30d5\u30a7\u30fc\u30ba\u304b\u3089\u69cb\u6210\u3055\u308c\u308b\u4ed6\u306eSQP\u6cd5\u3068\u306f\u6bdb\u8272\u304c\u9055\u3046\u6700\u9069\u5316\u624b\u6cd5 \u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP) \u300c\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5\u300d\u3068\u3044\u3046\u65e5\u672c\u8a9e\u8a33\u306f\u3042\u3063\u3066\u306a\u3044\u304b\u65e5\u672c\u8a9e\u8a33\u304c\u5f53\u3066\u3089\u308c\u3066\u3044\u306a\u3044\u53ef\u80fd\u6027\u304c\u3042\u308b MATLAB\u3084Scipy\u3067\u5c0e\u5165\u3055\u308c\u3066\u3044\u308bSLSQP\u306f1988\u5e74Kraft\u3089\u306e\u767a\u8868\u3057\u305f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u540c\u68b1\u3055\u308c\u8a00\u8a9e\u306fFortran \u8ad6\u6587\u30bf\u30a4\u30c8\u30eb\u306f\u4ee5\u4e0b Kraft, D. A software package for sequential quadratic programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace Center -- Institute for Flight Mechanics, Koln, Germany. \u53c2\u8003\u6587\u732e \u6700\u9069\u5316\u554f\u984c \u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5 B.2 \u5358\u4f53\u6cd5\u30fb\u6709\u52b9\u5236\u7d04\u6cd5 \u5185\u70b9\u6cd5 \u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 B.1 \u5185\u70b9\u6cd5 B.7 \u5916\u70b9\u6cd5 B.3 \u9010\u6b21\u4e8c\u6b21\u8a08\u753b\uff08SQP\uff09\u6cd5 SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u6982\u8981"},{"location":"tech_note/optimize/algo_abst/#_1","text":"\u3053\u3053\u3067\u306f\u5909\u6570\u30fb\u5236\u7d04\u306b\u53d6\u308b\u5024\u304c\u6574\u6570\u306b\u5236\u9650\u3055\u308c\u306a\u3044\u6700\u9069\u5316\u554f\u984c\u306b\u3064\u3044\u3066\u6982\u8981\u3092\u307e\u3068\u3081\u308b","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u6982\u8981"},{"location":"tech_note/optimize/algo_abst/#_2","text":"\u7dda\u5f62\u8a08\u753b\u554f\u984c\u3067\u4f7f\u7528\u3055\u308c\u308bDantzig\u306b\u3088\u3063\u3066\u63d0\u6848\u3055\u308c\u305f\u624b\u6cd5\u3002\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5883\u754c\u306b\u6cbf\u3063\u3066\u89e3\u3092\u66f4\u65b0\u3059\u308b\u3002\u5f8c\u306b\u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u304c\u63d0\u6848\u3057\u305f\u591a\u9805\u5f0f\u6642\u9593\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u6955\u5186\u4f53\u6cd5\u306b\u3088\u3063\u3066\u666e\u53ca\u3057\u305f\u5185\u70b9\u6cd5\u3068\u4e26\u3093\u3067\u5e83\u304f\u4f7f\u308f\u308c\u3066\u3044\u308b\u3002 \u5358\u4f53\u6cd5\u3068\u3044\u3046\u540d\u524d\u306f\u3001Dantzig\u304c\u63d0\u6848\u3057\u305f\u7279\u6b8a\u306a\u56f3\u89e3\u6cd5\u306b\u304a\u3044\u3066\u306f\u3001\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u9032\u884c\u306b\u5f93\u3063\u3066\u5358\u4f53\u304c\u4e0b\u306b\u843d\u3061\u3066\u3044\u304f\u3088\u3046\u306b\u898b\u3048\u308b\u3053\u3068\u306b\u7531\u6765\u3059\u308b\u3002 max z = C x s.t. A x < b \\text{max} \\space z = Cx \\\\ \\text{s.t.} \\space Ax < b max z = C x s.t. A x < b","title":"\u5358\u4f53\u6cd5(\u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5)"},{"location":"tech_note/optimize/algo_abst/#_3","text":"\u6709\u52b9\u5236\u7d04\u6cd5\u306f\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\u7528\u3044\u3089\u308c\u308b\u3002 min f ( x ) = 1 2 x T Q x + c x s.t. a i T x \u2265 b i \\text{min} \\space f(x) = \\frac{1}{2}x^TQx + cx \\\\ \\text{s.t.} \\space a_i^T x \\geq b_i min f ( x ) = 2 1 \u200b x T Q x + c x s.t. a i T \u200b x \u2265 b i \u200b","title":"\u6709\u52b9\u5236\u7d04\u6cd5"},{"location":"tech_note/optimize/algo_abst/#_4","text":"\u30d0\u30ea\u30a2\u6cd5\u306e\u3088\u3046\u306a\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306e\u5185\u90e8\u3092\u9032\u3080\u3088\u3046\u306b\u89e3\u3092\u66f4\u65b0\u3059\u308b\u624b\u6cd5\u306e\u7dcf\u79f0 \u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u306a\u3044\u5834\u5408\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u89e3\u3092\u79fb\u52d5\u3055\u305b\u308b\u624b\u6bb5\u304c\u5fc5\u8981\u306b\u306a\u308b \u70b9\u5217\u3092\u751f\u6210\u3059\u308b\u65b9\u6cd5\u306b\u3088\u3063\u3066\u3001\u30a2\u30d5\u30a3\u30f3\u5909\u63db\u6cd5\u3001\u30dd\u30c6\u30f3\u30b7\u30e3\u30eb\u6e1b\u5c11\u6cd5\u3001\u30d1\u30b9\u8ffd\u8de1\u6cd5\u306a\u3069\u306b\u5206\u985e\u3055\u308c\u308b \u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u3092\u76f4\u63a5\u6271\u3046\u65b9\u6cd5(\u4e3b\u5185\u70b9\u6cd5)\u3001\u305d\u306e\u53cc\u5bfe\u554f\u984c\u3092\u6271\u3046\u65b9\u6cd5(\u53cc\u5bfe\u5185\u70b9\u6cd5)\u3001\u4e3b\u554f\u984c\u3068\u53cc\u5bfe\u554f\u984c\u3092\u540c\u6642\u306b\u89e3\u304f\u65b9\u6cd5(\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5)\u306b\u5206\u3051\u3089\u308c\u308b","title":"\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/algo_abst/#_5","text":"Note Todo","title":"\u4e3b\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/algo_abst/#_6","text":"Note Todo","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/algo_abst/#_7","text":"Note Todo","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/algo_abst/#_8","text":"\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u306b\u4ee3\u8868\u3055\u308c\u308b\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u306e\u53cd\u5fa9\u3092\u8a31\u3059\u624b\u6cd5\u306e\u7dcf\u79f0 \u5185\u70b9\u6cd5\u3068\u7570\u306a\u308a\u521d\u671f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u3067\u3042\u3063\u3066\u3082\u53cd\u5fa9\u8a08\u7b97\u304c\u53ef\u80fd\u3067\u3042\u308b\u304c\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u306e\u30b9\u30b1\u30fc\u30eb\u8abf\u6574\u306b\u3088\u3063\u3066\u306f\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u53ce\u675f\u3059\u308b\u5834\u5408\u304c\u3042\u308b","title":"\u5916\u70b9\u6cd5"},{"location":"tech_note/optimize/algo_abst/#sqp","text":"NLP\u554f\u984c\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0 \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u89e3\u304f\u624b\u6cd5 \u4fe1\u983c\u9818\u57df\u6cd5\u306b\u3088\u308a\u89e3\u304f\u624b\u6cd5 \u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP) \u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP) \u306a\u3069\u304c\u3042\u308b \u57fa\u672c\u7684\u306b\u9055\u3044\u306f\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3059\u308b\u65b9\u6cd5\u3068\u3001\u8fd1\u4f3c\u3057\u305f\u4e8c\u6b21\u554f\u984c\u304b\u3089\u63a2\u7d22\u65b9\u5411\u3092\u6c7a\u5b9a\u3059\u308b\u65b9\u6cd5\u3078\u306e\u9055\u3044","title":"\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(SQP\u6cd5)"},{"location":"tech_note/optimize/algo_abst/#_9","text":"\u30d8\u30c3\u30b7\u30a2\u30f3\u306e\u4ee3\u308f\u308a\u306bBFGS\u6cd5\u3067\u8fd1\u4f3c\u3057\u305fB\u884c\u5217\u3092\u4f7f\u7528\u3057\u305fQP\u554f\u984c\u3092\u4f5c\u6210\u3057\u3001\u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5"},{"location":"tech_note/optimize/algo_abst/#_10","text":"Note Todo","title":"\u4fe1\u983c\u9818\u57df\u6cd5"},{"location":"tech_note/optimize/algo_abst/#slp-sqp-slqp","text":"\u5236\u7d04\u5145\u8db3\u306e\u305f\u3081\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u76ee\u7684\u95a2\u6570\u5024\u6700\u5c0f\u5316\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u3044\u3046\u4e8c\u3064\u306e\u30d5\u30a7\u30fc\u30ba\u304b\u3089\u69cb\u6210\u3055\u308c\u308b\u4ed6\u306eSQP\u6cd5\u3068\u306f\u6bdb\u8272\u304c\u9055\u3046\u6700\u9069\u5316\u624b\u6cd5","title":"\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP, SLQP)"},{"location":"tech_note/optimize/algo_abst/#slsqp","text":"\u300c\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5\u300d\u3068\u3044\u3046\u65e5\u672c\u8a9e\u8a33\u306f\u3042\u3063\u3066\u306a\u3044\u304b\u65e5\u672c\u8a9e\u8a33\u304c\u5f53\u3066\u3089\u308c\u3066\u3044\u306a\u3044\u53ef\u80fd\u6027\u304c\u3042\u308b MATLAB\u3084Scipy\u3067\u5c0e\u5165\u3055\u308c\u3066\u3044\u308bSLSQP\u306f1988\u5e74Kraft\u3089\u306e\u767a\u8868\u3057\u305f\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u30d1\u30c3\u30b1\u30fc\u30b8\u306b\u540c\u68b1\u3055\u308c\u8a00\u8a9e\u306fFortran \u8ad6\u6587\u30bf\u30a4\u30c8\u30eb\u306f\u4ee5\u4e0b Kraft, D. A software package for sequential quadratic programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace Center -- Institute for Flight Mechanics, Koln, Germany.","title":"\u9010\u6b21\u6700\u5c0f\u4e8c\u4e57\u8a08\u753b\u6cd5(SLSQP)"},{"location":"tech_note/optimize/algo_abst/#_11","text":"\u6700\u9069\u5316\u554f\u984c \u30b7\u30f3\u30d7\u30ec\u30c3\u30af\u30b9\u6cd5 B.2 \u5358\u4f53\u6cd5\u30fb\u6709\u52b9\u5236\u7d04\u6cd5 \u5185\u70b9\u6cd5 \u30ab\u30fc\u30de\u30fc\u30ab\u30fc\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 B.1 \u5185\u70b9\u6cd5 B.7 \u5916\u70b9\u6cd5 B.3 \u9010\u6b21\u4e8c\u6b21\u8a08\u753b\uff08SQP\uff09\u6cd5 SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/barrier_method/","text":"\u30d0\u30ea\u30a2\u6cd5 \u30d0\u30ea\u30a2\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u76ee\u7684\u95a2\u6570\u306b\u5236\u7d04\u306e\u8a55\u4fa1\u5024\u306b\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5024\u3092\u8db3\u3057\u3066\u5236\u7d04\u306a\u3057\u306e\u6700\u9069\u5316\u554f\u984c\u3068\u3057\u3066\u89e3\u304f\u5185\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b","title":"\u30d0\u30ea\u30a2\u6cd5"},{"location":"tech_note/optimize/barrier_method/#_1","text":"\u30d0\u30ea\u30a2\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u76ee\u7684\u95a2\u6570\u306b\u5236\u7d04\u306e\u8a55\u4fa1\u5024\u306b\u91cd\u307f\u4ed8\u3051\u3057\u305f\u5024\u3092\u8db3\u3057\u3066\u5236\u7d04\u306a\u3057\u306e\u6700\u9069\u5316\u554f\u984c\u3068\u3057\u3066\u89e3\u304f\u5185\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b","title":"\u30d0\u30ea\u30a2\u6cd5"},{"location":"tech_note/optimize/benchmark_cont/","text":"\u9023\u7d9a\u95a2\u6570\u6700\u9069\u5316\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570 \u6700\u9069\u5316\u624b\u6cd5\u306e\u6bd4\u8f03\u306a\u3069\u306b\u4f7f\u7528\u3055\u308c\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u7528\u306e\u95a2\u6570\u306f\u4ee5\u4e0b\u3092\u8003\u616e\u3057\u3066\u4f5c\u3089\u308c\u305f\u3082\u306e\u304c\u591a\u3044\u3002 \u5909\u6570\u306b\u3088\u3063\u3066\u53d6\u308b\u7bc4\u56f2\u304c\u9055\u3046(\u60aa\u30b9\u30b1\u30fc\u30eb\u6027) \u5909\u6570\u304c\u72ec\u7acb\u3067\u306a\u304f\u5909\u6570\u3054\u3068\u306e\u95a2\u6570\u306e\u548c\u3068\u3057\u3066\u8868\u73fe\u3067\u304d\u306a\u3044(\u5909\u6570\u9593\u4f9d\u5b58\u6027) \u5c40\u6240\u89e3\u304c\u6ca2\u5c71\u5b58\u5728\u3059\u308b\u3082\u306e(\u591a\u5cf0\u6027) \u4f8b\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u95a2\u6570\u304c\u6319\u3052\u3089\u308c\u308b\u3002 Sphere\u95a2\u6570 Ellipsoid\u95a2\u6570 k-tablet\u95a2\u6570 Rosenbrock\u95a2\u6570(star\u578b/chain\u578b) Bohachevsky\u95a2\u6570 Ackley\u95a2\u6570 Scaffer\u95a2\u6570 Rastrign\u95a2\u6570 \u53c2\u8003\u6587\u732e \u6700\u9069\u5316\u624b\u6cd5\u8a55\u4fa1\u306e\u305f\u3081\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u3010Python\u30d7\u30ed\u30b0\u30e9\u30e0\u4ed8\u3011 \u6700\u9069\u5316\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8a55\u4fa1\u3059\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u307e\u3068\u3081","title":"\u30d9\u30f3\u30c1\u30de\u30fc\u30af"},{"location":"tech_note/optimize/benchmark_cont/#_1","text":"\u6700\u9069\u5316\u624b\u6cd5\u306e\u6bd4\u8f03\u306a\u3069\u306b\u4f7f\u7528\u3055\u308c\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u7528\u306e\u95a2\u6570\u306f\u4ee5\u4e0b\u3092\u8003\u616e\u3057\u3066\u4f5c\u3089\u308c\u305f\u3082\u306e\u304c\u591a\u3044\u3002 \u5909\u6570\u306b\u3088\u3063\u3066\u53d6\u308b\u7bc4\u56f2\u304c\u9055\u3046(\u60aa\u30b9\u30b1\u30fc\u30eb\u6027) \u5909\u6570\u304c\u72ec\u7acb\u3067\u306a\u304f\u5909\u6570\u3054\u3068\u306e\u95a2\u6570\u306e\u548c\u3068\u3057\u3066\u8868\u73fe\u3067\u304d\u306a\u3044(\u5909\u6570\u9593\u4f9d\u5b58\u6027) \u5c40\u6240\u89e3\u304c\u6ca2\u5c71\u5b58\u5728\u3059\u308b\u3082\u306e(\u591a\u5cf0\u6027) \u4f8b\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u95a2\u6570\u304c\u6319\u3052\u3089\u308c\u308b\u3002 Sphere\u95a2\u6570 Ellipsoid\u95a2\u6570 k-tablet\u95a2\u6570 Rosenbrock\u95a2\u6570(star\u578b/chain\u578b) Bohachevsky\u95a2\u6570 Ackley\u95a2\u6570 Scaffer\u95a2\u6570 Rastrign\u95a2\u6570","title":"\u9023\u7d9a\u95a2\u6570\u6700\u9069\u5316\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570"},{"location":"tech_note/optimize/benchmark_cont/#_2","text":"\u6700\u9069\u5316\u624b\u6cd5\u8a55\u4fa1\u306e\u305f\u3081\u306e\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u3010Python\u30d7\u30ed\u30b0\u30e9\u30e0\u4ed8\u3011 \u6700\u9069\u5316\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u8a55\u4fa1\u3059\u308b\u30d9\u30f3\u30c1\u30de\u30fc\u30af\u95a2\u6570\u307e\u3068\u3081","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/conj_grad/","text":"\u6700\u6025\u964d\u4e0b\u6cd5 \u6700\u6025\u964d\u4e0b\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u306e\u9006\u65b9\u5411\u306b\u5909\u6570\u306e\u66f4\u65b0\u65b9\u5411\u3092\u53d6\u308a\u3001\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u56de\u3059\u3053\u3068\u3067\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002","title":"\u6700\u6025\u964d\u4e0b\u6cd5"},{"location":"tech_note/optimize/conj_grad/#_1","text":"\u6700\u6025\u964d\u4e0b\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u306e\u9006\u65b9\u5411\u306b\u5909\u6570\u306e\u66f4\u65b0\u65b9\u5411\u3092\u53d6\u308a\u3001\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u56de\u3059\u3053\u3068\u3067\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002","title":"\u6700\u6025\u964d\u4e0b\u6cd5"},{"location":"tech_note/optimize/derivative/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u6570\u5024\u5fae\u5206\u6cd5 1\u968e\u5dee\u5206\u6cd5 \u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e1\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5 \u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u65b9\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044 ( \u2202 f \u2202 x ) i = f i + 1 \u2212 f i \u2212 1 2 \u0394 x \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_{i+1} - f_{i-1}}{2\\Delta x} ( \u2202 x \u2202 f \u200b ) i \u200b = 2\u0394 x f i + 1 \u200b \u2212 f i \u2212 1 \u200b \u200b \u3053\u306e\u4ed6\u7c21\u5358\u306a\u65b9\u6cd5\u3068\u3057\u3066\u306f\u5f8c\u9000\u5dee\u5206\u6cd5\u304c\u3042\u308b ( \u2202 f \u2202 x ) i = f i \u2212 f i \u2212 1 \u0394 x \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_i - f_{i-1}}{\\Delta x} ( \u2202 x \u2202 f \u200b ) i \u200b = \u0394 x f i \u200b \u2212 f i \u2212 1 \u200b \u200b 2\u968e\u5dee\u5206\u6cd5 \u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e2\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5 \u3053\u308c\u3082\u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u6cd5\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044 ( \u2202 2 f \u2202 2 x ) i = f i + 1 \u2212 2 f i + f i \u2212 1 \u0394 x 2 \\left(\\frac{\\partial^2 f}{\\partial^2 x}\\right)_i = \\frac{f_{i+1} - 2f_{i} + f_{i-1}}{\\Delta x^2} ( \u2202 2 x \u2202 2 f \u200b ) i \u200b = \u0394 x 2 f i + 1 \u200b \u2212 2 f i \u200b + f i \u2212 1 \u200b \u200b","title":"\u6570\u5024\u5fae\u5206"},{"location":"tech_note/optimize/derivative/#_1","text":"","title":"\u6570\u5024\u5fae\u5206\u6cd5"},{"location":"tech_note/optimize/derivative/#1","text":"\u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e1\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5 \u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u65b9\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044 ( \u2202 f \u2202 x ) i = f i + 1 \u2212 f i \u2212 1 2 \u0394 x \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_{i+1} - f_{i-1}}{2\\Delta x} ( \u2202 x \u2202 f \u200b ) i \u200b = 2\u0394 x f i + 1 \u200b \u2212 f i \u2212 1 \u200b \u200b \u3053\u306e\u4ed6\u7c21\u5358\u306a\u65b9\u6cd5\u3068\u3057\u3066\u306f\u5f8c\u9000\u5dee\u5206\u6cd5\u304c\u3042\u308b ( \u2202 f \u2202 x ) i = f i \u2212 f i \u2212 1 \u0394 x \\left(\\frac{\\partial f}{\\partial x}\\right)_i = \\frac{f_i - f_{i-1}}{\\Delta x} ( \u2202 x \u2202 f \u200b ) i \u200b = \u0394 x f i \u200b \u2212 f i \u2212 1 \u200b \u200b","title":"1\u968e\u5dee\u5206\u6cd5"},{"location":"tech_note/optimize/derivative/#2","text":"\u4e0e\u3048\u3089\u308c\u305f\u95a2\u6570\u306e\u4e0e\u3048\u3089\u308c\u305f\u5909\u6570\u5468\u308a\u3067\u306e2\u968e\u5fae\u5206\u3092\u6c42\u3081\u308b\u65b9\u6cd5 \u3053\u308c\u3082\u4f55\u3082\u306a\u3051\u308c\u3070\u4e2d\u592e\u5dee\u5206\u6cd5\u3092\u4f7f\u3046\u306e\u304c\u826f\u3044 ( \u2202 2 f \u2202 2 x ) i = f i + 1 \u2212 2 f i + f i \u2212 1 \u0394 x 2 \\left(\\frac{\\partial^2 f}{\\partial^2 x}\\right)_i = \\frac{f_{i+1} - 2f_{i} + f_{i-1}}{\\Delta x^2} ( \u2202 2 x \u2202 2 f \u200b ) i \u200b = \u0394 x 2 f i + 1 \u200b \u2212 2 f i \u200b + f i \u2212 1 \u200b \u200b","title":"2\u968e\u5dee\u5206\u6cd5"},{"location":"tech_note/optimize/interior_method/","text":"\u5185\u70b9\u6cd5 \u4e3b\u5185\u70b9\u6cd5 Note Todo \u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 Note Todo \u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 Note Todo HPIPM(High Performance Interior Point Method) \u53c2\u8003\u6587\u732e \u51f8\u6700\u9069\u5316\u306e\u6982\u8981\u3068\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac \u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \uff12\u6b21\u8a08\u753b\u554f\u984c\u3068\u5185\u70b9\u6cd5 \u6570\u7406\u6700\u9069\u5316\u3092\u3057\u3063\u304b\u308a\u5b66\u3076\u305f\u3081\u306b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3068\u305d\u308c\u3092\u4f7f\u3063\u305fSVM\u3092\u5b9f\u88c5","title":"\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/interior_method/#_1","text":"","title":"\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/interior_method/#_2","text":"Note Todo","title":"\u4e3b\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/interior_method/#_3","text":"Note Todo","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/interior_method/#_4","text":"Note Todo","title":"\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/interior_method/#hpipmhigh-performance-interior-point-method","text":"","title":"HPIPM(High Performance Interior Point Method)"},{"location":"tech_note/optimize/interior_method/#_5","text":"\u51f8\u6700\u9069\u5316\u306e\u6982\u8981\u3068\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u89e3\u8aac \u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \uff12\u6b21\u8a08\u753b\u554f\u984c\u3068\u5185\u70b9\u6cd5 \u6570\u7406\u6700\u9069\u5316\u3092\u3057\u3063\u304b\u308a\u5b66\u3076\u305f\u3081\u306b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3068\u305d\u308c\u3092\u4f7f\u3063\u305fSVM\u3092\u5b9f\u88c5","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/kkt_condition/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } KKT\u6761\u4ef6 \u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027 min f ( x ) s.t. g i ( x ) = 0 , i = 0 , \u2026 , m x \u2208 R n \\text{min} \\space f(x)\\\\ \\text{s.t.} \\space g_i(x) = 0, \\space i = 0, \\dots , m\\\\ x \\in \\R^n min f ( x ) s.t. g i \u200b ( x ) = 0 , i = 0 , \u2026 , m x \u2208 R n \u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9 x \u2217 x^* x \u2217 \u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059 u \u2217 u^* u \u2217 \u304c\u5b58\u5728\u3059\u308b \u2207 f ( x \u2217 ) + \u03a3 i = 1 m u i \u2217 \u2207 g i ( x \u2217 ) = 0 \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0 \u2207 f ( x \u2217 ) + \u03a3 i = 1 m \u200b u i \u2217 \u200b \u2207 g i \u200b ( x \u2217 ) = 0 Note \u70b9 x x x \u306b\u304a\u3044\u3066 \u2207 g 1 ( x ) , \u2026 , \u2207 g m ( x ) \\nabla g_1(x), \\dots ,\\nabla g_m(x) \u2207 g 1 \u200b ( x ) , \u2026 , \u2207 g m \u200b ( x ) \u304c\u4e92\u3044\u306b1\u6b21\u72ec\u7acb\u306a\u3089\u3070\u70b9 x x x \u306f \u6b63\u5247 \u3067\u3042\u308b\u3068\u3044\u3046 \u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027 min f ( x ) s.t. g i ( x ) \u2264 0 , i = 0 , \u2026 , m x \u2208 R n \\text{min} \\space f(x)\\\\ \\text{s.t.} \\space g_i(x) \\leq 0, \\space i = 0, \\dots , m\\\\ x \\in \\R^n min f ( x ) s.t. g i \u200b ( x ) \u2264 0 , i = 0 , \u2026 , m x \u2208 R n \u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9 x \u2217 x^* x \u2217 \u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059 u \u2217 u^* u \u2217 \u304c\u5b58\u5728\u3059\u308b \u2207 f ( x \u2217 ) + \u03a3 i = 1 m u i \u2217 \u2207 g i ( x \u2217 ) = 0 u i \u2217 g i ( x \u2217 ) = 0 , i = 0 , \u2026 , m u i \u2217 \u2265 0 , i = 0 , \u2026 , m \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0\\\\ u_i^* g_i(x^*) = 0, \\space i = 0, \\dots , m\\\\ u_i^* \\geq 0, \\space i = 0, \\dots , m \u2207 f ( x \u2217 ) + \u03a3 i = 1 m \u200b u i \u2217 \u200b \u2207 g i \u200b ( x \u2217 ) = 0 u i \u2217 \u200b g i \u200b ( x \u2217 ) = 0 , i = 0 , \u2026 , m u i \u2217 \u200b \u2265 0 , i = 0 , \u2026 , m 2\u5f0f\u76ee\u306f \u76f8\u88dc\u6027\u6761\u4ef6 \u3068\u547c\u3070\u308c\u308b\u3002 g i ( x \u2217 ) g_i(x^*) g i \u200b ( x \u2217 ) \u304c\u6709\u52b9\u306a\u6642\u306f g i ( x \u2217 ) = 0 g_i(x^*)=0 g i \u200b ( x \u2217 ) = 0 \u3068\u306a\u308a, \u6709\u52b9\u3067\u306a\u3044\u5834\u5408\u306f u i \u2217 = 0 u_i^*=0 u i \u2217 \u200b = 0 \u3068\u306a\u308b\u3002 \u53c2\u8003\u6587\u732e \u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316","title":"KKT\u6761\u4ef6"},{"location":"tech_note/optimize/kkt_condition/#kkt","text":"","title":"KKT\u6761\u4ef6"},{"location":"tech_note/optimize/kkt_condition/#1","text":"min f ( x ) s.t. g i ( x ) = 0 , i = 0 , \u2026 , m x \u2208 R n \\text{min} \\space f(x)\\\\ \\text{s.t.} \\space g_i(x) = 0, \\space i = 0, \\dots , m\\\\ x \\in \\R^n min f ( x ) s.t. g i \u200b ( x ) = 0 , i = 0 , \u2026 , m x \u2208 R n \u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9 x \u2217 x^* x \u2217 \u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059 u \u2217 u^* u \u2217 \u304c\u5b58\u5728\u3059\u308b \u2207 f ( x \u2217 ) + \u03a3 i = 1 m u i \u2217 \u2207 g i ( x \u2217 ) = 0 \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0 \u2207 f ( x \u2217 ) + \u03a3 i = 1 m \u200b u i \u2217 \u200b \u2207 g i \u200b ( x \u2217 ) = 0 Note \u70b9 x x x \u306b\u304a\u3044\u3066 \u2207 g 1 ( x ) , \u2026 , \u2207 g m ( x ) \\nabla g_1(x), \\dots ,\\nabla g_m(x) \u2207 g 1 \u200b ( x ) , \u2026 , \u2207 g m \u200b ( x ) \u304c\u4e92\u3044\u306b1\u6b21\u72ec\u7acb\u306a\u3089\u3070\u70b9 x x x \u306f \u6b63\u5247 \u3067\u3042\u308b\u3068\u3044\u3046","title":"\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027"},{"location":"tech_note/optimize/kkt_condition/#1_1","text":"min f ( x ) s.t. g i ( x ) \u2264 0 , i = 0 , \u2026 , m x \u2208 R n \\text{min} \\space f(x)\\\\ \\text{s.t.} \\space g_i(x) \\leq 0, \\space i = 0, \\dots , m\\\\ x \\in \\R^n min f ( x ) s.t. g i \u200b ( x ) \u2264 0 , i = 0 , \u2026 , m x \u2208 R n \u4e0a\u8a18\u306e\u6700\u9069\u554f\u984c\u306b\u304a\u3044\u30661\u6b21\u306e\u6700\u9069\u6027\u306f\u4ee5\u4e0b \u70b9 x \u2217 x^* x \u2217 \u306f\u5c40\u6240\u6700\u9069\u89e3\u304b\u3064\u6b63\u5247\u3002\u3053\u306e\u6642\u4ee5\u4e0b\u3092\u6e80\u305f\u3059 u \u2217 u^* u \u2217 \u304c\u5b58\u5728\u3059\u308b \u2207 f ( x \u2217 ) + \u03a3 i = 1 m u i \u2217 \u2207 g i ( x \u2217 ) = 0 u i \u2217 g i ( x \u2217 ) = 0 , i = 0 , \u2026 , m u i \u2217 \u2265 0 , i = 0 , \u2026 , m \\nabla f(x^*) + \\Sigma_{i=1}^{m} u_i^* \\nabla g_i(x^*) = 0\\\\ u_i^* g_i(x^*) = 0, \\space i = 0, \\dots , m\\\\ u_i^* \\geq 0, \\space i = 0, \\dots , m \u2207 f ( x \u2217 ) + \u03a3 i = 1 m \u200b u i \u2217 \u200b \u2207 g i \u200b ( x \u2217 ) = 0 u i \u2217 \u200b g i \u200b ( x \u2217 ) = 0 , i = 0 , \u2026 , m u i \u2217 \u200b \u2265 0 , i = 0 , \u2026 , m 2\u5f0f\u76ee\u306f \u76f8\u88dc\u6027\u6761\u4ef6 \u3068\u547c\u3070\u308c\u308b\u3002 g i ( x \u2217 ) g_i(x^*) g i \u200b ( x \u2217 ) \u304c\u6709\u52b9\u306a\u6642\u306f g i ( x \u2217 ) = 0 g_i(x^*)=0 g i \u200b ( x \u2217 ) = 0 \u3068\u306a\u308a, \u6709\u52b9\u3067\u306a\u3044\u5834\u5408\u306f u i \u2217 = 0 u_i^*=0 u i \u2217 \u200b = 0 \u3068\u306a\u308b\u3002","title":"\u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u6700\u9069\u5316\u554f\u984c\u306b\u304a\u3051\u308b1\u6b21\u306e\u6700\u9069\u6027"},{"location":"tech_note/optimize/kkt_condition/#_1","text":"\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/least_squares_method/","text":"\u6700\u5c0f\u4e8c\u4e57\u6cd5 \u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u672c \u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5 \u7dda\u5f62\u7b49\u5f0f\u30fb\u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5 \u53c2\u8003\u6587\u732e \u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b \u5236\u7d04\u4ed8\u304d\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b Conversion from least squares to quadratic programming lsqlin \u6700\u5c0f\u4e8c\u4e57 (\u30e2\u30c7\u30eb\u5f53\u3066\u306f\u3081) \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5"},{"location":"tech_note/optimize/least_squares_method/#_1","text":"","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5"},{"location":"tech_note/optimize/least_squares_method/#_2","text":"","title":"\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u672c"},{"location":"tech_note/optimize/least_squares_method/#_3","text":"","title":"\u7dda\u5f62\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5"},{"location":"tech_note/optimize/least_squares_method/#_4","text":"","title":"\u7dda\u5f62\u7b49\u5f0f\u30fb\u4e0d\u7b49\u5f0f\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5"},{"location":"tech_note/optimize/least_squares_method/#_5","text":"\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b \u5236\u7d04\u4ed8\u304d\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306e\u57fa\u790e\u3092\u307e\u3068\u3081\u308b Conversion from least squares to quadratic programming lsqlin \u6700\u5c0f\u4e8c\u4e57 (\u30e2\u30c7\u30eb\u5f53\u3066\u306f\u3081) \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/line_search/","text":"\u76f4\u7dda\u63a2\u7d22 \u56f2\u3044\u8fbc\u307f\u6cd5 \u30a2\u30eb\u30df\u30db\u6761\u4ef6 \u30a6\u30eb\u30d5\u6761\u4ef6 \u53c2\u8003\u6587\u732e \u76f4\u7dda\u63a2\u7d22\u306b\u304a\u3051\u308bArmijo\u6761\u4ef6\u3068Wolfe\u6761\u4ef6\u3092\u56f3\u304b\u3089\u7406\u89e3\u3059\u308b","title":"\u76f4\u7dda\u63a2\u7d22"},{"location":"tech_note/optimize/line_search/#_1","text":"","title":"\u76f4\u7dda\u63a2\u7d22"},{"location":"tech_note/optimize/line_search/#_2","text":"","title":"\u56f2\u3044\u8fbc\u307f\u6cd5"},{"location":"tech_note/optimize/line_search/#_3","text":"","title":"\u30a2\u30eb\u30df\u30db\u6761\u4ef6"},{"location":"tech_note/optimize/line_search/#_4","text":"","title":"\u30a6\u30eb\u30d5\u6761\u4ef6"},{"location":"tech_note/optimize/line_search/#_5","text":"\u76f4\u7dda\u63a2\u7d22\u306b\u304a\u3051\u308bArmijo\u6761\u4ef6\u3068Wolfe\u6761\u4ef6\u3092\u56f3\u304b\u3089\u7406\u89e3\u3059\u308b","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/newton/","text":"\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 \u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u3068\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u3044\u95a2\u6570\u3092\u5909\u6570\u306e\u5468\u308a\u30672\u6b21\u8fd1\u4f3c\u3057\u89e3\u304f\u4f5c\u696d\u3092\u7e70\u308a\u8fd4\u3059\u3053\u3068\u3067\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002","title":"\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5"},{"location":"tech_note/optimize/newton/#_1","text":"\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u95a2\u6570\u306e\u52fe\u914d\u3068\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u3044\u95a2\u6570\u3092\u5909\u6570\u306e\u5468\u308a\u30672\u6b21\u8fd1\u4f3c\u3057\u89e3\u304f\u4f5c\u696d\u3092\u7e70\u308a\u8fd4\u3059\u3053\u3068\u3067\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002","title":"\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5"},{"location":"tech_note/optimize/penalty_methond/","text":"\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5 \u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u79fb\u52d5\u3057\u305f\u969b\u306b\u5024\u304c\u5897\u52a0\u3059\u308b\u3088\u3046\u306a\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u76ee\u7684\u95a2\u6570\u306b\u4ed8\u52a0\u3057\u305f\u5916\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b","title":"\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5"},{"location":"tech_note/optimize/penalty_methond/#_1","text":"\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5\u3068\u306f\u89e3\u304c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u5916\u306b\u79fb\u52d5\u3057\u305f\u969b\u306b\u5024\u304c\u5897\u52a0\u3059\u308b\u3088\u3046\u306a\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u76ee\u7684\u95a2\u6570\u306b\u4ed8\u52a0\u3057\u305f\u5916\u70b9\u6cd5\u306e\u4e00\u7a2e\u3067\u3042\u308b","title":"\u30da\u30ca\u30eb\u30c6\u30a3\u6cd5"},{"location":"tech_note/optimize/prob_and_algo/","text":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7 \u6570\u7406\u8a08\u753b\u554f\u984c LP (Linear Programming : \u7dda\u5f62\u8a08\u753b\u554f\u984c) \u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u554f\u984c\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u3082\u306e MILP (Mixed Integer Linear Programming : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c) \u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e MIP(Mixed Integer Programming)\u3068\u547c\u3070\u308c\u308b\u3053\u3068\u3082\u591a\u3044 MIQP (Mixed Integer Quadratic Programming : \u6df7\u5408\u6574\u6570\u4e8c\u6b21\u8a08\u753b\u554f\u984c) \u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3001\u76ee\u7684\u95a2\u6570\u304c\u4e8c\u6b21\u95a2\u6570\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e MINLP (Mixed Integer Nonlinear Programming : \u6df7\u5408\u6574\u6570\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c) \u5236\u7d04\u5f0f\u304a\u3088\u3073\u76ee\u7684\u95a2\u6570\u304c\u975e\u7dda\u5f62\u3067\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e CQP (Convex Quadratic Programming : \u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c) \u76ee\u7684\u95a2\u6570\u304c\u51f8\u306a\u4e8c\u6b21\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u3082\u306e (\u305f\u3060\u3057\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u3082\u306e) CP (Convex Programming : \u51f8\u8a08\u753b\u554f\u984c) \u76ee\u7684\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u306a\u3082\u306e\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304c\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u304c\u51f8\u3067\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u554f\u984c\u3053\u3053\u3067\u306f\u6574\u6570\u5909\u6570\u306f\u542b\u307e\u306a\u3044\u3082\u306e\u3092\u6307\u3059 \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3082\u51f8\u8a08\u753b\u554f\u984c\u306e\u4e00\u90e8\u3067\u3059\u304c\u3001\u3053\u3053\u306b\u306f\u542b\u3081\u306a\u3044 NLP (Nonlinear Programming : \u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c) \u4e0a\u8a18\u4ee5\u5916\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c SDP (SemiDefinite Programing : \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c) \u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u3080\u7dda\u5f62\u8a08\u753b\u554f\u984c NLSDP (NonLinear SemiDefinite Programing : \u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c) \u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u307f\u3001\u306a\u304a\u304b\u3064\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u542b\u307e\u308c\u308b\u554f\u984c WCSP (Weighted Constraint Satisfaction Problem : \u91cd\u307f\u4ed8\u304d\u5236\u7d04\u5145\u8db3\u554f\u984c) \u5404\u3005\u91cd\u307f\u306e\u4ed8\u3044\u305f\u5236\u7d04\u6761\u4ef6\u3092\u306a\u308b\u3079\u304f\u6e80\u8db3\u3059\u308b\u305f\u3081\u306b\u306f\u5024\u3092\u3069\u306e\u3088\u3046\u306b\u5272\u308a\u5f53\u3066\u308b\u3068\u826f\u3044\u304b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0wcsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b RCPSP (Resource Constrained Project Scheduling Problem : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c) \u4e00\u5b9a\u306e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\u3067\u3001\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u3000\u3000 \u4e00\u822c\u306e\u6574\u6570\u8a08\u753b\u554f\u984c(MILP)\u3068\u3057\u3066\u8a18\u8ff0\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3060\u304c\u3001\u7279\u6b8a\u306a\u8a18\u6cd5\u3092\u884c\u3046\u3068\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0rcpsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7 simplex : \u5358\u4f53\u6cd5() \u7dda\u5f62\u8a08\u753b\u6cd5\u306e\u89e3\u6cd5\u3068\u3057\u3066\u53e4\u304f\u304b\u3089\u77e5\u3089\u308c\u3066\u3044\u308b\u65b9\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\u5185\u70b9\u6cd5\u306b\u901f\u5ea6\u7684\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u304c\u6c42\u307e\u308a\u539f\u7406\u7684\u306b\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e \u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u6307\u5b9a\u3059\u308b\u3068\uff0c\u5358\u4f53\u6cd5\u3092\u5206\u679d\u9650\u5b9a\u6cd5(Branch and bound method)\u3068\u3044\u3046\u67a0\u7d44\u306e\u306a\u304b\u3067\u7e70\u308a\u8fd4\u3057\u884c\u3063\u3066\uff0c\u6700\u9069\u6027\u306e\u4fdd\u8a3c\u306e\u3042\u308b\u6574\u6570\u89e3\u3092\u6c42\u3081\u307e\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u306b\u304a\u3044\u3066\u57fa\u5e95\u89e3\u304c\u5fc5\u8981\u306a\u5834\u5408\u306b\u306f\uff0c\"cross:on\"\u3068\u6307\u5b9a\u3057\u3066\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u306e\u304c\u6709\u5229\u3067\u3059\uff0e dual_simplex : \u53cc\u5bfe\u5358\u4f53\u6cd5(DUAL_SIMPLEX) (\u4e3b)\u5358\u4f53\u6cd5\u304c\u4e3b\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304f\u306e\u306b\u5bfe\u3057\uff0c\u53cc\u5bfe\u5358\u4f53\u6cd5\u306f\u53cc\u5bfe\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304d\u307e\u3059\uff0e \u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\uff0c(\u4e3b)\u5358\u4f53\u6cd5\u3068\u6bd4\u8f03\u3057\u3066\u6709\u5229\u3067\u3042\u308b\u3053\u3068\u304c\u3042\u308a\u307e\u3059\uff0e asqp : \u6709\u52b9\u5236\u7d04\u6cd5(ACTIVE_SET_QP) \u5358\u4f53\u6cd5\u3068\u540c\u69d8\uff0c\u53e4\u5178\u7684\u306a\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u53b3\u5bc6\u89e3\u6cd5\u3067\u3059\uff0e1\u4e07\u5909\u6570\u4ee5\u4e0a\u306e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\uff0c\u4e00\u822c\u306b\u5185\u70b9\u6cd5(\u76f4\u7dda\u63a2\u7d22\u6cd5(Line Search Method))\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c \u5909\u6570\u306b\u6bd4\u3079\u3066\u5236\u7d04\u5f0f\u306e\u6570\u304c\u975e\u5e38\u306b\u5c11\u306a\u3044(1/10\u4ee5\u4e0b)\u5834\u5408 \u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30bb\u884c\u5217\u304c\u5bc6\u884c\u5217\u3067\u3042\u308b\u5834\u5408 \u306b\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u304b\u3064\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e\u307e\u305f\uff0c\u6574\u6570\u8a08\u753b\u6cd5\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u306e\u3067\uff0c\u6574\u6570\u5909\u6570\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\"cross:on\"\u3068\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\uff0c\u5927\u898f\u6a21\u554f\u984c\u306b\u5bfe\u3057\u3066\u9ad8\u7cbe\u5ea6\u306a\u89e3\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e higher : \u7dda\u5f62\u8a08\u753b\u554f\u984c\u5c02\u7528\u5185\u70b9\u6cd5(HIGHER_ORDER) \u7dda\u5f62\u8a08\u753b\u6cd5\u306b\u7279\u5316\u3057\u305f\u5185\u70b9\u6cd5\u3067\uff0c\u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306e\u89e3\u6cd5\u3068\u3057\u3066\u306f\u6700\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5358\u4f53\u6cd5\u3068\u9055\u3044\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u306f\u6c42\u307e\u308a\u307e\u305b\u3093\uff0e lipm : (\u65b0\u7248)\u76f4\u7dda\u63a2\u7d22\u6cd5(LINE_SEARCH_IPM) lepm : \u76f4\u7dda\u63a2\u7d22\u5916\u70b9\u6cd5(LINE_SEARCH_EPM) line : (\u65e7\u7248)\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5(LINE_SEARCH) \u4e00\u822c\u306e\u51f8\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u554f\u984c\u304c\u51f8\u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u5834\u5408\u306b\u306f\u4fe1\u983c\u9818\u57df\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(lipm)\uff0c\u5916\u70b9\u6cd5(lepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(line)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5line\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5lipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059)\uff0e bfgs : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(BFGS_LINE_SEARCH) \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u201cbfgs\u201d\u306f\u30d8\u30c3\u30bb\u884c\u5217\u306e\u8fd1\u4f3c\u884c\u5217\u3092\u5bc6\u884c\u5217\u3068\u3057\u3066\u4fdd\u6301\u3057\u307e\u3059\u306e\u3067\uff0c\u5c0f\u898f\u6a21(50\uff5e500\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e tipm : (\u65b0\u7248)\u4fe1\u983c\u9818\u57df\u5185\u70b9\u6cd5(TRUST_REGION_IPM) tepm : \u4fe1\u983c\u9818\u57df\u5916\u70b9\u6cd5(TRUST_REGION_EPM) trust : (\u65e7\u7248)\u4fe1\u983c\u9818\u57df\u6cd5\u5185\u70b9\u6cd5(TRUST_REGION) \u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(tipm)\uff0c\u5916\u70b9\u6cd5(tepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(trust)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5trust\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5tipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3054\u3056\u3044\u307e\u3059)\uff0e lsqp : \u76f4\u7dda\u63a2\u7d22\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(LINE_SEARCH_SQP) \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5c0f\u898f\u6a21(50\uff5e100\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e \u554f\u984c\u306b\u3088\u3063\u3066\u306f\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(lipm/lepm/line)\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e tsqp : \u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(TRUST_REGION_SQP) \u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u305d\u306e\u307e\u307e\u7528\u3044\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u65b9\u6cd5\u3067\u3059\uff0e\u4e00\u822c\u306b\u5185\u70b9\u6cd5\u3088\u308a\u3082\u4f4e\u901f\u3067\u3059\u304c\uff0c\u554f\u984c\u306b\u3088\u3063\u3066\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\uff0c\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u5909\u6570\u306e\u6570\u3088\u308a\u3082\u5236\u7d04\u5f0f\u6570\u304c\u591a\u3044\u5834\u5408\u306b\u306f\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3088\u308a\u3082\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e slpsqp : \u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP) \u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u7528\u3044\u306a\u3044\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u3042\u308b\u7a0b\u5ea6\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u3067\u3059\uff0e\u5927\u57df\u7684\u53ce\u675f\u6027\u3092\u4fdd\u8a3c\u3059\u308b\u539f\u7406\u304c\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3084\u5f93\u6765\u306e\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(lsqp/tsqp)\u306e\u3082\u306e\u3068\u306f\u7570\u306a\u308b\u305f\u3081\uff0c\u4ed6\u306e\u65b9\u6cd5\u3067\u53ce\u675f\u3057\u306a\u3044\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e\u307e\u305f\uff0c\u5236\u7d04\u5f0f\u306e\u52fe\u914d\u304c\u5c0f\u3055\u3044\u53cd\u5fa9\u70b9\u306b\u3044\u308b\u6642\uff0c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u63a5\u8fd1\u3059\u308b\u3068\u3044\u3046\u4ed5\u7d44\u307f\u304c\u7d44\u307f\u8fbc\u307e\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u8907\u96d1\u306a\u5236\u7d04\u306b\u304a\u3044\u3066\u3082\u5b89\u5b9a\u7684\u306a\u52d5\u4f5c\u304c\u671f\u5f85\u3067\u304d\u307e\u3059\uff0e lsdp : \u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u7dda\u5f62\u306e\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u51fa\u73fe\u3059\u308b\u9805\u306f\u7dda\u5f62\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3044\u307e\u305b\u3093\uff0e csdp : \u51f8\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u76ee\u7684\u95a2\u6570\u304c\u51f8\u975e\u7dda\u5f62\u95a2\u6570\u3067\uff0c\u5236\u7d04\u304c\u7dda\u5f62\u306a\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u3053\u306e\u985e\u306e\u554f\u984c\u306f\uff0c\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3067\u8a18\u8ff0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u304c\uff0c\u305d\u306e\u307e\u307e\u6271\u3063\u305f\u65b9\u304c\u9ad8\u901f\u306b\u6c42\u89e3\u3067\u304d\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3046\u70b9\u304clsdp\u3068\u7570\u306a\u308a\u307e\u3059\uff0e qnsdp : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e lmsdp : Levenberg-Marquardt\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u70ba\u306b\uff0cLevenberg-Marquardt\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u306b\u6bd4\u3079\u3066\uff0c\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e\u5909\u6570\u304c\u5c11\u306a\u304f\uff0c\u884c\u5217\u6b21\u5143\u304c\u5927\u304d\u3044\u554f\u984c\u306e\u5834\u5408\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(trsdp)\u3088\u308a\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e trsdp : \u4fe1\u983c\u9818\u57df\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u3088\u308a\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e wcsp : \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0(WCSP) \u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u5236\u7d04\u5145\u8db3\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u5fc5\u305a\u3057\u3082\u53b3\u5bc6\u89e3\u304c\u6c42\u307e\u308b\u308f\u3051\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\uff0c\u5927\u898f\u6a21\u306a\u6574\u6570\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\uff0c\u975e\u5e38\u306b\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3(\u8fd1\u4f3c\u89e3)\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u6574\u6570\u5909\u6570\u306e\u307f\u3092\u542b\u307f\uff0c\u304b\u3064\u3059\u3079\u3066\u306e\u5909\u6570\u306b\u4e0a\u9650\u3068\u4e0b\u9650\u304c\u3042\u308b\u554f\u984c\u306b\u5bfe\u3057\u3066\u306e\u307f\u6709\u52b9\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\uff0c\u5236\u7d04\u5f0f\u306b\u91cd\u307f\u3092\u8a2d\u5b9a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u5236\u7d04\u306e\u91cd\u307f\u306b\u306f\uff0c\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bb\u30df\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bd\u30d5\u30c8\u5236\u7d04\u306e\u4e09\u7a2e\u985e\u304c\u3042\u308a\u307e\u3059\uff0e wcsplp : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u5c02\u7528\u306e\u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0 \u7dda\u5f62\u306a\u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u3092\u5236\u7d04\u5145\u8db3\u554f\u984c\u306e\u67a0\u7d44\u307f\u3067\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u306f\uff0c\u9023\u7d9a\u5909\u6570\u306f\u9069\u5f53\u306a\u523b\u307f\u5e45\u3092\u3082\u3064DiscreteVariable\u3068\u89e3\u91c8\u3055\u308c\u307e\u3059\uff0ewcsplp\u3067\u306f\u5168\u3066\u306e\u5236\u7d04\u5f0f\u3092\u30cf\u30fc\u30c9\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\uff0c\u76ee\u7684\u95a2\u6570\u3092\u30bd\u30d5\u30c8\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\u307e\u3059\uff0e rcpsp : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0(RCPSP) \u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\uff0c\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u306e\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u9ad8\u901f\u306b\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0ercpsp\u306e\u8a18\u8ff0\u306b\u3042\u305f\u3063\u3066\u306f\u554f\u984c\u3092SIMPLE\u306e\u7279\u6b8a\u306a\u30af\u30e9\u30b9\u3092\u7528\u3044\u3066\u8a18\u8ff0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5b8c\u4e86\u6642\u523b\u306e\u6700\u5c0f\u5316\u554f\u984c\u3068\uff0c\u7d0d\u671f\u9045\u308c\u6700\u5c0f\u5316\u554f\u984c\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u524d\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30bd\u30d5\u30c8\u5236\u7d04\uff0c\u5f8c\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30cf\u30fc\u30c9\u5236\u7d04\u306e\u307f\u304c\u4f7f\u7528\u3067\u304d\u307e\u3059\uff0e \u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc LP MILP MIQP MINLP CQP CP NLP SDP NLSDP RCPSP simplex \u25cb \u25cb -- -- -- -- -- -- -- \u25b3 dual_simplex \u25cb -- -- -- -- -- -- -- -- -- asqp \u25cb -- \u25cb -- \u25cb -- -- -- -- -- higher \u25cb -- -- -- -- -- -- -- -- -- lipm/lepm/line \u25b3 -- -- -- \u25cb \u25cb -- -- -- -- bfgs \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- tipm/tepm/trust \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- lsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- tsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- slpsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- lsdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- csdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- qnsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- trsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- lmsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- wcsp -- \u25cb\u203b1 \u25cb\u203b1 \u25cb\u203b1 -- -- -- -- -- -- wcsplp \u25b3 \u25cb\u203b2 -- -- -- -- -- -- -- -- global \u25b3 \u25b3 \u25b3 \u25cb \u25b3 \u25b3 \u25cb \u25cb \u25cb \u25b3 DFO \u25b3 -- -- -- \u25b3 \u25b3 \u25cb -- -- -- rcpsp -- -- -- -- -- -- -- -- -- \u25cb Info \u203b1: 0-1\u6574\u6570\u5909\u6570\u3068\u96e2\u6563\u5909\u6570\u306e\u307f\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u9069\u7528\u3067\u304d\u308b\u3053\u3068\u3092\u610f\u5473\u3059\u308b \u3000\u3000\u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u3042\u308b\u3044\u306f\u4e0a\u9650\u3068\u4e0b\u9650\u3092\u6301\u305f\u306a\u3044\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u306f\u9069\u7528\u3067\u304d\u306a\u3044 \u203b2: \u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u5834\u5408\u3082\u9069\u7528\u304c\u3067\u304d\u308b\u304c\u52b9\u7387\u304c\u843d\u3061\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b \u53c2\u8003\u6587\u732e 14.1 \u6570\u7406\u8a08\u753b\u554f\u984c\u4e00\u89a7 14.2 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7 14.3 \u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc","title":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7"},{"location":"tech_note/optimize/prob_and_algo/#_1","text":"","title":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7"},{"location":"tech_note/optimize/prob_and_algo/#_2","text":"","title":"\u6570\u7406\u8a08\u753b\u554f\u984c"},{"location":"tech_note/optimize/prob_and_algo/#lp-linear-programming","text":"\u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u554f\u984c\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u3082\u306e","title":"LP (Linear Programming : \u7dda\u5f62\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#milp-mixed-integer-linear-programming","text":"\u76ee\u7684\u95a2\u6570\u3068\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e MIP(Mixed Integer Programming)\u3068\u547c\u3070\u308c\u308b\u3053\u3068\u3082\u591a\u3044","title":"MILP (Mixed Integer Linear Programming : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#miqp-mixed-integer-quadratic-programming","text":"\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3001\u76ee\u7684\u95a2\u6570\u304c\u4e8c\u6b21\u95a2\u6570\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e","title":"MIQP (Mixed Integer Quadratic Programming : \u6df7\u5408\u6574\u6570\u4e8c\u6b21\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#minlp-mixed-integer-nonlinear-programming","text":"\u5236\u7d04\u5f0f\u304a\u3088\u3073\u76ee\u7684\u95a2\u6570\u304c\u975e\u7dda\u5f62\u3067\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u3082\u306e","title":"MINLP (Mixed Integer Nonlinear Programming : \u6df7\u5408\u6574\u6570\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#cqp-convex-quadratic-programming","text":"\u76ee\u7684\u95a2\u6570\u304c\u51f8\u306a\u4e8c\u6b21\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u304c\u3059\u3079\u3066\u7dda\u5f62\u3067\u3042\u308b\u3082\u306e (\u305f\u3060\u3057\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u3082\u306e)","title":"CQP (Convex Quadratic Programming : \u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#cp-convex-programming","text":"\u76ee\u7684\u95a2\u6570\u3001\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u306a\u3082\u306e\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u304c\u3001\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u304c\u51f8\u3067\u3001\u76ee\u7684\u95a2\u6570\u306e\u7b26\u53f7\u306e\u5909\u66f4\u3067\u4e0b\u306b\u51f8\u306a\u76ee\u7684\u95a2\u6570\u306e\u6700\u5c0f\u5316\u306b\u5e30\u7740\u3067\u304d\u308b\u554f\u984c\u3053\u3053\u3067\u306f\u6574\u6570\u5909\u6570\u306f\u542b\u307e\u306a\u3044\u3082\u306e\u3092\u6307\u3059 \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3082\u51f8\u8a08\u753b\u554f\u984c\u306e\u4e00\u90e8\u3067\u3059\u304c\u3001\u3053\u3053\u306b\u306f\u542b\u3081\u306a\u3044","title":"CP (Convex Programming : \u51f8\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#nlp-nonlinear-programming","text":"\u4e0a\u8a18\u4ee5\u5916\u3067\u3001\u6574\u6570\u5909\u6570\u3092\u542b\u307e\u306a\u3044\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c","title":"NLP (Nonlinear Programming : \u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#sdp-semidefinite-programing","text":"\u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u3080\u7dda\u5f62\u8a08\u753b\u554f\u984c","title":"SDP (SemiDefinite Programing : \u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#nlsdp-nonlinear-semidefinite-programing","text":"\u884c\u5217\u306e\u534a\u6b63\u5b9a\u5024\u5236\u7d04\u3092\u542b\u307f\u3001\u306a\u304a\u304b\u3064\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u542b\u307e\u308c\u308b\u554f\u984c","title":"NLSDP (NonLinear SemiDefinite Programing : \u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#wcsp-weighted-constraint-satisfaction-problem","text":"\u5404\u3005\u91cd\u307f\u306e\u4ed8\u3044\u305f\u5236\u7d04\u6761\u4ef6\u3092\u306a\u308b\u3079\u304f\u6e80\u8db3\u3059\u308b\u305f\u3081\u306b\u306f\u5024\u3092\u3069\u306e\u3088\u3046\u306b\u5272\u308a\u5f53\u3066\u308b\u3068\u826f\u3044\u304b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0wcsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b","title":"WCSP (Weighted Constraint Satisfaction Problem : \u91cd\u307f\u4ed8\u304d\u5236\u7d04\u5145\u8db3\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#rcpsp-resource-constrained-project-scheduling-problem","text":"\u4e00\u5b9a\u306e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\u3067\u3001\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u3000\u3000 \u4e00\u822c\u306e\u6574\u6570\u8a08\u753b\u554f\u984c(MILP)\u3068\u3057\u3066\u8a18\u8ff0\u3059\u308b\u3053\u3068\u3082\u53ef\u80fd\u3060\u304c\u3001\u7279\u6b8a\u306a\u8a18\u6cd5\u3092\u884c\u3046\u3068\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0rcpsp\u306b\u3088\u308a\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u5f97\u308b\u3053\u3068\u304c\u3067\u304d\u308b","title":"RCPSP (Resource Constrained Project Scheduling Problem : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c)"},{"location":"tech_note/optimize/prob_and_algo/#_3","text":"","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7"},{"location":"tech_note/optimize/prob_and_algo/#simplex","text":"\u7dda\u5f62\u8a08\u753b\u6cd5\u306e\u89e3\u6cd5\u3068\u3057\u3066\u53e4\u304f\u304b\u3089\u77e5\u3089\u308c\u3066\u3044\u308b\u65b9\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\u5185\u70b9\u6cd5\u306b\u901f\u5ea6\u7684\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u304c\u6c42\u307e\u308a\u539f\u7406\u7684\u306b\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e \u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u6307\u5b9a\u3059\u308b\u3068\uff0c\u5358\u4f53\u6cd5\u3092\u5206\u679d\u9650\u5b9a\u6cd5(Branch and bound method)\u3068\u3044\u3046\u67a0\u7d44\u306e\u306a\u304b\u3067\u7e70\u308a\u8fd4\u3057\u884c\u3063\u3066\uff0c\u6700\u9069\u6027\u306e\u4fdd\u8a3c\u306e\u3042\u308b\u6574\u6570\u89e3\u3092\u6c42\u3081\u307e\u3059\uff0e\u5927\u898f\u6a21\u554f\u984c\u306b\u304a\u3044\u3066\u57fa\u5e95\u89e3\u304c\u5fc5\u8981\u306a\u5834\u5408\u306b\u306f\uff0c\"cross:on\"\u3068\u6307\u5b9a\u3057\u3066\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u306e\u304c\u6709\u5229\u3067\u3059\uff0e","title":"simplex : \u5358\u4f53\u6cd5()"},{"location":"tech_note/optimize/prob_and_algo/#dual_simplex-dual_simplex","text":"(\u4e3b)\u5358\u4f53\u6cd5\u304c\u4e3b\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304f\u306e\u306b\u5bfe\u3057\uff0c\u53cc\u5bfe\u5358\u4f53\u6cd5\u306f\u53cc\u5bfe\u5b9f\u884c\u53ef\u80fd\u306a\u57fa\u5e95\u89e3\u3092\u305f\u3069\u308a\u306a\u304c\u3089\u6700\u9069\u89e3\u306b\u305f\u3069\u308a\u7740\u304d\u307e\u3059\uff0e \u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\u3066\uff0c(\u4e3b)\u5358\u4f53\u6cd5\u3068\u6bd4\u8f03\u3057\u3066\u6709\u5229\u3067\u3042\u308b\u3053\u3068\u304c\u3042\u308a\u307e\u3059\uff0e","title":"dual_simplex : \u53cc\u5bfe\u5358\u4f53\u6cd5(DUAL_SIMPLEX)"},{"location":"tech_note/optimize/prob_and_algo/#asqp-active_set_qp","text":"\u5358\u4f53\u6cd5\u3068\u540c\u69d8\uff0c\u53e4\u5178\u7684\u306a\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u53b3\u5bc6\u89e3\u6cd5\u3067\u3059\uff0e1\u4e07\u5909\u6570\u4ee5\u4e0a\u306e\u5927\u898f\u6a21\u554f\u984c\u3067\u306f\uff0c\u4e00\u822c\u306b\u5185\u70b9\u6cd5(\u76f4\u7dda\u63a2\u7d22\u6cd5(Line Search Method))\u306b\u52a3\u308a\u307e\u3059\u304c\uff0c \u5909\u6570\u306b\u6bd4\u3079\u3066\u5236\u7d04\u5f0f\u306e\u6570\u304c\u975e\u5e38\u306b\u5c11\u306a\u3044(1/10\u4ee5\u4e0b)\u5834\u5408 \u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30bb\u884c\u5217\u304c\u5bc6\u884c\u5217\u3067\u3042\u308b\u5834\u5408 \u306b\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u304b\u3064\u9ad8\u7cbe\u5ea6\u3067\u3059\uff0e\u307e\u305f\uff0c\u6574\u6570\u8a08\u753b\u6cd5\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u306e\u3067\uff0c\u6574\u6570\u5909\u6570\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u51f8\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u3092\u89e3\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\"cross:on\"\u3068\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\u5185\u70b9\u6cd5\u304b\u3089\u306e\u30af\u30ed\u30b9\u30aa\u30fc\u30d0\u30fc\u3092\u7528\u3044\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\uff0c\u5927\u898f\u6a21\u554f\u984c\u306b\u5bfe\u3057\u3066\u9ad8\u7cbe\u5ea6\u306a\u89e3\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e","title":"asqp : \u6709\u52b9\u5236\u7d04\u6cd5(ACTIVE_SET_QP)"},{"location":"tech_note/optimize/prob_and_algo/#higher-higher_order","text":"\u7dda\u5f62\u8a08\u753b\u6cd5\u306b\u7279\u5316\u3057\u305f\u5185\u70b9\u6cd5\u3067\uff0c\u5927\u898f\u6a21\u306a\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306e\u89e3\u6cd5\u3068\u3057\u3066\u306f\u6700\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5358\u4f53\u6cd5\u3068\u9055\u3044\uff0c\u53ef\u80fd\u57fa\u5e95\u89e3\u306f\u6c42\u307e\u308a\u307e\u305b\u3093\uff0e","title":"higher : \u7dda\u5f62\u8a08\u753b\u554f\u984c\u5c02\u7528\u5185\u70b9\u6cd5(HIGHER_ORDER)"},{"location":"tech_note/optimize/prob_and_algo/#lipm-line_search_ipm","text":"","title":"lipm : (\u65b0\u7248)\u76f4\u7dda\u63a2\u7d22\u6cd5(LINE_SEARCH_IPM)"},{"location":"tech_note/optimize/prob_and_algo/#lepm-line_search_epm","text":"","title":"lepm : \u76f4\u7dda\u63a2\u7d22\u5916\u70b9\u6cd5(LINE_SEARCH_EPM)"},{"location":"tech_note/optimize/prob_and_algo/#line-line_search","text":"\u4e00\u822c\u306e\u51f8\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u554f\u984c\u304c\u51f8\u3067\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u5834\u5408\u306b\u306f\u4fe1\u983c\u9818\u57df\u6cd5\u3088\u308a\u3082\u9ad8\u901f\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(lipm)\uff0c\u5916\u70b9\u6cd5(lepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(line)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5line\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5lipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3042\u308a\u307e\u3059)\uff0e","title":"line : (\u65e7\u7248)\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5(LINE_SEARCH)"},{"location":"tech_note/optimize/prob_and_algo/#bfgs-bfgs_line_search","text":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u201cbfgs\u201d\u306f\u30d8\u30c3\u30bb\u884c\u5217\u306e\u8fd1\u4f3c\u884c\u5217\u3092\u5bc6\u884c\u5217\u3068\u3057\u3066\u4fdd\u6301\u3057\u307e\u3059\u306e\u3067\uff0c\u5c0f\u898f\u6a21(50\uff5e500\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e","title":"bfgs : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5(BFGS_LINE_SEARCH)"},{"location":"tech_note/optimize/prob_and_algo/#tipm-trust_region_ipm","text":"","title":"tipm : (\u65b0\u7248)\u4fe1\u983c\u9818\u57df\u5185\u70b9\u6cd5(TRUST_REGION_IPM)"},{"location":"tech_note/optimize/prob_and_algo/#tepm-trust_region_epm","text":"","title":"tepm : \u4fe1\u983c\u9818\u57df\u5916\u70b9\u6cd5(TRUST_REGION_EPM)"},{"location":"tech_note/optimize/prob_and_algo/#trust-trust_region","text":"\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u5185\u70b9\u6cd5\u30fb\u5916\u70b9\u6cd5\u3067\u3059\uff0e\u5e45\u5e83\u3044\u7bc4\u56f2\u306e\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u306e\u304c\u5185\u70b9\u6cd5(tipm)\uff0c\u5916\u70b9\u6cd5(tepm)\u306f\u554f\u984c\u306b\u5bfe\u3057\u3066\u6bd4\u8f03\u7684\u826f\u3044\u521d\u671f\u5024\u304c\u5f97\u3089\u308c\u3066\u3044\u308b\u5834\u5408\u306b\u6709\u52b9\u3067\u3042\u308b\u3053\u3068\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\uff0e\u65e7\u7248\u306e\u5185\u70b9\u6cd5(trust)\u306f\uff0c\u4ee5\u524d\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3068\u306e\u6574\u5408\u3092\u53d6\u308b\u5834\u5408\u306b\u3054\u5229\u7528\u304f\u3060\u3055\u3044(Ver.7\u4ee5\u524d\u306e\u5185\u70b9\u6cd5trust\u3068Ver.8\u4ee5\u964d\u306e\u5185\u70b9\u6cd5tipm\u3067\u306f\uff0c\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u5b9a\u7fa9\u304c\u82e5\u5e72\u7570\u306a\u3063\u3066\u304a\u308a\u307e\u3059\u306e\u3067\uff0c\u65b0\u7248\u3068\u65e7\u7248\u3067\u306f\u7570\u306a\u308b\u7d50\u679c\u3092\u4e0e\u3048\u308b\u5834\u5408\u304c\u3054\u3056\u3044\u307e\u3059)\uff0e","title":"trust : (\u65e7\u7248)\u4fe1\u983c\u9818\u57df\u6cd5\u5185\u70b9\u6cd5(TRUST_REGION)"},{"location":"tech_note/optimize/prob_and_algo/#lsqp-line_search_sqp","text":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u3063\u3066\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u6c42\u3081\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5c0f\u898f\u6a21(50\uff5e100\u5909\u6570\u4ee5\u4e0b)\u306a\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u3057\u3066\u3044\u307e\u3059\uff0e \u554f\u984c\u306b\u3088\u3063\u3066\u306f\u76f4\u7dda\u63a2\u7d22\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(lipm/lepm/line)\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e","title":"lsqp : \u76f4\u7dda\u63a2\u7d22\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(LINE_SEARCH_SQP)"},{"location":"tech_note/optimize/prob_and_algo/#tsqp-trust_region_sqp","text":"\u4e8c\u968e\u5fae\u4fc2\u6570\u3092\u305d\u306e\u307e\u307e\u7528\u3044\u308b\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u306a\u65b9\u6cd5\u3067\u3059\uff0e\u4e00\u822c\u306b\u5185\u70b9\u6cd5\u3088\u308a\u3082\u4f4e\u901f\u3067\u3059\u304c\uff0c\u554f\u984c\u306b\u3088\u3063\u3066\u306f\u5185\u70b9\u6cd5\u3088\u308a\u3082\u5b89\u5b9a\u7684\u306b\uff0c\u3088\u308a\u7cbe\u5ea6\u306e\u826f\u3044\u89e3\u3092\u5c0e\u304f\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u5909\u6570\u306e\u6570\u3088\u308a\u3082\u5236\u7d04\u5f0f\u6570\u304c\u591a\u3044\u5834\u5408\u306b\u306f\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3088\u308a\u3082\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e","title":"tsqp : \u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(TRUST_REGION_SQP)"},{"location":"tech_note/optimize/prob_and_algo/#slpsqp-slp-sqp","text":"\u30da\u30ca\u30eb\u30c6\u30a3\u95a2\u6570\u3092\u7528\u3044\u306a\u3044\u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5\u3067\u3059\uff0e\u3042\u308b\u7a0b\u5ea6\u5927\u898f\u6a21\u306a\u3082\u306e\u3092\u542b\u3080\u4e00\u822c\u306e\u975e\u7dda\u5f62\u8a08\u753b\u554f\u984c\u306b\u9069\u7528\u53ef\u80fd\u3067\u3059\uff0e\u5927\u57df\u7684\u53ce\u675f\u6027\u3092\u4fdd\u8a3c\u3059\u308b\u539f\u7406\u304c\u5185\u70b9\u6cd5/\u5916\u70b9\u6cd5(tipm/tepm/trust)\u3084\u5f93\u6765\u306e\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5(lsqp/tsqp)\u306e\u3082\u306e\u3068\u306f\u7570\u306a\u308b\u305f\u3081\uff0c\u4ed6\u306e\u65b9\u6cd5\u3067\u53ce\u675f\u3057\u306a\u3044\u554f\u984c\u306b\u5bfe\u3057\u3066\u6709\u52b9\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e\u307e\u305f\uff0c\u5236\u7d04\u5f0f\u306e\u52fe\u914d\u304c\u5c0f\u3055\u3044\u53cd\u5fa9\u70b9\u306b\u3044\u308b\u6642\uff0c\u5b9f\u884c\u53ef\u80fd\u9818\u57df\u306b\u63a5\u8fd1\u3059\u308b\u3068\u3044\u3046\u4ed5\u7d44\u307f\u304c\u7d44\u307f\u8fbc\u307e\u308c\u3066\u3044\u307e\u3059\u306e\u3067\u8907\u96d1\u306a\u5236\u7d04\u306b\u304a\u3044\u3066\u3082\u5b89\u5b9a\u7684\u306a\u52d5\u4f5c\u304c\u671f\u5f85\u3067\u304d\u307e\u3059\uff0e","title":"slpsqp : \u9010\u6b21\u7dda\u5f62\u4e8c\u6b21\u8a08\u753b\u6cd5(SLP-SQP)"},{"location":"tech_note/optimize/prob_and_algo/#lsdp","text":"\u7dda\u5f62\u306e\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u51fa\u73fe\u3059\u308b\u9805\u306f\u7dda\u5f62\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3044\u307e\u305b\u3093\uff0e","title":"lsdp : \u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/prob_and_algo/#csdp","text":"\u76ee\u7684\u95a2\u6570\u304c\u51f8\u975e\u7dda\u5f62\u95a2\u6570\u3067\uff0c\u5236\u7d04\u304c\u7dda\u5f62\u306a\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u3053\u306e\u985e\u306e\u554f\u984c\u306f\uff0c\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u3067\u8a18\u8ff0\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u304c\uff0c\u305d\u306e\u307e\u307e\u6271\u3063\u305f\u65b9\u304c\u9ad8\u901f\u306b\u6c42\u89e3\u3067\u304d\u307e\u3059\uff0e\u5185\u90e8\u3067\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u8a08\u7b97\u3092\u884c\u3046\u70b9\u304clsdp\u3068\u7570\u306a\u308a\u307e\u3059\uff0e","title":"csdp : \u51f8\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/prob_and_algo/#qnsdp","text":"\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e","title":"qnsdp : \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/prob_and_algo/#lmsdp-levenberg-marquardt","text":"\u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u70ba\u306b\uff0cLevenberg-Marquardt\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u306b\u6bd4\u3079\u3066\uff0c\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e\u5909\u6570\u304c\u5c11\u306a\u304f\uff0c\u884c\u5217\u6b21\u5143\u304c\u5927\u304d\u3044\u554f\u984c\u306e\u5834\u5408\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(trsdp)\u3088\u308a\u9ad8\u901f\u306a\u5834\u5408\u304c\u3042\u308a\u307e\u3059\uff0e trsdp : \u4fe1\u983c\u9818\u57df\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5 \u76ee\u7684\u95a2\u6570\u30fb\u5236\u7d04\u5f0f\u306b\u975e\u7dda\u5f62\u9805\u304c\u51fa\u73fe\u3059\u308b\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5\u3067\u3059\uff0e\u30e1\u30ea\u30c3\u30c8\u95a2\u6570\u306e\u964d\u4e0b\u3092\u4fdd\u8a3c\u3059\u308b\u305f\u3081\u306b\uff0c\u4fe1\u983c\u9818\u57df\u6cd5\u3092\u5229\u7528\u3057\u3066\u3044\u307e\u3059\uff0e\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u57fa\u3065\u304f\u65b9\u6cd5(qnsdp)\u3088\u308a\u898f\u6a21\u306e\u5927\u304d\u306a\u554f\u984c\u3092\u53d6\u308a\u6271\u3046\u4e8b\u304c\u3067\u304d\u307e\u3059\uff0e","title":"lmsdp : Levenberg-Marquardt\u6cd5\u3092\u7528\u3044\u305f\u975e\u7dda\u5f62\u534a\u6b63\u5b9a\u5024\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3059\u308b\u4e3b\u53cc\u5bfe\u5185\u70b9\u6cd5"},{"location":"tech_note/optimize/prob_and_algo/#wcsp-wcsp","text":"\u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u5236\u7d04\u5145\u8db3\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u5fc5\u305a\u3057\u3082\u53b3\u5bc6\u89e3\u304c\u6c42\u307e\u308b\u308f\u3051\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u304c\uff0c\u5927\u898f\u6a21\u306a\u6574\u6570\u8a08\u753b\u554f\u984c\u306b\u5bfe\u3057\uff0c\u975e\u5e38\u306b\u9ad8\u901f\u306b\u5b9f\u884c\u53ef\u80fd\u89e3(\u8fd1\u4f3c\u89e3)\u3092\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e \u6574\u6570\u5909\u6570\u306e\u307f\u3092\u542b\u307f\uff0c\u304b\u3064\u3059\u3079\u3066\u306e\u5909\u6570\u306b\u4e0a\u9650\u3068\u4e0b\u9650\u304c\u3042\u308b\u554f\u984c\u306b\u5bfe\u3057\u3066\u306e\u307f\u6709\u52b9\u3067\u3059\uff0e\u76ee\u7684\u95a2\u6570\uff0c\u5236\u7d04\u5f0f\u306b\u91cd\u307f\u3092\u8a2d\u5b9a\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u5236\u7d04\u306e\u91cd\u307f\u306b\u306f\uff0c\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bb\u30df\u30cf\u30fc\u30c9\u5236\u7d04\uff0c\u30bd\u30d5\u30c8\u5236\u7d04\u306e\u4e09\u7a2e\u985e\u304c\u3042\u308a\u307e\u3059\uff0e","title":"wcsp : \u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0(WCSP)"},{"location":"tech_note/optimize/prob_and_algo/#wcsplp","text":"\u7dda\u5f62\u306a\u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u3092\u5236\u7d04\u5145\u8db3\u554f\u984c\u306e\u67a0\u7d44\u307f\u3067\u89e3\u304f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u306f\uff0c\u9023\u7d9a\u5909\u6570\u306f\u9069\u5f53\u306a\u523b\u307f\u5e45\u3092\u3082\u3064DiscreteVariable\u3068\u89e3\u91c8\u3055\u308c\u307e\u3059\uff0ewcsplp\u3067\u306f\u5168\u3066\u306e\u5236\u7d04\u5f0f\u3092\u30cf\u30fc\u30c9\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\uff0c\u76ee\u7684\u95a2\u6570\u3092\u30bd\u30d5\u30c8\u5236\u7d04\u3068\u3057\u3066\u6271\u3044\u307e\u3059\uff0e","title":"wcsplp : \u6df7\u5408\u6574\u6570\u8a08\u753b\u554f\u984c\u5c02\u7528\u306e\u5236\u7d04\u5145\u8db3\u554f\u984c\u30bd\u30eb\u30d0"},{"location":"tech_note/optimize/prob_and_algo/#rcpsp-rcpsp","text":"\u4eac\u90fd\u5927\u5b66\u300c\u554f\u984c\u89e3\u6c7a\u30a8\u30f3\u30b8\u30f3\u300d\u30b0\u30eb\u30fc\u30d7\u306e\u958b\u767a\u306b\u3088\u308b\u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u306b\u5bfe\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3059\uff0e\u8cc7\u6e90\u5236\u7d04\u306e\u4e0b\uff0c\u6c7a\u3081\u3089\u308c\u305f\u4f5c\u696d\u306e\u958b\u59cb\u30fb\u7d42\u4e86\u6642\u523b\u3092\u6c7a\u5b9a\u3059\u308b\u554f\u984c\u306e\u5b9f\u884c\u53ef\u80fd\u89e3\u3092\u9ad8\u901f\u306b\u6c42\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0ercpsp\u306e\u8a18\u8ff0\u306b\u3042\u305f\u3063\u3066\u306f\u554f\u984c\u3092SIMPLE\u306e\u7279\u6b8a\u306a\u30af\u30e9\u30b9\u3092\u7528\u3044\u3066\u8a18\u8ff0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\uff0e\u5b8c\u4e86\u6642\u523b\u306e\u6700\u5c0f\u5316\u554f\u984c\u3068\uff0c\u7d0d\u671f\u9045\u308c\u6700\u5c0f\u5316\u554f\u984c\u3092\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e\u524d\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30bd\u30d5\u30c8\u5236\u7d04\uff0c\u5f8c\u8005\u3092\u6271\u3046\u969b\u306b\u306f\u30cf\u30fc\u30c9\u5236\u7d04\u306e\u307f\u304c\u4f7f\u7528\u3067\u304d\u307e\u3059\uff0e","title":"rcpsp : \u8cc7\u6e90\u5236\u7d04\u4ed8\u304d\u30b9\u30b1\u30b8\u30e5\u30fc\u30ea\u30f3\u30b0\u554f\u984c\u30bd\u30eb\u30d0(RCPSP)"},{"location":"tech_note/optimize/prob_and_algo/#_4","text":"LP MILP MIQP MINLP CQP CP NLP SDP NLSDP RCPSP simplex \u25cb \u25cb -- -- -- -- -- -- -- \u25b3 dual_simplex \u25cb -- -- -- -- -- -- -- -- -- asqp \u25cb -- \u25cb -- \u25cb -- -- -- -- -- higher \u25cb -- -- -- -- -- -- -- -- -- lipm/lepm/line \u25b3 -- -- -- \u25cb \u25cb -- -- -- -- bfgs \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- tipm/tepm/trust \u25b3 -- -- -- -- \u25b3 \u25cb -- -- -- lsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- tsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- slpsqp \u25b3 -- -- -- \u25b3 \u25cb \u25cb -- -- -- lsdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- csdp \u25b3 -- -- -- \u25b3 \u25b3 -- \u25cb -- -- qnsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- trsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- lmsdp \u25b3 -- -- -- \u25b3 \u25b3 \u25b3 \u25b3 \u25cb -- wcsp -- \u25cb\u203b1 \u25cb\u203b1 \u25cb\u203b1 -- -- -- -- -- -- wcsplp \u25b3 \u25cb\u203b2 -- -- -- -- -- -- -- -- global \u25b3 \u25b3 \u25b3 \u25cb \u25b3 \u25b3 \u25cb \u25cb \u25cb \u25b3 DFO \u25b3 -- -- -- \u25b3 \u25b3 \u25cb -- -- -- rcpsp -- -- -- -- -- -- -- -- -- \u25cb Info \u203b1: 0-1\u6574\u6570\u5909\u6570\u3068\u96e2\u6563\u5909\u6570\u306e\u307f\u3092\u542b\u3080\u554f\u984c\u306b\u5bfe\u3057\u3066\u9069\u7528\u3067\u304d\u308b\u3053\u3068\u3092\u610f\u5473\u3059\u308b \u3000\u3000\u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u3042\u308b\u3044\u306f\u4e0a\u9650\u3068\u4e0b\u9650\u3092\u6301\u305f\u306a\u3044\u6574\u6570\u5909\u6570\u3092\u542b\u3080\u554f\u984c\u306b\u306f\u9069\u7528\u3067\u304d\u306a\u3044 \u203b2: \u9023\u7d9a\u5909\u6570\u3092\u542b\u3080\u5834\u5408\u3082\u9069\u7528\u304c\u3067\u304d\u308b\u304c\u52b9\u7387\u304c\u843d\u3061\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b","title":"\u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc"},{"location":"tech_note/optimize/prob_and_algo/#_5","text":"14.1 \u6570\u7406\u8a08\u753b\u554f\u984c\u4e00\u89a7 14.2 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u4e00\u89a7 14.3 \u6570\u7406\u8a08\u753b\u554f\u984c\u3068\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u5bfe\u5fdc","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/quadprog/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u4e8c\u6b21\u8a08\u753b\u6cd5 \u4ee5\u4e0b\u306e\u6700\u9069\u5316\u554f\u984c\u3092\u8003\u3048\u308b min 1 2 x T Q x + c T x s.t. A x = b , A e q x \u2264 b e q , l x \u2264 x \u2264 u x x \u2208 R n \\text{min} \\space \\dfrac{1}{2}x^TQx + c^T x\\\\ \\text{s.t.} \\space Ax = b, A_{eq}x \\leq b_{eq}, l_x \\leq x \\leq u_x \\\\ x \\in \\R^n min 2 1 \u200b x T Q x + c T x s.t. A x = b , A e q \u200b x \u2264 b e q \u200b , l x \u200b \u2264 x \u2264 u x \u200b x \u2208 R n \u524d\u51e6\u7406 \u4e88\u6e2c\u5b50\u4fee\u6b63\u5b50 \u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u306b\u5bfe\u3059\u308bKKT\u6761\u4ef6\u306f\u4ee5\u4e0b Q x + c \u2212 A \u02c9 T \u03bb \u2212 \\begin{array}{l} Qx+c -\\bar{A}^T\\lambda - \\end{array} Q x + c \u2212 A \u02c9 T \u03bb \u2212 \u200b KKT\u6761\u4ef6\u306b\u3064\u3044\u3066 \u505c\u6b62\u6761\u4ef6 \u5b9f\u884c\u4e0d\u53ef\u80fd\u6027\u306e\u691c\u51fa \u53c2\u8003\u6587\u732e \u4e8c\u6b21\u8a08\u753b\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","title":"\u4e8c\u6b21\u8a08\u753b\u6cd5"},{"location":"tech_note/optimize/quadprog/#_1","text":"\u4ee5\u4e0b\u306e\u6700\u9069\u5316\u554f\u984c\u3092\u8003\u3048\u308b min 1 2 x T Q x + c T x s.t. A x = b , A e q x \u2264 b e q , l x \u2264 x \u2264 u x x \u2208 R n \\text{min} \\space \\dfrac{1}{2}x^TQx + c^T x\\\\ \\text{s.t.} \\space Ax = b, A_{eq}x \\leq b_{eq}, l_x \\leq x \\leq u_x \\\\ x \\in \\R^n min 2 1 \u200b x T Q x + c T x s.t. A x = b , A e q \u200b x \u2264 b e q \u200b , l x \u200b \u2264 x \u2264 u x \u200b x \u2208 R n","title":"\u4e8c\u6b21\u8a08\u753b\u6cd5"},{"location":"tech_note/optimize/quadprog/#_2","text":"","title":"\u524d\u51e6\u7406"},{"location":"tech_note/optimize/quadprog/#_3","text":"\u4e0e\u3048\u3089\u308c\u305f\u554f\u984c\u306b\u5bfe\u3059\u308bKKT\u6761\u4ef6\u306f\u4ee5\u4e0b Q x + c \u2212 A \u02c9 T \u03bb \u2212 \\begin{array}{l} Qx+c -\\bar{A}^T\\lambda - \\end{array} Q x + c \u2212 A \u02c9 T \u03bb \u2212 \u200b KKT\u6761\u4ef6\u306b\u3064\u3044\u3066","title":"\u4e88\u6e2c\u5b50\u4fee\u6b63\u5b50"},{"location":"tech_note/optimize/quadprog/#_4","text":"","title":"\u505c\u6b62\u6761\u4ef6"},{"location":"tech_note/optimize/quadprog/#_5","text":"","title":"\u5b9f\u884c\u4e0d\u53ef\u80fd\u6027\u306e\u691c\u51fa"},{"location":"tech_note/optimize/quadprog/#_6","text":"\u4e8c\u6b21\u8a08\u753b\u6cd5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/quasi_newton/","text":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u4f7f\u7528\u3057\u305f\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u7528\u305b\u305a\u8fd1\u4f3c\u3057\u305f\u3082\u306e\u3092\u4f7f\u7528\u3057\u3066\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u3053\u306e\u3068\u304d\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u306f\u6b63\u5247\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067BFGS\u516c\u5f0f\u3092\u4f7f\u7528\u3057\u3066\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u66f4\u65b0\u3059\u308b\u3002","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5"},{"location":"tech_note/optimize/quasi_newton/#_1","text":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306f\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u3067\u4f7f\u7528\u3057\u305f\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u4f7f\u7528\u305b\u305a\u8fd1\u4f3c\u3057\u305f\u3082\u306e\u3092\u4f7f\u7528\u3057\u3066\u95a2\u6570\u3092\u6700\u5c0f\u5316\u3059\u308b\u624b\u6cd5\u3067\u3042\u308b\u3002\u3053\u306e\u3068\u304d\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u306f\u6b63\u5247\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067BFGS\u516c\u5f0f\u3092\u4f7f\u7528\u3057\u3066\u8fd1\u4f3c\u30d8\u30c3\u30b7\u30a2\u30f3\u3092\u66f4\u65b0\u3059\u308b\u3002","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5"},{"location":"tech_note/optimize/scalar_opt/","text":"\u30b9\u30ab\u30e9\u30fc\u6700\u9069\u5316 \u56f2\u3044\u8fbc\u307f\u6cd5 \u30a2\u30eb\u30df\u30db\u6761\u4ef6 \u30a6\u30eb\u30d5\u6761\u4ef6 \u9ec4\u91d1\u63a2\u7d22\u6cd5","title":"\u30b9\u30ab\u30e9\u30fc\u6700\u9069\u5316"},{"location":"tech_note/optimize/scalar_opt/#_1","text":"","title":"\u30b9\u30ab\u30e9\u30fc\u6700\u9069\u5316"},{"location":"tech_note/optimize/scalar_opt/#_2","text":"","title":"\u56f2\u3044\u8fbc\u307f\u6cd5"},{"location":"tech_note/optimize/scalar_opt/#_3","text":"","title":"\u30a2\u30eb\u30df\u30db\u6761\u4ef6"},{"location":"tech_note/optimize/scalar_opt/#_4","text":"","title":"\u30a6\u30eb\u30d5\u6761\u4ef6"},{"location":"tech_note/optimize/scalar_opt/#_5","text":"","title":"\u9ec4\u91d1\u63a2\u7d22\u6cd5"},{"location":"tech_note/optimize/sqp/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5) NLP\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0 QP\u3078\u306e\u8fd1\u4f3c\u3068\u305d\u306e\u89e3\u6cd5\u306b\u3088\u3063\u3066\u3044\u304f\u3064\u304b\u306e\u7a2e\u985e\u306b\u5206\u304b\u308c\u308b \u3053\u3053\u3067\u306f\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u3082\u306e\u3068SLSQP\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 \u307e\u305a\u306f\u7d14\u7c8b\u306aSQP\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b\u3002\u4e0e\u3048\u3089\u308c\u308b\u554f\u984c\u306f\u4ee5\u4e0b\u306e\u5f62\u5f0f\u3067\u3042\u308b Todo \\text{Todo} Todo \u30b5\u30d6\u554f\u984c\u3068\u3057\u3066QP\u306b\u8fd1\u4f3c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u5f62\u3092\u53d6\u308b Todo \\text{Todo} Todo \u3053\u3053\u3067\u4efb\u610f\u306e\u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30b7\u30a2\u30f3 H H H \u306b\u3064\u3044\u3066\u534a\u6b63\u5b9a\u5024\u6027\u304c\u4fdd\u8a3c\u3055\u308c\u306a\u3044\u305f\u3081\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5\u306b\u3088\u308a\u8fd1\u4f3c\u3057\u305f\u884c\u5217\u306b\u7f6e\u304d\u63db\u3048\u308b\u3002 Todo \\text{Todo} Todo Note \u3053\u3053\u3067\u4efb\u610f\u306e\u76ee\u7684\u95a2\u6570\u306b\u5bfe\u3057\u3066BFGS\u6cd5\u3092\u9069\u7528\u3059\u308b\u3068\u6b63\u5b9a\u5024\u6027\u304c\u4fdd\u8a3c\u3055\u308c\u306a\u3044\u305f\u3081\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5\u3092\u4f7f\u7528\u3059\u308b \u3053\u306e\u554f\u984c\u306b\u3064\u3044\u3066\u5909\u6570\u3092\u898b\u308b\u3068 \u0394 x \\Delta x \u0394 x , \u0394 s \\Delta s \u0394 s , \u0394 \u03bb \\Delta \\lambda \u0394 \u03bb ,\u3067\u3042\u308b\u3002\u3053\u306e\u5909\u6570\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u308b\u3068\u4ee5\u4e0b\u306e\u9023\u7acb\u65b9\u7a0b\u5f0f\u304c\u3067\u304d\u308b\u3002 Note \u3053\u3053\u3067 f ( x ) f(x) f ( x ) \u306f\u5b9a\u6570\u3068\u3057\u3066\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\u7701\u7565\u3057\u3066\u3044\u308b \u3053\u308c\u3067\u63a2\u7d22\u65b9\u5411\u3068\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u5b9a\u6570\u3068\u30b9\u30e9\u30c3\u30af\u5909\u6570\u304c\u6c42\u307e\u308b\u306e\u3067\u63a2\u7d22\u65b9\u5411\u306b\u76f4\u7dda\u63a2\u7d22\u3001BFGS\u306b\u3088\u308bB\u884c\u5217\u306e\u66f4\u65b0\u3092\u884c\u3046\u64cd\u4f5c\u3092 \u0394 x \\Delta x \u0394 x \u304c\u5341\u5206\u306b\u5c0f\u3055\u304f\u306a\u308b\u307e\u3067\u884c\u3046\u3002 SLSQP SLSQP\u3067\u306f\u30b5\u30d6\u554f\u984c\u3067\u3042\u308b\u4ee5\u4e0b\u306eQP\u3092\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306b\u3088\u3063\u3066\u89e3\u3044\u3066\u3044\u308b\u3002 B\u884c\u5217\u3092\u4ee5\u4e0b\u306e\u7528\u306b\u5206\u89e3\u3059\u308b B = L D L T B = LDL^T B = L D L T \u5206\u89e3\u3057\u305f\u884c\u5217\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u3092\u89e3\u304f min \u2223 \u2223 \u2223 \u2223 \\text{min} || || min \u2223\u2223\u2223\u2223 Kraft, D. A software package for sequential quadratic programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace Center -- Institute for Flight Mechanics, Koln, Germany. \u53c2\u8003\u6587\u732e \u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316 SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066 fmincon SQP \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 \u57fa\u672c\u7684\u306a\u5b9f\u88c5\u306f\u3053\u306e\u30da\u30fc\u30b8\u306efmincon \u30a2\u30af\u30c6\u30a3\u30d6 \u30bb\u30c3\u30c8 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u53c2\u7167","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)"},{"location":"tech_note/optimize/sqp/#sqp","text":"NLP\u306b\u5bfe\u3057\u3066\u73fe\u5728\u306e\u89e3\u4ed8\u8fd1\u3067\u554f\u984c\u3092\u4e8c\u6b21\u8fd1\u4f3c\u3057\u3001\u305d\u306e\u4e8c\u6b21\u8a08\u753b\u554f\u984c\u306e\u89e3\u3092\u63a2\u7d22\u65b9\u5411\u3068\u3057\u3066\u53cd\u5fa9\u8a08\u7b97\u3092\u884c\u3046\u624b\u6cd5\u306e\u7dcf\u79f0 QP\u3078\u306e\u8fd1\u4f3c\u3068\u305d\u306e\u89e3\u6cd5\u306b\u3088\u3063\u3066\u3044\u304f\u3064\u304b\u306e\u7a2e\u985e\u306b\u5206\u304b\u308c\u308b \u3053\u3053\u3067\u306f\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5\u306b\u3088\u308b\u3082\u306e\u3068SLSQP\u306b\u3064\u3044\u3066\u89e3\u8aac\u3059\u308b","title":"SQP(\u9010\u6b21\u4e8c\u6b21\u8a08\u753b\u6cd5)"},{"location":"tech_note/optimize/sqp/#_1","text":"\u307e\u305a\u306f\u7d14\u7c8b\u306aSQP\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b\u3002\u4e0e\u3048\u3089\u308c\u308b\u554f\u984c\u306f\u4ee5\u4e0b\u306e\u5f62\u5f0f\u3067\u3042\u308b Todo \\text{Todo} Todo \u30b5\u30d6\u554f\u984c\u3068\u3057\u3066QP\u306b\u8fd1\u4f3c\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u5f62\u3092\u53d6\u308b Todo \\text{Todo} Todo \u3053\u3053\u3067\u4efb\u610f\u306e\u76ee\u7684\u95a2\u6570\u306e\u30d8\u30c3\u30b7\u30a2\u30f3 H H H \u306b\u3064\u3044\u3066\u534a\u6b63\u5b9a\u5024\u6027\u304c\u4fdd\u8a3c\u3055\u308c\u306a\u3044\u305f\u3081\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5\u306b\u3088\u308a\u8fd1\u4f3c\u3057\u305f\u884c\u5217\u306b\u7f6e\u304d\u63db\u3048\u308b\u3002 Todo \\text{Todo} Todo Note \u3053\u3053\u3067\u4efb\u610f\u306e\u76ee\u7684\u95a2\u6570\u306b\u5bfe\u3057\u3066BFGS\u6cd5\u3092\u9069\u7528\u3059\u308b\u3068\u6b63\u5b9a\u5024\u6027\u304c\u4fdd\u8a3c\u3055\u308c\u306a\u3044\u305f\u3081\u30d1\u30a6\u30a8\u30eb\u306e\u4fee\u6b63BFGS\u6cd5\u3092\u4f7f\u7528\u3059\u308b \u3053\u306e\u554f\u984c\u306b\u3064\u3044\u3066\u5909\u6570\u3092\u898b\u308b\u3068 \u0394 x \\Delta x \u0394 x , \u0394 s \\Delta s \u0394 s , \u0394 \u03bb \\Delta \\lambda \u0394 \u03bb ,\u3067\u3042\u308b\u3002\u3053\u306e\u5909\u6570\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u308b\u3068\u4ee5\u4e0b\u306e\u9023\u7acb\u65b9\u7a0b\u5f0f\u304c\u3067\u304d\u308b\u3002 Note \u3053\u3053\u3067 f ( x ) f(x) f ( x ) \u306f\u5b9a\u6570\u3068\u3057\u3066\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u3067\u7701\u7565\u3057\u3066\u3044\u308b \u3053\u308c\u3067\u63a2\u7d22\u65b9\u5411\u3068\u30e9\u30b0\u30e9\u30f3\u30b8\u30e5\u5b9a\u6570\u3068\u30b9\u30e9\u30c3\u30af\u5909\u6570\u304c\u6c42\u307e\u308b\u306e\u3067\u63a2\u7d22\u65b9\u5411\u306b\u76f4\u7dda\u63a2\u7d22\u3001BFGS\u306b\u3088\u308bB\u884c\u5217\u306e\u66f4\u65b0\u3092\u884c\u3046\u64cd\u4f5c\u3092 \u0394 x \\Delta x \u0394 x \u304c\u5341\u5206\u306b\u5c0f\u3055\u304f\u306a\u308b\u307e\u3067\u884c\u3046\u3002","title":"\u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5"},{"location":"tech_note/optimize/sqp/#slsqp","text":"SLSQP\u3067\u306f\u30b5\u30d6\u554f\u984c\u3067\u3042\u308b\u4ee5\u4e0b\u306eQP\u3092\u5236\u7d04\u4ed8\u304d\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u306b\u3088\u3063\u3066\u89e3\u3044\u3066\u3044\u308b\u3002 B\u884c\u5217\u3092\u4ee5\u4e0b\u306e\u7528\u306b\u5206\u89e3\u3059\u308b B = L D L T B = LDL^T B = L D L T \u5206\u89e3\u3057\u305f\u884c\u5217\u3092\u4f7f\u3063\u3066\u4ee5\u4e0b\u306e\u6700\u5c0f\u4e8c\u4e57\u6cd5\u3092\u89e3\u304f min \u2223 \u2223 \u2223 \u2223 \\text{min} || || min \u2223\u2223\u2223\u2223 Kraft, D. A software package for sequential quadratic programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace Center -- Institute for Flight Mechanics, Koln, Germany.","title":"SLSQP"},{"location":"tech_note/optimize/sqp/#_2","text":"\u3057\u3063\u304b\u308a\u5b66\u3076\u6570\u7406\u6700\u9069\u5316 SQP\u3068SLSQP\u306e\u9055\u3044\u306b\u3064\u3044\u3066 fmincon SQP \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 \u57fa\u672c\u7684\u306a\u5b9f\u88c5\u306f\u3053\u306e\u30da\u30fc\u30b8\u306efmincon \u30a2\u30af\u30c6\u30a3\u30d6 \u30bb\u30c3\u30c8 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3092\u53c2\u7167","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/optimize/tolerances_and_stopping/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u8a31\u5bb9\u8aa4\u5dee\u30fb\u505c\u6b62\u6761\u4ef6 \u6700\u9069\u5316\u3092\u884c\u3046\u4e0a\u3067\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u505c\u6b62\u6761\u4ef6\u3092\u5224\u65ad\u3059\u308b\u305f\u3081\u306b\u8a31\u5bb9\u8aa4\u5dee\u3092\u8a2d\u5b9a\u3059\u308b\u3002 \u3053\u306e\u8a31\u5bb9\u8aa4\u5dee\u306b\u306f\u6700\u9069\u6027\u30fb\u95a2\u6570\u5024\u30fb\u30b9\u30c6\u30c3\u30d7\u30fb\u5236\u7d04\u306b\u5bfe\u3057\u3066\u76e3\u8996\u3055\u308c\u3001\u307e\u305f\u3001\u305d\u308c\u305e\u308c\u306e\u8a31\u5bb9\u8aa4\u5dee\u306f\u554f\u984c\u8a2d\u5b9a\u306b\u3088\u3063\u3066\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u304b\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u5316\u304c\u7570\u306a\u308b\u3002 \u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u3068\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee \u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee \u5404\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3067\u8a55\u4fa1\u3055\u308c\u305f\u5024\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408 ( f ( x i + 1 ) \u2212 f ( x i ) ) < A b s T o l e r a n c e (f(x_{i+1}) - f(x_i)) < AbsTolerance ( f ( x i + 1 \u200b ) \u2212 f ( x i \u200b )) < A b s T o l er an ce \u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408 \u2223 x i + 1 \u2212 x i \u2223 < A b s T o l e r a n c e |x_{i+1} - x_{i}| < AbsTolerance \u2223 x i + 1 \u200b \u2212 x i \u200b \u2223 < A b s T o l er an ce \u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee \u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308b\u5024\u306e\u5909\u5316\u91cf\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408 ( f ( x i + 1 ) \u2212 f ( x i ) ) < R e l T o l e r a n c e \u00d7 ( 1 + f ( x i ) ) (f(x_{i+1}) - f(x_i)) < RelTolerance \\times (1 + f(x_i)) ( f ( x i + 1 \u200b ) \u2212 f ( x i \u200b )) < R e lT o l er an ce \u00d7 ( 1 + f ( x i \u200b )) \u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408 \u2223 x i + 1 \u2212 x i \u2223 < R e l T o l e r a n c e \u00d7 ( 1 + \u2223 x i \u2223 ) |x_{i+1} - x_{i}| < RelTolerance \\times (1 + |x_i|) \u2223 x i + 1 \u200b \u2212 x i \u200b \u2223 < R e lT o l er an ce \u00d7 ( 1 + \u2223 x i \u200b \u2223 ) \u554f\u984c \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 \u6700\u9069\u6027\u306e\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u8a31\u5bb9\u8aa4\u5dee \u30b9\u30c6\u30c3\u30d7\u306e\u8a31\u5bb9\u8aa4\u5dee \u5236\u7d04\u306e\u8a31\u5bb9\u8aa4\u5dee \u5099\u8003 \u5236\u7d04\u306a\u3057\u975e\u7dda\u5f62\u6700\u9069\u5316 (fminsearch) - Abs Abs - \u540c\u6642\u306b\u6e80\u305f\u3057\u305f\u6642\u7d42\u4e86\u3068\u3059\u308b \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Rel - Rel - \u5236\u7d04\u4ed8\u304d\u975e\u7dda\u5f62\u6700\u9069\u5316 \u5185\u70b9\u6cd5 Rel - Rel Rel \u6709\u52b9\u5236\u7d04\u6cd5 Abs Abs Abs Abs \u9010\u6b21\u4e8c\u6b21\u6700\u9069\u5316(SQP) Rel - Rel Rel Abs: \u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee Rel: \u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee \u53c2\u8003\u6587\u732e \u8a31\u5bb9\u8aa4\u5dee\u3068\u505c\u6b62\u6761\u4ef6 \u8a31\u5bb9\u8aa4\u5dee\u306e\u8a73\u7d30","title":"\u6700\u9069\u5316\u306e\u53ce\u675f\u5224\u5b9a"},{"location":"tech_note/optimize/tolerances_and_stopping/#_1","text":"\u6700\u9069\u5316\u3092\u884c\u3046\u4e0a\u3067\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306e\u505c\u6b62\u6761\u4ef6\u3092\u5224\u65ad\u3059\u308b\u305f\u3081\u306b\u8a31\u5bb9\u8aa4\u5dee\u3092\u8a2d\u5b9a\u3059\u308b\u3002 \u3053\u306e\u8a31\u5bb9\u8aa4\u5dee\u306b\u306f\u6700\u9069\u6027\u30fb\u95a2\u6570\u5024\u30fb\u30b9\u30c6\u30c3\u30d7\u30fb\u5236\u7d04\u306b\u5bfe\u3057\u3066\u76e3\u8996\u3055\u308c\u3001\u307e\u305f\u3001\u305d\u308c\u305e\u308c\u306e\u8a31\u5bb9\u8aa4\u5dee\u306f\u554f\u984c\u8a2d\u5b9a\u306b\u3088\u3063\u3066\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u304b\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u5316\u304c\u7570\u306a\u308b\u3002","title":"\u8a31\u5bb9\u8aa4\u5dee\u30fb\u505c\u6b62\u6761\u4ef6"},{"location":"tech_note/optimize/tolerances_and_stopping/#_2","text":"","title":"\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee\u3068\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee"},{"location":"tech_note/optimize/tolerances_and_stopping/#_3","text":"\u5404\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u3067\u8a55\u4fa1\u3055\u308c\u305f\u5024\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408 ( f ( x i + 1 ) \u2212 f ( x i ) ) < A b s T o l e r a n c e (f(x_{i+1}) - f(x_i)) < AbsTolerance ( f ( x i + 1 \u200b ) \u2212 f ( x i \u200b )) < A b s T o l er an ce \u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408 \u2223 x i + 1 \u2212 x i \u2223 < A b s T o l e r a n c e |x_{i+1} - x_{i}| < AbsTolerance \u2223 x i + 1 \u200b \u2212 x i \u200b \u2223 < A b s T o l er an ce","title":"\u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee"},{"location":"tech_note/optimize/tolerances_and_stopping/#_4","text":"\u30a4\u30c6\u30ec\u30fc\u30b7\u30e7\u30f3\u306b\u3088\u308b\u5024\u306e\u5909\u5316\u91cf\u306b\u5bfe\u3057\u3066\u8ab2\u3055\u308c\u308b\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u5834\u5408 ( f ( x i + 1 ) \u2212 f ( x i ) ) < R e l T o l e r a n c e \u00d7 ( 1 + f ( x i ) ) (f(x_{i+1}) - f(x_i)) < RelTolerance \\times (1 + f(x_i)) ( f ( x i + 1 \u200b ) \u2212 f ( x i \u200b )) < R e lT o l er an ce \u00d7 ( 1 + f ( x i \u200b )) \u30b9\u30c6\u30c3\u30d7\u306e\u5834\u5408 \u2223 x i + 1 \u2212 x i \u2223 < R e l T o l e r a n c e \u00d7 ( 1 + \u2223 x i \u2223 ) |x_{i+1} - x_{i}| < RelTolerance \\times (1 + |x_i|) \u2223 x i + 1 \u200b \u2212 x i \u200b \u2223 < R e lT o l er an ce \u00d7 ( 1 + \u2223 x i \u200b \u2223 ) \u554f\u984c \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 \u6700\u9069\u6027\u306e\u8a31\u5bb9\u8aa4\u5dee \u95a2\u6570\u8a55\u4fa1\u5024\u306e\u8a31\u5bb9\u8aa4\u5dee \u30b9\u30c6\u30c3\u30d7\u306e\u8a31\u5bb9\u8aa4\u5dee \u5236\u7d04\u306e\u8a31\u5bb9\u8aa4\u5dee \u5099\u8003 \u5236\u7d04\u306a\u3057\u975e\u7dda\u5f62\u6700\u9069\u5316 (fminsearch) - Abs Abs - \u540c\u6642\u306b\u6e80\u305f\u3057\u305f\u6642\u7d42\u4e86\u3068\u3059\u308b \u6e96\u30cb\u30e5\u30fc\u30c8\u30f3\u6cd5 Rel - Rel - \u5236\u7d04\u4ed8\u304d\u975e\u7dda\u5f62\u6700\u9069\u5316 \u5185\u70b9\u6cd5 Rel - Rel Rel \u6709\u52b9\u5236\u7d04\u6cd5 Abs Abs Abs Abs \u9010\u6b21\u4e8c\u6b21\u6700\u9069\u5316(SQP) Rel - Rel Rel Abs: \u7d76\u5bfe\u8a31\u5bb9\u8aa4\u5dee Rel: \u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee","title":"\u76f8\u5bfe\u8a31\u5bb9\u8aa4\u5dee"},{"location":"tech_note/optimize/tolerances_and_stopping/#_5","text":"\u8a31\u5bb9\u8aa4\u5dee\u3068\u505c\u6b62\u6761\u4ef6 \u8a31\u5bb9\u8aa4\u5dee\u306e\u8a73\u7d30","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/path_planning/a_star/","text":"A* A*\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u30b0\u30e9\u30d5\u63a2\u7d22\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u4e00\u7a2e\u3067\u3001\u30b0\u30ea\u30c3\u30c9\u72b6\u306b\u533a\u5207\u3089\u308c\u305f\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u304a\u3051\u308b\u7d4c\u8def\u8a08\u753b\u3067\u3088\u304f\u7528\u3044\u3089\u308c\u3066\u3044\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002 \u53c2\u8003\u6587\u732e A* \u3088\u304f\u308f\u304b\u308bA*(A-star)\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 (Unity2D\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3064\u304d)","title":"A*"},{"location":"tech_note/path_planning/a_star/#a","text":"A*\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306f\u30b0\u30e9\u30d5\u63a2\u7d22\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306e\u4e00\u7a2e\u3067\u3001\u30b0\u30ea\u30c3\u30c9\u72b6\u306b\u533a\u5207\u3089\u308c\u305f\u30d5\u30a3\u30fc\u30eb\u30c9\u306b\u304a\u3051\u308b\u7d4c\u8def\u8a08\u753b\u3067\u3088\u304f\u7528\u3044\u3089\u308c\u3066\u3044\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002","title":"A*"},{"location":"tech_note/path_planning/a_star/#_1","text":"A* \u3088\u304f\u308f\u304b\u308bA*(A-star)\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 (Unity2D\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3064\u304d)","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/path_planning/dubins_path/","text":"Dubins\u66f2\u7dda Dubins\u30d1\u30b9\u306f2\u6b21\u5143\u7a7a\u9593\u4e0a\u3067\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u5411\u304d\u3092\u4e0e\u3048\u308b\u3068\u3001\u59cb\u70b9\u3068\u7d42\u70b9\u3092\u76f4\u9032\u304b\u4e00\u5b9a\u306e\u66f2\u7387\u306e\u30ab\u30fc\u30d6\u304b\u3067\u6700\u77ed\u3068\u306a\u308b\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002 \u30a2\u30eb\u30b4\u30ea\u30ba\u30e0 Dubins\u30d1\u30b9\u3067\u306f\u76f4\u9032\u3092S\u3001\u53f3\u56de\u308a\u306e\u7d4c\u8def\u3092R\u3001\u5de6\u56de\u308a\u306e\u7d4c\u8def\u3092L\u3068\u3057\u3066\u6587\u5b57\u306e\u7d44\u307f\u5408\u308f\u305b\u3067\u3069\u3046\u3044\u3046\u5f62\u3092\u7d4c\u8def\u5316\u3092\u8868\u3059\u3002\u4f8b\u3048\u3070\u76f4\u9032\u3057\u305f\u5f8c\u306b\u53f3\u56de\u308a\u3059\u308b\u3088\u3046\u306a\u7d4c\u8def\u306fSR\u3068\u306a\u308b\u3002 Dubins\u30d1\u30b9\u3067\u306f\u4e8c\u70b9\u9593\u3092\u7d50\u3076\u7d4c\u8def\u306f3\u533a\u9593\u304b\u3089\u306a\u308b\u7d4c\u8def\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3057\u3066\u3044\u308b\u3002\u3055\u3089\u306b\u306f6\u7a2e\u985e\u306e\u7d4c\u8def\u306e\u3069\u308c\u304b\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u307e\u3067\u8a3c\u660e\u3057\u3066\u3044\u308b\u3002 \u5177\u4f53\u7684\u306b\u306f RLR LRL LSR LSL RSL RSR \u306e6\u7a2e\u985e\u3092\u7dcf\u5f53\u308a\u3059\u308c\u3070\u305d\u306e\u3046\u3061\u3069\u308c\u304b\u304c\u6700\u77ed\u3067\u5230\u9054\u3067\u304d\u308b\u7d4c\u8def\u3068\u306a\u308b\u3002 \u53c2\u8003\u6587\u732e Python\u306b\u3088\u308bDubins\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0","title":"Dubins\u66f2\u7dda"},{"location":"tech_note/path_planning/dubins_path/#dubins","text":"Dubins\u30d1\u30b9\u306f2\u6b21\u5143\u7a7a\u9593\u4e0a\u3067\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u5411\u304d\u3092\u4e0e\u3048\u308b\u3068\u3001\u59cb\u70b9\u3068\u7d42\u70b9\u3092\u76f4\u9032\u304b\u4e00\u5b9a\u306e\u66f2\u7387\u306e\u30ab\u30fc\u30d6\u304b\u3067\u6700\u77ed\u3068\u306a\u308b\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067\u3042\u308b\u3002","title":"Dubins\u66f2\u7dda"},{"location":"tech_note/path_planning/dubins_path/#_1","text":"Dubins\u30d1\u30b9\u3067\u306f\u76f4\u9032\u3092S\u3001\u53f3\u56de\u308a\u306e\u7d4c\u8def\u3092R\u3001\u5de6\u56de\u308a\u306e\u7d4c\u8def\u3092L\u3068\u3057\u3066\u6587\u5b57\u306e\u7d44\u307f\u5408\u308f\u305b\u3067\u3069\u3046\u3044\u3046\u5f62\u3092\u7d4c\u8def\u5316\u3092\u8868\u3059\u3002\u4f8b\u3048\u3070\u76f4\u9032\u3057\u305f\u5f8c\u306b\u53f3\u56de\u308a\u3059\u308b\u3088\u3046\u306a\u7d4c\u8def\u306fSR\u3068\u306a\u308b\u3002 Dubins\u30d1\u30b9\u3067\u306f\u4e8c\u70b9\u9593\u3092\u7d50\u3076\u7d4c\u8def\u306f3\u533a\u9593\u304b\u3089\u306a\u308b\u7d4c\u8def\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3057\u3066\u3044\u308b\u3002\u3055\u3089\u306b\u306f6\u7a2e\u985e\u306e\u7d4c\u8def\u306e\u3069\u308c\u304b\u3067\u5230\u9054\u3067\u304d\u308b\u3068\u3044\u3046\u3053\u3068\u307e\u3067\u8a3c\u660e\u3057\u3066\u3044\u308b\u3002 \u5177\u4f53\u7684\u306b\u306f RLR LRL LSR LSL RSL RSR \u306e6\u7a2e\u985e\u3092\u7dcf\u5f53\u308a\u3059\u308c\u3070\u305d\u306e\u3046\u3061\u3069\u308c\u304b\u304c\u6700\u77ed\u3067\u5230\u9054\u3067\u304d\u308b\u7d4c\u8def\u3068\u306a\u308b\u3002","title":"\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0"},{"location":"tech_note/path_planning/dubins_path/#_2","text":"Python\u306b\u3088\u308bDubins\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/path_planning/dwa/","text":"DWA(Dynamic Window Approach) \u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u306f\u591a\u304f\u306e\u6d3e\u751f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304c\u5b58\u5728\u3059\u308b \u53c2\u8003\u6587\u732e DWA\uff08Dynamic Window Approach\uff09\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u3066\u307f\u305f Dynamic Window Approach\u3092\u5229\u7528\u3057\u305fMotion planning\u306eMATLAB, Python \u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0","title":"DWA"},{"location":"tech_note/path_planning/dwa/#dwadynamic-window-approach","text":"\u3053\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u306f\u591a\u304f\u306e\u6d3e\u751f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304c\u5b58\u5728\u3059\u308b","title":"DWA(Dynamic Window Approach)"},{"location":"tech_note/path_planning/dwa/#_1","text":"DWA\uff08Dynamic Window Approach\uff09\u306b\u3064\u3044\u3066\u307e\u3068\u3081\u3066\u307f\u305f Dynamic Window Approach\u3092\u5229\u7528\u3057\u305fMotion planning\u306eMATLAB, Python \u30b5\u30f3\u30d7\u30eb\u30d7\u30ed\u30b0\u30e9\u30e0","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/path_planning/frenet_path/","text":"\u30d5\u30ec\u30cd\u5ea7\u6a19\u7cfb \u53c2\u8003\u6587\u732e","title":"\u30d5\u30ec\u30cd\u5ea7\u6a19\u7cfb"},{"location":"tech_note/path_planning/frenet_path/#_1","text":"","title":"\u30d5\u30ec\u30cd\u5ea7\u6a19\u7cfb"},{"location":"tech_note/path_planning/frenet_path/#_2","text":"","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/path_planning/rvo/","text":"RVO \u53c2\u8003\u6587\u732e RVO\u306b\u3088\u308b\u885d\u7a81\u56de\u907f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","title":"RVO"},{"location":"tech_note/path_planning/rvo/#rvo","text":"","title":"RVO"},{"location":"tech_note/path_planning/rvo/#_1","text":"RVO\u306b\u3088\u308b\u885d\u7a81\u56de\u907f\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/path_planning/spline/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda \u88dc\u9593\u66f2\u7dda\u306e\u7a2e\u985e \u30ed\u30dc\u30c3\u30c8\u306e\u79fb\u52d5\u3084\u30a2\u30af\u30c1\u30e5\u30a8\u30fc\u30bf\u306e\u8ecc\u9053\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u901a\u904e\u70b9\u3060\u3051\u3092\u6307\u5b9a\u3057\u3066\u66f2\u7dda\u7684\u306b\u88dc\u9593\u3055\u305b\u3066\u8ecc\u9053\u3092\u751f\u6210\u3059\u308b\u3002\u88dc\u9593\u66f2\u7dda\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3082\u306e\u304c\u3042\u308b Bezier\u66f2\u7dda(\u30d9\u30b8\u30a8\u66f2\u7dda) Hermite\u66f2\u7dda(\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda) Catmull-Rom\u66f2\u7dda(\u30ad\u30e3\u30c3\u30c8\u30e0\u30eb-\u30ed\u30e0\u66f2\u7dda?) Cubic-Spline\u66f2\u7dda(3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda) \u3053\u306e\u8a18\u4e8b\u3067\u306f\u4e8c\u6b21\u5143\u5e73\u9762\u4e0a\u3067\u306e\u66f2\u7dda\u306b\u3064\u3044\u3066\u8ff0\u3079\u3066\u3044\u304f Bezier\u66f2\u7dda N\u500b\u306e\u5236\u5fa1\u70b9\u3092\u4f7f\u3063\u3066\u66f2\u7dda\u3092\u4f5c\u308b\u7279\u5fb4\u3068\u3057\u3066 \u4e00\u822c\u306b0\u70b9\u76ee, N-1\u70b9\u76ee\u3057\u304b\u901a\u904e\u3057\u306a\u3044 \u3088\u3063\u3066\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3068\u6349\u3048\u3066\u3082\u307b\u3068\u3093\u3069\u9593\u9055\u3044\u306a\u3044\u3060\u308d\u3046 N\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda N\u500b\u306e\u5236\u5fa1\u70b9\u304b\u3089\u306a\u308b\u30d9\u30b8\u30a8\u66f2\u7dda\u3067\u3042\u308bN\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u6b21\u5f0f\u3067\u8868\u3055\u308c\u308b P ( t ) = \u2211 i = 0 N \u2212 1 B i J N \u2212 1 , i ( t ) P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) P ( t ) = i = 0 \u2211 N \u2212 1 \u200b B i \u200b J N \u2212 1 , i \u200b ( t ) \u3053\u3053\u3067 B n Bn B n : \u5236\u5fa1\u70b9\u306e\u4e8c\u6b21\u5143\u5ea7\u6a19( n n n = 0, 1\u22ef N N N \u2212 1) J N JN J N \u2212 1, i i i ( t t t ): \u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570 \u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570 J n , i ( t ) = ( n i ) t i ( 1 \u2212 t ) n \u2212 i J_{n, i}(t) = \\left(\\begin{array}{c}n\\\\i\\end{array} \\right)t^i(1-t)^{n-i} J n , i \u200b ( t ) = ( n i \u200b ) t i ( 1 \u2212 t ) n \u2212 i \u3053\u3053\u3067\u4e8c\u9805\u4fc2\u6570 ( n i ) = n ! i ! ( n \u2212 i ) ! \\left(\\begin{array}{c}n\\\\i\\end{array} \\right) = \\frac{n!}{i!(n-i)!} ( n i \u200b ) = i ! ( n \u2212 i )! n ! \u200b \u4e8c\u9805\u4fc2\u6570\u304c\u3071\u3063\u3068\u51fa\u3066\u3053\u306a\u3044\u3068\u304d\u306f \u30d1\u30b9\u30ab\u30eb\u306e\u4e09\u89d2\u5f62 \u3092\u8003\u3048\u308b\u3068\u65e9\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002 n n n \u3068 i i i \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u4e0a\u304b\u3089 n +1\u6bb5\u76ee\u306e(\u5de6\u304b\u3089) i \u2005+\u20051\u500b\u76ee\u304c\u4fc2\u6570\u306b\u306a\u308b \u4ed6\u306e\u66f2\u7dda\u3068\u306e\u6bd4\u8f03\u306e\u305f\u3081\u306bN=4\u3068\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u306e\u3067N=4\u306b\u3064\u3044\u3066\u66f8\u304d\u4e0b\u3059\u3068\u4fc2\u6570\u306f J 3 , 0 ( t ) = ( 1 \u2212 t ) 3 J 3 , 1 ( t ) = 3 ( 1 \u2212 t ) 2 t J 3 , 2 ( t ) = 3 ( 1 \u2212 t ) t 2 J 3 , 3 ( t ) = t 3 \\begin{array}{l} J_{3, 0}(t) = (1-t)^3\\\\ J_{3, 1}(t) = 3(1-t)^2t\\\\ J_{3, 2}(t) = 3(1-t)t^2\\\\ J_{3, 3}(t) = t^3 \\end{array} J 3 , 0 \u200b ( t ) = ( 1 \u2212 t ) 3 J 3 , 1 \u200b ( t ) = 3 ( 1 \u2212 t ) 2 t J 3 , 2 \u200b ( t ) = 3 ( 1 \u2212 t ) t 2 J 3 , 3 \u200b ( t ) = t 3 \u200b \u3088\u3063\u3066\u30d9\u30b8\u30a8\u66f2\u7dda P ( t ) = ( 1 \u2212 t ) 3 B 0 + 3 ( 1 \u2212 t ) 2 t B 1 + 3 ( 1 \u2212 t ) t 2 B 2 + t 3 B 3 t \u2208 [ 0 , 1 ] P(t)=(1-t)^3 B_0 + 3(1-t)^2t B_1 + 3(1-t)t^2 B_2 + t^3 B_3 \\quad \\quad t \\in [0, 1] P ( t ) = ( 1 \u2212 t ) 3 B 0 \u200b + 3 ( 1 \u2212 t ) 2 t B 1 \u200b + 3 ( 1 \u2212 t ) t 2 B 2 \u200b + t 3 B 3 \u200b t \u2208 [ 0 , 1 ] Hermite\u66f2\u7dda \u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u540c\u69d8\u4e8c\u70b9\u9593\u306e\u66f2\u7dda\u88dc\u9593\u6cd5\u3067\u3042\u308b\u3002\u7279\u5fb4\u3068\u3057\u3066 \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u6307\u5b9a\u3059\u308b \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u3092\u305d\u308c\u305e\u308c\u6b21\u306e\u3088\u3046\u306b\u7f6e\u304f P 0,\u2006 P 1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19 v 0,\u2006 v 1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb (\u3044\u305a\u308c\u3082\u4e8c\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b) 3\u6b21\u5f0f\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7f6e\u304f f x ( t ) = a x t 3 + b x t 2 + c x t + d x f y ( t ) = a y t 3 + b y t 2 + c y t + d y t \u2208 [ 0 , 1 ] \\begin{array}{l} f_x(t) = a_x t^3 + b_x t^2 + c_x t + d_x\\\\ f_y(t) = a_y t^3 + b_y t^2 + c_y t + d_y \\quad \\quad t \\in [0, 1] \\end{array} f x \u200b ( t ) = a x \u200b t 3 + b x \u200b t 2 + c x \u200b t + d x \u200b f y \u200b ( t ) = a y \u200b t 3 + b y \u200b t 2 + c y \u200b t + d y \u200b t \u2208 [ 0 , 1 ] \u200b \u307e\u305f P 0\u7b49\u306b\u3064\u3044\u3066\u3082 P 0 x ,\u2006 P 0 y \u304c\u5b58\u5728\u3059\u308b \u4eca\u3001x\u3068y\u306b\u3064\u3044\u3066\u64cd\u4f5c\u306f\u540c\u3058\u306a\u306e\u3067\u3053\u3053\u304b\u3089\u306f\u5f0f\u3092\u898b\u3084\u3059\u304f\u3059\u308b\u305f\u3081\u306bxy\u306e\u6dfb\u5b57\u306f\u7701\u7565\u3059\u308b f ( t )\u3092\u5fae\u5206\u3059\u308b\u3068 f ( x ) = a t 3 + b t 2 + c t + d f \u2032 ( x ) = 3 a t 2 + 2 b t + c f(x) = at^3 + bt^2 + ct + d\\\\ f'(x) = 3at^2 + 2bt + c f ( x ) = a t 3 + b t 2 + c t + d f \u2032 ( x ) = 3 a t 2 + 2 b t + c a\u304b\u3089d\u3092\u6c42\u3081\u3066\u3044\u304f\u3002 \u4e0e\u3048\u3089\u308c\u305f\u30d1\u30e9\u30e1\u30fc\u30bf\u3088\u308a f ( 0 ) = P 0 f ( 1 ) = P 1 f \u2032 ( 0 ) = v 0 f \u2032 ( 1 ) = v 1 \\begin{array}{l} f(0) = P_0\\\\ f(1) = P_1\\\\ f'(0) = v_0\\\\ f'(1) = v_1 \\end{array} f ( 0 ) = P 0 \u200b f ( 1 ) = P 1 \u200b f \u2032 ( 0 ) = v 0 \u200b f \u2032 ( 1 ) = v 1 \u200b \u200b \u3088\u3063\u3066t=0\u306b\u7740\u76ee\u3059\u308b\u3068 d = P 0 c = v 0 d = P_0\\\\ c = v_0 d = P 0 \u200b c = v 0 \u200b \u307e\u305ft=1\u306b\u304a\u3044\u3066 f ( 1 ) = a + b + c + d = P 1 \u3088\u308a c = v 0 , d = P 0 \u3092\u4ee3\u5165\u3057\u3066 a + b = P 1 \u2212 P 0 \u2212 v 0 f \u2032 ( 1 ) = 3 a + 2 b + c = v 1 \u3088\u308a c = v 0 \u3092\u4ee3\u5165\u3057\u3066 3 a + 2 b = v 1 \u2212 v 0 \\begin{array}{l} f(1) = a + b + c + d = P_1 \u3088\u308a\\\\ c = v_0, d=P_0\u3092\u4ee3\u5165\u3057\u3066\\\\ a + b = P_1 - P_0 - v_0\\\\ \\\\ f'(1) = 3a + 2b + c = v_1 \u3088\u308a\\\\ c = v_0\u3092\u4ee3\u5165\u3057\u3066\\\\ 3a + 2b = v_1 - v_0 \\end{array} f ( 1 ) = a + b + c + d = P 1 \u200b \u3088\u308a c = v 0 \u200b , d = P 0 \u200b \u3092\u4ee3\u5165\u3057\u3066 a + b = P 1 \u200b \u2212 P 0 \u200b \u2212 v 0 \u200b f \u2032 ( 1 ) = 3 a + 2 b + c = v 1 \u200b \u3088\u308a c = v 0 \u200b \u3092\u4ee3\u5165\u3057\u3066 3 a + 2 b = v 1 \u200b \u2212 v 0 \u200b \u200b \u305d\u308c\u305e\u308c\u306e\u5f0f\u3092\u2460,\u2461\u3068\u3057\u3066\u2461\u22122\u00d7\u2460\u3067a\u3092\u6c42\u3081\u3066\u304b\u3089b\u306b\u3064\u3044\u3066\u3082\u89e3\u304f\u3068 a = 2 P 0 \u2212 2 P 1 + v 0 + v 1 b = \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1 a = 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b b = \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b \u3088\u3063\u3066 a = 2 P 0 \u2212 2 P 1 + v 0 + v 1 b = \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 c = v 0 d = P 0 \\begin{array}{l} a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1\\\\ c = v_0\\\\ d = P_0 \\end{array} a = 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b b = \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b c = v 0 \u200b d = P 0 \u200b \u200b a\u301cd\u3092x,y\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u6c42\u3081\u3066 fx ( t ), fy ( t )\u306b\u4ee3\u5165\u3059\u308b\u3053\u3068\u3067Hermite\u66f2\u7dda\u3092\u63cf\u753b\u3067\u304d\u308b \u30e1\u30e2\u66f8\u304d\u3068\u3057\u3066\u6b8b\u3057\u3066\u304a\u304f\u304ct\u306e\u6b21\u6570\u3067\u306f\u306a\u304f P 0,\u2006 P 1,\u2006 v 0,\u2006 v 1\u306b\u3064\u3044\u3066\u304f\u304f\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b f ( t ) = ( 2 t 3 \u2212 3 t 2 + 1 ) P 0 ( \u2212 2 t 3 + 3 t 2 ) P 1 ( t 3 \u2212 2 t 2 + t ) v 0 ( t 3 \u2212 t 2 ) v 1 \\begin{array}{l} f(t) = \\\\ (2t^3 - 3t^2 + 1)P_0\\\\ (-2t^3 + 3t^2)P_1\\\\ (t^3 -2t^2 + t)v_0\\\\ (t^3 - t^2)v_1\\\\ \\end{array} f ( t ) = ( 2 t 3 \u2212 3 t 2 + 1 ) P 0 \u200b ( \u2212 2 t 3 + 3 t 2 ) P 1 \u200b ( t 3 \u2212 2 t 2 + t ) v 0 \u200b ( t 3 \u2212 t 2 ) v 1 \u200b \u200b Catmull-Rom\u66f2\u7dda \u5b9f\u969b\u554f\u984c\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3060\u3051\u3060\u3068\u8db3\u308a\u306a\u3044\u3053\u3068\u304c\u591a\u3044\u3068\u601d\u3046 \u305d\u3053\u3067Hermite\u66f2\u7dda\u3092\u3064\u306a\u3052\u3066\u4f5c\u3089\u308c\u308bCatmull-Rom\u66f2\u7dda\u3092\u8003\u3048\u308b\u3002\u7279\u5fb4\u306f N\u500b(N > 1)\u306e\u70b9\u3092\u3059\u3079\u3066\u901a\u904e\u3059\u308b\u66f2\u7dda\u3092\u4f5c\u308c\u308b Herimite\u66f2\u7dda\u3067\u4f7f\u3063\u305f\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u5fc5\u8981\u3068\u3057\u306a\u3044 (\u672c\u5f53\u306fHermite\u66f2\u7dda\u3068\u306f\u5225\u306bCatmull-\u66f2\u7dda\u304c\u3067\u304d\u3066\u540c\u30583\u6b21\u5f0f\u3060\u304b\u3089\u5909\u63db\u3067\u304d\u308b\u3088\u306d\u3001\u306e\u6d41\u308c\u306a\u6c17\u304c\u3059\u308b\u3051\u3069\u6587\u732e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u304b\u3063\u305f) i\u756a\u76ee\u306e\u7d42\u70b9\u3092i+1\u756a\u76ee\u306e\u59cb\u70b9\u306b\u3059\u308b\u3053\u3068\u3067\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u306f\u306a\u308b\u304c\u6ed1\u3089\u304b\u306b\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u3059\u308b\u305f\u3081\u306e\u62d8\u675f\u304c\u5fc5\u8981\u306b\u306a\u308b N\u70b9\u304b\u3089\u306a\u308b\u66f2\u7dda\u306e\u3046\u3061\u7aef\u70b9\u4ee5\u5916\u306e\u88dc\u9593\u306b\u3064\u3044\u3066\u8003\u3048\u308b i\u756a\u76ee\u306e\u70b9\u306b\u304a\u3051\u308b\u901f\u5ea6\u3092\u4e21\u96a3\u306e\u5ea7\u6a19\u304b\u3089\u4f5c\u308b\u3053\u3068\u3067\u6ed1\u3089\u304b\u306b\u3064\u306a\u3050 v i = 1 2 ( P i + 1 \u2212 P i \u2212 1 ) v_i = \\frac{1}{2}(P_{i+1} - P_{i-1}) v i \u200b = 2 1 \u200b ( P i + 1 \u200b \u2212 P i \u2212 1 \u200b ) \u66f2\u7dda\u306e\u7aef\u70b9( i \u2004=\u20040,\u2006 N \u2005\u2212\u20051)\u3067\u306f\u3053\u306e\u5f0f\u304c\u4f7f\u3048\u306a\u3044\u306e\u3067\u81ea\u8eab\u306e\u5ea7\u6a19\u3068\u96a3\u306e\u5ea7\u6a19\u3067\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u4f5c\u308b v 0 = P 1 \u2212 P 0 v N \u2212 1 = P N \u2212 1 \u2212 P N \u2212 2 \\begin{array}{l} v_0 = P_1 - P_0\\\\ v_{N-1} = P_{N-1} - P_{N-2} \\end{array} v 0 \u200b = P 1 \u200b \u2212 P 0 \u200b v N \u2212 1 \u200b = P N \u2212 1 \u200b \u2212 P N \u2212 2 \u200b \u200b tension\u306b\u3064\u3044\u3066 Info Todo \u30d1\u30e9\u30e1\u30fc\u30bf\u533a\u5206\u306b\u3064\u3044\u3066 Info Todo Cubic-Spline\u66f2\u7dda \u81ea\u5206\u304c\u9ad8\u5c02\u30ed\u30dc\u30b3\u30f3\u3067\u53c2\u7167\u8ecc\u9053\u306f\u3053\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3060\u3063\u305f\u3002 \u7279\u5fb4\u3068\u3057\u3066 \u5165\u529b\u306fCatmull-Rom\u3068\u540c\u3058\u901a\u904e\u70b9\u306e\u307f\u3060\u304c\u3088\u308a\u6ed1\u3089\u304b\u3067\u3042\u308b (\u3082\u3057\u304b\u3057\u305f\u3089\u5c11\u3057\u91cd\u3044?) 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3067\u306f\u4ee5\u4e0b\u306e\u6761\u4ef6\u306b\u5f93\u3046\u3088\u3046\u306a\u66f2\u7dda\u3092\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f\u3053\u3068\u306b\u3088\u3063\u3066\u6c42\u3081\u308b S j ( x j ) = y j S j ( x j + 1 ) = S j + 1 ( x j + 1 ) = y j + 1 S j \u2032 ( x j + 1 ) = S j + 1 \u2032 ( x j + 1 ) S j \u2032 \u2032 ( x j + 1 ) = S j + 1 \u2032 \u2032 ( x j + 1 ) S 0 \u2032 ( x 0 ) = S n \u2212 1 \u2032 ( x n ) = 0 \\begin{array}{l} S_j(x_j) = y_j\\\\ S_j(x_{j+1}) = S_{j+1}(x_{j+1}) = y_{j+1}\\\\ S'_j(x_{j+1}) = S'_{j+1}(x_{j+1})\\\\ S''_j(x_{j+1}) = S''_{j+1}(x_{j+1})\\\\ S'_0(x_{0}) = S'_{n-1}(x_{n}) = 0 \\end{array} S j \u200b ( x j \u200b ) = y j \u200b S j \u200b ( x j + 1 \u200b ) = S j + 1 \u200b ( x j + 1 \u200b ) = y j + 1 \u200b S j \u2032 \u200b ( x j + 1 \u200b ) = S j + 1 \u2032 \u200b ( x j + 1 \u200b ) S j \u2032\u2032 \u200b ( x j + 1 \u200b ) = S j + 1 \u2032\u2032 \u200b ( x j + 1 \u200b ) S 0 \u2032 \u200b ( x 0 \u200b ) = S n \u2212 1 \u2032 \u200b ( x n \u200b ) = 0 \u200b \u3053\u308c\u3089\u306f \u591a\u9805\u5f0f S \u306b x \u3092\u5165\u529b\u3059\u308b\u3068 y \u3092\u51fa\u529b\u3059\u308b \u591a\u9805\u5f0f S \u306e\u304c\u7e4b\u304c\u3063\u3066\u3044\u3066\u5236\u5fa1\u70b9\u3092\u901a\u308b \u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b \u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u52a0\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b \u7aef\u70b9\u3067\u306f\u52a0\u901f\u5ea6\u306f0\u3067\u3042\u308b \u3053\u3068\u3092\u793a\u3059\u3002 Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b \u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u901a\u904e\u3057\u306a\u3044\u5ea7\u6a19\u3092\u4e0e\u3048\u308b\u305f\u3081\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089\u66f2\u7dda\u3092\u60f3\u50cf\u3057\u3065\u3089\u3044\u305f\u3081\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda\u306e\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u30894\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b\u5b9f\u88c5\u304c\u3055\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u3092\u898b\u304b\u3051\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u305d\u306e\u5b9f\u88c5\u306e\u5c0e\u51fa\u3092\u3057\u3066\u3044\u304f\u3002 \u307e\u305a\u305d\u308c\u305e\u308c\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092 Bezier\u66f2\u7dda: B 0,\u2006 B 1,\u2006 B 2,\u2006 B 3(\u5236\u5fa1\u70b9) Hermite\u66f2\u7dda: P 0,\u2006 P 1,\u2006 v 0,\u2006 v 1(\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb) \u3068\u3059\u308b\u3002 \u6b21\u306b\u305d\u308c\u305e\u308c\u5f0f\u3092\u66f8\u304d\u4e0b\u3057\u3001t\u306e\u6b21\u6570\u3054\u3068\u306b\u62ec\u308b\u3068 P b e z i e r ( t ) = ( \u2212 B 0 + 3 B 1 \u2212 3 B 2 + B 3 ) t 3 + ( 3 B 0 \u2212 6 B 1 + 3 B 2 ) t 2 + ( \u2212 3 B 0 + 3 B 1 ) t 1 + ( B 0 ) t 0 \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} P b ez i er \u200b ( t ) = ( \u2212 B 0 \u200b + 3 B 1 \u200b \u2212 3 B 2 \u200b + B 3 \u200b ) t 3 + ( 3 B 0 \u200b \u2212 6 B 1 \u200b + 3 B 2 \u200b ) t 2 + ( \u2212 3 B 0 \u200b + 3 B 1 \u200b ) t 1 + ( B 0 \u200b ) t 0 \u200b P h e r i m i t e ( t ) = ( 2 P 0 \u2212 2 P 1 + v 0 + v 1 ) t 3 ( \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 ) t 2 ( v 0 ) t 1 ( P 0 ) t 0 \\begin{array}{l} P_{herimite}(t) = \\\\ (2 P _0 - 2 P_1 + v_0 + v_1)t^3\\\\ (-3 P_0 + 3 P_1 -2 v_0 - v_1)t^2\\\\ (v_0)t^1\\\\ (P_0)t^0 \\end{array} P h er imi t e \u200b ( t ) = ( 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b ) t 3 ( \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b ) t 2 ( v 0 \u200b ) t 1 ( P 0 \u200b ) t 0 \u200b Pbezier ( t )\u2004=\u2004 Pherimite ( t )\u3068\u3057\u3066\u6052\u7b49\u5f0f\u3092\u89e3\u304f\u3068 ( t 0\u306b\u3064\u3044\u3066) B 0 = P 0 B_0 = P_0 B 0 \u200b = P 0 \u200b ( t 1\u306b\u3064\u3044\u3066) v 0 = \u2212 3 B 0 + 3 B 1 B 1 = P 0 + 1 3 v 0 v_0 = -3 B_0 + 3 B_1\\\\ B_1 = P_0 + \\frac{1}{3}v_0 v 0 \u200b = \u2212 3 B 0 \u200b + 3 B 1 \u200b B 1 \u200b = P 0 \u200b + 3 1 \u200b v 0 \u200b ( t 2\u306b\u3064\u3044\u3066) \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 = 3 P 0 \u2212 6 ( P 0 + 1 3 v 0 ) + 3 B 2 B 2 = P 1 \u2212 1 3 v 1 -3 P_0 + 3 P_1 -2 v_0 - v_1 = 3 P_0 -6(P_0 + \\frac{1}{3} v_0) + 3 B_2\\\\ B_2 = P_1 - \\frac{1}{3} v_1 \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b = 3 P 0 \u200b \u2212 6 ( P 0 \u200b + 3 1 \u200b v 0 \u200b ) + 3 B 2 \u200b B 2 \u200b = P 1 \u200b \u2212 3 1 \u200b v 1 \u200b ( t 3\u306b\u3064\u3044\u3066) 2 P 0 \u2212 2 P 1 + v 0 + v 1 = \u2212 P 0 + 3 ( P 0 + 1 3 v 0 ) \u2212 3 ( P 1 \u2212 1 3 v 1 ) + B 3 B 3 = P 1 2 P _0 - 2 P_1 + v_0 + v_1 = - P_0 + 3(P_0 + \\frac{1}{3}v_0) - 3(P_1 - \\frac{1}{3}v_1) + B_3\\\\ B_3 = P_1 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b = \u2212 P 0 \u200b + 3 ( P 0 \u200b + 3 1 \u200b v 0 \u200b ) \u2212 3 ( P 1 \u200b \u2212 3 1 \u200b v 1 \u200b ) + B 3 \u200b B 3 \u200b = P 1 \u200b \u3088\u3063\u3066 B 0 = P 0 B 1 = P 0 + 1 3 v 0 B 2 = P 1 \u2212 1 3 v 1 B 3 = P 1 \\begin{array}{l} B_0 = P_0\\\\ B_1 = P_0 + \\frac{1}{3}v_0\\\\ B_2 = P_1 - \\frac{1}{3} v_1\\\\ B_3 = P_1 \\end{array} B 0 \u200b = P 0 \u200b B 1 \u200b = P 0 \u200b + 3 1 \u200b v 0 \u200b B 2 \u200b = P 1 \u200b \u2212 3 1 \u200b v 1 \u200b B 3 \u200b = P 1 \u200b \u200b \u3068\u3059\u308b\u3068Hermite\u66f2\u7dda\u306e\u5165\u529b\u3092Bezier\u66f2\u7dda\u3067\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u5b9f\u88c5\u3059\u308b\u306b\u5f53\u305f\u3063\u3066 B P 1 = P 0 + 1 3 v 0 B P 2 = P 1 \u2212 1 3 v 1 \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}v_0\\\\ BP_2 = P_1 - \\frac{1}{3} v_1 \\end{array} B P 1 \u200b = P 0 \u200b + 3 1 \u200b v 0 \u200b B P 2 \u200b = P 1 \u200b \u2212 3 1 \u200b v 1 \u200b \u200b \u3068\u4e00\u6642\u5909\u6570\u3092\u5ba3\u8a00\u3057\u3066\u3044\u308b\u3053\u3068\u3082\u3042\u308b Catmull-Rom\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u6c42\u3081\u3066\u3044\u308c\u3070\u4ee3\u5165\u3059\u308b\u3060\u3051 B P 1 = P i + 1 6 ( P i + 1 \u2212 P i \u2212 1 ) B P 2 = P i + 1 \u2212 1 6 ( P i + 2 \u2212 P i ) \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1})\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) \\end{array} B P 1 \u200b = P i \u200b + 6 1 \u200b ( P i + 1 \u200b \u2212 P i \u2212 1 \u200b ) B P 2 \u200b = P i + 1 \u200b \u2212 6 1 \u200b ( P i + 2 \u200b \u2212 P i \u200b ) \u200b i=0\u306e\u3068\u304d B P 1 = P 0 + 1 3 ( P 1 \u2212 P 0 ) B P 2 = P i + 1 \u2212 1 6 ( P i + 2 \u2212 P i ) ( \u5909\u308f\u3089\u305a ) \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}(P_1 - P_0)\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) (\u5909\u308f\u3089\u305a) \\end{array} B P 1 \u200b = P 0 \u200b + 3 1 \u200b ( P 1 \u200b \u2212 P 0 \u200b ) B P 2 \u200b = P i + 1 \u200b \u2212 6 1 \u200b ( P i + 2 \u200b \u2212 P i \u200b ) ( \u5909\u308f\u3089\u305a ) \u200b i = N-1\u306e\u3068\u304d B P 1 = P i + 1 6 ( P i + 1 \u2212 P i \u2212 1 ) ( \u5909\u308f\u3089\u305a ) B P 2 = P N \u2212 1 \u2212 1 3 ( P N \u2212 1 \u2212 P N \u2212 2 ) \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1}) (\u5909\u308f\u3089\u305a)\\\\ BP_2 = P_{N-1} - \\frac{1}{3} (P_{N-1} - P_{N-2}) \\end{array} B P 1 \u200b = P i \u200b + 6 1 \u200b ( P i + 1 \u200b \u2212 P i \u2212 1 \u200b ) ( \u5909\u308f\u3089\u305a ) B P 2 \u200b = P N \u2212 1 \u200b \u2212 3 1 \u200b ( P N \u2212 1 \u200b \u2212 P N \u2212 2 \u200b ) \u200b \u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b \u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f f ( t ) = a t 3 + b t 2 + c t + d f(t) = a t^3 + b t^2 + c t + d f ( t ) = a t 3 + b t 2 + c t + d \u306b\u3064\u3044\u3066Bezier\u66f2\u7dda\u3068\u6052\u7b49\u5f0f\u3068\u3057\u3066\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b(Hermite->Bezier\u306e\u6642\u3068\u540c\u3058) P b e z i e r ( t ) = ( \u2212 B 0 + 3 B 1 \u2212 3 B 2 + B 3 ) t 3 + ( 3 B 0 \u2212 6 B 1 + 3 B 2 ) t 2 + ( \u2212 3 B 0 + 3 B 1 ) t 1 + ( B 0 ) t 0 \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} P b ez i er \u200b ( t ) = ( \u2212 B 0 \u200b + 3 B 1 \u200b \u2212 3 B 2 \u200b + B 3 \u200b ) t 3 + ( 3 B 0 \u200b \u2212 6 B 1 \u200b + 3 B 2 \u200b ) t 2 + ( \u2212 3 B 0 \u200b + 3 B 1 \u200b ) t 1 + ( B 0 \u200b ) t 0 \u200b \u3088\u3063\u3066 a = B 0 + 3 B 1 \u2212 3 B 2 + B 3 b = 3 B 0 \u2212 6 B 1 + 3 B 2 c = \u2212 3 B 0 + 3 B 1 d = B 0 \\begin{array}{l} a = B_0 + 3 B_1 -3 B_2 + B_3\\\\ b = 3 B_0 -6 B_1 + 3 B_2\\\\ c = -3 B_0 + 3 B_1\\\\ d = B_0 \\end{array} a = B 0 \u200b + 3 B 1 \u200b \u2212 3 B 2 \u200b + B 3 \u200b b = 3 B 0 \u200b \u2212 6 B 1 \u200b + 3 B 2 \u200b c = \u2212 3 B 0 \u200b + 3 B 1 \u200b d = B 0 \u200b \u200b \u3053\u308c\u3092\u89e3\u304f\u3068 B 0 = d B 1 = d + 1 3 c B 2 = 1 3 b + 2 3 c + d B 3 = a + b + c + d \\begin{array}{l} B_0 = d\\\\ B_1 = d + \\frac{1}{3}c\\\\ B_2 = \\frac{1}{3}b + \\frac{2}{3}c + d\\\\ B_3 = a + b + c + d \\end{array} B 0 \u200b = d B 1 \u200b = d + 3 1 \u200b c B 2 \u200b = 3 1 \u200b b + 3 2 \u200b c + d B 3 \u200b = a + b + c + d \u200b \u4f4d\u7f6e\u30fb\u901f\u5ea6\u30fb\u52a0\u901f\u5ea6 Bezier\u66f2\u7dda\u306e\u5b9a\u7fa9\u3088\u308a\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570\u306b\u3088\u308b\u91cd\u307f\u3092\u305d\u308c\u305e\u308c B = [ B 0 , B 1 , B 2 , B 3 ] B = \\left[B_0, B_1, B_2, B_3\\right] B = [ B 0 \u200b , B 1 \u200b , B 2 \u200b , B 3 \u200b ] W = [ \u2212 t 3 + 3 t 2 \u2212 3 t + 1 3 t 3 \u2212 6 t 2 + 3 t \u2212 3 t 3 + t 2 t 3 ] W = \\left[ \\begin{array}{c} -t^3 + 3t^2 - 3t + 1\\\\ 3t^3 -6 t^2 +3 t\\\\ -3 t^3 + t^2\\\\ t^3 \\end{array} \\right] W = \u23a3 \u23a1 \u200b \u2212 t 3 + 3 t 2 \u2212 3 t + 1 3 t 3 \u2212 6 t 2 + 3 t \u2212 3 t 3 + t 2 t 3 \u200b \u23a6 \u23a4 \u200b \u3068\u30d9\u30af\u30c8\u30eb\u8868\u8a18\u3057\u305f\u5834\u5408\u3001\u4f4d\u7f6e\u306f\u6b21\u5f0f\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002 P ( t ) = B \u22c5 W P(t) = B \\cdot W P ( t ) = B \u22c5 W \u3053\u3053\u3067 W \u3092\u4fc2\u6570\u3068 tn \u306b\u5206\u89e3\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308b W = W m T = [ \u2212 1 3 \u2212 3 1 3 \u2212 6 3 0 \u2212 3 1 0 0 1 0 0 0 ] [ t 3 t 2 t 1 ] W = W_m T = \\left [\\begin{array}{c} -1 & 3 & -3 & 1\\\\ 3 & -6 & 3 & 0\\\\ -3 & 1 & 0 & 0\\\\ 1 & 0 & 0 & 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] W = W m \u200b T = \u23a3 \u23a1 \u200b \u2212 1 3 \u2212 3 1 \u200b 3 \u2212 6 1 0 \u200b \u2212 3 3 0 0 \u200b 1 0 0 0 \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b t 3 t 2 t 1 \u200b \u23a6 \u23a4 \u200b \u3053\u308c\u3092\u4f7f\u3046\u3068\u4f4d\u7f6e\u306e\u5f0f\u306f\u6b21\u306e\u3088\u3046\u306b\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b P ( t ) = B W m T = [ B 0 , B 1 , B 2 , B 3 ] [ \u2212 1 3 \u2212 3 1 3 \u2212 6 3 0 \u2212 3 1 0 0 1 0 0 0 ] [ t 3 t 2 t 1 ] P(t) = B W_m T = \\left[B_0, B_1, B_2, B_3\\right] \\left [\\begin{array}{c} -1 & 3 & -3 & 1\\\\ 3 & -6 & 3 & 0\\\\ -3 & 1 & 0 & 0\\\\ 1 & 0 & 0 & 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] P ( t ) = B W m \u200b T = [ B 0 \u200b , B 1 \u200b , B 2 \u200b , B 3 \u200b ] \u23a3 \u23a1 \u200b \u2212 1 3 \u2212 3 1 \u200b 3 \u2212 6 1 0 \u200b \u2212 3 3 0 0 \u200b 1 0 0 0 \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b t 3 t 2 t 1 \u200b \u23a6 \u23a4 \u200b T \u306e\u8981\u7d20\u3092 t \u30671\u56de\u5fae\u5206\u30012\u56de\u5fae\u5206\u3057\u3066\u3059\u308b\u3053\u3068\u3067\u901f\u5ea6\u3001\u52a0\u901f\u5ea6\u3082\u8868\u73fe\u53ef\u80fd\u3067\u3042\u308b \u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408 T = [ 3 t 2 2 t 1 0 ] T = \\left [\\begin{array}{c} 3t^2\\\\ 2t\\\\ 1\\\\ 0 \\end{array} \\right ] T = \u23a3 \u23a1 \u200b 3 t 2 2 t 1 0 \u200b \u23a6 \u23a4 \u200b \u52a0\u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408 T = [ 6 t 2 0 0 ] T = \\left [\\begin{array}{c} 6t\\\\ 2\\\\ 0\\\\ 0 \\end{array} \\right ] T = \u23a3 \u23a1 \u200b 6 t 2 0 0 \u200b \u23a6 \u23a4 \u200b De Casteljau\u6cd5\u306b\u3088\u308bBezier\u66f2\u7dda\u306e\u5206\u5272 \u89e3\u6790\u7684\u306b\u9023\u7d9a\u306a\u95a2\u6570\u3068\u3057\u3066\u66f2\u7dda\u304c\u5f97\u3089\u308c\u3066\u3082\u5b9f\u7528\u4e0a\u306f\u76f4\u7dda\u8fd1\u4f3c\u3057\u3066\u4f7f\u3046\u307f\u305f\u3044\u306a\u306e\u306f \u305d\u3093\u306a\u3068\u304d\u5a92\u4ecb\u5909\u6570 t \u3067\u7b49\u5206\u3059\u308b\u3053\u3068\u3092\u307e\u305a\u601d\u3044\u3064\u304f\u3060\u308d\u3046\u304c\u66f2\u7387\u304c\u5c0f\u3055\u3044\u3068\u3053\u308d\u3067\u7121\u99c4\u306b\u5206\u5272\u3055\u308c\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3057\u3001\u66f2\u7387\u304c\u5927\u304d\u3044\u3068\u3053\u308d\u3067\u5206\u5272\u304c\u8db3\u308a\u305a\u306b\u4e0a\u624b\u304f\u66f2\u7dda\u8fd1\u4f3c\u3067\u304d\u306a\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\u76f4\u7dda\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306b\u306f\u66f2\u7387\u306b\u3088\u3063\u3066\u5206\u5272\u3059\u308b\u533a\u5206\u306e\u9577\u3055\u3092\u5909\u3048\u305f\u307b\u3046\u304c\u8fd1\u4f3c\u5ea6\u304b\u3089\u8003\u3048\u308b\u3068\u5408\u7406\u7684\u3060\u308d\u3046\u3002 Bezier\u66f2\u7dda P ( t ) = \u2211 i = 0 N \u2212 1 B i J N \u2212 1 , i ( t ) t \u2208 [ 0 , 1 ] P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) \\quad \\quad t \\in [0, 1] P ( t ) = i = 0 \u2211 N \u2212 1 \u200b B i \u200b J N \u2212 1 , i \u200b ( t ) t \u2208 [ 0 , 1 ] \u3092 t 0\u30672\u3064\u306e\u533a\u9593\u306b\u5206\u5272\u3059\u308b P 0 ( t ) = \u2211 i = 0 N \u2212 1 B 0 i J N \u2212 1 , i ( t t 0 ) t \u2208 [ 0 , t 0 ] P_0(t) = \\sum_{i = 0}^{N-1}B_{0i} J_{N-1, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] P 0 \u200b ( t ) = i = 0 \u2211 N \u2212 1 \u200b B 0 i \u200b J N \u2212 1 , i \u200b ( t 0 \u200b t \u200b ) t \u2208 [ 0 , t 0 \u200b ] P 1 ( t ) = \u2211 i = 0 N \u2212 1 B 1 i J N \u2212 1 , i ( t \u2212 t 0 1 \u2212 t 0 ) t \u2208 [ t 0 , 1 ] P_1(t) = \\sum_{i = 0}^{N-1}B_{1i} J_{N-1, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] P 1 \u200b ( t ) = i = 0 \u2211 N \u2212 1 \u200b B 1 i \u200b J N \u2212 1 , i \u200b ( 1 \u2212 t 0 \u200b t \u2212 t 0 \u200b \u200b ) t \u2208 [ t 0 \u200b , 1 ] \u4eca\u3001\u898b\u3084\u3059\u3055\u306e\u305f\u3081\u306b n \u2004=\u2004 N \u2005\u2212\u20051\u3068\u3057\u3066\u304a\u304f P 0 ( t ) = \u2211 i = 0 n B 0 i J n , i ( t t 0 ) t \u2208 [ 0 , t 0 ] P_0(t) = \\sum_{i = 0}^{n}B_{0i} J_{n, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] P 0 \u200b ( t ) = i = 0 \u2211 n \u200b B 0 i \u200b J n , i \u200b ( t 0 \u200b t \u200b ) t \u2208 [ 0 , t 0 \u200b ] P 1 ( t ) = \u2211 i = 0 n B 1 i J n , i ( t \u2212 t 0 1 \u2212 t 0 ) t \u2208 [ t 0 , 1 ] P_1(t) = \\sum_{i = 0}^{n}B_{1i} J_{n, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] P 1 \u200b ( t ) = i = 0 \u2211 n \u200b B 1 i \u200b J n , i \u200b ( 1 \u2212 t 0 \u200b t \u2212 t 0 \u200b \u200b ) t \u2208 [ t 0 \u200b , 1 ] \u3053\u306e\u3068\u304d B 0 n ,\u2006 B 1 n \u306e\u8a08\u7b97\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u518d\u5e30\u7684\u306b\u4e0e\u3048\u3089\u308c\u308b B i ( 0 ) : = B i i = 0 , 1 \u22ef n B i ( j ) : = B i ( j \u2212 1 ) ( 1 \u2212 t 0 ) + B i + 1 ( j \u2212 1 ) t 0 i i = 0 , 1 \u22ef ( n \u2212 j ) , j = 1 , 2 \u22ef n \\begin{array}{l} B_i^{(0)} := B_i \\quad \\quad \\quad i = 0, 1 \\cdots n\\\\ B_i^{(j)} := B_i^{(j-1)}(1-t_0) + B_{i+1}^{(j-1)}t_0 i \\quad \\quad i = 0, 1 \\cdots (n-j), \\quad j = 1, 2 \\cdots n\\\\ \\end{array} B i ( 0 ) \u200b := B i \u200b i = 0 , 1 \u22ef n B i ( j ) \u200b := B i ( j \u2212 1 ) \u200b ( 1 \u2212 t 0 \u200b ) + B i + 1 ( j \u2212 1 ) \u200b t 0 \u200b i i = 0 , 1 \u22ef ( n \u2212 j ) , j = 1 , 2 \u22ef n \u200b \u3068\u5b9a\u7fa9\u3057\u305f\u3068\u304d B 0 n = B 0 ( i ) B 1 n = B i ( n \u2212 1 ) \\begin{array}{l} B_{0n} = B_0^{(i)}\\\\ B_{1n}= B_i^{(n-1)} \\end{array} B 0 n \u200b = B 0 ( i ) \u200b B 1 n \u200b = B i ( n \u2212 1 ) \u200b \u200b N \u2004=\u20044\u306b\u3064\u3044\u3066\u7dda\u5f62\u88dc\u9593\u95a2\u6570 lerp ( a ,\u2006 b ,\u2006 t )\u3092\u5b9a\u7fa9\u3057\u305f\u4e0a\u3067\u66f8\u304d\u4e0b\u3057\u3066\u307f\u308b l e r p ( a , b , t ) : = a ( 1 \u2212 t ) + b t t \u2208 [ 0 , 1 ] lerp(a, b, t) := a(1-t) + bt \\quad \\quad t \\in [0, 1] l er p ( a , b , t ) := a ( 1 \u2212 t ) + b t t \u2208 [ 0 , 1 ] \u3068\u3057\u3066\u5206\u5272\u524d\u306e\u4fc2\u6570 B \u2004=\u2004[ B 0,\u2006 B 1,\u2006 B 2,\u2006 B 3],\u5206\u5272\u5f8c\u306e\u4fc2\u6570\u3092\u305d\u308c\u305e\u308c SB 0\u2004=\u2004[ B 00,\u2006 B 01,\u2006 B 02,\u2006 B 03], SB 1\u2004=\u2004[ B 10,\u2006 B 11,\u2006 B 12,\u2006 B 13]\u3068\u3057\u3066 t 0\u3067 B \u3092\u5206\u5272\u3059\u308b\u3068 S B 0 = [ B 0 l e r p ( B 0 , B 1 , t 0 ) l e r p ( l e r p ( B 0 , B 1 , t 0 ) , l e r p ( B 1 , B 2 , t 0 ) , t 0 ) l e r p ( l e r p ( l e r p ( B 0 , B 1 , t 0 ) , l e r p ( B 1 , B 2 , t 0 ) , t 0 ) , l e r p ( l e r p ( B 1 , B 2 , t 0 ) , l e r p ( B 2 , B 3 , t 0 ) , t 0 ) , t 0 ) ] SB_0 = \\left[ \\begin{array}{l} B_0\\\\ lerp(B_0, B_1, t_0)\\\\ lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0)\\\\ lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0) \\end{array} \\right] S B 0 \u200b = \u23a3 \u23a1 \u200b B 0 \u200b l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) l er p ( l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) , l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , t 0 \u200b ) l er p ( l er p ( l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) , l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , t 0 \u200b ) , l er p ( l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) , t 0 \u200b ) , t 0 \u200b ) \u200b \u23a6 \u23a4 \u200b S B 1 = [ l e r p ( l e r p ( l e r p ( B 0 , B 1 , t 0 ) , l e r p ( B 1 , B 2 , t 0 ) , t 0 ) , l e r p ( l e r p ( B 1 , B 2 , t 0 ) , l e r p ( B 2 , B 3 , t 0 ) , t 0 ) , t 0 ) l e r p ( l e r p ( B 1 , B 2 , t 0 ) , l e r p ( B 2 , B 3 , t 0 ) , t 0 ) l e r p ( B 2 , B 3 , t 0 ) B 3 ] SB_1 = \\left[ \\begin{array}{l} lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0)\\\\ lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0)\\\\ lerp(B_2, B_3, t_0)\\\\ B_3 \\end{array} \\right] S B 1 \u200b = \u23a3 \u23a1 \u200b l er p ( l er p ( l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) , l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , t 0 \u200b ) , l er p ( l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) , t 0 \u200b ) , t 0 \u200b ) l er p ( l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) , t 0 \u200b ) l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) B 3 \u200b \u200b \u23a6 \u23a4 \u200b \u66f2\u7dda\u306e\u9577\u3055 Bezier\u66f2\u7dda\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b Bezier\u66f2\u7dda\u3067\u306a\u3044\u66f2\u7dda\u306b\u3064\u3044\u3066\u306fBezier\u66f2\u7dda\u306b\u5909\u63db\u3067\u304d\u308b\u306e\u3067\u3053\u3053\u3067\u306f\u8003\u3048\u306a\u3044\u3082\u306e\u3068\u3059\u308b \u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u3066\u307f\u308b \u53b3\u5bc6\u306b\u8003\u3048\u305a\u306b\u3042\u308b\u7a0b\u5ea6\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3053\u3068\u3092\u8003\u3048\u308b \u4e0b\u306e\u56f3\u3088\u308a\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u9577\u3055\u306f\u5927\u96d1\u628a\u306b\u898b\u3066\u3082| P 3\u2212 P 0|\u4ee5\u4e0a\u3067| P 1\u2212 P 0|\u2005+\u2005| P 2\u2212 P 1|\u2005+\u2005| P 3\u2212 P 2|\u4ee5\u4e0b\u3067\u3042\u308b\u3053\u3068\u304c\u898b\u3066\u53d6\u308c\u308b\u3060\u308d\u3046 (\u51fa\u5178\uff1a 1.\u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u306f ) \u4eca MinLength \u3068 MaxLength \u3092\u6b21\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3059\u308b M i n L n e g t h = \u2223 P 3 \u2212 P 0 \u2223 = ( P 3 x \u2212 P 0 x ) 2 + ( P 3 y \u2212 P 0 y ) 2 M a x L e n g t h = \u2223 P 1 \u2212 P 0 \u2223 + \u2223 P 2 \u2212 P 1 \u2223 + \u2223 P 3 \u2212 P 2 \u2223 = ( P 1 x \u2212 P 0 x ) 2 + ( P 1 y \u2212 P 0 y ) 2 + ( P 2 x \u2212 P 1 x ) 2 + ( P 2 y \u2212 P 1 y ) 2 + ( P 3 x \u2212 P 2 x ) 2 + ( P 3 y \u2212 P 2 y ) 2 \\begin{aligned} MinLnegth &= |P_3-P_0|\\\\ &= \\sqrt{(P_{3x}-P_{0x})^2 + (P_{3y}-P_{0y})^2}\\\\ MaxLength &= |P_1-P_0| + |P_2-P_1| + |P_3-P_2|\\\\ &= \\sqrt{(P_{1x}-P_{0x})^2 + (P_{1y}-P_{0y})^2} + \\sqrt{(P_{2x}-P_{1x})^2 + (P_{2y}-P_{1y})^2} + \\sqrt{(P_{3x}-P_{2x})^2 + (P_{3y}-P_{2y})^2} \\end{aligned} M in L n e g t h M a xL e n g t h \u200b = \u2223 P 3 \u200b \u2212 P 0 \u200b \u2223 = ( P 3 x \u200b \u2212 P 0 x \u200b ) 2 + ( P 3 y \u200b \u2212 P 0 y \u200b ) 2 \u200b = \u2223 P 1 \u200b \u2212 P 0 \u200b \u2223 + \u2223 P 2 \u200b \u2212 P 1 \u200b \u2223 + \u2223 P 3 \u200b \u2212 P 2 \u200b \u2223 = ( P 1 x \u200b \u2212 P 0 x \u200b ) 2 + ( P 1 y \u200b \u2212 P 0 y \u200b ) 2 \u200b + ( P 2 x \u200b \u2212 P 1 x \u200b ) 2 + ( P 2 y \u200b \u2212 P 1 y \u200b ) 2 \u200b + ( P 3 x \u200b \u2212 P 2 x \u200b ) 2 + ( P 3 y \u200b \u2212 P 2 y \u200b ) 2 \u200b \u200b ( Pn \u306f\u524d\u9805\u307e\u3067 Bn \u3068\u8a18\u8ff0\u3057\u3066\u3044\u305f\u3051\u3069\u753b\u50cf\u3092\u4f5c\u308b\u306e\u304c\u9762\u5012\u304f\u3055\u304f\u3066\u6301\u3063\u3066\u304d\u305f\u306e\u306b\u5408\u308f\u305b\u305f\u3060\u3051\u306a\u306e\u3067\u8aa4\u89e3\u3057\u306a\u3044\u3067\u306d) \u3053\u306e\u5e73\u5747\u3092\u5927\u4f53\u306e\u9577\u3055\u3068\u3057\u3066\u5b9a\u7fa9\u3059\u308b E s t i m a t e L e n g t h = M i n L e n g t h + M a x L e n g t h 2 EstimateLength = \\frac{MinLength + MaxLength}{2} E s t ima t e L e n g t h = 2 M in L e n g t h + M a xL e n g t h \u200b \u3059\u308b\u3068\u8aa4\u5dee\u306f\u5927\u304d\u304f\u3066\u3082\u5dee\u306e\u534a\u5206\u3067\u3042\u308b M a x E r r o r = M a x L e n g t h \u2212 M i n L e n g t h 2 MaxError = \\frac{MaxLength - MinLength}{2} M a x E rror = 2 M a xL e n g t h \u2212 M in L e n g t h \u200b \u8a31\u5bb9\u8aa4\u5dee\u306e\u60c5\u5831\u3092\u4f7f\u3063\u3066\u89e3\u50cf\u5ea6\u3092\u6700\u9069\u5316\u3059\u308b \u4e0a\u8a18\u306e\u65b9\u6cd5\u3067\u300c\u5927\u4f53\u306e\u300d\u9577\u3055\u304c\u6c42\u307e\u308b\u3002 MaxError \u306e\u5024\u304c\u5927\u304d\u3051\u308c\u3070\u66f2\u7dda\u306e\u524d\u8ff0\u306e\u65b9\u6cd5\u3067\u5206\u89e3\u3057\u3066\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u518d\u5e30\u7684\u306a\u51e6\u7406\u306b\u306a\u308b\u3060\u308d\u3046\u3002\u3053\u3053\u3067\u6ce8\u610f\u3059\u308b\u306e\u306f MaxError \u306f\u3042\u304f\u307e\u3067 MinLength \u3068 MaxLength \u304b\u3089\u898b\u305f\u8aa4\u5dee\u306e\u6700\u5927\u3067\u7cbe\u5ea6\u304c\u307b\u3057\u3044\u304b\u3089\u3068\u8a00\u3063\u3066 MaxError \u304c0.001\u3092\u4e0b\u56de\u308b\u307e\u3067\u5206\u5272\u3057\u7d9a\u3051\u308b\u306a\u3093\u3066\u5fc5\u8981\u306f\u306a\u3044\u3002\u691c\u8a3c\u306f\u3057\u3066\u306a\u3044\u304c0.1\u3001\u5c0f\u3055\u304f\u3066\u30820.05\u3092\u4e0b\u56de\u3063\u3066\u3044\u308c\u3070\u5341\u5206\u306a\u7cbe\u5ea6\u3092\u5f97\u3089\u308c\u308b\u3068\u601d\u3046\u3002 \u533a\u9593\u3092\u6307\u5b9a\u3057\u3066\u9577\u3055\u3092\u6c42\u3081\u308b \u4e0a\u3067\u6c42\u3081\u305f\u9577\u3055\u306f t \u304c0\u304b\u30891\u307e\u3067\u306e\u9577\u3055\u3068\u6349\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u4efb\u610f\u306e t \u306e\u533a\u9593\u306b\u304a\u3051\u308b\u9577\u3055\u306b\u3064\u3044\u3066\u62e1\u5f35\u3059\u308b\u306b\u306f\u533a\u9593\u306e\u5206\u5272\u3092\u6d3b\u7528\u3059\u308b t 0\u304b\u3089 t 1\u306e\u7bc4\u56f2\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3068\u304d t 0\u2004=\u20040\u306e\u3068\u304d -> t 1\u3067\u5206\u5272\u3057\u305f\u524d\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 t 1\u2004=\u20041\u306e\u3068\u304d -> t 0\u3067\u5206\u5272\u3057\u3066\u5f8c\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 \u305d\u308c\u4ee5\u5916\u306e\u3068\u304d -> \u5206\u5272\u3092\u4e8c\u56de\u884c\u3063\u3066\u533a\u9593\u3092\u51fa\u3057\u3066\u304b\u3089\u9577\u3055\u3092\u51fa\u3059 \u6570\u5024\u7684\u306b\u901f\u5ea6\u30921\u306b\u3059\u308b \u5a92\u4ecb\u5909\u6570 t \u3092\u7528\u3044\u3066 t \u3092\u52d5\u304b\u3057\u305f\u3068\u304d\u306b\u66f2\u7dda\u306e\u4e0a\u3092\u79fb\u52d5\u3059\u308b\u70b9\u306e\u901f\u5ea6\u306f\u4e00\u5b9a\u3067\u306f\u306a\u3044\u3002Catmull-Rom\u66f2\u7dda\u3084Cubic-Spline\u66f2\u7dda\u3067\u306f\u901f\u5ea6\u3092\u6307\u5b9a\u3057\u306a\u3044\u305f\u3081\u901f\u5ea6\u306b\u3064\u3044\u3066\u8003\u3048\u306b\u304f\u3044\u3002 \u901f\u5ea6\u3092\u7dda\u5f62\u5316\u3059\u308b\u3088\u3046\u306a\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u3066\u5a92\u4ecb\u5909\u6570\u3068\u3057\u3066\u66f2\u7dda\u306e\u95a2\u6570\u306b\u6e21\u3059\u3053\u3068\u306b\u306a\u308b\u304c\u3053\u306e\u95a2\u6570\u306f\u89e3\u6790\u7684\u306b\u6c42\u3081\u308b\u306e\u306f\u3067\u304d\u306a\u3044(\u3068\u601d\u3046)\u306e\u3067\u6570\u5024\u7684\u306b\u5b9f\u88c5\u3059\u308b\u65b9\u6cd5\u3092\u3068\u308b Info Todo \u66f2\u7387 \u8a73\u7d30\u306f\u7701\u7565\u3059\u308b\u304c\u5fd8\u308c\u304c\u3061\u306a\u306e\u3067\u66f8\u3044\u3066\u304a\u304f \u66f2\u7387 \u03ba \u3068\u66f2\u7387\u534a\u5f84 R \u306e\u95a2\u4fc2 \u03ba = 1 R \\kappa = \\frac{1}{R} \u03ba = R 1 \u200b \u901f\u5ea6\u30d9\u30af\u30c8\u30eb v \u3068\u52a0\u901f\u5ea6\u30d9\u30af\u30c8\u30eb a \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d R = \u2223 v \u2223 3 \u2223 v \u00d7 a \u2223 R = \\frac{|v|^3}{|v\\times a|} R = \u2223 v \u00d7 a \u2223 \u2223 v \u2223 3 \u200b (Todo)\u4efb\u610f\u306e\u5ea7\u6a19\u304b\u3089\u4e00\u756a\u8fd1\u3044\u66f2\u7dda\u4e0a\u306e\u70b9\u3092\u51fa\u3059 Info Todo \u5186\u5f27\u8fd1\u4f3c \u5186\u5468\u4e0a\u306e\u4e8c\u70b9\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u305d\u306e\u4e8c\u70b9\u3092\u7d50\u3076\u5186\u5f27\u3092Hermite\u66f2\u7dda\u3067\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8003\u3048\u308b\u3002 \u524d\u63d0\u6761\u4ef6\u3068\u3057\u3066 \u4e8c\u70b9\u306f\u4e00\u3064\u306e\u5186\u5468\u4e0a\u306b\u3042\u308b Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf$P_0$, $P_1$, $v_0$, $v_1$\u306e\u3046\u3061$P_0$, $P_1$\u306f\u4e0e\u3048\u3089\u308c\u305f\u4e8c\u70b9\u3001$v_0$, $v_1$\u306e\u65b9\u5411\u306f\u5186\u306b\u6b63\u63a5\u3067\u5927\u304d\u3055\u306f\u4ee5\u4e0b\u3067\u8fd1\u4f3c\u3055\u308c\u308b \u03ba = 4 3 r t a n \u03b8 4 \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \u03ba = 3 r \u200b 4 \u200b t an 4 \u03b8 \u200b \u3053\u3053\u3067$\\theta$\u306f\u5186\u5f27\u306e\u89d2\u5ea6\u3001$r$\u306f\u5186\u306e\u534a\u5f84 \u307e\u305f\u3053\u306e\u8fd1\u4f3c\u306f$\\theta < \\pi$\u306e\u3068\u304d\u306b\u6709\u52b9\u3067\u3042\u308a\u305d\u308c\u4ee5\u4e0a\u3067\u306f\u8457\u3057\u304f\u5186\u5f27\u304b\u3089\u96e2\u308c\u3066\u3057\u307e\u3046\u305f\u3081\u6ce8\u610f\u304c\u5fc5\u8981 \u7279\u6b8a\u306a\u6761\u4ef6\u3067\u306e\u5186\u5f27\u8fd1\u4f3c(\u5f0f\u5909\u5f62) \u65e2\u77e5\u306e\u30d1\u30e9\u30e1\u30fc\u30bf r r r P 0 P_0 P 0 \u200b , P 1 P_1 P 1 \u200b v 0 v_0 v 0 \u200b , v 1 v_1 v 1 \u200b \u306e\u65b9\u5411 c o s \u03b8 = v 0 \u22c5 v 1 \u2223 v 0 \u2223 \u2223 v 1 \u2223 cos\\theta = \\frac{v_0 \\cdot v_1}{|v_0| |v_1|} cos \u03b8 = \u2223 v 0 \u200b \u2223\u2223 v 1 \u200b \u2223 v 0 \u200b \u22c5 v 1 \u200b \u200b \u534a\u89d2\u516c\u5f0f c o s \u03b8 = 1 + c o s \u03b8 2 cos\\theta = \\sqrt{\\frac{1+cos\\theta}{2}} cos \u03b8 = 2 1 + cos \u03b8 \u200b \u200b \u534a\u89d2\u516c\u5f0f tan \u2061 \u03b8 4 = 1 \u2212 cos \u2061 \u03b8 2 1 + cos \u2061 \u03b8 2 \\tan\\frac{\\theta}{4} = \\sqrt{ \\frac{1-\\cos{ \\frac{\\theta}{2}}}{1+\\cos{\\frac{\\theta}{2}}} } tan 4 \u03b8 \u200b = 1 + cos 2 \u03b8 \u200b 1 \u2212 cos 2 \u03b8 \u200b \u200b \u200b \u03ba = 4 3 r t a n \u03b8 4 \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \u03ba = 3 r \u200b 4 \u200b t an 4 \u03b8 \u200b \u53c2\u8003\u6587\u732e \u30d9\u30b8\u30a7\u66f2\u7dda \u30b2\u30fc\u30e0\u30d7\u30ed\u30b0\u30e9\u30de\u306e\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30c8\u30ea\u30c3\u30af\u66f2\u7dda\u5165\u9580(Hermite Curve) t-pot\u300e3\u6b21\u66f2\u7dda\u300f \u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b0\u30e9\u30d5\u30a3\u30af\u30b9\u8ad6 \u7c21\u7565\u5316\u3057\u305f3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u751f\u6210\u65b9\u6cd5 \uff13\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u88dc\u9593\u306e\u6982\u8981\u3068C++, Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9 De Casteljau\u2019s algorithm \u30d9\u30b8\u30a7\u66f2\u7dda\u3067\u63cf\u304f\u5186\u5f27\u3068\u672c\u7269\u306e\u5186\u5f27\u306e\u5dee\uff08\u4e2d\u5fc3\u89d2\u306b\u3064\u3044\u3066\u4e00\u822c\u5316\uff09","title":"\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda"},{"location":"tech_note/path_planning/spline/#_1","text":"","title":"\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda"},{"location":"tech_note/path_planning/spline/#_2","text":"\u30ed\u30dc\u30c3\u30c8\u306e\u79fb\u52d5\u3084\u30a2\u30af\u30c1\u30e5\u30a8\u30fc\u30bf\u306e\u8ecc\u9053\u3092\u4f5c\u308d\u3046\u3068\u3057\u305f\u6642\u306b\u3044\u304f\u3064\u304b\u306e\u901a\u904e\u70b9\u3060\u3051\u3092\u6307\u5b9a\u3057\u3066\u66f2\u7dda\u7684\u306b\u88dc\u9593\u3055\u305b\u3066\u8ecc\u9053\u3092\u751f\u6210\u3059\u308b\u3002\u88dc\u9593\u66f2\u7dda\u3068\u3057\u3066\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u3082\u306e\u304c\u3042\u308b Bezier\u66f2\u7dda(\u30d9\u30b8\u30a8\u66f2\u7dda) Hermite\u66f2\u7dda(\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda) Catmull-Rom\u66f2\u7dda(\u30ad\u30e3\u30c3\u30c8\u30e0\u30eb-\u30ed\u30e0\u66f2\u7dda?) Cubic-Spline\u66f2\u7dda(3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda) \u3053\u306e\u8a18\u4e8b\u3067\u306f\u4e8c\u6b21\u5143\u5e73\u9762\u4e0a\u3067\u306e\u66f2\u7dda\u306b\u3064\u3044\u3066\u8ff0\u3079\u3066\u3044\u304f","title":"\u88dc\u9593\u66f2\u7dda\u306e\u7a2e\u985e"},{"location":"tech_note/path_planning/spline/#bezier","text":"N\u500b\u306e\u5236\u5fa1\u70b9\u3092\u4f7f\u3063\u3066\u66f2\u7dda\u3092\u4f5c\u308b\u7279\u5fb4\u3068\u3057\u3066 \u4e00\u822c\u306b0\u70b9\u76ee, N-1\u70b9\u76ee\u3057\u304b\u901a\u904e\u3057\u306a\u3044 \u3088\u3063\u3066\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3068\u6349\u3048\u3066\u3082\u307b\u3068\u3093\u3069\u9593\u9055\u3044\u306a\u3044\u3060\u308d\u3046","title":"Bezier\u66f2\u7dda"},{"location":"tech_note/path_planning/spline/#n","text":"N\u500b\u306e\u5236\u5fa1\u70b9\u304b\u3089\u306a\u308b\u30d9\u30b8\u30a8\u66f2\u7dda\u3067\u3042\u308bN\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u6b21\u5f0f\u3067\u8868\u3055\u308c\u308b P ( t ) = \u2211 i = 0 N \u2212 1 B i J N \u2212 1 , i ( t ) P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) P ( t ) = i = 0 \u2211 N \u2212 1 \u200b B i \u200b J N \u2212 1 , i \u200b ( t ) \u3053\u3053\u3067 B n Bn B n : \u5236\u5fa1\u70b9\u306e\u4e8c\u6b21\u5143\u5ea7\u6a19( n n n = 0, 1\u22ef N N N \u2212 1) J N JN J N \u2212 1, i i i ( t t t ): \u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570","title":"N\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda"},{"location":"tech_note/path_planning/spline/#_3","text":"J n , i ( t ) = ( n i ) t i ( 1 \u2212 t ) n \u2212 i J_{n, i}(t) = \\left(\\begin{array}{c}n\\\\i\\end{array} \\right)t^i(1-t)^{n-i} J n , i \u200b ( t ) = ( n i \u200b ) t i ( 1 \u2212 t ) n \u2212 i \u3053\u3053\u3067\u4e8c\u9805\u4fc2\u6570 ( n i ) = n ! i ! ( n \u2212 i ) ! \\left(\\begin{array}{c}n\\\\i\\end{array} \\right) = \\frac{n!}{i!(n-i)!} ( n i \u200b ) = i ! ( n \u2212 i )! n ! \u200b \u4e8c\u9805\u4fc2\u6570\u304c\u3071\u3063\u3068\u51fa\u3066\u3053\u306a\u3044\u3068\u304d\u306f \u30d1\u30b9\u30ab\u30eb\u306e\u4e09\u89d2\u5f62 \u3092\u8003\u3048\u308b\u3068\u65e9\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002 n n n \u3068 i i i \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u4e0a\u304b\u3089 n +1\u6bb5\u76ee\u306e(\u5de6\u304b\u3089) i \u2005+\u20051\u500b\u76ee\u304c\u4fc2\u6570\u306b\u306a\u308b \u4ed6\u306e\u66f2\u7dda\u3068\u306e\u6bd4\u8f03\u306e\u305f\u3081\u306bN=4\u3068\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u306e\u3067N=4\u306b\u3064\u3044\u3066\u66f8\u304d\u4e0b\u3059\u3068\u4fc2\u6570\u306f J 3 , 0 ( t ) = ( 1 \u2212 t ) 3 J 3 , 1 ( t ) = 3 ( 1 \u2212 t ) 2 t J 3 , 2 ( t ) = 3 ( 1 \u2212 t ) t 2 J 3 , 3 ( t ) = t 3 \\begin{array}{l} J_{3, 0}(t) = (1-t)^3\\\\ J_{3, 1}(t) = 3(1-t)^2t\\\\ J_{3, 2}(t) = 3(1-t)t^2\\\\ J_{3, 3}(t) = t^3 \\end{array} J 3 , 0 \u200b ( t ) = ( 1 \u2212 t ) 3 J 3 , 1 \u200b ( t ) = 3 ( 1 \u2212 t ) 2 t J 3 , 2 \u200b ( t ) = 3 ( 1 \u2212 t ) t 2 J 3 , 3 \u200b ( t ) = t 3 \u200b \u3088\u3063\u3066\u30d9\u30b8\u30a8\u66f2\u7dda P ( t ) = ( 1 \u2212 t ) 3 B 0 + 3 ( 1 \u2212 t ) 2 t B 1 + 3 ( 1 \u2212 t ) t 2 B 2 + t 3 B 3 t \u2208 [ 0 , 1 ] P(t)=(1-t)^3 B_0 + 3(1-t)^2t B_1 + 3(1-t)t^2 B_2 + t^3 B_3 \\quad \\quad t \\in [0, 1] P ( t ) = ( 1 \u2212 t ) 3 B 0 \u200b + 3 ( 1 \u2212 t ) 2 t B 1 \u200b + 3 ( 1 \u2212 t ) t 2 B 2 \u200b + t 3 B 3 \u200b t \u2208 [ 0 , 1 ]","title":"\u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570"},{"location":"tech_note/path_planning/spline/#hermite","text":"\u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u540c\u69d8\u4e8c\u70b9\u9593\u306e\u66f2\u7dda\u88dc\u9593\u6cd5\u3067\u3042\u308b\u3002\u7279\u5fb4\u3068\u3057\u3066 \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u6307\u5b9a\u3059\u308b \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u4f4d\u7f6e\u3068\u901f\u5ea6\u3092\u305d\u308c\u305e\u308c\u6b21\u306e\u3088\u3046\u306b\u7f6e\u304f P 0,\u2006 P 1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19 v 0,\u2006 v 1: \u59cb\u70b9\u3068\u7d42\u70b9\u306e\u901f\u5ea6\u30d9\u30af\u30c8\u30eb (\u3044\u305a\u308c\u3082\u4e8c\u6b21\u5143\u306e\u30d9\u30af\u30c8\u30eb\u3067\u3042\u308b) 3\u6b21\u5f0f\u3092\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u7f6e\u304f f x ( t ) = a x t 3 + b x t 2 + c x t + d x f y ( t ) = a y t 3 + b y t 2 + c y t + d y t \u2208 [ 0 , 1 ] \\begin{array}{l} f_x(t) = a_x t^3 + b_x t^2 + c_x t + d_x\\\\ f_y(t) = a_y t^3 + b_y t^2 + c_y t + d_y \\quad \\quad t \\in [0, 1] \\end{array} f x \u200b ( t ) = a x \u200b t 3 + b x \u200b t 2 + c x \u200b t + d x \u200b f y \u200b ( t ) = a y \u200b t 3 + b y \u200b t 2 + c y \u200b t + d y \u200b t \u2208 [ 0 , 1 ] \u200b \u307e\u305f P 0\u7b49\u306b\u3064\u3044\u3066\u3082 P 0 x ,\u2006 P 0 y \u304c\u5b58\u5728\u3059\u308b \u4eca\u3001x\u3068y\u306b\u3064\u3044\u3066\u64cd\u4f5c\u306f\u540c\u3058\u306a\u306e\u3067\u3053\u3053\u304b\u3089\u306f\u5f0f\u3092\u898b\u3084\u3059\u304f\u3059\u308b\u305f\u3081\u306bxy\u306e\u6dfb\u5b57\u306f\u7701\u7565\u3059\u308b f ( t )\u3092\u5fae\u5206\u3059\u308b\u3068 f ( x ) = a t 3 + b t 2 + c t + d f \u2032 ( x ) = 3 a t 2 + 2 b t + c f(x) = at^3 + bt^2 + ct + d\\\\ f'(x) = 3at^2 + 2bt + c f ( x ) = a t 3 + b t 2 + c t + d f \u2032 ( x ) = 3 a t 2 + 2 b t + c a\u304b\u3089d\u3092\u6c42\u3081\u3066\u3044\u304f\u3002 \u4e0e\u3048\u3089\u308c\u305f\u30d1\u30e9\u30e1\u30fc\u30bf\u3088\u308a f ( 0 ) = P 0 f ( 1 ) = P 1 f \u2032 ( 0 ) = v 0 f \u2032 ( 1 ) = v 1 \\begin{array}{l} f(0) = P_0\\\\ f(1) = P_1\\\\ f'(0) = v_0\\\\ f'(1) = v_1 \\end{array} f ( 0 ) = P 0 \u200b f ( 1 ) = P 1 \u200b f \u2032 ( 0 ) = v 0 \u200b f \u2032 ( 1 ) = v 1 \u200b \u200b \u3088\u3063\u3066t=0\u306b\u7740\u76ee\u3059\u308b\u3068 d = P 0 c = v 0 d = P_0\\\\ c = v_0 d = P 0 \u200b c = v 0 \u200b \u307e\u305ft=1\u306b\u304a\u3044\u3066 f ( 1 ) = a + b + c + d = P 1 \u3088\u308a c = v 0 , d = P 0 \u3092\u4ee3\u5165\u3057\u3066 a + b = P 1 \u2212 P 0 \u2212 v 0 f \u2032 ( 1 ) = 3 a + 2 b + c = v 1 \u3088\u308a c = v 0 \u3092\u4ee3\u5165\u3057\u3066 3 a + 2 b = v 1 \u2212 v 0 \\begin{array}{l} f(1) = a + b + c + d = P_1 \u3088\u308a\\\\ c = v_0, d=P_0\u3092\u4ee3\u5165\u3057\u3066\\\\ a + b = P_1 - P_0 - v_0\\\\ \\\\ f'(1) = 3a + 2b + c = v_1 \u3088\u308a\\\\ c = v_0\u3092\u4ee3\u5165\u3057\u3066\\\\ 3a + 2b = v_1 - v_0 \\end{array} f ( 1 ) = a + b + c + d = P 1 \u200b \u3088\u308a c = v 0 \u200b , d = P 0 \u200b \u3092\u4ee3\u5165\u3057\u3066 a + b = P 1 \u200b \u2212 P 0 \u200b \u2212 v 0 \u200b f \u2032 ( 1 ) = 3 a + 2 b + c = v 1 \u200b \u3088\u308a c = v 0 \u200b \u3092\u4ee3\u5165\u3057\u3066 3 a + 2 b = v 1 \u200b \u2212 v 0 \u200b \u200b \u305d\u308c\u305e\u308c\u306e\u5f0f\u3092\u2460,\u2461\u3068\u3057\u3066\u2461\u22122\u00d7\u2460\u3067a\u3092\u6c42\u3081\u3066\u304b\u3089b\u306b\u3064\u3044\u3066\u3082\u89e3\u304f\u3068 a = 2 P 0 \u2212 2 P 1 + v 0 + v 1 b = \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1 a = 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b b = \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b \u3088\u3063\u3066 a = 2 P 0 \u2212 2 P 1 + v 0 + v 1 b = \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 c = v 0 d = P 0 \\begin{array}{l} a = 2P_0 - 2P_1 + v_0 + v_1\\\\ b = -3P_0 + 3P_1 - 2v_0 - v_1\\\\ c = v_0\\\\ d = P_0 \\end{array} a = 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b b = \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b c = v 0 \u200b d = P 0 \u200b \u200b a\u301cd\u3092x,y\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u6c42\u3081\u3066 fx ( t ), fy ( t )\u306b\u4ee3\u5165\u3059\u308b\u3053\u3068\u3067Hermite\u66f2\u7dda\u3092\u63cf\u753b\u3067\u304d\u308b \u30e1\u30e2\u66f8\u304d\u3068\u3057\u3066\u6b8b\u3057\u3066\u304a\u304f\u304ct\u306e\u6b21\u6570\u3067\u306f\u306a\u304f P 0,\u2006 P 1,\u2006 v 0,\u2006 v 1\u306b\u3064\u3044\u3066\u304f\u304f\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u308b f ( t ) = ( 2 t 3 \u2212 3 t 2 + 1 ) P 0 ( \u2212 2 t 3 + 3 t 2 ) P 1 ( t 3 \u2212 2 t 2 + t ) v 0 ( t 3 \u2212 t 2 ) v 1 \\begin{array}{l} f(t) = \\\\ (2t^3 - 3t^2 + 1)P_0\\\\ (-2t^3 + 3t^2)P_1\\\\ (t^3 -2t^2 + t)v_0\\\\ (t^3 - t^2)v_1\\\\ \\end{array} f ( t ) = ( 2 t 3 \u2212 3 t 2 + 1 ) P 0 \u200b ( \u2212 2 t 3 + 3 t 2 ) P 1 \u200b ( t 3 \u2212 2 t 2 + t ) v 0 \u200b ( t 3 \u2212 t 2 ) v 1 \u200b \u200b","title":"Hermite\u66f2\u7dda"},{"location":"tech_note/path_planning/spline/#catmull-rom","text":"\u5b9f\u969b\u554f\u984c\u4e8c\u70b9\u9593\u306e\u88dc\u9593\u3060\u3051\u3060\u3068\u8db3\u308a\u306a\u3044\u3053\u3068\u304c\u591a\u3044\u3068\u601d\u3046 \u305d\u3053\u3067Hermite\u66f2\u7dda\u3092\u3064\u306a\u3052\u3066\u4f5c\u3089\u308c\u308bCatmull-Rom\u66f2\u7dda\u3092\u8003\u3048\u308b\u3002\u7279\u5fb4\u306f N\u500b(N > 1)\u306e\u70b9\u3092\u3059\u3079\u3066\u901a\u904e\u3059\u308b\u66f2\u7dda\u3092\u4f5c\u308c\u308b Herimite\u66f2\u7dda\u3067\u4f7f\u3063\u305f\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u5fc5\u8981\u3068\u3057\u306a\u3044 (\u672c\u5f53\u306fHermite\u66f2\u7dda\u3068\u306f\u5225\u306bCatmull-\u66f2\u7dda\u304c\u3067\u304d\u3066\u540c\u30583\u6b21\u5f0f\u3060\u304b\u3089\u5909\u63db\u3067\u304d\u308b\u3088\u306d\u3001\u306e\u6d41\u308c\u306a\u6c17\u304c\u3059\u308b\u3051\u3069\u6587\u732e\u3092\u898b\u3064\u3051\u3089\u308c\u306a\u304b\u3063\u305f) i\u756a\u76ee\u306e\u7d42\u70b9\u3092i+1\u756a\u76ee\u306e\u59cb\u70b9\u306b\u3059\u308b\u3053\u3068\u3067\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u306f\u306a\u308b\u304c\u6ed1\u3089\u304b\u306b\u7e4b\u304c\u3063\u305f\u66f2\u7dda\u306b\u3059\u308b\u305f\u3081\u306e\u62d8\u675f\u304c\u5fc5\u8981\u306b\u306a\u308b N\u70b9\u304b\u3089\u306a\u308b\u66f2\u7dda\u306e\u3046\u3061\u7aef\u70b9\u4ee5\u5916\u306e\u88dc\u9593\u306b\u3064\u3044\u3066\u8003\u3048\u308b i\u756a\u76ee\u306e\u70b9\u306b\u304a\u3051\u308b\u901f\u5ea6\u3092\u4e21\u96a3\u306e\u5ea7\u6a19\u304b\u3089\u4f5c\u308b\u3053\u3068\u3067\u6ed1\u3089\u304b\u306b\u3064\u306a\u3050 v i = 1 2 ( P i + 1 \u2212 P i \u2212 1 ) v_i = \\frac{1}{2}(P_{i+1} - P_{i-1}) v i \u200b = 2 1 \u200b ( P i + 1 \u200b \u2212 P i \u2212 1 \u200b ) \u66f2\u7dda\u306e\u7aef\u70b9( i \u2004=\u20040,\u2006 N \u2005\u2212\u20051)\u3067\u306f\u3053\u306e\u5f0f\u304c\u4f7f\u3048\u306a\u3044\u306e\u3067\u81ea\u8eab\u306e\u5ea7\u6a19\u3068\u96a3\u306e\u5ea7\u6a19\u3067\u901f\u5ea6\u30d9\u30af\u30c8\u30eb\u3092\u4f5c\u308b v 0 = P 1 \u2212 P 0 v N \u2212 1 = P N \u2212 1 \u2212 P N \u2212 2 \\begin{array}{l} v_0 = P_1 - P_0\\\\ v_{N-1} = P_{N-1} - P_{N-2} \\end{array} v 0 \u200b = P 1 \u200b \u2212 P 0 \u200b v N \u2212 1 \u200b = P N \u2212 1 \u200b \u2212 P N \u2212 2 \u200b \u200b","title":"Catmull-Rom\u66f2\u7dda"},{"location":"tech_note/path_planning/spline/#tension","text":"Info Todo","title":"tension\u306b\u3064\u3044\u3066"},{"location":"tech_note/path_planning/spline/#_4","text":"Info Todo","title":"\u30d1\u30e9\u30e1\u30fc\u30bf\u533a\u5206\u306b\u3064\u3044\u3066"},{"location":"tech_note/path_planning/spline/#cubic-spline","text":"\u81ea\u5206\u304c\u9ad8\u5c02\u30ed\u30dc\u30b3\u30f3\u3067\u53c2\u7167\u8ecc\u9053\u306f\u3053\u306e\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3060\u3063\u305f\u3002 \u7279\u5fb4\u3068\u3057\u3066 \u5165\u529b\u306fCatmull-Rom\u3068\u540c\u3058\u901a\u904e\u70b9\u306e\u307f\u3060\u304c\u3088\u308a\u6ed1\u3089\u304b\u3067\u3042\u308b (\u3082\u3057\u304b\u3057\u305f\u3089\u5c11\u3057\u91cd\u3044?) 3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u3067\u306f\u4ee5\u4e0b\u306e\u6761\u4ef6\u306b\u5f93\u3046\u3088\u3046\u306a\u66f2\u7dda\u3092\u65b9\u7a0b\u5f0f\u3092\u89e3\u304f\u3053\u3068\u306b\u3088\u3063\u3066\u6c42\u3081\u308b S j ( x j ) = y j S j ( x j + 1 ) = S j + 1 ( x j + 1 ) = y j + 1 S j \u2032 ( x j + 1 ) = S j + 1 \u2032 ( x j + 1 ) S j \u2032 \u2032 ( x j + 1 ) = S j + 1 \u2032 \u2032 ( x j + 1 ) S 0 \u2032 ( x 0 ) = S n \u2212 1 \u2032 ( x n ) = 0 \\begin{array}{l} S_j(x_j) = y_j\\\\ S_j(x_{j+1}) = S_{j+1}(x_{j+1}) = y_{j+1}\\\\ S'_j(x_{j+1}) = S'_{j+1}(x_{j+1})\\\\ S''_j(x_{j+1}) = S''_{j+1}(x_{j+1})\\\\ S'_0(x_{0}) = S'_{n-1}(x_{n}) = 0 \\end{array} S j \u200b ( x j \u200b ) = y j \u200b S j \u200b ( x j + 1 \u200b ) = S j + 1 \u200b ( x j + 1 \u200b ) = y j + 1 \u200b S j \u2032 \u200b ( x j + 1 \u200b ) = S j + 1 \u2032 \u200b ( x j + 1 \u200b ) S j \u2032\u2032 \u200b ( x j + 1 \u200b ) = S j + 1 \u2032\u2032 \u200b ( x j + 1 \u200b ) S 0 \u2032 \u200b ( x 0 \u200b ) = S n \u2212 1 \u2032 \u200b ( x n \u200b ) = 0 \u200b \u3053\u308c\u3089\u306f \u591a\u9805\u5f0f S \u306b x \u3092\u5165\u529b\u3059\u308b\u3068 y \u3092\u51fa\u529b\u3059\u308b \u591a\u9805\u5f0f S \u306e\u304c\u7e4b\u304c\u3063\u3066\u3044\u3066\u5236\u5fa1\u70b9\u3092\u901a\u308b \u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b \u533a\u9593\u306e\u3064\u306a\u304e\u76ee\u3067\u52a0\u901f\u5ea6\u304c\u9023\u7d9a\u3067\u3042\u308b \u7aef\u70b9\u3067\u306f\u52a0\u901f\u5ea6\u306f0\u3067\u3042\u308b \u3053\u3068\u3092\u793a\u3059\u3002","title":"Cubic-Spline\u66f2\u7dda"},{"location":"tech_note/path_planning/spline/#hermitebezier","text":"\u30d9\u30b8\u30a8\u66f2\u7dda\u306f\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u901a\u904e\u3057\u306a\u3044\u5ea7\u6a19\u3092\u4e0e\u3048\u308b\u305f\u3081\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089\u66f2\u7dda\u3092\u60f3\u50cf\u3057\u3065\u3089\u3044\u305f\u3081\u30a8\u30eb\u30df\u30fc\u30c8\u66f2\u7dda\u306e\u5165\u529b\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u30894\u6b21\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b\u5b9f\u88c5\u304c\u3055\u308c\u3066\u3044\u308b\u30b3\u30fc\u30c9\u3092\u898b\u304b\u3051\u308b\u3053\u3068\u304c\u3042\u308b\u3002\u305d\u306e\u5b9f\u88c5\u306e\u5c0e\u51fa\u3092\u3057\u3066\u3044\u304f\u3002 \u307e\u305a\u305d\u308c\u305e\u308c\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092 Bezier\u66f2\u7dda: B 0,\u2006 B 1,\u2006 B 2,\u2006 B 3(\u5236\u5fa1\u70b9) Hermite\u66f2\u7dda: P 0,\u2006 P 1,\u2006 v 0,\u2006 v 1(\u59cb\u70b9\u3068\u7d42\u70b9\u306e\u5ea7\u6a19\u3068\u901f\u5ea6\u30d9\u30af\u30c8\u30eb) \u3068\u3059\u308b\u3002 \u6b21\u306b\u305d\u308c\u305e\u308c\u5f0f\u3092\u66f8\u304d\u4e0b\u3057\u3001t\u306e\u6b21\u6570\u3054\u3068\u306b\u62ec\u308b\u3068 P b e z i e r ( t ) = ( \u2212 B 0 + 3 B 1 \u2212 3 B 2 + B 3 ) t 3 + ( 3 B 0 \u2212 6 B 1 + 3 B 2 ) t 2 + ( \u2212 3 B 0 + 3 B 1 ) t 1 + ( B 0 ) t 0 \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} P b ez i er \u200b ( t ) = ( \u2212 B 0 \u200b + 3 B 1 \u200b \u2212 3 B 2 \u200b + B 3 \u200b ) t 3 + ( 3 B 0 \u200b \u2212 6 B 1 \u200b + 3 B 2 \u200b ) t 2 + ( \u2212 3 B 0 \u200b + 3 B 1 \u200b ) t 1 + ( B 0 \u200b ) t 0 \u200b P h e r i m i t e ( t ) = ( 2 P 0 \u2212 2 P 1 + v 0 + v 1 ) t 3 ( \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 ) t 2 ( v 0 ) t 1 ( P 0 ) t 0 \\begin{array}{l} P_{herimite}(t) = \\\\ (2 P _0 - 2 P_1 + v_0 + v_1)t^3\\\\ (-3 P_0 + 3 P_1 -2 v_0 - v_1)t^2\\\\ (v_0)t^1\\\\ (P_0)t^0 \\end{array} P h er imi t e \u200b ( t ) = ( 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b ) t 3 ( \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b ) t 2 ( v 0 \u200b ) t 1 ( P 0 \u200b ) t 0 \u200b Pbezier ( t )\u2004=\u2004 Pherimite ( t )\u3068\u3057\u3066\u6052\u7b49\u5f0f\u3092\u89e3\u304f\u3068 ( t 0\u306b\u3064\u3044\u3066) B 0 = P 0 B_0 = P_0 B 0 \u200b = P 0 \u200b ( t 1\u306b\u3064\u3044\u3066) v 0 = \u2212 3 B 0 + 3 B 1 B 1 = P 0 + 1 3 v 0 v_0 = -3 B_0 + 3 B_1\\\\ B_1 = P_0 + \\frac{1}{3}v_0 v 0 \u200b = \u2212 3 B 0 \u200b + 3 B 1 \u200b B 1 \u200b = P 0 \u200b + 3 1 \u200b v 0 \u200b ( t 2\u306b\u3064\u3044\u3066) \u2212 3 P 0 + 3 P 1 \u2212 2 v 0 \u2212 v 1 = 3 P 0 \u2212 6 ( P 0 + 1 3 v 0 ) + 3 B 2 B 2 = P 1 \u2212 1 3 v 1 -3 P_0 + 3 P_1 -2 v_0 - v_1 = 3 P_0 -6(P_0 + \\frac{1}{3} v_0) + 3 B_2\\\\ B_2 = P_1 - \\frac{1}{3} v_1 \u2212 3 P 0 \u200b + 3 P 1 \u200b \u2212 2 v 0 \u200b \u2212 v 1 \u200b = 3 P 0 \u200b \u2212 6 ( P 0 \u200b + 3 1 \u200b v 0 \u200b ) + 3 B 2 \u200b B 2 \u200b = P 1 \u200b \u2212 3 1 \u200b v 1 \u200b ( t 3\u306b\u3064\u3044\u3066) 2 P 0 \u2212 2 P 1 + v 0 + v 1 = \u2212 P 0 + 3 ( P 0 + 1 3 v 0 ) \u2212 3 ( P 1 \u2212 1 3 v 1 ) + B 3 B 3 = P 1 2 P _0 - 2 P_1 + v_0 + v_1 = - P_0 + 3(P_0 + \\frac{1}{3}v_0) - 3(P_1 - \\frac{1}{3}v_1) + B_3\\\\ B_3 = P_1 2 P 0 \u200b \u2212 2 P 1 \u200b + v 0 \u200b + v 1 \u200b = \u2212 P 0 \u200b + 3 ( P 0 \u200b + 3 1 \u200b v 0 \u200b ) \u2212 3 ( P 1 \u200b \u2212 3 1 \u200b v 1 \u200b ) + B 3 \u200b B 3 \u200b = P 1 \u200b \u3088\u3063\u3066 B 0 = P 0 B 1 = P 0 + 1 3 v 0 B 2 = P 1 \u2212 1 3 v 1 B 3 = P 1 \\begin{array}{l} B_0 = P_0\\\\ B_1 = P_0 + \\frac{1}{3}v_0\\\\ B_2 = P_1 - \\frac{1}{3} v_1\\\\ B_3 = P_1 \\end{array} B 0 \u200b = P 0 \u200b B 1 \u200b = P 0 \u200b + 3 1 \u200b v 0 \u200b B 2 \u200b = P 1 \u200b \u2212 3 1 \u200b v 1 \u200b B 3 \u200b = P 1 \u200b \u200b \u3068\u3059\u308b\u3068Hermite\u66f2\u7dda\u306e\u5165\u529b\u3092Bezier\u66f2\u7dda\u3067\u6271\u3046\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u5b9f\u88c5\u3059\u308b\u306b\u5f53\u305f\u3063\u3066 B P 1 = P 0 + 1 3 v 0 B P 2 = P 1 \u2212 1 3 v 1 \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}v_0\\\\ BP_2 = P_1 - \\frac{1}{3} v_1 \\end{array} B P 1 \u200b = P 0 \u200b + 3 1 \u200b v 0 \u200b B P 2 \u200b = P 1 \u200b \u2212 3 1 \u200b v 1 \u200b \u200b \u3068\u4e00\u6642\u5909\u6570\u3092\u5ba3\u8a00\u3057\u3066\u3044\u308b\u3053\u3068\u3082\u3042\u308b","title":"Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b"},{"location":"tech_note/path_planning/spline/#catmull-rombezier","text":"Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u3057\u3066\u6c42\u3081\u3066\u3044\u308c\u3070\u4ee3\u5165\u3059\u308b\u3060\u3051 B P 1 = P i + 1 6 ( P i + 1 \u2212 P i \u2212 1 ) B P 2 = P i + 1 \u2212 1 6 ( P i + 2 \u2212 P i ) \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1})\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) \\end{array} B P 1 \u200b = P i \u200b + 6 1 \u200b ( P i + 1 \u200b \u2212 P i \u2212 1 \u200b ) B P 2 \u200b = P i + 1 \u200b \u2212 6 1 \u200b ( P i + 2 \u200b \u2212 P i \u200b ) \u200b i=0\u306e\u3068\u304d B P 1 = P 0 + 1 3 ( P 1 \u2212 P 0 ) B P 2 = P i + 1 \u2212 1 6 ( P i + 2 \u2212 P i ) ( \u5909\u308f\u3089\u305a ) \\begin{array}{l} BP_1 = P_0 + \\frac{1}{3}(P_1 - P_0)\\\\ BP_2 = P_{i+1} - \\frac{1}{6} (P_{i+2} - P_{i}) (\u5909\u308f\u3089\u305a) \\end{array} B P 1 \u200b = P 0 \u200b + 3 1 \u200b ( P 1 \u200b \u2212 P 0 \u200b ) B P 2 \u200b = P i + 1 \u200b \u2212 6 1 \u200b ( P i + 2 \u200b \u2212 P i \u200b ) ( \u5909\u308f\u3089\u305a ) \u200b i = N-1\u306e\u3068\u304d B P 1 = P i + 1 6 ( P i + 1 \u2212 P i \u2212 1 ) ( \u5909\u308f\u3089\u305a ) B P 2 = P N \u2212 1 \u2212 1 3 ( P N \u2212 1 \u2212 P N \u2212 2 ) \\begin{array}{l} BP_1 = P_i + \\frac{1}{6}(P_{i+1} - P_{i-1}) (\u5909\u308f\u3089\u305a)\\\\ BP_2 = P_{N-1} - \\frac{1}{3} (P_{N-1} - P_{N-2}) \\end{array} B P 1 \u200b = P i \u200b + 6 1 \u200b ( P i + 1 \u200b \u2212 P i \u2212 1 \u200b ) ( \u5909\u308f\u3089\u305a ) B P 2 \u200b = P N \u2212 1 \u200b \u2212 3 1 \u200b ( P N \u2212 1 \u200b \u2212 P N \u2212 2 \u200b ) \u200b","title":"Catmull-Rom\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b"},{"location":"tech_note/path_planning/spline/#bezier_1","text":"\u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f f ( t ) = a t 3 + b t 2 + c t + d f(t) = a t^3 + b t^2 + c t + d f ( t ) = a t 3 + b t 2 + c t + d \u306b\u3064\u3044\u3066Bezier\u66f2\u7dda\u3068\u6052\u7b49\u5f0f\u3068\u3057\u3066\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b(Hermite->Bezier\u306e\u6642\u3068\u540c\u3058) P b e z i e r ( t ) = ( \u2212 B 0 + 3 B 1 \u2212 3 B 2 + B 3 ) t 3 + ( 3 B 0 \u2212 6 B 1 + 3 B 2 ) t 2 + ( \u2212 3 B 0 + 3 B 1 ) t 1 + ( B 0 ) t 0 \\begin{array}{l} P_{bezier}(t) = \\\\ (-B_0 + 3 B_1 -3 B_2 + B_3)t^3 +\\\\ (3 B_0 -6 B_1 + 3 B_2)t^2 + \\\\ (-3 B_0 + 3 B_1)t^1 +\\\\ (B_0)t^0\\\\ \\end{array} P b ez i er \u200b ( t ) = ( \u2212 B 0 \u200b + 3 B 1 \u200b \u2212 3 B 2 \u200b + B 3 \u200b ) t 3 + ( 3 B 0 \u200b \u2212 6 B 1 \u200b + 3 B 2 \u200b ) t 2 + ( \u2212 3 B 0 \u200b + 3 B 1 \u200b ) t 1 + ( B 0 \u200b ) t 0 \u200b \u3088\u3063\u3066 a = B 0 + 3 B 1 \u2212 3 B 2 + B 3 b = 3 B 0 \u2212 6 B 1 + 3 B 2 c = \u2212 3 B 0 + 3 B 1 d = B 0 \\begin{array}{l} a = B_0 + 3 B_1 -3 B_2 + B_3\\\\ b = 3 B_0 -6 B_1 + 3 B_2\\\\ c = -3 B_0 + 3 B_1\\\\ d = B_0 \\end{array} a = B 0 \u200b + 3 B 1 \u200b \u2212 3 B 2 \u200b + B 3 \u200b b = 3 B 0 \u200b \u2212 6 B 1 \u200b + 3 B 2 \u200b c = \u2212 3 B 0 \u200b + 3 B 1 \u200b d = B 0 \u200b \u200b \u3053\u308c\u3092\u89e3\u304f\u3068 B 0 = d B 1 = d + 1 3 c B 2 = 1 3 b + 2 3 c + d B 3 = a + b + c + d \\begin{array}{l} B_0 = d\\\\ B_1 = d + \\frac{1}{3}c\\\\ B_2 = \\frac{1}{3}b + \\frac{2}{3}c + d\\\\ B_3 = a + b + c + d \\end{array} B 0 \u200b = d B 1 \u200b = d + 3 1 \u200b c B 2 \u200b = 3 1 \u200b b + 3 2 \u200b c + d B 3 \u200b = a + b + c + d \u200b","title":"\u4efb\u610f\u306e\u4e09\u6b21\u65b9\u7a0b\u5f0f\u304b\u3089Bezier\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u6c42\u3081\u308b"},{"location":"tech_note/path_planning/spline/#_5","text":"Bezier\u66f2\u7dda\u306e\u5b9a\u7fa9\u3088\u308a\u30d1\u30e9\u30e1\u30fc\u30bf\u3068\u30d0\u30fc\u30f3\u30b9\u30bf\u30a4\u30f3\u57fa\u5e95\u95a2\u6570\u306b\u3088\u308b\u91cd\u307f\u3092\u305d\u308c\u305e\u308c B = [ B 0 , B 1 , B 2 , B 3 ] B = \\left[B_0, B_1, B_2, B_3\\right] B = [ B 0 \u200b , B 1 \u200b , B 2 \u200b , B 3 \u200b ] W = [ \u2212 t 3 + 3 t 2 \u2212 3 t + 1 3 t 3 \u2212 6 t 2 + 3 t \u2212 3 t 3 + t 2 t 3 ] W = \\left[ \\begin{array}{c} -t^3 + 3t^2 - 3t + 1\\\\ 3t^3 -6 t^2 +3 t\\\\ -3 t^3 + t^2\\\\ t^3 \\end{array} \\right] W = \u23a3 \u23a1 \u200b \u2212 t 3 + 3 t 2 \u2212 3 t + 1 3 t 3 \u2212 6 t 2 + 3 t \u2212 3 t 3 + t 2 t 3 \u200b \u23a6 \u23a4 \u200b \u3068\u30d9\u30af\u30c8\u30eb\u8868\u8a18\u3057\u305f\u5834\u5408\u3001\u4f4d\u7f6e\u306f\u6b21\u5f0f\u3067\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3002 P ( t ) = B \u22c5 W P(t) = B \\cdot W P ( t ) = B \u22c5 W \u3053\u3053\u3067 W \u3092\u4fc2\u6570\u3068 tn \u306b\u5206\u89e3\u3059\u308b\u3068\u6b21\u306e\u3088\u3046\u306b\u306a\u308b W = W m T = [ \u2212 1 3 \u2212 3 1 3 \u2212 6 3 0 \u2212 3 1 0 0 1 0 0 0 ] [ t 3 t 2 t 1 ] W = W_m T = \\left [\\begin{array}{c} -1 & 3 & -3 & 1\\\\ 3 & -6 & 3 & 0\\\\ -3 & 1 & 0 & 0\\\\ 1 & 0 & 0 & 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] W = W m \u200b T = \u23a3 \u23a1 \u200b \u2212 1 3 \u2212 3 1 \u200b 3 \u2212 6 1 0 \u200b \u2212 3 3 0 0 \u200b 1 0 0 0 \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b t 3 t 2 t 1 \u200b \u23a6 \u23a4 \u200b \u3053\u308c\u3092\u4f7f\u3046\u3068\u4f4d\u7f6e\u306e\u5f0f\u306f\u6b21\u306e\u3088\u3046\u306b\u8868\u3059\u3053\u3068\u304c\u3067\u304d\u308b P ( t ) = B W m T = [ B 0 , B 1 , B 2 , B 3 ] [ \u2212 1 3 \u2212 3 1 3 \u2212 6 3 0 \u2212 3 1 0 0 1 0 0 0 ] [ t 3 t 2 t 1 ] P(t) = B W_m T = \\left[B_0, B_1, B_2, B_3\\right] \\left [\\begin{array}{c} -1 & 3 & -3 & 1\\\\ 3 & -6 & 3 & 0\\\\ -3 & 1 & 0 & 0\\\\ 1 & 0 & 0 & 0 \\end{array} \\right ] \\left [\\begin{array}{c} t^3\\\\ t^2\\\\ t\\\\ 1 \\end{array} \\right ] P ( t ) = B W m \u200b T = [ B 0 \u200b , B 1 \u200b , B 2 \u200b , B 3 \u200b ] \u23a3 \u23a1 \u200b \u2212 1 3 \u2212 3 1 \u200b 3 \u2212 6 1 0 \u200b \u2212 3 3 0 0 \u200b 1 0 0 0 \u200b \u23a6 \u23a4 \u200b \u23a3 \u23a1 \u200b t 3 t 2 t 1 \u200b \u23a6 \u23a4 \u200b T \u306e\u8981\u7d20\u3092 t \u30671\u56de\u5fae\u5206\u30012\u56de\u5fae\u5206\u3057\u3066\u3059\u308b\u3053\u3068\u3067\u901f\u5ea6\u3001\u52a0\u901f\u5ea6\u3082\u8868\u73fe\u53ef\u80fd\u3067\u3042\u308b \u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408 T = [ 3 t 2 2 t 1 0 ] T = \\left [\\begin{array}{c} 3t^2\\\\ 2t\\\\ 1\\\\ 0 \\end{array} \\right ] T = \u23a3 \u23a1 \u200b 3 t 2 2 t 1 0 \u200b \u23a6 \u23a4 \u200b \u52a0\u901f\u5ea6\u3092\u5f97\u305f\u3044\u5834\u5408 T = [ 6 t 2 0 0 ] T = \\left [\\begin{array}{c} 6t\\\\ 2\\\\ 0\\\\ 0 \\end{array} \\right ] T = \u23a3 \u23a1 \u200b 6 t 2 0 0 \u200b \u23a6 \u23a4 \u200b","title":"\u4f4d\u7f6e\u30fb\u901f\u5ea6\u30fb\u52a0\u901f\u5ea6"},{"location":"tech_note/path_planning/spline/#de-casteljaubezier","text":"\u89e3\u6790\u7684\u306b\u9023\u7d9a\u306a\u95a2\u6570\u3068\u3057\u3066\u66f2\u7dda\u304c\u5f97\u3089\u308c\u3066\u3082\u5b9f\u7528\u4e0a\u306f\u76f4\u7dda\u8fd1\u4f3c\u3057\u3066\u4f7f\u3046\u307f\u305f\u3044\u306a\u306e\u306f \u305d\u3093\u306a\u3068\u304d\u5a92\u4ecb\u5909\u6570 t \u3067\u7b49\u5206\u3059\u308b\u3053\u3068\u3092\u307e\u305a\u601d\u3044\u3064\u304f\u3060\u308d\u3046\u304c\u66f2\u7387\u304c\u5c0f\u3055\u3044\u3068\u3053\u308d\u3067\u7121\u99c4\u306b\u5206\u5272\u3055\u308c\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u3057\u3001\u66f2\u7387\u304c\u5927\u304d\u3044\u3068\u3053\u308d\u3067\u5206\u5272\u304c\u8db3\u308a\u305a\u306b\u4e0a\u624b\u304f\u66f2\u7dda\u8fd1\u4f3c\u3067\u304d\u306a\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\u76f4\u7dda\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306b\u306f\u66f2\u7387\u306b\u3088\u3063\u3066\u5206\u5272\u3059\u308b\u533a\u5206\u306e\u9577\u3055\u3092\u5909\u3048\u305f\u307b\u3046\u304c\u8fd1\u4f3c\u5ea6\u304b\u3089\u8003\u3048\u308b\u3068\u5408\u7406\u7684\u3060\u308d\u3046\u3002 Bezier\u66f2\u7dda P ( t ) = \u2211 i = 0 N \u2212 1 B i J N \u2212 1 , i ( t ) t \u2208 [ 0 , 1 ] P(t) =\\sum_{i = 0}^{N-1}B_i J_{N-1, i}(t) \\quad \\quad t \\in [0, 1] P ( t ) = i = 0 \u2211 N \u2212 1 \u200b B i \u200b J N \u2212 1 , i \u200b ( t ) t \u2208 [ 0 , 1 ] \u3092 t 0\u30672\u3064\u306e\u533a\u9593\u306b\u5206\u5272\u3059\u308b P 0 ( t ) = \u2211 i = 0 N \u2212 1 B 0 i J N \u2212 1 , i ( t t 0 ) t \u2208 [ 0 , t 0 ] P_0(t) = \\sum_{i = 0}^{N-1}B_{0i} J_{N-1, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] P 0 \u200b ( t ) = i = 0 \u2211 N \u2212 1 \u200b B 0 i \u200b J N \u2212 1 , i \u200b ( t 0 \u200b t \u200b ) t \u2208 [ 0 , t 0 \u200b ] P 1 ( t ) = \u2211 i = 0 N \u2212 1 B 1 i J N \u2212 1 , i ( t \u2212 t 0 1 \u2212 t 0 ) t \u2208 [ t 0 , 1 ] P_1(t) = \\sum_{i = 0}^{N-1}B_{1i} J_{N-1, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] P 1 \u200b ( t ) = i = 0 \u2211 N \u2212 1 \u200b B 1 i \u200b J N \u2212 1 , i \u200b ( 1 \u2212 t 0 \u200b t \u2212 t 0 \u200b \u200b ) t \u2208 [ t 0 \u200b , 1 ] \u4eca\u3001\u898b\u3084\u3059\u3055\u306e\u305f\u3081\u306b n \u2004=\u2004 N \u2005\u2212\u20051\u3068\u3057\u3066\u304a\u304f P 0 ( t ) = \u2211 i = 0 n B 0 i J n , i ( t t 0 ) t \u2208 [ 0 , t 0 ] P_0(t) = \\sum_{i = 0}^{n}B_{0i} J_{n, i}\\left(\\frac{t}{t_0}\\right) \\quad \\quad t \\in [0, t_0] P 0 \u200b ( t ) = i = 0 \u2211 n \u200b B 0 i \u200b J n , i \u200b ( t 0 \u200b t \u200b ) t \u2208 [ 0 , t 0 \u200b ] P 1 ( t ) = \u2211 i = 0 n B 1 i J n , i ( t \u2212 t 0 1 \u2212 t 0 ) t \u2208 [ t 0 , 1 ] P_1(t) = \\sum_{i = 0}^{n}B_{1i} J_{n, i}\\left( \\frac{t-t_0}{1-t_0} \\right) \\quad \\quad t \\in [t_0, 1] P 1 \u200b ( t ) = i = 0 \u2211 n \u200b B 1 i \u200b J n , i \u200b ( 1 \u2212 t 0 \u200b t \u2212 t 0 \u200b \u200b ) t \u2208 [ t 0 \u200b , 1 ] \u3053\u306e\u3068\u304d B 0 n ,\u2006 B 1 n \u306e\u8a08\u7b97\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u518d\u5e30\u7684\u306b\u4e0e\u3048\u3089\u308c\u308b B i ( 0 ) : = B i i = 0 , 1 \u22ef n B i ( j ) : = B i ( j \u2212 1 ) ( 1 \u2212 t 0 ) + B i + 1 ( j \u2212 1 ) t 0 i i = 0 , 1 \u22ef ( n \u2212 j ) , j = 1 , 2 \u22ef n \\begin{array}{l} B_i^{(0)} := B_i \\quad \\quad \\quad i = 0, 1 \\cdots n\\\\ B_i^{(j)} := B_i^{(j-1)}(1-t_0) + B_{i+1}^{(j-1)}t_0 i \\quad \\quad i = 0, 1 \\cdots (n-j), \\quad j = 1, 2 \\cdots n\\\\ \\end{array} B i ( 0 ) \u200b := B i \u200b i = 0 , 1 \u22ef n B i ( j ) \u200b := B i ( j \u2212 1 ) \u200b ( 1 \u2212 t 0 \u200b ) + B i + 1 ( j \u2212 1 ) \u200b t 0 \u200b i i = 0 , 1 \u22ef ( n \u2212 j ) , j = 1 , 2 \u22ef n \u200b \u3068\u5b9a\u7fa9\u3057\u305f\u3068\u304d B 0 n = B 0 ( i ) B 1 n = B i ( n \u2212 1 ) \\begin{array}{l} B_{0n} = B_0^{(i)}\\\\ B_{1n}= B_i^{(n-1)} \\end{array} B 0 n \u200b = B 0 ( i ) \u200b B 1 n \u200b = B i ( n \u2212 1 ) \u200b \u200b N \u2004=\u20044\u306b\u3064\u3044\u3066\u7dda\u5f62\u88dc\u9593\u95a2\u6570 lerp ( a ,\u2006 b ,\u2006 t )\u3092\u5b9a\u7fa9\u3057\u305f\u4e0a\u3067\u66f8\u304d\u4e0b\u3057\u3066\u307f\u308b l e r p ( a , b , t ) : = a ( 1 \u2212 t ) + b t t \u2208 [ 0 , 1 ] lerp(a, b, t) := a(1-t) + bt \\quad \\quad t \\in [0, 1] l er p ( a , b , t ) := a ( 1 \u2212 t ) + b t t \u2208 [ 0 , 1 ] \u3068\u3057\u3066\u5206\u5272\u524d\u306e\u4fc2\u6570 B \u2004=\u2004[ B 0,\u2006 B 1,\u2006 B 2,\u2006 B 3],\u5206\u5272\u5f8c\u306e\u4fc2\u6570\u3092\u305d\u308c\u305e\u308c SB 0\u2004=\u2004[ B 00,\u2006 B 01,\u2006 B 02,\u2006 B 03], SB 1\u2004=\u2004[ B 10,\u2006 B 11,\u2006 B 12,\u2006 B 13]\u3068\u3057\u3066 t 0\u3067 B \u3092\u5206\u5272\u3059\u308b\u3068 S B 0 = [ B 0 l e r p ( B 0 , B 1 , t 0 ) l e r p ( l e r p ( B 0 , B 1 , t 0 ) , l e r p ( B 1 , B 2 , t 0 ) , t 0 ) l e r p ( l e r p ( l e r p ( B 0 , B 1 , t 0 ) , l e r p ( B 1 , B 2 , t 0 ) , t 0 ) , l e r p ( l e r p ( B 1 , B 2 , t 0 ) , l e r p ( B 2 , B 3 , t 0 ) , t 0 ) , t 0 ) ] SB_0 = \\left[ \\begin{array}{l} B_0\\\\ lerp(B_0, B_1, t_0)\\\\ lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0)\\\\ lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0) \\end{array} \\right] S B 0 \u200b = \u23a3 \u23a1 \u200b B 0 \u200b l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) l er p ( l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) , l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , t 0 \u200b ) l er p ( l er p ( l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) , l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , t 0 \u200b ) , l er p ( l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) , t 0 \u200b ) , t 0 \u200b ) \u200b \u23a6 \u23a4 \u200b S B 1 = [ l e r p ( l e r p ( l e r p ( B 0 , B 1 , t 0 ) , l e r p ( B 1 , B 2 , t 0 ) , t 0 ) , l e r p ( l e r p ( B 1 , B 2 , t 0 ) , l e r p ( B 2 , B 3 , t 0 ) , t 0 ) , t 0 ) l e r p ( l e r p ( B 1 , B 2 , t 0 ) , l e r p ( B 2 , B 3 , t 0 ) , t 0 ) l e r p ( B 2 , B 3 , t 0 ) B 3 ] SB_1 = \\left[ \\begin{array}{l} lerp(lerp(lerp(B_0, B_1, t_0), lerp(B_1, B_2, t_0), t_0), lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0), t_0)\\\\ lerp(lerp(B_1, B_2, t_0), lerp(B_2, B_3, t_0), t_0)\\\\ lerp(B_2, B_3, t_0)\\\\ B_3 \\end{array} \\right] S B 1 \u200b = \u23a3 \u23a1 \u200b l er p ( l er p ( l er p ( B 0 \u200b , B 1 \u200b , t 0 \u200b ) , l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , t 0 \u200b ) , l er p ( l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) , t 0 \u200b ) , t 0 \u200b ) l er p ( l er p ( B 1 \u200b , B 2 \u200b , t 0 \u200b ) , l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) , t 0 \u200b ) l er p ( B 2 \u200b , B 3 \u200b , t 0 \u200b ) B 3 \u200b \u200b \u23a6 \u23a4 \u200b","title":"De Casteljau\u6cd5\u306b\u3088\u308bBezier\u66f2\u7dda\u306e\u5206\u5272"},{"location":"tech_note/path_planning/spline/#_6","text":"Bezier\u66f2\u7dda\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u65b9\u6cd5\u306b\u3064\u3044\u3066\u8003\u3048\u3066\u307f\u308b Bezier\u66f2\u7dda\u3067\u306a\u3044\u66f2\u7dda\u306b\u3064\u3044\u3066\u306fBezier\u66f2\u7dda\u306b\u5909\u63db\u3067\u304d\u308b\u306e\u3067\u3053\u3053\u3067\u306f\u8003\u3048\u306a\u3044\u3082\u306e\u3068\u3059\u308b","title":"\u66f2\u7dda\u306e\u9577\u3055"},{"location":"tech_note/path_planning/spline/#_7","text":"\u53b3\u5bc6\u306b\u8003\u3048\u305a\u306b\u3042\u308b\u7a0b\u5ea6\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3053\u3068\u3092\u8003\u3048\u308b \u4e0b\u306e\u56f3\u3088\u308a\u30d9\u30b8\u30a8\u66f2\u7dda\u306e\u9577\u3055\u306f\u5927\u96d1\u628a\u306b\u898b\u3066\u3082| P 3\u2212 P 0|\u4ee5\u4e0a\u3067| P 1\u2212 P 0|\u2005+\u2005| P 2\u2212 P 1|\u2005+\u2005| P 3\u2212 P 2|\u4ee5\u4e0b\u3067\u3042\u308b\u3053\u3068\u304c\u898b\u3066\u53d6\u308c\u308b\u3060\u308d\u3046 (\u51fa\u5178\uff1a 1.\u30d9\u30b8\u30a8\u66f2\u7dda\u3068\u306f ) \u4eca MinLength \u3068 MaxLength \u3092\u6b21\u306e\u3088\u3046\u306b\u5b9a\u7fa9\u3059\u308b M i n L n e g t h = \u2223 P 3 \u2212 P 0 \u2223 = ( P 3 x \u2212 P 0 x ) 2 + ( P 3 y \u2212 P 0 y ) 2 M a x L e n g t h = \u2223 P 1 \u2212 P 0 \u2223 + \u2223 P 2 \u2212 P 1 \u2223 + \u2223 P 3 \u2212 P 2 \u2223 = ( P 1 x \u2212 P 0 x ) 2 + ( P 1 y \u2212 P 0 y ) 2 + ( P 2 x \u2212 P 1 x ) 2 + ( P 2 y \u2212 P 1 y ) 2 + ( P 3 x \u2212 P 2 x ) 2 + ( P 3 y \u2212 P 2 y ) 2 \\begin{aligned} MinLnegth &= |P_3-P_0|\\\\ &= \\sqrt{(P_{3x}-P_{0x})^2 + (P_{3y}-P_{0y})^2}\\\\ MaxLength &= |P_1-P_0| + |P_2-P_1| + |P_3-P_2|\\\\ &= \\sqrt{(P_{1x}-P_{0x})^2 + (P_{1y}-P_{0y})^2} + \\sqrt{(P_{2x}-P_{1x})^2 + (P_{2y}-P_{1y})^2} + \\sqrt{(P_{3x}-P_{2x})^2 + (P_{3y}-P_{2y})^2} \\end{aligned} M in L n e g t h M a xL e n g t h \u200b = \u2223 P 3 \u200b \u2212 P 0 \u200b \u2223 = ( P 3 x \u200b \u2212 P 0 x \u200b ) 2 + ( P 3 y \u200b \u2212 P 0 y \u200b ) 2 \u200b = \u2223 P 1 \u200b \u2212 P 0 \u200b \u2223 + \u2223 P 2 \u200b \u2212 P 1 \u200b \u2223 + \u2223 P 3 \u200b \u2212 P 2 \u200b \u2223 = ( P 1 x \u200b \u2212 P 0 x \u200b ) 2 + ( P 1 y \u200b \u2212 P 0 y \u200b ) 2 \u200b + ( P 2 x \u200b \u2212 P 1 x \u200b ) 2 + ( P 2 y \u200b \u2212 P 1 y \u200b ) 2 \u200b + ( P 3 x \u200b \u2212 P 2 x \u200b ) 2 + ( P 3 y \u200b \u2212 P 2 y \u200b ) 2 \u200b \u200b ( Pn \u306f\u524d\u9805\u307e\u3067 Bn \u3068\u8a18\u8ff0\u3057\u3066\u3044\u305f\u3051\u3069\u753b\u50cf\u3092\u4f5c\u308b\u306e\u304c\u9762\u5012\u304f\u3055\u304f\u3066\u6301\u3063\u3066\u304d\u305f\u306e\u306b\u5408\u308f\u305b\u305f\u3060\u3051\u306a\u306e\u3067\u8aa4\u89e3\u3057\u306a\u3044\u3067\u306d) \u3053\u306e\u5e73\u5747\u3092\u5927\u4f53\u306e\u9577\u3055\u3068\u3057\u3066\u5b9a\u7fa9\u3059\u308b E s t i m a t e L e n g t h = M i n L e n g t h + M a x L e n g t h 2 EstimateLength = \\frac{MinLength + MaxLength}{2} E s t ima t e L e n g t h = 2 M in L e n g t h + M a xL e n g t h \u200b \u3059\u308b\u3068\u8aa4\u5dee\u306f\u5927\u304d\u304f\u3066\u3082\u5dee\u306e\u534a\u5206\u3067\u3042\u308b M a x E r r o r = M a x L e n g t h \u2212 M i n L e n g t h 2 MaxError = \\frac{MaxLength - MinLength}{2} M a x E rror = 2 M a xL e n g t h \u2212 M in L e n g t h \u200b","title":"\u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u3066\u307f\u308b"},{"location":"tech_note/path_planning/spline/#_8","text":"\u4e0a\u8a18\u306e\u65b9\u6cd5\u3067\u300c\u5927\u4f53\u306e\u300d\u9577\u3055\u304c\u6c42\u307e\u308b\u3002 MaxError \u306e\u5024\u304c\u5927\u304d\u3051\u308c\u3070\u66f2\u7dda\u306e\u524d\u8ff0\u306e\u65b9\u6cd5\u3067\u5206\u89e3\u3057\u3066\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u5927\u4f53\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u518d\u5e30\u7684\u306a\u51e6\u7406\u306b\u306a\u308b\u3060\u308d\u3046\u3002\u3053\u3053\u3067\u6ce8\u610f\u3059\u308b\u306e\u306f MaxError \u306f\u3042\u304f\u307e\u3067 MinLength \u3068 MaxLength \u304b\u3089\u898b\u305f\u8aa4\u5dee\u306e\u6700\u5927\u3067\u7cbe\u5ea6\u304c\u307b\u3057\u3044\u304b\u3089\u3068\u8a00\u3063\u3066 MaxError \u304c0.001\u3092\u4e0b\u56de\u308b\u307e\u3067\u5206\u5272\u3057\u7d9a\u3051\u308b\u306a\u3093\u3066\u5fc5\u8981\u306f\u306a\u3044\u3002\u691c\u8a3c\u306f\u3057\u3066\u306a\u3044\u304c0.1\u3001\u5c0f\u3055\u304f\u3066\u30820.05\u3092\u4e0b\u56de\u3063\u3066\u3044\u308c\u3070\u5341\u5206\u306a\u7cbe\u5ea6\u3092\u5f97\u3089\u308c\u308b\u3068\u601d\u3046\u3002","title":"\u8a31\u5bb9\u8aa4\u5dee\u306e\u60c5\u5831\u3092\u4f7f\u3063\u3066\u89e3\u50cf\u5ea6\u3092\u6700\u9069\u5316\u3059\u308b"},{"location":"tech_note/path_planning/spline/#_9","text":"\u4e0a\u3067\u6c42\u3081\u305f\u9577\u3055\u306f t \u304c0\u304b\u30891\u307e\u3067\u306e\u9577\u3055\u3068\u6349\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002\u4efb\u610f\u306e t \u306e\u533a\u9593\u306b\u304a\u3051\u308b\u9577\u3055\u306b\u3064\u3044\u3066\u62e1\u5f35\u3059\u308b\u306b\u306f\u533a\u9593\u306e\u5206\u5272\u3092\u6d3b\u7528\u3059\u308b t 0\u304b\u3089 t 1\u306e\u7bc4\u56f2\u306e\u9577\u3055\u3092\u6c42\u3081\u308b\u3068\u304d t 0\u2004=\u20040\u306e\u3068\u304d -> t 1\u3067\u5206\u5272\u3057\u305f\u524d\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 t 1\u2004=\u20041\u306e\u3068\u304d -> t 0\u3067\u5206\u5272\u3057\u3066\u5f8c\u534a\u306e\u9577\u3055\u3092\u51fa\u3059 \u305d\u308c\u4ee5\u5916\u306e\u3068\u304d -> \u5206\u5272\u3092\u4e8c\u56de\u884c\u3063\u3066\u533a\u9593\u3092\u51fa\u3057\u3066\u304b\u3089\u9577\u3055\u3092\u51fa\u3059","title":"\u533a\u9593\u3092\u6307\u5b9a\u3057\u3066\u9577\u3055\u3092\u6c42\u3081\u308b"},{"location":"tech_note/path_planning/spline/#1","text":"\u5a92\u4ecb\u5909\u6570 t \u3092\u7528\u3044\u3066 t \u3092\u52d5\u304b\u3057\u305f\u3068\u304d\u306b\u66f2\u7dda\u306e\u4e0a\u3092\u79fb\u52d5\u3059\u308b\u70b9\u306e\u901f\u5ea6\u306f\u4e00\u5b9a\u3067\u306f\u306a\u3044\u3002Catmull-Rom\u66f2\u7dda\u3084Cubic-Spline\u66f2\u7dda\u3067\u306f\u901f\u5ea6\u3092\u6307\u5b9a\u3057\u306a\u3044\u305f\u3081\u901f\u5ea6\u306b\u3064\u3044\u3066\u8003\u3048\u306b\u304f\u3044\u3002 \u901f\u5ea6\u3092\u7dda\u5f62\u5316\u3059\u308b\u3088\u3046\u306a\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u3066\u5a92\u4ecb\u5909\u6570\u3068\u3057\u3066\u66f2\u7dda\u306e\u95a2\u6570\u306b\u6e21\u3059\u3053\u3068\u306b\u306a\u308b\u304c\u3053\u306e\u95a2\u6570\u306f\u89e3\u6790\u7684\u306b\u6c42\u3081\u308b\u306e\u306f\u3067\u304d\u306a\u3044(\u3068\u601d\u3046)\u306e\u3067\u6570\u5024\u7684\u306b\u5b9f\u88c5\u3059\u308b\u65b9\u6cd5\u3092\u3068\u308b Info Todo","title":"\u6570\u5024\u7684\u306b\u901f\u5ea6\u30921\u306b\u3059\u308b"},{"location":"tech_note/path_planning/spline/#_10","text":"\u8a73\u7d30\u306f\u7701\u7565\u3059\u308b\u304c\u5fd8\u308c\u304c\u3061\u306a\u306e\u3067\u66f8\u3044\u3066\u304a\u304f \u66f2\u7387 \u03ba \u3068\u66f2\u7387\u534a\u5f84 R \u306e\u95a2\u4fc2 \u03ba = 1 R \\kappa = \\frac{1}{R} \u03ba = R 1 \u200b \u901f\u5ea6\u30d9\u30af\u30c8\u30eb v \u3068\u52a0\u901f\u5ea6\u30d9\u30af\u30c8\u30eb a \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d R = \u2223 v \u2223 3 \u2223 v \u00d7 a \u2223 R = \\frac{|v|^3}{|v\\times a|} R = \u2223 v \u00d7 a \u2223 \u2223 v \u2223 3 \u200b","title":"\u66f2\u7387"},{"location":"tech_note/path_planning/spline/#todo","text":"Info Todo","title":"(Todo)\u4efb\u610f\u306e\u5ea7\u6a19\u304b\u3089\u4e00\u756a\u8fd1\u3044\u66f2\u7dda\u4e0a\u306e\u70b9\u3092\u51fa\u3059"},{"location":"tech_note/path_planning/spline/#_11","text":"\u5186\u5468\u4e0a\u306e\u4e8c\u70b9\u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u3001\u305d\u306e\u4e8c\u70b9\u3092\u7d50\u3076\u5186\u5f27\u3092Hermite\u66f2\u7dda\u3067\u8fd1\u4f3c\u3059\u308b\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u8003\u3048\u308b\u3002 \u524d\u63d0\u6761\u4ef6\u3068\u3057\u3066 \u4e8c\u70b9\u306f\u4e00\u3064\u306e\u5186\u5468\u4e0a\u306b\u3042\u308b Hermite\u66f2\u7dda\u306e\u30d1\u30e9\u30e1\u30fc\u30bf$P_0$, $P_1$, $v_0$, $v_1$\u306e\u3046\u3061$P_0$, $P_1$\u306f\u4e0e\u3048\u3089\u308c\u305f\u4e8c\u70b9\u3001$v_0$, $v_1$\u306e\u65b9\u5411\u306f\u5186\u306b\u6b63\u63a5\u3067\u5927\u304d\u3055\u306f\u4ee5\u4e0b\u3067\u8fd1\u4f3c\u3055\u308c\u308b \u03ba = 4 3 r t a n \u03b8 4 \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \u03ba = 3 r \u200b 4 \u200b t an 4 \u03b8 \u200b \u3053\u3053\u3067$\\theta$\u306f\u5186\u5f27\u306e\u89d2\u5ea6\u3001$r$\u306f\u5186\u306e\u534a\u5f84 \u307e\u305f\u3053\u306e\u8fd1\u4f3c\u306f$\\theta < \\pi$\u306e\u3068\u304d\u306b\u6709\u52b9\u3067\u3042\u308a\u305d\u308c\u4ee5\u4e0a\u3067\u306f\u8457\u3057\u304f\u5186\u5f27\u304b\u3089\u96e2\u308c\u3066\u3057\u307e\u3046\u305f\u3081\u6ce8\u610f\u304c\u5fc5\u8981","title":"\u5186\u5f27\u8fd1\u4f3c"},{"location":"tech_note/path_planning/spline/#_12","text":"\u65e2\u77e5\u306e\u30d1\u30e9\u30e1\u30fc\u30bf r r r P 0 P_0 P 0 \u200b , P 1 P_1 P 1 \u200b v 0 v_0 v 0 \u200b , v 1 v_1 v 1 \u200b \u306e\u65b9\u5411 c o s \u03b8 = v 0 \u22c5 v 1 \u2223 v 0 \u2223 \u2223 v 1 \u2223 cos\\theta = \\frac{v_0 \\cdot v_1}{|v_0| |v_1|} cos \u03b8 = \u2223 v 0 \u200b \u2223\u2223 v 1 \u200b \u2223 v 0 \u200b \u22c5 v 1 \u200b \u200b \u534a\u89d2\u516c\u5f0f c o s \u03b8 = 1 + c o s \u03b8 2 cos\\theta = \\sqrt{\\frac{1+cos\\theta}{2}} cos \u03b8 = 2 1 + cos \u03b8 \u200b \u200b \u534a\u89d2\u516c\u5f0f tan \u2061 \u03b8 4 = 1 \u2212 cos \u2061 \u03b8 2 1 + cos \u2061 \u03b8 2 \\tan\\frac{\\theta}{4} = \\sqrt{ \\frac{1-\\cos{ \\frac{\\theta}{2}}}{1+\\cos{\\frac{\\theta}{2}}} } tan 4 \u03b8 \u200b = 1 + cos 2 \u03b8 \u200b 1 \u2212 cos 2 \u03b8 \u200b \u200b \u200b \u03ba = 4 3 r t a n \u03b8 4 \\kappa = \\frac{4}{3\\sqrt{r}}tan\\frac{\\theta}{4} \u03ba = 3 r \u200b 4 \u200b t an 4 \u03b8 \u200b","title":"\u7279\u6b8a\u306a\u6761\u4ef6\u3067\u306e\u5186\u5f27\u8fd1\u4f3c(\u5f0f\u5909\u5f62)"},{"location":"tech_note/path_planning/spline/#_13","text":"\u30d9\u30b8\u30a7\u66f2\u7dda \u30b2\u30fc\u30e0\u30d7\u30ed\u30b0\u30e9\u30de\u306e\u305f\u3081\u306e\u30d1\u30e9\u30e1\u30c8\u30ea\u30c3\u30af\u66f2\u7dda\u5165\u9580(Hermite Curve) t-pot\u300e3\u6b21\u66f2\u7dda\u300f \u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30b0\u30e9\u30d5\u30a3\u30af\u30b9\u8ad6 \u7c21\u7565\u5316\u3057\u305f3\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u66f2\u7dda\u306e\u751f\u6210\u65b9\u6cd5 \uff13\u6b21\u30b9\u30d7\u30e9\u30a4\u30f3\u88dc\u9593\u306e\u6982\u8981\u3068C++, Python\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9 De Casteljau\u2019s algorithm \u30d9\u30b8\u30a7\u66f2\u7dda\u3067\u63cf\u304f\u5186\u5f27\u3068\u672c\u7269\u306e\u5186\u5f27\u306e\u5dee\uff08\u4e2d\u5fc3\u89d2\u306b\u3064\u3044\u3066\u4e00\u822c\u5316\uff09","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/path_planning/wave_propagation/","text":"Wave propagation Wave propagation\u306f\u30b0\u30ea\u30c3\u30c9\u306e\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u4e00\u7a2e\u3067\u3042\u308b\u3002A*\u3088\u308a\u5c48\u6298\u304c\u5c11\u306a\u3044\u5f62\u306e\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u3002 \u53c2\u8003\u6587\u732e Path Planning #2 Wave Propagation, Potential Fields & Modern(ish) C++ (YouTube)","title":"wave propagation"},{"location":"tech_note/path_planning/wave_propagation/#wave-propagation","text":"Wave propagation\u306f\u30b0\u30ea\u30c3\u30c9\u306e\u30d1\u30b9\u30d7\u30e9\u30f3\u30cb\u30f3\u30b0\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u306b\u4e00\u7a2e\u3067\u3042\u308b\u3002A*\u3088\u308a\u5c48\u6298\u304c\u5c11\u306a\u3044\u5f62\u306e\u7d4c\u8def\u3092\u751f\u6210\u3059\u308b\u3053\u3068\u304c\u591a\u3044\u3002","title":"Wave propagation"},{"location":"tech_note/path_planning/wave_propagation/#_1","text":"Path Planning #2 Wave Propagation, Potential Fields & Modern(ish) C++ (YouTube)","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/software_design/design_pattern/","text":"\u30c7\u30b6\u30a4\u30f3\u30d1\u30bf\u30fc\u30f3","title":"\u30c7\u30b6\u30a4\u30f3\u30d1\u30bf\u30fc\u30f3"},{"location":"tech_note/software_design/design_pattern/#_1","text":"","title":"\u30c7\u30b6\u30a4\u30f3\u30d1\u30bf\u30fc\u30f3"},{"location":"tech_note/software_design/solid/","text":"SOLID\u539f\u5247 \u53c2\u8003\u6587\u732e SOLID","title":"SOLID\u539f\u5247"},{"location":"tech_note/software_design/solid/#solid","text":"","title":"SOLID\u539f\u5247"},{"location":"tech_note/software_design/solid/#_1","text":"SOLID","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/system/discrete/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u96e2\u6563\u5316 \u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u30b7\u30b9\u30c6\u30e0\u30e2\u30c7\u30eb\u3092\u6271\u3046\u969b\u306b\u306f\u3075\u308b\u307e\u3044\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b\u305f\u3081\u306b\u9023\u7d9a\u6642\u9593\u9818\u57df\u3084s\u9818\u57df\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u4ee5\u4e0b\u306b\u96e2\u6563\u5316\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u8ff0\u3079\u308b\u3002 \u96e2\u6563\u5316\u624b\u6cd5\u3068\u65b9\u6cd5 ZOH\u6cd5(0\u6b21\u30db\u30fc\u30eb\u30c9) \u5f8c\u9000\u5dee\u5206\u6cd5 \u30aa\u30a4\u30e9\u30fc\u6cd5 \u53cc\u4e00\u6b21\u5909\u63db \u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316 \u4f1d\u9054\u95a2\u6570 G ( s ) = n u m ( s ) d e n ( s ) G(s) = \\frac{num(s)}{den(s)} G ( s ) = d e n ( s ) n u m ( s ) \u200b \u306b\u5bfe\u3057\u3066 s = 2 T z \u2212 1 z + 1 s = \\frac{2}{T} \\frac{z-1}{z+1} s = T 2 \u200b z + 1 z \u2212 1 \u200b \u3068\u3057\u3066z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306b\u5909\u63db\u3057\u305f\u5f8c y u = n u m ( z ) d e n ( z ) \\frac{y}{u} = \\frac{num(z)}{den(z)} u y \u200b = d e n ( z ) n u m ( z ) \u200b \u306e\u5f62\u3092\u5909\u5f62\u3059\u308b\u3053\u3068\u3067 y = f ( u , u \u2212 1 , u \u2212 2 \u22ef \u2009 , y \u2212 1 , y \u2212 2 \u22ef \u2009 ) y = f(u, u^{-1}, u^{-2} \\cdots, y^{-1}, y^{-2} \\cdots) y = f ( u , u \u2212 1 , u \u2212 2 \u22ef , y \u2212 1 , y \u2212 2 \u22ef ) \u3092\u5f97\u308b\u3002 \u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316 Waring Todo \u53c2\u8003\u6587\u732e \u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u96e2\u6563\u5316\u624b\u6cd5\u306e\u6bd4\u8f03 [Python Scipy] \u96e2\u6563\u5316 (Wikipedia) \u53cc\u4e00\u6b21\u5909\u63db (Wikipedia) \u9023\u7d9a\u7cfb\u306e\u4ee3\u8868\u7684\u306a\u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316","title":"\u96e2\u6563\u5316"},{"location":"tech_note/system/discrete/#_1","text":"\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u3067\u30b7\u30b9\u30c6\u30e0\u30e2\u30c7\u30eb\u3092\u6271\u3046\u969b\u306b\u306f\u3075\u308b\u307e\u3044\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3059\u308b\u305f\u3081\u306b\u9023\u7d9a\u6642\u9593\u9818\u57df\u3084s\u9818\u57df\u3067\u4e0e\u3048\u3089\u308c\u3066\u3044\u308b\u30b7\u30b9\u30c6\u30e0\u3092\u96e2\u6563\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\u4ee5\u4e0b\u306b\u96e2\u6563\u5316\u306e\u624b\u6cd5\u306b\u3064\u3044\u3066\u8ff0\u3079\u308b\u3002","title":"\u96e2\u6563\u5316"},{"location":"tech_note/system/discrete/#_2","text":"ZOH\u6cd5(0\u6b21\u30db\u30fc\u30eb\u30c9) \u5f8c\u9000\u5dee\u5206\u6cd5 \u30aa\u30a4\u30e9\u30fc\u6cd5 \u53cc\u4e00\u6b21\u5909\u63db","title":"\u96e2\u6563\u5316\u624b\u6cd5\u3068\u65b9\u6cd5"},{"location":"tech_note/system/discrete/#_3","text":"\u4f1d\u9054\u95a2\u6570 G ( s ) = n u m ( s ) d e n ( s ) G(s) = \\frac{num(s)}{den(s)} G ( s ) = d e n ( s ) n u m ( s ) \u200b \u306b\u5bfe\u3057\u3066 s = 2 T z \u2212 1 z + 1 s = \\frac{2}{T} \\frac{z-1}{z+1} s = T 2 \u200b z + 1 z \u2212 1 \u200b \u3068\u3057\u3066z\u9818\u57df\u306e\u4f1d\u9054\u95a2\u6570\u306b\u5909\u63db\u3057\u305f\u5f8c y u = n u m ( z ) d e n ( z ) \\frac{y}{u} = \\frac{num(z)}{den(z)} u y \u200b = d e n ( z ) n u m ( z ) \u200b \u306e\u5f62\u3092\u5909\u5f62\u3059\u308b\u3053\u3068\u3067 y = f ( u , u \u2212 1 , u \u2212 2 \u22ef \u2009 , y \u2212 1 , y \u2212 2 \u22ef \u2009 ) y = f(u, u^{-1}, u^{-2} \\cdots, y^{-1}, y^{-2} \\cdots) y = f ( u , u \u2212 1 , u \u2212 2 \u22ef , y \u2212 1 , y \u2212 2 \u22ef ) \u3092\u5f97\u308b\u3002","title":"\u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316"},{"location":"tech_note/system/discrete/#_4","text":"Waring Todo","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316"},{"location":"tech_note/system/discrete/#_5","text":"\u9023\u7d9a\u6642\u9593\u30b7\u30b9\u30c6\u30e0\u306e\u96e2\u6563\u5316\u624b\u6cd5\u306e\u6bd4\u8f03 [Python Scipy] \u96e2\u6563\u5316 (Wikipedia) \u53cc\u4e00\u6b21\u5909\u63db (Wikipedia) \u9023\u7d9a\u7cfb\u306e\u4ee3\u8868\u7684\u306a\u4f1d\u9054\u95a2\u6570\u306e\u53cc\u4e00\u6b21\u5909\u63db\u306b\u3088\u308b\u96e2\u6563\u5316","title":"\u53c2\u8003\u6587\u732e"},{"location":"tech_note/system/state_space_system/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u72b6\u614b\u7a7a\u9593\u8868\u73fe \u72b6\u614b\u7a7a\u9593\u8868\u73fe\u3068\u306f\u5165\u529b\u3068\u51fa\u529b\u3068\u72b6\u614b\u5909\u6570\u3092\u4f7f\u3063\u305f\u4e00\u968e\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3067\u8868\u3057\u305f\u6570\u5b66\u7684\u30e2\u30c7\u30eb\u3067\u3042\u308b\u3002 x \u02d9 ( t ) = A x ( t ) + B u ( t ) y ( t ) = C x ( t ) + D u ( t ) \\begin{array}{lll} \\dot{\\bold{x}}(t) &=& \\bold{A}\\bold{x}(t) + \\bold{B}\\bold{u}(t)\\\\ \\bold{y}(t) &=& \\bold{C}\\bold{x}(t) + \\bold{D}\\bold{u}(t) \\end{array} x \u02d9 ( t ) y ( t ) \u200b = = \u200b Ax ( t ) + Bu ( t ) Cx ( t ) + Du ( t ) \u200b \u53ef\u5236\u5fa1\u6027 \u53ef\u5236\u5fa1\u6027\u3068\u306f\u6709\u9650\u6642\u9593\u306e\u5165\u529b\u3067\u521d\u671f\u72b6\u614b\u304b\u3089\u4efb\u610f\u306e\u72b6\u614b\u306b\u5909\u5316\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u5236\u5fa1\u3067\u3042\u308b\u3068\u3044\u3046\u3002 r a n k [ B A B A 2 B \u22ef A n \u2212 1 B ] = n \\rm{rank} \\left[ B \\space AB \\space A^2B \\cdots A^{n-1}B\\right] = n rank [ B AB A 2 B \u22ef A n \u2212 1 B ] = n \u53ef\u89b3\u6e2c\u6027 \u53ef\u89b3\u6e2c\u6027\u3068\u306f\u30b7\u30b9\u30c6\u30e0\u306e\u51fa\u529b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u3067\u30b7\u30b9\u30c6\u30e0\u306e\u5185\u90e8\u72b6\u614b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u89b3\u6e2c\u3067\u3042\u308b\u3068\u3044\u3046\u3002 r a n k [ C C A C A 2 \u22ee C A n \u2212 1 ] = n \\rm{rank} \\begin{bmatrix} C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n-1} \\end{bmatrix} = n rank \u23a3 \u23a1 \u200b C C A C A 2 \u22ee C A n \u2212 1 \u200b \u23a6 \u23a4 \u200b = n \u6b63\u6e96\u5f62 \u30b7\u30b9\u30c6\u30e0\u306e\u751f\u606f\u884c\u5217\u306b\u3088\u3063\u3066\u540c\u5024\u5909\u63db\u3057\u3066\u3082\u57fa\u672c\u7684\u306a\u6027\u8cea\u306f\u5909\u5316\u3057\u306a\u3044\u3002\u4e2d\u3067\u3082\u6709\u540d\u306a\u6b63\u6e96\u5f62\u3092\u7d39\u4ecb\u3059\u308b \u53ef\u5236\u5fa1\u6b63\u6e96\u5f62 \u5909\u63db\u884c\u5217\u306b\u53ef\u5236\u5fa1\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u5909\u63db\u3092\u884c\u3046\u3002\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092 U c U_c U c \u200b \u3068\u3057\u3066 A ~ = U c \u2212 1 A U c B ~ = U c \u2212 1 B C ~ = C U c D ~ = D \\begin{array}{lll} \\tilde{A} = U_c^{-1} A U_c \\\\ \\tilde{B} = U_c^{-1} B \\\\ \\tilde{C} = C U_c \\\\ \\tilde{D} = D \\end{array} A ~ = U c \u2212 1 \u200b A U c \u200b B ~ = U c \u2212 1 \u200b B C ~ = C U c \u200b D ~ = D \u200b \u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62 \u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306b\u5bfe\u3057\u3066\u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62\u306f\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3002 A o = A c T B o = C c T C o = B c T D o = D c \\begin{array}{lll} A_o = A_c^T \\\\ B_o = C_c^T \\\\ C_o = B_c^T \\\\ D_o = D_c \\end{array} A o \u200b = A c T \u200b B o \u200b = C c T \u200b C o \u200b = B c T \u200b D o \u200b = D c \u200b \u200b","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe"},{"location":"tech_note/system/state_space_system/#_1","text":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u3068\u306f\u5165\u529b\u3068\u51fa\u529b\u3068\u72b6\u614b\u5909\u6570\u3092\u4f7f\u3063\u305f\u4e00\u968e\u9023\u7acb\u5fae\u5206\u65b9\u7a0b\u5f0f\u3067\u8868\u3057\u305f\u6570\u5b66\u7684\u30e2\u30c7\u30eb\u3067\u3042\u308b\u3002 x \u02d9 ( t ) = A x ( t ) + B u ( t ) y ( t ) = C x ( t ) + D u ( t ) \\begin{array}{lll} \\dot{\\bold{x}}(t) &=& \\bold{A}\\bold{x}(t) + \\bold{B}\\bold{u}(t)\\\\ \\bold{y}(t) &=& \\bold{C}\\bold{x}(t) + \\bold{D}\\bold{u}(t) \\end{array} x \u02d9 ( t ) y ( t ) \u200b = = \u200b Ax ( t ) + Bu ( t ) Cx ( t ) + Du ( t ) \u200b","title":"\u72b6\u614b\u7a7a\u9593\u8868\u73fe"},{"location":"tech_note/system/state_space_system/#_2","text":"\u53ef\u5236\u5fa1\u6027\u3068\u306f\u6709\u9650\u6642\u9593\u306e\u5165\u529b\u3067\u521d\u671f\u72b6\u614b\u304b\u3089\u4efb\u610f\u306e\u72b6\u614b\u306b\u5909\u5316\u3055\u305b\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u5236\u5fa1\u3067\u3042\u308b\u3068\u3044\u3046\u3002 r a n k [ B A B A 2 B \u22ef A n \u2212 1 B ] = n \\rm{rank} \\left[ B \\space AB \\space A^2B \\cdots A^{n-1}B\\right] = n rank [ B AB A 2 B \u22ef A n \u2212 1 B ] = n","title":"\u53ef\u5236\u5fa1\u6027"},{"location":"tech_note/system/state_space_system/#_3","text":"\u53ef\u89b3\u6e2c\u6027\u3068\u306f\u30b7\u30b9\u30c6\u30e0\u306e\u51fa\u529b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u3067\u30b7\u30b9\u30c6\u30e0\u306e\u5185\u90e8\u72b6\u614b\u3092\u89b3\u6e2c\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u793a\u3059\u3082\u306e\u3067\u3042\u308b\u3002 \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u6642\u306b\u30b7\u30b9\u30c6\u30e0\u306f\u53ef\u89b3\u6e2c\u3067\u3042\u308b\u3068\u3044\u3046\u3002 r a n k [ C C A C A 2 \u22ee C A n \u2212 1 ] = n \\rm{rank} \\begin{bmatrix} C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n-1} \\end{bmatrix} = n rank \u23a3 \u23a1 \u200b C C A C A 2 \u22ee C A n \u2212 1 \u200b \u23a6 \u23a4 \u200b = n","title":"\u53ef\u89b3\u6e2c\u6027"},{"location":"tech_note/system/state_space_system/#_4","text":"\u30b7\u30b9\u30c6\u30e0\u306e\u751f\u606f\u884c\u5217\u306b\u3088\u3063\u3066\u540c\u5024\u5909\u63db\u3057\u3066\u3082\u57fa\u672c\u7684\u306a\u6027\u8cea\u306f\u5909\u5316\u3057\u306a\u3044\u3002\u4e2d\u3067\u3082\u6709\u540d\u306a\u6b63\u6e96\u5f62\u3092\u7d39\u4ecb\u3059\u308b","title":"\u6b63\u6e96\u5f62"},{"location":"tech_note/system/state_space_system/#_5","text":"\u5909\u63db\u884c\u5217\u306b\u53ef\u5236\u5fa1\u884c\u5217\u3092\u4f7f\u7528\u3057\u3066\u5909\u63db\u3092\u884c\u3046\u3002\u53ef\u5236\u5fa1\u6027\u884c\u5217\u3092 U c U_c U c \u200b \u3068\u3057\u3066 A ~ = U c \u2212 1 A U c B ~ = U c \u2212 1 B C ~ = C U c D ~ = D \\begin{array}{lll} \\tilde{A} = U_c^{-1} A U_c \\\\ \\tilde{B} = U_c^{-1} B \\\\ \\tilde{C} = C U_c \\\\ \\tilde{D} = D \\end{array} A ~ = U c \u2212 1 \u200b A U c \u200b B ~ = U c \u2212 1 \u200b B C ~ = C U c \u200b D ~ = D \u200b","title":"\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62"},{"location":"tech_note/system/state_space_system/#_6","text":"\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306b\u5bfe\u3057\u3066\u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62\u306f\u4ee5\u4e0b\u3067\u4e0e\u3048\u3089\u308c\u308b\u3002 A o = A c T B o = C c T C o = B c T D o = D c \\begin{array}{lll} A_o = A_c^T \\\\ B_o = C_c^T \\\\ C_o = B_c^T \\\\ D_o = D_c \\end{array} A o \u200b = A c T \u200b B o \u200b = C c T \u200b C o \u200b = B c T \u200b D o \u200b = D c \u200b \u200b","title":"\u53ef\u89b3\u6e2c\u6b63\u6e96\u5f62"},{"location":"tech_note/system/transfer_function/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } \u4f1d\u9054\u95a2\u6570 \u4f1d\u9054\u95a2\u6570\u3068\u306f1\u5165\u529b1\u51fa\u529b\u30b7\u30b9\u30c6\u30e0\u306e\u5165\u51fa\u529b\u95a2\u4fc2\u3092\u8868\u3059\u95a2\u6570\u306e\u4e00\u7a2e\u3067\u3042\u308b\u3002 \u30b7\u30b9\u30c6\u30e0\u306e\u5168\u3066\u306e\u5909\u6570\u306e\u521d\u671f\u5024\u30920\u3068\u3057\u3066\u5165\u529b\u4fe1\u53f7\u3068\u51fa\u529b\u4fe1\u53f7\u306e\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u3092 X ( s ) X(s) X ( s ) , Y ( s ) Y(s) Y ( s ) \u3068\u3059\u308b\u3068 G ( s ) = Y ( s ) X ( s ) G(s) = \\frac{Y(s)}{X(s)} G ( s ) = X ( s ) Y ( s ) \u200b \u3067\u8868\u3055\u308c\u308b\u3002 \u6642\u9593\u9818\u57df\u306e\u5fae\u5206\u65b9\u7a0b\u5f0f\u7b49\u3067\u8868\u3055\u308c\u308b\u30e2\u30c7\u30eb\u3092\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u306b\u3088\u308a\u8907\u7d20\u5e73\u9762\u306b\u5199\u50cf\u3092\u53d6\u308b\u3002 \u5468\u6ce2\u6570\u9818\u57df\u306e\u5468\u6ce2\u6570\u4f1d\u9054\u95a2\u6570\u306f\u5b89\u5b9a\u6027\u306a\u3069\u306e\u89e3\u6790\u30fb\u8a55\u4fa1\u306b\u7528\u3044\u3089\u308c\u308b\u3002 \u7279\u6027\u306e\u8a55\u4fa1\u65b9\u6cd5\u3068\u3057\u3066\u30dc\u30fc\u30c9\u7dda\u56f3\u3084\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u7528\u3044\u305f\u3082\u306e\u304c\u3042\u308b\u3002 \u4f1d\u9054\u95a2\u6570\u306f\u5206\u6bcd\u5206\u5b50\u306e\u4fc2\u6570\u3092\u884c\u5217\u306b\u914d\u7f6e\u3059\u308b\u3053\u3068\u3067\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306b\u5909\u63db\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002 \u4f1d\u9054\u95a2\u6570\u4f8b \u7a4d\u5206\u8981\u7d20 G ( s ) = 1 s G(s) = \\frac{1}{s} G ( s ) = s 1 \u200b \u5fae\u5206\u8981\u7d20 G ( s ) = s G(s) = s G ( s ) = s 1\u6b21\u9045\u308c\u8981\u7d20 G ( s ) = 1 T s + 1 G(s) = \\frac{1}{Ts + 1} G ( s ) = T s + 1 1 \u200b 2\u6b21\u9045\u308c\u8981\u7d20 G ( s ) = \u03c9 2 s 2 + 2 \u03b6 \u03c9 + \u03c9 2 G(s) = \\frac{\\omega^2}{s^2 + 2\\zeta\\omega + \\omega^2} G ( s ) = s 2 + 2 \u03b6 \u03c9 + \u03c9 2 \u03c9 2 \u200b \u7121\u99c4\u6642\u9593\u8981\u7d20 G ( s ) = e \u2212 s T G(s) = e^{-sT} G ( s ) = e \u2212 s T \u5468\u6ce2\u6570\u3068\u6642\u5b9a\u6570 \u4f1d\u9054\u95a2\u6570\u3084\u30dc\u30fc\u30c9\u7dda\u56f3\u3067\u8b70\u8ad6\u3059\u308b\u3068\u304d\u306f\u5468\u6ce2\u6570\u306e\u5358\u4f4d\u304c[rad/s]\u3067\u3042\u308b\u3053\u3068\u304c\u591a\u3044\u3002[Hz]\u3068\u306e\u95a2\u4fc2\u306f \u03c9 = 2 \u03c0 f \\omega = 2\\pi f \u03c9 = 2 \u03c0 f \u6642\u5b9a\u6570\u3068\u5468\u6ce2\u6570\u306e\u95a2\u4fc2\u306f \u03c4 = 1 \u03c9 \\tau = \\frac{1}{\\omega} \u03c4 = \u03c9 1 \u200b","title":"\u4f1d\u9054\u95a2\u6570"},{"location":"tech_note/system/transfer_function/#_1","text":"\u4f1d\u9054\u95a2\u6570\u3068\u306f1\u5165\u529b1\u51fa\u529b\u30b7\u30b9\u30c6\u30e0\u306e\u5165\u51fa\u529b\u95a2\u4fc2\u3092\u8868\u3059\u95a2\u6570\u306e\u4e00\u7a2e\u3067\u3042\u308b\u3002 \u30b7\u30b9\u30c6\u30e0\u306e\u5168\u3066\u306e\u5909\u6570\u306e\u521d\u671f\u5024\u30920\u3068\u3057\u3066\u5165\u529b\u4fe1\u53f7\u3068\u51fa\u529b\u4fe1\u53f7\u306e\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u3092 X ( s ) X(s) X ( s ) , Y ( s ) Y(s) Y ( s ) \u3068\u3059\u308b\u3068 G ( s ) = Y ( s ) X ( s ) G(s) = \\frac{Y(s)}{X(s)} G ( s ) = X ( s ) Y ( s ) \u200b \u3067\u8868\u3055\u308c\u308b\u3002 \u6642\u9593\u9818\u57df\u306e\u5fae\u5206\u65b9\u7a0b\u5f0f\u7b49\u3067\u8868\u3055\u308c\u308b\u30e2\u30c7\u30eb\u3092\u30e9\u30d7\u30e9\u30b9\u5909\u63db\u306b\u3088\u308a\u8907\u7d20\u5e73\u9762\u306b\u5199\u50cf\u3092\u53d6\u308b\u3002 \u5468\u6ce2\u6570\u9818\u57df\u306e\u5468\u6ce2\u6570\u4f1d\u9054\u95a2\u6570\u306f\u5b89\u5b9a\u6027\u306a\u3069\u306e\u89e3\u6790\u30fb\u8a55\u4fa1\u306b\u7528\u3044\u3089\u308c\u308b\u3002 \u7279\u6027\u306e\u8a55\u4fa1\u65b9\u6cd5\u3068\u3057\u3066\u30dc\u30fc\u30c9\u7dda\u56f3\u3084\u30ca\u30a4\u30ad\u30b9\u30c8\u7dda\u56f3\u3092\u7528\u3044\u305f\u3082\u306e\u304c\u3042\u308b\u3002 \u4f1d\u9054\u95a2\u6570\u306f\u5206\u6bcd\u5206\u5b50\u306e\u4fc2\u6570\u3092\u884c\u5217\u306b\u914d\u7f6e\u3059\u308b\u3053\u3068\u3067\u53ef\u5236\u5fa1\u6b63\u6e96\u5f62\u306e\u72b6\u614b\u7a7a\u9593\u8868\u73fe\u306b\u5909\u63db\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u3002","title":"\u4f1d\u9054\u95a2\u6570"},{"location":"tech_note/system/transfer_function/#_2","text":"","title":"\u4f1d\u9054\u95a2\u6570\u4f8b"},{"location":"tech_note/system/transfer_function/#_3","text":"G ( s ) = 1 s G(s) = \\frac{1}{s} G ( s ) = s 1 \u200b","title":"\u7a4d\u5206\u8981\u7d20"},{"location":"tech_note/system/transfer_function/#_4","text":"G ( s ) = s G(s) = s G ( s ) = s","title":"\u5fae\u5206\u8981\u7d20"},{"location":"tech_note/system/transfer_function/#1","text":"G ( s ) = 1 T s + 1 G(s) = \\frac{1}{Ts + 1} G ( s ) = T s + 1 1 \u200b","title":"1\u6b21\u9045\u308c\u8981\u7d20"},{"location":"tech_note/system/transfer_function/#2","text":"G ( s ) = \u03c9 2 s 2 + 2 \u03b6 \u03c9 + \u03c9 2 G(s) = \\frac{\\omega^2}{s^2 + 2\\zeta\\omega + \\omega^2} G ( s ) = s 2 + 2 \u03b6 \u03c9 + \u03c9 2 \u03c9 2 \u200b","title":"2\u6b21\u9045\u308c\u8981\u7d20"},{"location":"tech_note/system/transfer_function/#_5","text":"G ( s ) = e \u2212 s T G(s) = e^{-sT} G ( s ) = e \u2212 s T","title":"\u7121\u99c4\u6642\u9593\u8981\u7d20"},{"location":"tech_note/system/transfer_function/#_6","text":"\u4f1d\u9054\u95a2\u6570\u3084\u30dc\u30fc\u30c9\u7dda\u56f3\u3067\u8b70\u8ad6\u3059\u308b\u3068\u304d\u306f\u5468\u6ce2\u6570\u306e\u5358\u4f4d\u304c[rad/s]\u3067\u3042\u308b\u3053\u3068\u304c\u591a\u3044\u3002[Hz]\u3068\u306e\u95a2\u4fc2\u306f \u03c9 = 2 \u03c0 f \\omega = 2\\pi f \u03c9 = 2 \u03c0 f \u6642\u5b9a\u6570\u3068\u5468\u6ce2\u6570\u306e\u95a2\u4fc2\u306f \u03c4 = 1 \u03c9 \\tau = \\frac{1}{\\omega} \u03c4 = \u03c9 1 \u200b","title":"\u5468\u6ce2\u6570\u3068\u6642\u5b9a\u6570"}]}